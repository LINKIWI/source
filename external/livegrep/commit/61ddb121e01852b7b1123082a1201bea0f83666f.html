<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>govendor init - livegrep - Fast, regular expression code search service</title>
<meta name="description" content="Fast, regular expression code search service" />
<meta name="author" content="Kevin Lin" />
<link rel="icon" type="image/png" href="https://static.kevinlin.info/favicon.png" />
<link rel="alternate" type="application/atom+xml" title="livegrep Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="livegrep Atom Feed (tags)" href="../tags.xml" />
<style type="text/css">
body{color:#000;background-color:#fff;font-family:monospace}h1,h2,h3,h4,h5,h6{font-size:1em;margin:0}img,h1,h2{vertical-align:middle}img{border:0}a:target{background-color:#ccc}a.d,a.h,a.i{text-decoration:none}a.line{text-decoration:none;user-select:none}#blob a{color:#555}#blob a:hover{color:blue;text-decoration:none}table thead td{font-weight:bold}table td{padding:0 .4em}table td pre{margin:0}#content table td{vertical-align:top;white-space:nowrap}#branches tr:hover td,#tags tr:hover td,#index tr:hover td,#log tr:hover td,#files tr:hover td{background-color:#eee}#index tr td:nth-child(2),#tags tr td:nth-child(3),#branches tr td:nth-child(3),#log tr td:nth-child(2){white-space:normal}td.num{text-align:right}.desc{color:#555}hr{border:0;border-top:1px solid #555;height:1px}pre{font-family:monospace}pre a.h{color:#00a}.A,span.i,pre a.i{color:#070}.D,span.d,pre a.d{color:#e00}pre a.h:hover,pre a.i:hover,pre a.d:hover{text-decoration:none}
</style>
</head>
<body>
<table><tr><td><a href="/"><img src="https://static.kevinlin.info/favicon.png" alt="" width="32" height="32" /></a></td><td><h1>livegrep</h1><span class="desc">Fast, regular expression code search service</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://source.static.kevinlin.info/external/livegrep.git">https://source.static.kevinlin.info/external/livegrep.git</a></td></tr><tr><td></td><td>
<a href="../log">Log</a> | <a href="../files">Files</a> | <a href="../refs">Refs</a> | <a href="../file/README.md">README</a> | <a href="../file/COPYING">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/61ddb121e01852b7b1123082a1201bea0f83666f">61ddb121e01852b7b1123082a1201bea0f83666f</a>
<b>parent</b> <a href="../commit/6ec8c291876f5ec82fcab789394de53b50d88017">6ec8c291876f5ec82fcab789394de53b50d88017</a>
<b>Author:</b> Nelson Elhage &lt;<a href="mailto:nelhage@nelhage.com">nelhage@nelhage.com</a>&gt;
<b>Date:</b>   Sun 14 Aug 2016 18:35:31 -0700

govendor init

<b>Diffstat:</b>
<table><tr><td class="A">A</td><td><a href="#h0">vendor/github.com/bmizerany/pat/README.md</a></td><td> | </td><td class="num">82</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h1">vendor/github.com/bmizerany/pat/mux.go</a></td><td> | </td><td class="num">310</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h2">vendor/github.com/google/go-github/LICENSE</a></td><td> | </td><td class="num">341</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h3">vendor/github.com/google/go-github/github/activity.go</a></td><td> | </td><td class="num">69</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h4">vendor/github.com/google/go-github/github/activity_events.go</a></td><td> | </td><td class="num">245</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h5">vendor/github.com/google/go-github/github/activity_notifications.go</a></td><td> | </td><td class="num">225</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h6">vendor/github.com/google/go-github/github/activity_star.go</a></td><td> | </td><td class="num">123</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h7">vendor/github.com/google/go-github/github/activity_watching.go</a></td><td> | </td><td class="num">136</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h8">vendor/github.com/google/go-github/github/authorizations.go</a></td><td> | </td><td class="num">320</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h9">vendor/github.com/google/go-github/github/doc.go</a></td><td> | </td><td class="num">133</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h10">vendor/github.com/google/go-github/github/event_types.go</a></td><td> | </td><td class="num">444</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h11">vendor/github.com/google/go-github/github/gists.go</a></td><td> | </td><td class="num">281</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h12">vendor/github.com/google/go-github/github/gists_comments.go</a></td><td> | </td><td class="num">118</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h13">vendor/github.com/google/go-github/github/git.go</a></td><td> | </td><td class="num">14</td><td><span class="i">++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h14">vendor/github.com/google/go-github/github/git_blobs.go</a></td><td> | </td><td class="num">47</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h15">vendor/github.com/google/go-github/github/git_commits.go</a></td><td> | </td><td class="num">115</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h16">vendor/github.com/google/go-github/github/git_refs.go</a></td><td> | </td><td class="num">162</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h17">vendor/github.com/google/go-github/github/git_tags.go</a></td><td> | </td><td class="num">73</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h18">vendor/github.com/google/go-github/github/git_trees.go</a></td><td> | </td><td class="num">89</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h19">vendor/github.com/google/go-github/github/github.go</a></td><td> | </td><td class="num">712</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h20">vendor/github.com/google/go-github/github/gitignore.go</a></td><td> | </td><td class="num">63</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h21">vendor/github.com/google/go-github/github/issues.go</a></td><td> | </td><td class="num">294</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h22">vendor/github.com/google/go-github/github/issues_assignees.go</a></td><td> | </td><td class="num">46</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h23">vendor/github.com/google/go-github/github/issues_comments.go</a></td><td> | </td><td class="num">138</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h24">vendor/github.com/google/go-github/github/issues_events.go</a></td><td> | </td><td class="num">149</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h25">vendor/github.com/google/go-github/github/issues_labels.go</a></td><td> | </td><td class="num">222</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h26">vendor/github.com/google/go-github/github/issues_milestones.go</a></td><td> | </td><td class="num">144</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h27">vendor/github.com/google/go-github/github/licenses.go</a></td><td> | </td><td class="num">81</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h28">vendor/github.com/google/go-github/github/migrations.go</a></td><td> | </td><td class="num">225</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h29">vendor/github.com/google/go-github/github/misc.go</a></td><td> | </td><td class="num">197</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h30">vendor/github.com/google/go-github/github/orgs.go</a></td><td> | </td><td class="num">170</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h31">vendor/github.com/google/go-github/github/orgs_hooks.go</a></td><td> | </td><td class="num">104</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h32">vendor/github.com/google/go-github/github/orgs_members.go</a></td><td> | </td><td class="num">276</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h33">vendor/github.com/google/go-github/github/orgs_teams.go</a></td><td> | </td><td class="num">399</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h34">vendor/github.com/google/go-github/github/pulls.go</a></td><td> | </td><td class="num">275</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h35">vendor/github.com/google/go-github/github/pulls_comments.go</a></td><td> | </td><td class="num">149</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h36">vendor/github.com/google/go-github/github/repos.go</a></td><td> | </td><td class="num">559</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h37">vendor/github.com/google/go-github/github/repos_collaborators.go</a></td><td> | </td><td class="num">95</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h38">vendor/github.com/google/go-github/github/repos_comments.go</a></td><td> | </td><td class="num">150</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h39">vendor/github.com/google/go-github/github/repos_commits.go</a></td><td> | </td><td class="num">196</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h40">vendor/github.com/google/go-github/github/repos_contents.go</a></td><td> | </td><td class="num">248</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h41">vendor/github.com/google/go-github/github/repos_deployments.go</a></td><td> | </td><td class="num">168</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h42">vendor/github.com/google/go-github/github/repos_forks.go</a></td><td> | </td><td class="num">73</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h43">vendor/github.com/google/go-github/github/repos_hooks.go</a></td><td> | </td><td class="num">196</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h44">vendor/github.com/google/go-github/github/repos_keys.go</a></td><td> | </td><td class="num">108</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h45">vendor/github.com/google/go-github/github/repos_merging.go</a></td><td> | </td><td class="num">37</td><td><span class="i">+++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h46">vendor/github.com/google/go-github/github/repos_pages.go</a></td><td> | </td><td class="num">90</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h47">vendor/github.com/google/go-github/github/repos_releases.go</a></td><td> | </td><td class="num">320</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h48">vendor/github.com/google/go-github/github/repos_stats.go</a></td><td> | </td><td class="num">214</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h49">vendor/github.com/google/go-github/github/repos_statuses.go</a></td><td> | </td><td class="num">128</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h50">vendor/github.com/google/go-github/github/search.go</a></td><td> | </td><td class="num">158</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h51">vendor/github.com/google/go-github/github/strings.go</a></td><td> | </td><td class="num">93</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h52">vendor/github.com/google/go-github/github/timestamp.go</a></td><td> | </td><td class="num">41</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h53">vendor/github.com/google/go-github/github/users.go</a></td><td> | </td><td class="num">145</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h54">vendor/github.com/google/go-github/github/users_administration.go</a></td><td> | </td><td class="num">64</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h55">vendor/github.com/google/go-github/github/users_emails.go</a></td><td> | </td><td class="num">69</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h56">vendor/github.com/google/go-github/github/users_followers.go</a></td><td> | </td><td class="num">116</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h57">vendor/github.com/google/go-github/github/users_keys.go</a></td><td> | </td><td class="num">104</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h58">vendor/github.com/google/go-querystring/LICENSE</a></td><td> | </td><td class="num">27</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h59">vendor/github.com/google/go-querystring/query/encode.go</a></td><td> | </td><td class="num">311</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h60">vendor/github.com/nelhage/go.cli/LICENSE</a></td><td> | </td><td class="num">26</td><td><span class="i">++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h61">vendor/github.com/nelhage/go.cli/config/README.md</a></td><td> | </td><td class="num">18</td><td><span class="i">++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h62">vendor/github.com/nelhage/go.cli/config/config.go</a></td><td> | </td><td class="num">71</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h63">vendor/golang.org/x/net/LICENSE</a></td><td> | </td><td class="num">27</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h64">vendor/golang.org/x/net/PATENTS</a></td><td> | </td><td class="num">22</td><td><span class="i">++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h65">vendor/golang.org/x/net/context/context.go</a></td><td> | </td><td class="num">156</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h66">vendor/golang.org/x/net/context/go17.go</a></td><td> | </td><td class="num">72</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h67">vendor/golang.org/x/net/context/pre_go17.go</a></td><td> | </td><td class="num">300</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h68">vendor/golang.org/x/oauth2/AUTHORS</a></td><td> | </td><td class="num">3</td><td><span class="i">+++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h69">vendor/golang.org/x/oauth2/CONTRIBUTING.md</a></td><td> | </td><td class="num">31</td><td><span class="i">+++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h70">vendor/golang.org/x/oauth2/CONTRIBUTORS</a></td><td> | </td><td class="num">3</td><td><span class="i">+++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h71">vendor/golang.org/x/oauth2/LICENSE</a></td><td> | </td><td class="num">27</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h72">vendor/golang.org/x/oauth2/README.md</a></td><td> | </td><td class="num">64</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h73">vendor/golang.org/x/oauth2/client_appengine.go</a></td><td> | </td><td class="num">25</td><td><span class="i">+++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h74">vendor/golang.org/x/oauth2/internal/oauth2.go</a></td><td> | </td><td class="num">76</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h75">vendor/golang.org/x/oauth2/internal/token.go</a></td><td> | </td><td class="num">225</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h76">vendor/golang.org/x/oauth2/internal/transport.go</a></td><td> | </td><td class="num">69</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h77">vendor/golang.org/x/oauth2/oauth2.go</a></td><td> | </td><td class="num">337</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h78">vendor/golang.org/x/oauth2/token.go</a></td><td> | </td><td class="num">158</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h79">vendor/golang.org/x/oauth2/transport.go</a></td><td> | </td><td class="num">132</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h80">vendor/gopkg.in/check.v1/LICENSE</a></td><td> | </td><td class="num">25</td><td><span class="i">+++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h81">vendor/gopkg.in/check.v1/README.md</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h82">vendor/gopkg.in/check.v1/TODO</a></td><td> | </td><td class="num">2</td><td><span class="i">++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h83">vendor/gopkg.in/check.v1/benchmark.go</a></td><td> | </td><td class="num">187</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h84">vendor/gopkg.in/check.v1/check.go</a></td><td> | </td><td class="num">873</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h85">vendor/gopkg.in/check.v1/checkers.go</a></td><td> | </td><td class="num">458</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h86">vendor/gopkg.in/check.v1/helpers.go</a></td><td> | </td><td class="num">231</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h87">vendor/gopkg.in/check.v1/printer.go</a></td><td> | </td><td class="num">168</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h88">vendor/gopkg.in/check.v1/reporter.go</a></td><td> | </td><td class="num">88</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h89">vendor/gopkg.in/check.v1/run.go</a></td><td> | </td><td class="num">175</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h90">vendor/vendor.json</a></td><td> | </td><td class="num">55</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
</table></pre><pre>91 files changed, 14805 insertions(+), 0 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/vendor/github.com/bmizerany/pat/README.md">vendor/github.com/bmizerany/pat/README.md</a> b/<a href="../file/vendor/github.com/bmizerany/pat/README.md">vendor/github.com/bmizerany/pat/README.md</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -0,0 +1,82 @@
</a><a href="#h0-0-0" id="h0-0-0" class="i">+# pat (formerly pat.go) - A Sinatra style pattern muxer for Go&#39;s net/http library
</a><a href="#h0-0-1" id="h0-0-1" class="i">+
</a><a href="#h0-0-2" id="h0-0-2" class="i">+[![GoDoc](https://godoc.org/github.com/bmizerany/pat?status.svg)](https://godoc.org/github.com/bmizerany/pat) 
</a><a href="#h0-0-3" id="h0-0-3" class="i">+
</a><a href="#h0-0-4" id="h0-0-4" class="i">+## INSTALL
</a><a href="#h0-0-5" id="h0-0-5" class="i">+
</a><a href="#h0-0-6" id="h0-0-6" class="i">+	$ go get github.com/bmizerany/pat
</a><a href="#h0-0-7" id="h0-0-7" class="i">+
</a><a href="#h0-0-8" id="h0-0-8" class="i">+## USE
</a><a href="#h0-0-9" id="h0-0-9" class="i">+
</a><a href="#h0-0-10" id="h0-0-10" class="i">+```go
</a><a href="#h0-0-11" id="h0-0-11" class="i">+package main
</a><a href="#h0-0-12" id="h0-0-12" class="i">+
</a><a href="#h0-0-13" id="h0-0-13" class="i">+import (
</a><a href="#h0-0-14" id="h0-0-14" class="i">+	&quot;io&quot;
</a><a href="#h0-0-15" id="h0-0-15" class="i">+	&quot;net/http&quot;
</a><a href="#h0-0-16" id="h0-0-16" class="i">+	&quot;github.com/bmizerany/pat&quot;
</a><a href="#h0-0-17" id="h0-0-17" class="i">+	&quot;log&quot;
</a><a href="#h0-0-18" id="h0-0-18" class="i">+)
</a><a href="#h0-0-19" id="h0-0-19" class="i">+
</a><a href="#h0-0-20" id="h0-0-20" class="i">+// hello world, the web server
</a><a href="#h0-0-21" id="h0-0-21" class="i">+func HelloServer(w http.ResponseWriter, req *http.Request) {
</a><a href="#h0-0-22" id="h0-0-22" class="i">+	io.WriteString(w, &quot;hello, &quot;+req.URL.Query().Get(&quot;:name&quot;)+&quot;!\n&quot;)
</a><a href="#h0-0-23" id="h0-0-23" class="i">+}
</a><a href="#h0-0-24" id="h0-0-24" class="i">+
</a><a href="#h0-0-25" id="h0-0-25" class="i">+func main() {
</a><a href="#h0-0-26" id="h0-0-26" class="i">+	m := pat.New()
</a><a href="#h0-0-27" id="h0-0-27" class="i">+	m.Get(&quot;/hello/:name&quot;, http.HandlerFunc(HelloServer))
</a><a href="#h0-0-28" id="h0-0-28" class="i">+
</a><a href="#h0-0-29" id="h0-0-29" class="i">+	// Register this pat with the default serve mux so that other packages
</a><a href="#h0-0-30" id="h0-0-30" class="i">+	// may also be exported. (i.e. /debug/pprof/*)
</a><a href="#h0-0-31" id="h0-0-31" class="i">+	http.Handle(&quot;/&quot;, m)
</a><a href="#h0-0-32" id="h0-0-32" class="i">+	err := http.ListenAndServe(&quot;:12345&quot;, nil)
</a><a href="#h0-0-33" id="h0-0-33" class="i">+	if err != nil {
</a><a href="#h0-0-34" id="h0-0-34" class="i">+		log.Fatal(&quot;ListenAndServe: &quot;, err)
</a><a href="#h0-0-35" id="h0-0-35" class="i">+	}
</a><a href="#h0-0-36" id="h0-0-36" class="i">+}
</a><a href="#h0-0-37" id="h0-0-37" class="i">+```
</a><a href="#h0-0-38" id="h0-0-38" class="i">+
</a><a href="#h0-0-39" id="h0-0-39" class="i">+It&#39;s that simple.
</a><a href="#h0-0-40" id="h0-0-40" class="i">+
</a><a href="#h0-0-41" id="h0-0-41" class="i">+For more information, see:
</a><a href="#h0-0-42" id="h0-0-42" class="i">+http://godoc.org/github.com/bmizerany/pat
</a><a href="#h0-0-43" id="h0-0-43" class="i">+
</a><a href="#h0-0-44" id="h0-0-44" class="i">+## CONTRIBUTORS
</a><a href="#h0-0-45" id="h0-0-45" class="i">+
</a><a href="#h0-0-46" id="h0-0-46" class="i">+* Alexis Svinartchouk (@zvin)
</a><a href="#h0-0-47" id="h0-0-47" class="i">+* Blake Mizerany (@bmizerany)
</a><a href="#h0-0-48" id="h0-0-48" class="i">+* Brian Ketelsen (@bketelsen)
</a><a href="#h0-0-49" id="h0-0-49" class="i">+* Bryan Matsuo (@bmatsuo)
</a><a href="#h0-0-50" id="h0-0-50" class="i">+* Caleb Spare (@cespare)
</a><a href="#h0-0-51" id="h0-0-51" class="i">+* Evan Shaw (@edsrzf)
</a><a href="#h0-0-52" id="h0-0-52" class="i">+* Gary Burd (@garyburd)
</a><a href="#h0-0-53" id="h0-0-53" class="i">+* George Rogers (@georgerogers42)
</a><a href="#h0-0-54" id="h0-0-54" class="i">+* Keith Rarick (@kr)
</a><a href="#h0-0-55" id="h0-0-55" class="i">+* Matt Williams (@mattyw)
</a><a href="#h0-0-56" id="h0-0-56" class="i">+* Mike Stipicevic (@wickedchicken)
</a><a href="#h0-0-57" id="h0-0-57" class="i">+* Nick Saika (@nesv)
</a><a href="#h0-0-58" id="h0-0-58" class="i">+* Timothy Cyrus (@tcyrus)
</a><a href="#h0-0-59" id="h0-0-59" class="i">+* binqin (@binku87)
</a><a href="#h0-0-60" id="h0-0-60" class="i">+
</a><a href="#h0-0-61" id="h0-0-61" class="i">+## LICENSE
</a><a href="#h0-0-62" id="h0-0-62" class="i">+
</a><a href="#h0-0-63" id="h0-0-63" class="i">+Copyright (C) 2012 by Keith Rarick, Blake Mizerany
</a><a href="#h0-0-64" id="h0-0-64" class="i">+
</a><a href="#h0-0-65" id="h0-0-65" class="i">+Permission is hereby granted, free of charge, to any person obtaining a copy
</a><a href="#h0-0-66" id="h0-0-66" class="i">+of this software and associated documentation files (the &quot;Software&quot;), to deal
</a><a href="#h0-0-67" id="h0-0-67" class="i">+in the Software without restriction, including without limitation the rights
</a><a href="#h0-0-68" id="h0-0-68" class="i">+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
</a><a href="#h0-0-69" id="h0-0-69" class="i">+copies of the Software, and to permit persons to whom the Software is
</a><a href="#h0-0-70" id="h0-0-70" class="i">+furnished to do so, subject to the following conditions:
</a><a href="#h0-0-71" id="h0-0-71" class="i">+
</a><a href="#h0-0-72" id="h0-0-72" class="i">+The above copyright notice and this permission notice shall be included in
</a><a href="#h0-0-73" id="h0-0-73" class="i">+all copies or substantial portions of the Software.
</a><a href="#h0-0-74" id="h0-0-74" class="i">+
</a><a href="#h0-0-75" id="h0-0-75" class="i">+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
</a><a href="#h0-0-76" id="h0-0-76" class="i">+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</a><a href="#h0-0-77" id="h0-0-77" class="i">+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
</a><a href="#h0-0-78" id="h0-0-78" class="i">+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
</a><a href="#h0-0-79" id="h0-0-79" class="i">+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
</a><a href="#h0-0-80" id="h0-0-80" class="i">+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
</a><a href="#h0-0-81" id="h0-0-81" class="i">+THE SOFTWARE.
</a><b>diff --git a/<a id="h1" href="../file/vendor/github.com/bmizerany/pat/mux.go">vendor/github.com/bmizerany/pat/mux.go</a> b/<a href="../file/vendor/github.com/bmizerany/pat/mux.go">vendor/github.com/bmizerany/pat/mux.go</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -0,0 +1,310 @@
</a><a href="#h1-0-0" id="h1-0-0" class="i">+// Package pat implements a simple URL pattern muxer
</a><a href="#h1-0-1" id="h1-0-1" class="i">+package pat
</a><a href="#h1-0-2" id="h1-0-2" class="i">+
</a><a href="#h1-0-3" id="h1-0-3" class="i">+import (
</a><a href="#h1-0-4" id="h1-0-4" class="i">+	&quot;net/http&quot;
</a><a href="#h1-0-5" id="h1-0-5" class="i">+	&quot;net/url&quot;
</a><a href="#h1-0-6" id="h1-0-6" class="i">+	&quot;strings&quot;
</a><a href="#h1-0-7" id="h1-0-7" class="i">+)
</a><a href="#h1-0-8" id="h1-0-8" class="i">+
</a><a href="#h1-0-9" id="h1-0-9" class="i">+// PatternServeMux is an HTTP request multiplexer. It matches the URL of each
</a><a href="#h1-0-10" id="h1-0-10" class="i">+// incoming request against a list of registered patterns with their associated
</a><a href="#h1-0-11" id="h1-0-11" class="i">+// methods and calls the handler for the pattern that most closely matches the
</a><a href="#h1-0-12" id="h1-0-12" class="i">+// URL.
</a><a href="#h1-0-13" id="h1-0-13" class="i">+//
</a><a href="#h1-0-14" id="h1-0-14" class="i">+// Pattern matching attempts each pattern in the order in which they were
</a><a href="#h1-0-15" id="h1-0-15" class="i">+// registered.
</a><a href="#h1-0-16" id="h1-0-16" class="i">+//
</a><a href="#h1-0-17" id="h1-0-17" class="i">+// Patterns may contain literals or captures. Capture names start with a colon
</a><a href="#h1-0-18" id="h1-0-18" class="i">+// and consist of letters A-Z, a-z, _, and 0-9. The rest of the pattern
</a><a href="#h1-0-19" id="h1-0-19" class="i">+// matches literally. The portion of the URL matching each name ends with an
</a><a href="#h1-0-20" id="h1-0-20" class="i">+// occurrence of the character in the pattern immediately following the name,
</a><a href="#h1-0-21" id="h1-0-21" class="i">+// or a /, whichever comes first. It is possible for a name to match the empty
</a><a href="#h1-0-22" id="h1-0-22" class="i">+// string.
</a><a href="#h1-0-23" id="h1-0-23" class="i">+//
</a><a href="#h1-0-24" id="h1-0-24" class="i">+// Example pattern with one capture:
</a><a href="#h1-0-25" id="h1-0-25" class="i">+//   /hello/:name
</a><a href="#h1-0-26" id="h1-0-26" class="i">+// Will match:
</a><a href="#h1-0-27" id="h1-0-27" class="i">+//   /hello/blake
</a><a href="#h1-0-28" id="h1-0-28" class="i">+//   /hello/keith
</a><a href="#h1-0-29" id="h1-0-29" class="i">+// Will not match:
</a><a href="#h1-0-30" id="h1-0-30" class="i">+//   /hello/blake/
</a><a href="#h1-0-31" id="h1-0-31" class="i">+//   /hello/blake/foo
</a><a href="#h1-0-32" id="h1-0-32" class="i">+//   /foo
</a><a href="#h1-0-33" id="h1-0-33" class="i">+//   /foo/bar
</a><a href="#h1-0-34" id="h1-0-34" class="i">+//
</a><a href="#h1-0-35" id="h1-0-35" class="i">+// Example 2:
</a><a href="#h1-0-36" id="h1-0-36" class="i">+//    /hello/:name/
</a><a href="#h1-0-37" id="h1-0-37" class="i">+// Will match:
</a><a href="#h1-0-38" id="h1-0-38" class="i">+//   /hello/blake/
</a><a href="#h1-0-39" id="h1-0-39" class="i">+//   /hello/keith/foo
</a><a href="#h1-0-40" id="h1-0-40" class="i">+//   /hello/blake
</a><a href="#h1-0-41" id="h1-0-41" class="i">+//   /hello/keith
</a><a href="#h1-0-42" id="h1-0-42" class="i">+// Will not match:
</a><a href="#h1-0-43" id="h1-0-43" class="i">+//   /foo
</a><a href="#h1-0-44" id="h1-0-44" class="i">+//   /foo/bar
</a><a href="#h1-0-45" id="h1-0-45" class="i">+//
</a><a href="#h1-0-46" id="h1-0-46" class="i">+// A pattern ending with a slash will add an implicit redirect for its non-slash
</a><a href="#h1-0-47" id="h1-0-47" class="i">+// version. For example: Get(&quot;/foo/&quot;, handler) also registers
</a><a href="#h1-0-48" id="h1-0-48" class="i">+// Get(&quot;/foo&quot;, handler) as a redirect. You may override it by registering
</a><a href="#h1-0-49" id="h1-0-49" class="i">+// Get(&quot;/foo&quot;, anotherhandler) before the slash version.
</a><a href="#h1-0-50" id="h1-0-50" class="i">+//
</a><a href="#h1-0-51" id="h1-0-51" class="i">+// Retrieve the capture from the r.URL.Query().Get(&quot;:name&quot;) in a handler (note
</a><a href="#h1-0-52" id="h1-0-52" class="i">+// the colon). If a capture name appears more than once, the additional values
</a><a href="#h1-0-53" id="h1-0-53" class="i">+// are appended to the previous values (see
</a><a href="#h1-0-54" id="h1-0-54" class="i">+// http://golang.org/pkg/net/url/#Values)
</a><a href="#h1-0-55" id="h1-0-55" class="i">+//
</a><a href="#h1-0-56" id="h1-0-56" class="i">+// A trivial example server is:
</a><a href="#h1-0-57" id="h1-0-57" class="i">+//
</a><a href="#h1-0-58" id="h1-0-58" class="i">+//	package main
</a><a href="#h1-0-59" id="h1-0-59" class="i">+//
</a><a href="#h1-0-60" id="h1-0-60" class="i">+//	import (
</a><a href="#h1-0-61" id="h1-0-61" class="i">+//		&quot;io&quot;
</a><a href="#h1-0-62" id="h1-0-62" class="i">+//		&quot;net/http&quot;
</a><a href="#h1-0-63" id="h1-0-63" class="i">+//		&quot;github.com/bmizerany/pat&quot;
</a><a href="#h1-0-64" id="h1-0-64" class="i">+//		&quot;log&quot;
</a><a href="#h1-0-65" id="h1-0-65" class="i">+//	)
</a><a href="#h1-0-66" id="h1-0-66" class="i">+//
</a><a href="#h1-0-67" id="h1-0-67" class="i">+//	// hello world, the web server
</a><a href="#h1-0-68" id="h1-0-68" class="i">+//	func HelloServer(w http.ResponseWriter, req *http.Request) {
</a><a href="#h1-0-69" id="h1-0-69" class="i">+//		io.WriteString(w, &quot;hello, &quot;+req.URL.Query().Get(&quot;:name&quot;)+&quot;!\n&quot;)
</a><a href="#h1-0-70" id="h1-0-70" class="i">+//	}
</a><a href="#h1-0-71" id="h1-0-71" class="i">+//
</a><a href="#h1-0-72" id="h1-0-72" class="i">+//	func main() {
</a><a href="#h1-0-73" id="h1-0-73" class="i">+//		m := pat.New()
</a><a href="#h1-0-74" id="h1-0-74" class="i">+//		m.Get(&quot;/hello/:name&quot;, http.HandlerFunc(HelloServer))
</a><a href="#h1-0-75" id="h1-0-75" class="i">+//
</a><a href="#h1-0-76" id="h1-0-76" class="i">+//		// Register this pat with the default serve mux so that other packages
</a><a href="#h1-0-77" id="h1-0-77" class="i">+//		// may also be exported. (i.e. /debug/pprof/*)
</a><a href="#h1-0-78" id="h1-0-78" class="i">+//		http.Handle(&quot;/&quot;, m)
</a><a href="#h1-0-79" id="h1-0-79" class="i">+//		err := http.ListenAndServe(&quot;:12345&quot;, nil)
</a><a href="#h1-0-80" id="h1-0-80" class="i">+//		if err != nil {
</a><a href="#h1-0-81" id="h1-0-81" class="i">+//			log.Fatal(&quot;ListenAndServe: &quot;, err)
</a><a href="#h1-0-82" id="h1-0-82" class="i">+//		}
</a><a href="#h1-0-83" id="h1-0-83" class="i">+//	}
</a><a href="#h1-0-84" id="h1-0-84" class="i">+//
</a><a href="#h1-0-85" id="h1-0-85" class="i">+// When &quot;Method Not Allowed&quot;:
</a><a href="#h1-0-86" id="h1-0-86" class="i">+//
</a><a href="#h1-0-87" id="h1-0-87" class="i">+// Pat knows what methods are allowed given a pattern and a URI. For
</a><a href="#h1-0-88" id="h1-0-88" class="i">+// convenience, PatternServeMux will add the Allow header for requests that
</a><a href="#h1-0-89" id="h1-0-89" class="i">+// match a pattern for a method other than the method requested and set the
</a><a href="#h1-0-90" id="h1-0-90" class="i">+// Status to &quot;405 Method Not Allowed&quot;.
</a><a href="#h1-0-91" id="h1-0-91" class="i">+//
</a><a href="#h1-0-92" id="h1-0-92" class="i">+// If the NotFound handler is set, then it is used whenever the pattern doesn&#39;t
</a><a href="#h1-0-93" id="h1-0-93" class="i">+// match the request path for the current method (and the Allow header is not
</a><a href="#h1-0-94" id="h1-0-94" class="i">+// altered).
</a><a href="#h1-0-95" id="h1-0-95" class="i">+type PatternServeMux struct {
</a><a href="#h1-0-96" id="h1-0-96" class="i">+	// NotFound, if set, is used whenever the request doesn&#39;t match any
</a><a href="#h1-0-97" id="h1-0-97" class="i">+	// pattern for its method. NotFound should be set before serving any
</a><a href="#h1-0-98" id="h1-0-98" class="i">+	// requests.
</a><a href="#h1-0-99" id="h1-0-99" class="i">+	NotFound http.Handler
</a><a href="#h1-0-100" id="h1-0-100" class="i">+	handlers map[string][]*patHandler
</a><a href="#h1-0-101" id="h1-0-101" class="i">+}
</a><a href="#h1-0-102" id="h1-0-102" class="i">+
</a><a href="#h1-0-103" id="h1-0-103" class="i">+// New returns a new PatternServeMux.
</a><a href="#h1-0-104" id="h1-0-104" class="i">+func New() *PatternServeMux {
</a><a href="#h1-0-105" id="h1-0-105" class="i">+	return &amp;PatternServeMux{handlers: make(map[string][]*patHandler)}
</a><a href="#h1-0-106" id="h1-0-106" class="i">+}
</a><a href="#h1-0-107" id="h1-0-107" class="i">+
</a><a href="#h1-0-108" id="h1-0-108" class="i">+// ServeHTTP matches r.URL.Path against its routing table using the rules
</a><a href="#h1-0-109" id="h1-0-109" class="i">+// described above.
</a><a href="#h1-0-110" id="h1-0-110" class="i">+func (p *PatternServeMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</a><a href="#h1-0-111" id="h1-0-111" class="i">+	for _, ph := range p.handlers[r.Method] {
</a><a href="#h1-0-112" id="h1-0-112" class="i">+		if params, ok := ph.try(r.URL.Path); ok {
</a><a href="#h1-0-113" id="h1-0-113" class="i">+			if len(params) &gt; 0 &amp;&amp; !ph.redirect {
</a><a href="#h1-0-114" id="h1-0-114" class="i">+				r.URL.RawQuery = url.Values(params).Encode() + &quot;&amp;&quot; + r.URL.RawQuery
</a><a href="#h1-0-115" id="h1-0-115" class="i">+			}
</a><a href="#h1-0-116" id="h1-0-116" class="i">+			ph.ServeHTTP(w, r)
</a><a href="#h1-0-117" id="h1-0-117" class="i">+			return
</a><a href="#h1-0-118" id="h1-0-118" class="i">+		}
</a><a href="#h1-0-119" id="h1-0-119" class="i">+	}
</a><a href="#h1-0-120" id="h1-0-120" class="i">+
</a><a href="#h1-0-121" id="h1-0-121" class="i">+	if p.NotFound != nil {
</a><a href="#h1-0-122" id="h1-0-122" class="i">+		p.NotFound.ServeHTTP(w, r)
</a><a href="#h1-0-123" id="h1-0-123" class="i">+		return
</a><a href="#h1-0-124" id="h1-0-124" class="i">+	}
</a><a href="#h1-0-125" id="h1-0-125" class="i">+
</a><a href="#h1-0-126" id="h1-0-126" class="i">+	allowed := make([]string, 0, len(p.handlers))
</a><a href="#h1-0-127" id="h1-0-127" class="i">+	for meth, handlers := range p.handlers {
</a><a href="#h1-0-128" id="h1-0-128" class="i">+		if meth == r.Method {
</a><a href="#h1-0-129" id="h1-0-129" class="i">+			continue
</a><a href="#h1-0-130" id="h1-0-130" class="i">+		}
</a><a href="#h1-0-131" id="h1-0-131" class="i">+
</a><a href="#h1-0-132" id="h1-0-132" class="i">+		for _, ph := range handlers {
</a><a href="#h1-0-133" id="h1-0-133" class="i">+			if _, ok := ph.try(r.URL.Path); ok {
</a><a href="#h1-0-134" id="h1-0-134" class="i">+				allowed = append(allowed, meth)
</a><a href="#h1-0-135" id="h1-0-135" class="i">+			}
</a><a href="#h1-0-136" id="h1-0-136" class="i">+		}
</a><a href="#h1-0-137" id="h1-0-137" class="i">+	}
</a><a href="#h1-0-138" id="h1-0-138" class="i">+
</a><a href="#h1-0-139" id="h1-0-139" class="i">+	if len(allowed) == 0 {
</a><a href="#h1-0-140" id="h1-0-140" class="i">+		http.NotFound(w, r)
</a><a href="#h1-0-141" id="h1-0-141" class="i">+		return
</a><a href="#h1-0-142" id="h1-0-142" class="i">+	}
</a><a href="#h1-0-143" id="h1-0-143" class="i">+
</a><a href="#h1-0-144" id="h1-0-144" class="i">+	w.Header().Add(&quot;Allow&quot;, strings.Join(allowed, &quot;, &quot;))
</a><a href="#h1-0-145" id="h1-0-145" class="i">+	http.Error(w, &quot;Method Not Allowed&quot;, 405)
</a><a href="#h1-0-146" id="h1-0-146" class="i">+}
</a><a href="#h1-0-147" id="h1-0-147" class="i">+
</a><a href="#h1-0-148" id="h1-0-148" class="i">+// Head will register a pattern with a handler for HEAD requests.
</a><a href="#h1-0-149" id="h1-0-149" class="i">+func (p *PatternServeMux) Head(pat string, h http.Handler) {
</a><a href="#h1-0-150" id="h1-0-150" class="i">+	p.Add(&quot;HEAD&quot;, pat, h)
</a><a href="#h1-0-151" id="h1-0-151" class="i">+}
</a><a href="#h1-0-152" id="h1-0-152" class="i">+
</a><a href="#h1-0-153" id="h1-0-153" class="i">+// Get will register a pattern with a handler for GET requests.
</a><a href="#h1-0-154" id="h1-0-154" class="i">+// It also registers pat for HEAD requests. If this needs to be overridden, use
</a><a href="#h1-0-155" id="h1-0-155" class="i">+// Head before Get with pat.
</a><a href="#h1-0-156" id="h1-0-156" class="i">+func (p *PatternServeMux) Get(pat string, h http.Handler) {
</a><a href="#h1-0-157" id="h1-0-157" class="i">+	p.Add(&quot;HEAD&quot;, pat, h)
</a><a href="#h1-0-158" id="h1-0-158" class="i">+	p.Add(&quot;GET&quot;, pat, h)
</a><a href="#h1-0-159" id="h1-0-159" class="i">+}
</a><a href="#h1-0-160" id="h1-0-160" class="i">+
</a><a href="#h1-0-161" id="h1-0-161" class="i">+// Post will register a pattern with a handler for POST requests.
</a><a href="#h1-0-162" id="h1-0-162" class="i">+func (p *PatternServeMux) Post(pat string, h http.Handler) {
</a><a href="#h1-0-163" id="h1-0-163" class="i">+	p.Add(&quot;POST&quot;, pat, h)
</a><a href="#h1-0-164" id="h1-0-164" class="i">+}
</a><a href="#h1-0-165" id="h1-0-165" class="i">+
</a><a href="#h1-0-166" id="h1-0-166" class="i">+// Put will register a pattern with a handler for PUT requests.
</a><a href="#h1-0-167" id="h1-0-167" class="i">+func (p *PatternServeMux) Put(pat string, h http.Handler) {
</a><a href="#h1-0-168" id="h1-0-168" class="i">+	p.Add(&quot;PUT&quot;, pat, h)
</a><a href="#h1-0-169" id="h1-0-169" class="i">+}
</a><a href="#h1-0-170" id="h1-0-170" class="i">+
</a><a href="#h1-0-171" id="h1-0-171" class="i">+// Del will register a pattern with a handler for DELETE requests.
</a><a href="#h1-0-172" id="h1-0-172" class="i">+func (p *PatternServeMux) Del(pat string, h http.Handler) {
</a><a href="#h1-0-173" id="h1-0-173" class="i">+	p.Add(&quot;DELETE&quot;, pat, h)
</a><a href="#h1-0-174" id="h1-0-174" class="i">+}
</a><a href="#h1-0-175" id="h1-0-175" class="i">+
</a><a href="#h1-0-176" id="h1-0-176" class="i">+// Options will register a pattern with a handler for OPTIONS requests.
</a><a href="#h1-0-177" id="h1-0-177" class="i">+func (p *PatternServeMux) Options(pat string, h http.Handler) {
</a><a href="#h1-0-178" id="h1-0-178" class="i">+	p.Add(&quot;OPTIONS&quot;, pat, h)
</a><a href="#h1-0-179" id="h1-0-179" class="i">+}
</a><a href="#h1-0-180" id="h1-0-180" class="i">+
</a><a href="#h1-0-181" id="h1-0-181" class="i">+// Patch will register a pattern with a handler for PATCH requests.
</a><a href="#h1-0-182" id="h1-0-182" class="i">+func (p *PatternServeMux) Patch(pat string, h http.Handler) {
</a><a href="#h1-0-183" id="h1-0-183" class="i">+	p.Add(&quot;PATCH&quot;, pat, h)
</a><a href="#h1-0-184" id="h1-0-184" class="i">+}
</a><a href="#h1-0-185" id="h1-0-185" class="i">+
</a><a href="#h1-0-186" id="h1-0-186" class="i">+// Add will register a pattern with a handler for meth requests.
</a><a href="#h1-0-187" id="h1-0-187" class="i">+func (p *PatternServeMux) Add(meth, pat string, h http.Handler) {
</a><a href="#h1-0-188" id="h1-0-188" class="i">+	p.add(meth, pat, h, false)
</a><a href="#h1-0-189" id="h1-0-189" class="i">+}
</a><a href="#h1-0-190" id="h1-0-190" class="i">+
</a><a href="#h1-0-191" id="h1-0-191" class="i">+func (p *PatternServeMux) add(meth, pat string, h http.Handler, redirect bool) {
</a><a href="#h1-0-192" id="h1-0-192" class="i">+	handlers := p.handlers[meth]
</a><a href="#h1-0-193" id="h1-0-193" class="i">+	for _, p1 := range handlers {
</a><a href="#h1-0-194" id="h1-0-194" class="i">+		if p1.pat == pat {
</a><a href="#h1-0-195" id="h1-0-195" class="i">+			return // found existing pattern; do nothing
</a><a href="#h1-0-196" id="h1-0-196" class="i">+		}
</a><a href="#h1-0-197" id="h1-0-197" class="i">+	}
</a><a href="#h1-0-198" id="h1-0-198" class="i">+	handler := &amp;patHandler{
</a><a href="#h1-0-199" id="h1-0-199" class="i">+		pat:      pat,
</a><a href="#h1-0-200" id="h1-0-200" class="i">+		Handler:  h,
</a><a href="#h1-0-201" id="h1-0-201" class="i">+		redirect: redirect,
</a><a href="#h1-0-202" id="h1-0-202" class="i">+	}
</a><a href="#h1-0-203" id="h1-0-203" class="i">+	p.handlers[meth] = append(handlers, handler)
</a><a href="#h1-0-204" id="h1-0-204" class="i">+
</a><a href="#h1-0-205" id="h1-0-205" class="i">+	n := len(pat)
</a><a href="#h1-0-206" id="h1-0-206" class="i">+	if n &gt; 0 &amp;&amp; pat[n-1] == &#39;/&#39; {
</a><a href="#h1-0-207" id="h1-0-207" class="i">+		p.add(meth, pat[:n-1], http.HandlerFunc(addSlashRedirect), true)
</a><a href="#h1-0-208" id="h1-0-208" class="i">+	}
</a><a href="#h1-0-209" id="h1-0-209" class="i">+}
</a><a href="#h1-0-210" id="h1-0-210" class="i">+
</a><a href="#h1-0-211" id="h1-0-211" class="i">+func addSlashRedirect(w http.ResponseWriter, r *http.Request) {
</a><a href="#h1-0-212" id="h1-0-212" class="i">+	u := *r.URL
</a><a href="#h1-0-213" id="h1-0-213" class="i">+	u.Path += &quot;/&quot;
</a><a href="#h1-0-214" id="h1-0-214" class="i">+	http.Redirect(w, r, u.String(), http.StatusMovedPermanently)
</a><a href="#h1-0-215" id="h1-0-215" class="i">+}
</a><a href="#h1-0-216" id="h1-0-216" class="i">+
</a><a href="#h1-0-217" id="h1-0-217" class="i">+// Tail returns the trailing string in path after the final slash for a pat ending with a slash.
</a><a href="#h1-0-218" id="h1-0-218" class="i">+//
</a><a href="#h1-0-219" id="h1-0-219" class="i">+// Examples:
</a><a href="#h1-0-220" id="h1-0-220" class="i">+//
</a><a href="#h1-0-221" id="h1-0-221" class="i">+//	Tail(&quot;/hello/:title/&quot;, &quot;/hello/mr/mizerany&quot;) == &quot;mizerany&quot;
</a><a href="#h1-0-222" id="h1-0-222" class="i">+//	Tail(&quot;/:a/&quot;, &quot;/x/y/z&quot;)                       == &quot;y/z&quot;
</a><a href="#h1-0-223" id="h1-0-223" class="i">+//
</a><a href="#h1-0-224" id="h1-0-224" class="i">+func Tail(pat, path string) string {
</a><a href="#h1-0-225" id="h1-0-225" class="i">+	var i, j int
</a><a href="#h1-0-226" id="h1-0-226" class="i">+	for i &lt; len(path) {
</a><a href="#h1-0-227" id="h1-0-227" class="i">+		switch {
</a><a href="#h1-0-228" id="h1-0-228" class="i">+		case j &gt;= len(pat):
</a><a href="#h1-0-229" id="h1-0-229" class="i">+			if pat[len(pat)-1] == &#39;/&#39; {
</a><a href="#h1-0-230" id="h1-0-230" class="i">+				return path[i:]
</a><a href="#h1-0-231" id="h1-0-231" class="i">+			}
</a><a href="#h1-0-232" id="h1-0-232" class="i">+			return &quot;&quot;
</a><a href="#h1-0-233" id="h1-0-233" class="i">+		case pat[j] == &#39;:&#39;:
</a><a href="#h1-0-234" id="h1-0-234" class="i">+			var nextc byte
</a><a href="#h1-0-235" id="h1-0-235" class="i">+			_, nextc, j = match(pat, isAlnum, j+1)
</a><a href="#h1-0-236" id="h1-0-236" class="i">+			_, _, i = match(path, matchPart(nextc), i)
</a><a href="#h1-0-237" id="h1-0-237" class="i">+		case path[i] == pat[j]:
</a><a href="#h1-0-238" id="h1-0-238" class="i">+			i++
</a><a href="#h1-0-239" id="h1-0-239" class="i">+			j++
</a><a href="#h1-0-240" id="h1-0-240" class="i">+		default:
</a><a href="#h1-0-241" id="h1-0-241" class="i">+			return &quot;&quot;
</a><a href="#h1-0-242" id="h1-0-242" class="i">+		}
</a><a href="#h1-0-243" id="h1-0-243" class="i">+	}
</a><a href="#h1-0-244" id="h1-0-244" class="i">+	return &quot;&quot;
</a><a href="#h1-0-245" id="h1-0-245" class="i">+}
</a><a href="#h1-0-246" id="h1-0-246" class="i">+
</a><a href="#h1-0-247" id="h1-0-247" class="i">+type patHandler struct {
</a><a href="#h1-0-248" id="h1-0-248" class="i">+	pat string
</a><a href="#h1-0-249" id="h1-0-249" class="i">+	http.Handler
</a><a href="#h1-0-250" id="h1-0-250" class="i">+	redirect bool
</a><a href="#h1-0-251" id="h1-0-251" class="i">+}
</a><a href="#h1-0-252" id="h1-0-252" class="i">+
</a><a href="#h1-0-253" id="h1-0-253" class="i">+func (ph *patHandler) try(path string) (url.Values, bool) {
</a><a href="#h1-0-254" id="h1-0-254" class="i">+	p := make(url.Values)
</a><a href="#h1-0-255" id="h1-0-255" class="i">+	var i, j int
</a><a href="#h1-0-256" id="h1-0-256" class="i">+	for i &lt; len(path) {
</a><a href="#h1-0-257" id="h1-0-257" class="i">+		switch {
</a><a href="#h1-0-258" id="h1-0-258" class="i">+		case j &gt;= len(ph.pat):
</a><a href="#h1-0-259" id="h1-0-259" class="i">+			if ph.pat != &quot;/&quot; &amp;&amp; len(ph.pat) &gt; 0 &amp;&amp; ph.pat[len(ph.pat)-1] == &#39;/&#39; {
</a><a href="#h1-0-260" id="h1-0-260" class="i">+				return p, true
</a><a href="#h1-0-261" id="h1-0-261" class="i">+			}
</a><a href="#h1-0-262" id="h1-0-262" class="i">+			return nil, false
</a><a href="#h1-0-263" id="h1-0-263" class="i">+		case ph.pat[j] == &#39;:&#39;:
</a><a href="#h1-0-264" id="h1-0-264" class="i">+			var name, val string
</a><a href="#h1-0-265" id="h1-0-265" class="i">+			var nextc byte
</a><a href="#h1-0-266" id="h1-0-266" class="i">+			name, nextc, j = match(ph.pat, isAlnum, j+1)
</a><a href="#h1-0-267" id="h1-0-267" class="i">+			val, _, i = match(path, matchPart(nextc), i)
</a><a href="#h1-0-268" id="h1-0-268" class="i">+			p.Add(&quot;:&quot;+name, val)
</a><a href="#h1-0-269" id="h1-0-269" class="i">+		case path[i] == ph.pat[j]:
</a><a href="#h1-0-270" id="h1-0-270" class="i">+			i++
</a><a href="#h1-0-271" id="h1-0-271" class="i">+			j++
</a><a href="#h1-0-272" id="h1-0-272" class="i">+		default:
</a><a href="#h1-0-273" id="h1-0-273" class="i">+			return nil, false
</a><a href="#h1-0-274" id="h1-0-274" class="i">+		}
</a><a href="#h1-0-275" id="h1-0-275" class="i">+	}
</a><a href="#h1-0-276" id="h1-0-276" class="i">+	if j != len(ph.pat) {
</a><a href="#h1-0-277" id="h1-0-277" class="i">+		return nil, false
</a><a href="#h1-0-278" id="h1-0-278" class="i">+	}
</a><a href="#h1-0-279" id="h1-0-279" class="i">+	return p, true
</a><a href="#h1-0-280" id="h1-0-280" class="i">+}
</a><a href="#h1-0-281" id="h1-0-281" class="i">+
</a><a href="#h1-0-282" id="h1-0-282" class="i">+func matchPart(b byte) func(byte) bool {
</a><a href="#h1-0-283" id="h1-0-283" class="i">+	return func(c byte) bool {
</a><a href="#h1-0-284" id="h1-0-284" class="i">+		return c != b &amp;&amp; c != &#39;/&#39;
</a><a href="#h1-0-285" id="h1-0-285" class="i">+	}
</a><a href="#h1-0-286" id="h1-0-286" class="i">+}
</a><a href="#h1-0-287" id="h1-0-287" class="i">+
</a><a href="#h1-0-288" id="h1-0-288" class="i">+func match(s string, f func(byte) bool, i int) (matched string, next byte, j int) {
</a><a href="#h1-0-289" id="h1-0-289" class="i">+	j = i
</a><a href="#h1-0-290" id="h1-0-290" class="i">+	for j &lt; len(s) &amp;&amp; f(s[j]) {
</a><a href="#h1-0-291" id="h1-0-291" class="i">+		j++
</a><a href="#h1-0-292" id="h1-0-292" class="i">+	}
</a><a href="#h1-0-293" id="h1-0-293" class="i">+	if j &lt; len(s) {
</a><a href="#h1-0-294" id="h1-0-294" class="i">+		next = s[j]
</a><a href="#h1-0-295" id="h1-0-295" class="i">+	}
</a><a href="#h1-0-296" id="h1-0-296" class="i">+	return s[i:j], next, j
</a><a href="#h1-0-297" id="h1-0-297" class="i">+}
</a><a href="#h1-0-298" id="h1-0-298" class="i">+
</a><a href="#h1-0-299" id="h1-0-299" class="i">+func isAlpha(ch byte) bool {
</a><a href="#h1-0-300" id="h1-0-300" class="i">+	return &#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39; || &#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39; || ch == &#39;_&#39;
</a><a href="#h1-0-301" id="h1-0-301" class="i">+}
</a><a href="#h1-0-302" id="h1-0-302" class="i">+
</a><a href="#h1-0-303" id="h1-0-303" class="i">+func isDigit(ch byte) bool {
</a><a href="#h1-0-304" id="h1-0-304" class="i">+	return &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;
</a><a href="#h1-0-305" id="h1-0-305" class="i">+}
</a><a href="#h1-0-306" id="h1-0-306" class="i">+
</a><a href="#h1-0-307" id="h1-0-307" class="i">+func isAlnum(ch byte) bool {
</a><a href="#h1-0-308" id="h1-0-308" class="i">+	return isAlpha(ch) || isDigit(ch)
</a><a href="#h1-0-309" id="h1-0-309" class="i">+}
</a><b>diff --git a/<a id="h2" href="../file/vendor/github.com/google/go-github/LICENSE">vendor/github.com/google/go-github/LICENSE</a> b/<a href="../file/vendor/github.com/google/go-github/LICENSE">vendor/github.com/google/go-github/LICENSE</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -0,0 +1,341 @@
</a><a href="#h2-0-0" id="h2-0-0" class="i">+Copyright (c) 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h2-0-1" id="h2-0-1" class="i">+
</a><a href="#h2-0-2" id="h2-0-2" class="i">+Redistribution and use in source and binary forms, with or without
</a><a href="#h2-0-3" id="h2-0-3" class="i">+modification, are permitted provided that the following conditions are
</a><a href="#h2-0-4" id="h2-0-4" class="i">+met:
</a><a href="#h2-0-5" id="h2-0-5" class="i">+
</a><a href="#h2-0-6" id="h2-0-6" class="i">+   * Redistributions of source code must retain the above copyright
</a><a href="#h2-0-7" id="h2-0-7" class="i">+notice, this list of conditions and the following disclaimer.
</a><a href="#h2-0-8" id="h2-0-8" class="i">+   * Redistributions in binary form must reproduce the above
</a><a href="#h2-0-9" id="h2-0-9" class="i">+copyright notice, this list of conditions and the following disclaimer
</a><a href="#h2-0-10" id="h2-0-10" class="i">+in the documentation and/or other materials provided with the
</a><a href="#h2-0-11" id="h2-0-11" class="i">+distribution.
</a><a href="#h2-0-12" id="h2-0-12" class="i">+   * Neither the name of Google Inc. nor the names of its
</a><a href="#h2-0-13" id="h2-0-13" class="i">+contributors may be used to endorse or promote products derived from
</a><a href="#h2-0-14" id="h2-0-14" class="i">+this software without specific prior written permission.
</a><a href="#h2-0-15" id="h2-0-15" class="i">+
</a><a href="#h2-0-16" id="h2-0-16" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h2-0-17" id="h2-0-17" class="i">+&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h2-0-18" id="h2-0-18" class="i">+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h2-0-19" id="h2-0-19" class="i">+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h2-0-20" id="h2-0-20" class="i">+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h2-0-21" id="h2-0-21" class="i">+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h2-0-22" id="h2-0-22" class="i">+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h2-0-23" id="h2-0-23" class="i">+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h2-0-24" id="h2-0-24" class="i">+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h2-0-25" id="h2-0-25" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h2-0-26" id="h2-0-26" class="i">+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h2-0-27" id="h2-0-27" class="i">+
</a><a href="#h2-0-28" id="h2-0-28" class="i">+----------
</a><a href="#h2-0-29" id="h2-0-29" class="i">+
</a><a href="#h2-0-30" id="h2-0-30" class="i">+Some documentation is taken from the GitHub Developer site
</a><a href="#h2-0-31" id="h2-0-31" class="i">+&lt;http://developer.github.com/&gt;, which is available under the following Creative
</a><a href="#h2-0-32" id="h2-0-32" class="i">+Commons Attribution 3.0 License.  This applies only to the go-github source
</a><a href="#h2-0-33" id="h2-0-33" class="i">+code and would not apply to any compiled binaries.
</a><a href="#h2-0-34" id="h2-0-34" class="i">+
</a><a href="#h2-0-35" id="h2-0-35" class="i">+THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE
</a><a href="#h2-0-36" id="h2-0-36" class="i">+COMMONS PUBLIC LICENSE (&quot;CCPL&quot; OR &quot;LICENSE&quot;). THE WORK IS PROTECTED BY
</a><a href="#h2-0-37" id="h2-0-37" class="i">+COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
</a><a href="#h2-0-38" id="h2-0-38" class="i">+AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
</a><a href="#h2-0-39" id="h2-0-39" class="i">+
</a><a href="#h2-0-40" id="h2-0-40" class="i">+BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
</a><a href="#h2-0-41" id="h2-0-41" class="i">+TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
</a><a href="#h2-0-42" id="h2-0-42" class="i">+BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
</a><a href="#h2-0-43" id="h2-0-43" class="i">+CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
</a><a href="#h2-0-44" id="h2-0-44" class="i">+CONDITIONS.
</a><a href="#h2-0-45" id="h2-0-45" class="i">+
</a><a href="#h2-0-46" id="h2-0-46" class="i">+1. Definitions
</a><a href="#h2-0-47" id="h2-0-47" class="i">+
</a><a href="#h2-0-48" id="h2-0-48" class="i">+ a. &quot;Adaptation&quot; means a work based upon the Work, or upon the Work and
</a><a href="#h2-0-49" id="h2-0-49" class="i">+    other pre-existing works, such as a translation, adaptation,
</a><a href="#h2-0-50" id="h2-0-50" class="i">+    derivative work, arrangement of music or other alterations of a
</a><a href="#h2-0-51" id="h2-0-51" class="i">+    literary or artistic work, or phonogram or performance and includes
</a><a href="#h2-0-52" id="h2-0-52" class="i">+    cinematographic adaptations or any other form in which the Work may be
</a><a href="#h2-0-53" id="h2-0-53" class="i">+    recast, transformed, or adapted including in any form recognizably
</a><a href="#h2-0-54" id="h2-0-54" class="i">+    derived from the original, except that a work that constitutes a
</a><a href="#h2-0-55" id="h2-0-55" class="i">+    Collection will not be considered an Adaptation for the purpose of
</a><a href="#h2-0-56" id="h2-0-56" class="i">+    this License. For the avoidance of doubt, where the Work is a musical
</a><a href="#h2-0-57" id="h2-0-57" class="i">+    work, performance or phonogram, the synchronization of the Work in
</a><a href="#h2-0-58" id="h2-0-58" class="i">+    timed-relation with a moving image (&quot;synching&quot;) will be considered an
</a><a href="#h2-0-59" id="h2-0-59" class="i">+    Adaptation for the purpose of this License.
</a><a href="#h2-0-60" id="h2-0-60" class="i">+ b. &quot;Collection&quot; means a collection of literary or artistic works, such as
</a><a href="#h2-0-61" id="h2-0-61" class="i">+    encyclopedias and anthologies, or performances, phonograms or
</a><a href="#h2-0-62" id="h2-0-62" class="i">+    broadcasts, or other works or subject matter other than works listed
</a><a href="#h2-0-63" id="h2-0-63" class="i">+    in Section 1(f) below, which, by reason of the selection and
</a><a href="#h2-0-64" id="h2-0-64" class="i">+    arrangement of their contents, constitute intellectual creations, in
</a><a href="#h2-0-65" id="h2-0-65" class="i">+    which the Work is included in its entirety in unmodified form along
</a><a href="#h2-0-66" id="h2-0-66" class="i">+    with one or more other contributions, each constituting separate and
</a><a href="#h2-0-67" id="h2-0-67" class="i">+    independent works in themselves, which together are assembled into a
</a><a href="#h2-0-68" id="h2-0-68" class="i">+    collective whole. A work that constitutes a Collection will not be
</a><a href="#h2-0-69" id="h2-0-69" class="i">+    considered an Adaptation (as defined above) for the purposes of this
</a><a href="#h2-0-70" id="h2-0-70" class="i">+    License.
</a><a href="#h2-0-71" id="h2-0-71" class="i">+ c. &quot;Distribute&quot; means to make available to the public the original and
</a><a href="#h2-0-72" id="h2-0-72" class="i">+    copies of the Work or Adaptation, as appropriate, through sale or
</a><a href="#h2-0-73" id="h2-0-73" class="i">+    other transfer of ownership.
</a><a href="#h2-0-74" id="h2-0-74" class="i">+ d. &quot;Licensor&quot; means the individual, individuals, entity or entities that
</a><a href="#h2-0-75" id="h2-0-75" class="i">+    offer(s) the Work under the terms of this License.
</a><a href="#h2-0-76" id="h2-0-76" class="i">+ e. &quot;Original Author&quot; means, in the case of a literary or artistic work,
</a><a href="#h2-0-77" id="h2-0-77" class="i">+    the individual, individuals, entity or entities who created the Work
</a><a href="#h2-0-78" id="h2-0-78" class="i">+    or if no individual or entity can be identified, the publisher; and in
</a><a href="#h2-0-79" id="h2-0-79" class="i">+    addition (i) in the case of a performance the actors, singers,
</a><a href="#h2-0-80" id="h2-0-80" class="i">+    musicians, dancers, and other persons who act, sing, deliver, declaim,
</a><a href="#h2-0-81" id="h2-0-81" class="i">+    play in, interpret or otherwise perform literary or artistic works or
</a><a href="#h2-0-82" id="h2-0-82" class="i">+    expressions of folklore; (ii) in the case of a phonogram the producer
</a><a href="#h2-0-83" id="h2-0-83" class="i">+    being the person or legal entity who first fixes the sounds of a
</a><a href="#h2-0-84" id="h2-0-84" class="i">+    performance or other sounds; and, (iii) in the case of broadcasts, the
</a><a href="#h2-0-85" id="h2-0-85" class="i">+    organization that transmits the broadcast.
</a><a href="#h2-0-86" id="h2-0-86" class="i">+ f. &quot;Work&quot; means the literary and/or artistic work offered under the terms
</a><a href="#h2-0-87" id="h2-0-87" class="i">+    of this License including without limitation any production in the
</a><a href="#h2-0-88" id="h2-0-88" class="i">+    literary, scientific and artistic domain, whatever may be the mode or
</a><a href="#h2-0-89" id="h2-0-89" class="i">+    form of its expression including digital form, such as a book,
</a><a href="#h2-0-90" id="h2-0-90" class="i">+    pamphlet and other writing; a lecture, address, sermon or other work
</a><a href="#h2-0-91" id="h2-0-91" class="i">+    of the same nature; a dramatic or dramatico-musical work; a
</a><a href="#h2-0-92" id="h2-0-92" class="i">+    choreographic work or entertainment in dumb show; a musical
</a><a href="#h2-0-93" id="h2-0-93" class="i">+    composition with or without words; a cinematographic work to which are
</a><a href="#h2-0-94" id="h2-0-94" class="i">+    assimilated works expressed by a process analogous to cinematography;
</a><a href="#h2-0-95" id="h2-0-95" class="i">+    a work of drawing, painting, architecture, sculpture, engraving or
</a><a href="#h2-0-96" id="h2-0-96" class="i">+    lithography; a photographic work to which are assimilated works
</a><a href="#h2-0-97" id="h2-0-97" class="i">+    expressed by a process analogous to photography; a work of applied
</a><a href="#h2-0-98" id="h2-0-98" class="i">+    art; an illustration, map, plan, sketch or three-dimensional work
</a><a href="#h2-0-99" id="h2-0-99" class="i">+    relative to geography, topography, architecture or science; a
</a><a href="#h2-0-100" id="h2-0-100" class="i">+    performance; a broadcast; a phonogram; a compilation of data to the
</a><a href="#h2-0-101" id="h2-0-101" class="i">+    extent it is protected as a copyrightable work; or a work performed by
</a><a href="#h2-0-102" id="h2-0-102" class="i">+    a variety or circus performer to the extent it is not otherwise
</a><a href="#h2-0-103" id="h2-0-103" class="i">+    considered a literary or artistic work.
</a><a href="#h2-0-104" id="h2-0-104" class="i">+ g. &quot;You&quot; means an individual or entity exercising rights under this
</a><a href="#h2-0-105" id="h2-0-105" class="i">+    License who has not previously violated the terms of this License with
</a><a href="#h2-0-106" id="h2-0-106" class="i">+    respect to the Work, or who has received express permission from the
</a><a href="#h2-0-107" id="h2-0-107" class="i">+    Licensor to exercise rights under this License despite a previous
</a><a href="#h2-0-108" id="h2-0-108" class="i">+    violation.
</a><a href="#h2-0-109" id="h2-0-109" class="i">+ h. &quot;Publicly Perform&quot; means to perform public recitations of the Work and
</a><a href="#h2-0-110" id="h2-0-110" class="i">+    to communicate to the public those public recitations, by any means or
</a><a href="#h2-0-111" id="h2-0-111" class="i">+    process, including by wire or wireless means or public digital
</a><a href="#h2-0-112" id="h2-0-112" class="i">+    performances; to make available to the public Works in such a way that
</a><a href="#h2-0-113" id="h2-0-113" class="i">+    members of the public may access these Works from a place and at a
</a><a href="#h2-0-114" id="h2-0-114" class="i">+    place individually chosen by them; to perform the Work to the public
</a><a href="#h2-0-115" id="h2-0-115" class="i">+    by any means or process and the communication to the public of the
</a><a href="#h2-0-116" id="h2-0-116" class="i">+    performances of the Work, including by public digital performance; to
</a><a href="#h2-0-117" id="h2-0-117" class="i">+    broadcast and rebroadcast the Work by any means including signs,
</a><a href="#h2-0-118" id="h2-0-118" class="i">+    sounds or images.
</a><a href="#h2-0-119" id="h2-0-119" class="i">+ i. &quot;Reproduce&quot; means to make copies of the Work by any means including
</a><a href="#h2-0-120" id="h2-0-120" class="i">+    without limitation by sound or visual recordings and the right of
</a><a href="#h2-0-121" id="h2-0-121" class="i">+    fixation and reproducing fixations of the Work, including storage of a
</a><a href="#h2-0-122" id="h2-0-122" class="i">+    protected performance or phonogram in digital form or other electronic
</a><a href="#h2-0-123" id="h2-0-123" class="i">+    medium.
</a><a href="#h2-0-124" id="h2-0-124" class="i">+
</a><a href="#h2-0-125" id="h2-0-125" class="i">+2. Fair Dealing Rights. Nothing in this License is intended to reduce,
</a><a href="#h2-0-126" id="h2-0-126" class="i">+limit, or restrict any uses free from copyright or rights arising from
</a><a href="#h2-0-127" id="h2-0-127" class="i">+limitations or exceptions that are provided for in connection with the
</a><a href="#h2-0-128" id="h2-0-128" class="i">+copyright protection under copyright law or other applicable laws.
</a><a href="#h2-0-129" id="h2-0-129" class="i">+
</a><a href="#h2-0-130" id="h2-0-130" class="i">+3. License Grant. Subject to the terms and conditions of this License,
</a><a href="#h2-0-131" id="h2-0-131" class="i">+Licensor hereby grants You a worldwide, royalty-free, non-exclusive,
</a><a href="#h2-0-132" id="h2-0-132" class="i">+perpetual (for the duration of the applicable copyright) license to
</a><a href="#h2-0-133" id="h2-0-133" class="i">+exercise the rights in the Work as stated below:
</a><a href="#h2-0-134" id="h2-0-134" class="i">+
</a><a href="#h2-0-135" id="h2-0-135" class="i">+ a. to Reproduce the Work, to incorporate the Work into one or more
</a><a href="#h2-0-136" id="h2-0-136" class="i">+    Collections, and to Reproduce the Work as incorporated in the
</a><a href="#h2-0-137" id="h2-0-137" class="i">+    Collections;
</a><a href="#h2-0-138" id="h2-0-138" class="i">+ b. to create and Reproduce Adaptations provided that any such Adaptation,
</a><a href="#h2-0-139" id="h2-0-139" class="i">+    including any translation in any medium, takes reasonable steps to
</a><a href="#h2-0-140" id="h2-0-140" class="i">+    clearly label, demarcate or otherwise identify that changes were made
</a><a href="#h2-0-141" id="h2-0-141" class="i">+    to the original Work. For example, a translation could be marked &quot;The
</a><a href="#h2-0-142" id="h2-0-142" class="i">+    original work was translated from English to Spanish,&quot; or a
</a><a href="#h2-0-143" id="h2-0-143" class="i">+    modification could indicate &quot;The original work has been modified.&quot;;
</a><a href="#h2-0-144" id="h2-0-144" class="i">+ c. to Distribute and Publicly Perform the Work including as incorporated
</a><a href="#h2-0-145" id="h2-0-145" class="i">+    in Collections; and,
</a><a href="#h2-0-146" id="h2-0-146" class="i">+ d. to Distribute and Publicly Perform Adaptations.
</a><a href="#h2-0-147" id="h2-0-147" class="i">+ e. For the avoidance of doubt:
</a><a href="#h2-0-148" id="h2-0-148" class="i">+
</a><a href="#h2-0-149" id="h2-0-149" class="i">+     i. Non-waivable Compulsory License Schemes. In those jurisdictions in
</a><a href="#h2-0-150" id="h2-0-150" class="i">+        which the right to collect royalties through any statutory or
</a><a href="#h2-0-151" id="h2-0-151" class="i">+        compulsory licensing scheme cannot be waived, the Licensor
</a><a href="#h2-0-152" id="h2-0-152" class="i">+        reserves the exclusive right to collect such royalties for any
</a><a href="#h2-0-153" id="h2-0-153" class="i">+        exercise by You of the rights granted under this License;
</a><a href="#h2-0-154" id="h2-0-154" class="i">+    ii. Waivable Compulsory License Schemes. In those jurisdictions in
</a><a href="#h2-0-155" id="h2-0-155" class="i">+        which the right to collect royalties through any statutory or
</a><a href="#h2-0-156" id="h2-0-156" class="i">+        compulsory licensing scheme can be waived, the Licensor waives the
</a><a href="#h2-0-157" id="h2-0-157" class="i">+        exclusive right to collect such royalties for any exercise by You
</a><a href="#h2-0-158" id="h2-0-158" class="i">+        of the rights granted under this License; and,
</a><a href="#h2-0-159" id="h2-0-159" class="i">+   iii. Voluntary License Schemes. The Licensor waives the right to
</a><a href="#h2-0-160" id="h2-0-160" class="i">+        collect royalties, whether individually or, in the event that the
</a><a href="#h2-0-161" id="h2-0-161" class="i">+        Licensor is a member of a collecting society that administers
</a><a href="#h2-0-162" id="h2-0-162" class="i">+        voluntary licensing schemes, via that society, from any exercise
</a><a href="#h2-0-163" id="h2-0-163" class="i">+        by You of the rights granted under this License.
</a><a href="#h2-0-164" id="h2-0-164" class="i">+
</a><a href="#h2-0-165" id="h2-0-165" class="i">+The above rights may be exercised in all media and formats whether now
</a><a href="#h2-0-166" id="h2-0-166" class="i">+known or hereafter devised. The above rights include the right to make
</a><a href="#h2-0-167" id="h2-0-167" class="i">+such modifications as are technically necessary to exercise the rights in
</a><a href="#h2-0-168" id="h2-0-168" class="i">+other media and formats. Subject to Section 8(f), all rights not expressly
</a><a href="#h2-0-169" id="h2-0-169" class="i">+granted by Licensor are hereby reserved.
</a><a href="#h2-0-170" id="h2-0-170" class="i">+
</a><a href="#h2-0-171" id="h2-0-171" class="i">+4. Restrictions. The license granted in Section 3 above is expressly made
</a><a href="#h2-0-172" id="h2-0-172" class="i">+subject to and limited by the following restrictions:
</a><a href="#h2-0-173" id="h2-0-173" class="i">+
</a><a href="#h2-0-174" id="h2-0-174" class="i">+ a. You may Distribute or Publicly Perform the Work only under the terms
</a><a href="#h2-0-175" id="h2-0-175" class="i">+    of this License. You must include a copy of, or the Uniform Resource
</a><a href="#h2-0-176" id="h2-0-176" class="i">+    Identifier (URI) for, this License with every copy of the Work You
</a><a href="#h2-0-177" id="h2-0-177" class="i">+    Distribute or Publicly Perform. You may not offer or impose any terms
</a><a href="#h2-0-178" id="h2-0-178" class="i">+    on the Work that restrict the terms of this License or the ability of
</a><a href="#h2-0-179" id="h2-0-179" class="i">+    the recipient of the Work to exercise the rights granted to that
</a><a href="#h2-0-180" id="h2-0-180" class="i">+    recipient under the terms of the License. You may not sublicense the
</a><a href="#h2-0-181" id="h2-0-181" class="i">+    Work. You must keep intact all notices that refer to this License and
</a><a href="#h2-0-182" id="h2-0-182" class="i">+    to the disclaimer of warranties with every copy of the Work You
</a><a href="#h2-0-183" id="h2-0-183" class="i">+    Distribute or Publicly Perform. When You Distribute or Publicly
</a><a href="#h2-0-184" id="h2-0-184" class="i">+    Perform the Work, You may not impose any effective technological
</a><a href="#h2-0-185" id="h2-0-185" class="i">+    measures on the Work that restrict the ability of a recipient of the
</a><a href="#h2-0-186" id="h2-0-186" class="i">+    Work from You to exercise the rights granted to that recipient under
</a><a href="#h2-0-187" id="h2-0-187" class="i">+    the terms of the License. This Section 4(a) applies to the Work as
</a><a href="#h2-0-188" id="h2-0-188" class="i">+    incorporated in a Collection, but this does not require the Collection
</a><a href="#h2-0-189" id="h2-0-189" class="i">+    apart from the Work itself to be made subject to the terms of this
</a><a href="#h2-0-190" id="h2-0-190" class="i">+    License. If You create a Collection, upon notice from any Licensor You
</a><a href="#h2-0-191" id="h2-0-191" class="i">+    must, to the extent practicable, remove from the Collection any credit
</a><a href="#h2-0-192" id="h2-0-192" class="i">+    as required by Section 4(b), as requested. If You create an
</a><a href="#h2-0-193" id="h2-0-193" class="i">+    Adaptation, upon notice from any Licensor You must, to the extent
</a><a href="#h2-0-194" id="h2-0-194" class="i">+    practicable, remove from the Adaptation any credit as required by
</a><a href="#h2-0-195" id="h2-0-195" class="i">+    Section 4(b), as requested.
</a><a href="#h2-0-196" id="h2-0-196" class="i">+ b. If You Distribute, or Publicly Perform the Work or any Adaptations or
</a><a href="#h2-0-197" id="h2-0-197" class="i">+    Collections, You must, unless a request has been made pursuant to
</a><a href="#h2-0-198" id="h2-0-198" class="i">+    Section 4(a), keep intact all copyright notices for the Work and
</a><a href="#h2-0-199" id="h2-0-199" class="i">+    provide, reasonable to the medium or means You are utilizing: (i) the
</a><a href="#h2-0-200" id="h2-0-200" class="i">+    name of the Original Author (or pseudonym, if applicable) if supplied,
</a><a href="#h2-0-201" id="h2-0-201" class="i">+    and/or if the Original Author and/or Licensor designate another party
</a><a href="#h2-0-202" id="h2-0-202" class="i">+    or parties (e.g., a sponsor institute, publishing entity, journal) for
</a><a href="#h2-0-203" id="h2-0-203" class="i">+    attribution (&quot;Attribution Parties&quot;) in Licensor&#39;s copyright notice,
</a><a href="#h2-0-204" id="h2-0-204" class="i">+    terms of service or by other reasonable means, the name of such party
</a><a href="#h2-0-205" id="h2-0-205" class="i">+    or parties; (ii) the title of the Work if supplied; (iii) to the
</a><a href="#h2-0-206" id="h2-0-206" class="i">+    extent reasonably practicable, the URI, if any, that Licensor
</a><a href="#h2-0-207" id="h2-0-207" class="i">+    specifies to be associated with the Work, unless such URI does not
</a><a href="#h2-0-208" id="h2-0-208" class="i">+    refer to the copyright notice or licensing information for the Work;
</a><a href="#h2-0-209" id="h2-0-209" class="i">+    and (iv) , consistent with Section 3(b), in the case of an Adaptation,
</a><a href="#h2-0-210" id="h2-0-210" class="i">+    a credit identifying the use of the Work in the Adaptation (e.g.,
</a><a href="#h2-0-211" id="h2-0-211" class="i">+    &quot;French translation of the Work by Original Author,&quot; or &quot;Screenplay
</a><a href="#h2-0-212" id="h2-0-212" class="i">+    based on original Work by Original Author&quot;). The credit required by
</a><a href="#h2-0-213" id="h2-0-213" class="i">+    this Section 4 (b) may be implemented in any reasonable manner;
</a><a href="#h2-0-214" id="h2-0-214" class="i">+    provided, however, that in the case of a Adaptation or Collection, at
</a><a href="#h2-0-215" id="h2-0-215" class="i">+    a minimum such credit will appear, if a credit for all contributing
</a><a href="#h2-0-216" id="h2-0-216" class="i">+    authors of the Adaptation or Collection appears, then as part of these
</a><a href="#h2-0-217" id="h2-0-217" class="i">+    credits and in a manner at least as prominent as the credits for the
</a><a href="#h2-0-218" id="h2-0-218" class="i">+    other contributing authors. For the avoidance of doubt, You may only
</a><a href="#h2-0-219" id="h2-0-219" class="i">+    use the credit required by this Section for the purpose of attribution
</a><a href="#h2-0-220" id="h2-0-220" class="i">+    in the manner set out above and, by exercising Your rights under this
</a><a href="#h2-0-221" id="h2-0-221" class="i">+    License, You may not implicitly or explicitly assert or imply any
</a><a href="#h2-0-222" id="h2-0-222" class="i">+    connection with, sponsorship or endorsement by the Original Author,
</a><a href="#h2-0-223" id="h2-0-223" class="i">+    Licensor and/or Attribution Parties, as appropriate, of You or Your
</a><a href="#h2-0-224" id="h2-0-224" class="i">+    use of the Work, without the separate, express prior written
</a><a href="#h2-0-225" id="h2-0-225" class="i">+    permission of the Original Author, Licensor and/or Attribution
</a><a href="#h2-0-226" id="h2-0-226" class="i">+    Parties.
</a><a href="#h2-0-227" id="h2-0-227" class="i">+ c. Except as otherwise agreed in writing by the Licensor or as may be
</a><a href="#h2-0-228" id="h2-0-228" class="i">+    otherwise permitted by applicable law, if You Reproduce, Distribute or
</a><a href="#h2-0-229" id="h2-0-229" class="i">+    Publicly Perform the Work either by itself or as part of any
</a><a href="#h2-0-230" id="h2-0-230" class="i">+    Adaptations or Collections, You must not distort, mutilate, modify or
</a><a href="#h2-0-231" id="h2-0-231" class="i">+    take other derogatory action in relation to the Work which would be
</a><a href="#h2-0-232" id="h2-0-232" class="i">+    prejudicial to the Original Author&#39;s honor or reputation. Licensor
</a><a href="#h2-0-233" id="h2-0-233" class="i">+    agrees that in those jurisdictions (e.g. Japan), in which any exercise
</a><a href="#h2-0-234" id="h2-0-234" class="i">+    of the right granted in Section 3(b) of this License (the right to
</a><a href="#h2-0-235" id="h2-0-235" class="i">+    make Adaptations) would be deemed to be a distortion, mutilation,
</a><a href="#h2-0-236" id="h2-0-236" class="i">+    modification or other derogatory action prejudicial to the Original
</a><a href="#h2-0-237" id="h2-0-237" class="i">+    Author&#39;s honor and reputation, the Licensor will waive or not assert,
</a><a href="#h2-0-238" id="h2-0-238" class="i">+    as appropriate, this Section, to the fullest extent permitted by the
</a><a href="#h2-0-239" id="h2-0-239" class="i">+    applicable national law, to enable You to reasonably exercise Your
</a><a href="#h2-0-240" id="h2-0-240" class="i">+    right under Section 3(b) of this License (right to make Adaptations)
</a><a href="#h2-0-241" id="h2-0-241" class="i">+    but not otherwise.
</a><a href="#h2-0-242" id="h2-0-242" class="i">+
</a><a href="#h2-0-243" id="h2-0-243" class="i">+5. Representations, Warranties and Disclaimer
</a><a href="#h2-0-244" id="h2-0-244" class="i">+
</a><a href="#h2-0-245" id="h2-0-245" class="i">+UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
</a><a href="#h2-0-246" id="h2-0-246" class="i">+OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
</a><a href="#h2-0-247" id="h2-0-247" class="i">+KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
</a><a href="#h2-0-248" id="h2-0-248" class="i">+INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
</a><a href="#h2-0-249" id="h2-0-249" class="i">+FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
</a><a href="#h2-0-250" id="h2-0-250" class="i">+LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
</a><a href="#h2-0-251" id="h2-0-251" class="i">+WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION
</a><a href="#h2-0-252" id="h2-0-252" class="i">+OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
</a><a href="#h2-0-253" id="h2-0-253" class="i">+
</a><a href="#h2-0-254" id="h2-0-254" class="i">+6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE
</a><a href="#h2-0-255" id="h2-0-255" class="i">+LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR
</a><a href="#h2-0-256" id="h2-0-256" class="i">+ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES
</a><a href="#h2-0-257" id="h2-0-257" class="i">+ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS
</a><a href="#h2-0-258" id="h2-0-258" class="i">+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
</a><a href="#h2-0-259" id="h2-0-259" class="i">+
</a><a href="#h2-0-260" id="h2-0-260" class="i">+7. Termination
</a><a href="#h2-0-261" id="h2-0-261" class="i">+
</a><a href="#h2-0-262" id="h2-0-262" class="i">+ a. This License and the rights granted hereunder will terminate
</a><a href="#h2-0-263" id="h2-0-263" class="i">+    automatically upon any breach by You of the terms of this License.
</a><a href="#h2-0-264" id="h2-0-264" class="i">+    Individuals or entities who have received Adaptations or Collections
</a><a href="#h2-0-265" id="h2-0-265" class="i">+    from You under this License, however, will not have their licenses
</a><a href="#h2-0-266" id="h2-0-266" class="i">+    terminated provided such individuals or entities remain in full
</a><a href="#h2-0-267" id="h2-0-267" class="i">+    compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will
</a><a href="#h2-0-268" id="h2-0-268" class="i">+    survive any termination of this License.
</a><a href="#h2-0-269" id="h2-0-269" class="i">+ b. Subject to the above terms and conditions, the license granted here is
</a><a href="#h2-0-270" id="h2-0-270" class="i">+    perpetual (for the duration of the applicable copyright in the Work).
</a><a href="#h2-0-271" id="h2-0-271" class="i">+    Notwithstanding the above, Licensor reserves the right to release the
</a><a href="#h2-0-272" id="h2-0-272" class="i">+    Work under different license terms or to stop distributing the Work at
</a><a href="#h2-0-273" id="h2-0-273" class="i">+    any time; provided, however that any such election will not serve to
</a><a href="#h2-0-274" id="h2-0-274" class="i">+    withdraw this License (or any other license that has been, or is
</a><a href="#h2-0-275" id="h2-0-275" class="i">+    required to be, granted under the terms of this License), and this
</a><a href="#h2-0-276" id="h2-0-276" class="i">+    License will continue in full force and effect unless terminated as
</a><a href="#h2-0-277" id="h2-0-277" class="i">+    stated above.
</a><a href="#h2-0-278" id="h2-0-278" class="i">+
</a><a href="#h2-0-279" id="h2-0-279" class="i">+8. Miscellaneous
</a><a href="#h2-0-280" id="h2-0-280" class="i">+
</a><a href="#h2-0-281" id="h2-0-281" class="i">+ a. Each time You Distribute or Publicly Perform the Work or a Collection,
</a><a href="#h2-0-282" id="h2-0-282" class="i">+    the Licensor offers to the recipient a license to the Work on the same
</a><a href="#h2-0-283" id="h2-0-283" class="i">+    terms and conditions as the license granted to You under this License.
</a><a href="#h2-0-284" id="h2-0-284" class="i">+ b. Each time You Distribute or Publicly Perform an Adaptation, Licensor
</a><a href="#h2-0-285" id="h2-0-285" class="i">+    offers to the recipient a license to the original Work on the same
</a><a href="#h2-0-286" id="h2-0-286" class="i">+    terms and conditions as the license granted to You under this License.
</a><a href="#h2-0-287" id="h2-0-287" class="i">+ c. If any provision of this License is invalid or unenforceable under
</a><a href="#h2-0-288" id="h2-0-288" class="i">+    applicable law, it shall not affect the validity or enforceability of
</a><a href="#h2-0-289" id="h2-0-289" class="i">+    the remainder of the terms of this License, and without further action
</a><a href="#h2-0-290" id="h2-0-290" class="i">+    by the parties to this agreement, such provision shall be reformed to
</a><a href="#h2-0-291" id="h2-0-291" class="i">+    the minimum extent necessary to make such provision valid and
</a><a href="#h2-0-292" id="h2-0-292" class="i">+    enforceable.
</a><a href="#h2-0-293" id="h2-0-293" class="i">+ d. No term or provision of this License shall be deemed waived and no
</a><a href="#h2-0-294" id="h2-0-294" class="i">+    breach consented to unless such waiver or consent shall be in writing
</a><a href="#h2-0-295" id="h2-0-295" class="i">+    and signed by the party to be charged with such waiver or consent.
</a><a href="#h2-0-296" id="h2-0-296" class="i">+ e. This License constitutes the entire agreement between the parties with
</a><a href="#h2-0-297" id="h2-0-297" class="i">+    respect to the Work licensed here. There are no understandings,
</a><a href="#h2-0-298" id="h2-0-298" class="i">+    agreements or representations with respect to the Work not specified
</a><a href="#h2-0-299" id="h2-0-299" class="i">+    here. Licensor shall not be bound by any additional provisions that
</a><a href="#h2-0-300" id="h2-0-300" class="i">+    may appear in any communication from You. This License may not be
</a><a href="#h2-0-301" id="h2-0-301" class="i">+    modified without the mutual written agreement of the Licensor and You.
</a><a href="#h2-0-302" id="h2-0-302" class="i">+ f. The rights granted under, and the subject matter referenced, in this
</a><a href="#h2-0-303" id="h2-0-303" class="i">+    License were drafted utilizing the terminology of the Berne Convention
</a><a href="#h2-0-304" id="h2-0-304" class="i">+    for the Protection of Literary and Artistic Works (as amended on
</a><a href="#h2-0-305" id="h2-0-305" class="i">+    September 28, 1979), the Rome Convention of 1961, the WIPO Copyright
</a><a href="#h2-0-306" id="h2-0-306" class="i">+    Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996
</a><a href="#h2-0-307" id="h2-0-307" class="i">+    and the Universal Copyright Convention (as revised on July 24, 1971).
</a><a href="#h2-0-308" id="h2-0-308" class="i">+    These rights and subject matter take effect in the relevant
</a><a href="#h2-0-309" id="h2-0-309" class="i">+    jurisdiction in which the License terms are sought to be enforced
</a><a href="#h2-0-310" id="h2-0-310" class="i">+    according to the corresponding provisions of the implementation of
</a><a href="#h2-0-311" id="h2-0-311" class="i">+    those treaty provisions in the applicable national law. If the
</a><a href="#h2-0-312" id="h2-0-312" class="i">+    standard suite of rights granted under applicable copyright law
</a><a href="#h2-0-313" id="h2-0-313" class="i">+    includes additional rights not granted under this License, such
</a><a href="#h2-0-314" id="h2-0-314" class="i">+    additional rights are deemed to be included in the License; this
</a><a href="#h2-0-315" id="h2-0-315" class="i">+    License is not intended to restrict the license of any rights under
</a><a href="#h2-0-316" id="h2-0-316" class="i">+    applicable law.
</a><a href="#h2-0-317" id="h2-0-317" class="i">+
</a><a href="#h2-0-318" id="h2-0-318" class="i">+
</a><a href="#h2-0-319" id="h2-0-319" class="i">+Creative Commons Notice
</a><a href="#h2-0-320" id="h2-0-320" class="i">+
</a><a href="#h2-0-321" id="h2-0-321" class="i">+    Creative Commons is not a party to this License, and makes no warranty
</a><a href="#h2-0-322" id="h2-0-322" class="i">+    whatsoever in connection with the Work. Creative Commons will not be
</a><a href="#h2-0-323" id="h2-0-323" class="i">+    liable to You or any party on any legal theory for any damages
</a><a href="#h2-0-324" id="h2-0-324" class="i">+    whatsoever, including without limitation any general, special,
</a><a href="#h2-0-325" id="h2-0-325" class="i">+    incidental or consequential damages arising in connection to this
</a><a href="#h2-0-326" id="h2-0-326" class="i">+    license. Notwithstanding the foregoing two (2) sentences, if Creative
</a><a href="#h2-0-327" id="h2-0-327" class="i">+    Commons has expressly identified itself as the Licensor hereunder, it
</a><a href="#h2-0-328" id="h2-0-328" class="i">+    shall have all rights and obligations of Licensor.
</a><a href="#h2-0-329" id="h2-0-329" class="i">+
</a><a href="#h2-0-330" id="h2-0-330" class="i">+    Except for the limited purpose of indicating to the public that the
</a><a href="#h2-0-331" id="h2-0-331" class="i">+    Work is licensed under the CCPL, Creative Commons does not authorize
</a><a href="#h2-0-332" id="h2-0-332" class="i">+    the use by either party of the trademark &quot;Creative Commons&quot; or any
</a><a href="#h2-0-333" id="h2-0-333" class="i">+    related trademark or logo of Creative Commons without the prior
</a><a href="#h2-0-334" id="h2-0-334" class="i">+    written consent of Creative Commons. Any permitted use will be in
</a><a href="#h2-0-335" id="h2-0-335" class="i">+    compliance with Creative Commons&#39; then-current trademark usage
</a><a href="#h2-0-336" id="h2-0-336" class="i">+    guidelines, as may be published on its website or otherwise made
</a><a href="#h2-0-337" id="h2-0-337" class="i">+    available upon request from time to time. For the avoidance of doubt,
</a><a href="#h2-0-338" id="h2-0-338" class="i">+    this trademark restriction does not form part of this License.
</a><a href="#h2-0-339" id="h2-0-339" class="i">+
</a><a href="#h2-0-340" id="h2-0-340" class="i">+    Creative Commons may be contacted at http://creativecommons.org/.
</a><b>diff --git a/<a id="h3" href="../file/vendor/github.com/google/go-github/github/activity.go">vendor/github.com/google/go-github/github/activity.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/activity.go">vendor/github.com/google/go-github/github/activity.go</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -0,0 +1,69 @@
</a><a href="#h3-0-0" id="h3-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h3-0-1" id="h3-0-1" class="i">+//
</a><a href="#h3-0-2" id="h3-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h3-0-3" id="h3-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h3-0-4" id="h3-0-4" class="i">+
</a><a href="#h3-0-5" id="h3-0-5" class="i">+package github
</a><a href="#h3-0-6" id="h3-0-6" class="i">+
</a><a href="#h3-0-7" id="h3-0-7" class="i">+// ActivityService handles communication with the activity related
</a><a href="#h3-0-8" id="h3-0-8" class="i">+// methods of the GitHub API.
</a><a href="#h3-0-9" id="h3-0-9" class="i">+//
</a><a href="#h3-0-10" id="h3-0-10" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/
</a><a href="#h3-0-11" id="h3-0-11" class="i">+type ActivityService struct {
</a><a href="#h3-0-12" id="h3-0-12" class="i">+	client *Client
</a><a href="#h3-0-13" id="h3-0-13" class="i">+}
</a><a href="#h3-0-14" id="h3-0-14" class="i">+
</a><a href="#h3-0-15" id="h3-0-15" class="i">+// FeedLink represents a link to a related resource.
</a><a href="#h3-0-16" id="h3-0-16" class="i">+type FeedLink struct {
</a><a href="#h3-0-17" id="h3-0-17" class="i">+	HRef *string `json:&quot;href,omitempty&quot;`
</a><a href="#h3-0-18" id="h3-0-18" class="i">+	Type *string `json:&quot;type,omitempty&quot;`
</a><a href="#h3-0-19" id="h3-0-19" class="i">+}
</a><a href="#h3-0-20" id="h3-0-20" class="i">+
</a><a href="#h3-0-21" id="h3-0-21" class="i">+// Feeds represents timeline resources in Atom format.
</a><a href="#h3-0-22" id="h3-0-22" class="i">+type Feeds struct {
</a><a href="#h3-0-23" id="h3-0-23" class="i">+	TimelineURL                 *string  `json:&quot;timeline_url,omitempty&quot;`
</a><a href="#h3-0-24" id="h3-0-24" class="i">+	UserURL                     *string  `json:&quot;user_url,omitempty&quot;`
</a><a href="#h3-0-25" id="h3-0-25" class="i">+	CurrentUserPublicURL        *string  `json:&quot;current_user_public_url,omitempty&quot;`
</a><a href="#h3-0-26" id="h3-0-26" class="i">+	CurrentUserURL              *string  `json:&quot;current_user_url,omitempty&quot;`
</a><a href="#h3-0-27" id="h3-0-27" class="i">+	CurrentUserActorURL         *string  `json:&quot;current_user_actor_url,omitempty&quot;`
</a><a href="#h3-0-28" id="h3-0-28" class="i">+	CurrentUserOrganizationURL  *string  `json:&quot;current_user_organization_url,omitempty&quot;`
</a><a href="#h3-0-29" id="h3-0-29" class="i">+	CurrentUserOrganizationURLs []string `json:&quot;current_user_organization_urls,omitempty&quot;`
</a><a href="#h3-0-30" id="h3-0-30" class="i">+	Links                       *struct {
</a><a href="#h3-0-31" id="h3-0-31" class="i">+		Timeline                 *FeedLink  `json:&quot;timeline,omitempty&quot;`
</a><a href="#h3-0-32" id="h3-0-32" class="i">+		User                     *FeedLink  `json:&quot;user,omitempty&quot;`
</a><a href="#h3-0-33" id="h3-0-33" class="i">+		CurrentUserPublic        *FeedLink  `json:&quot;current_user_public,omitempty&quot;`
</a><a href="#h3-0-34" id="h3-0-34" class="i">+		CurrentUser              *FeedLink  `json:&quot;current_user,omitempty&quot;`
</a><a href="#h3-0-35" id="h3-0-35" class="i">+		CurrentUserActor         *FeedLink  `json:&quot;current_user_actor,omitempty&quot;`
</a><a href="#h3-0-36" id="h3-0-36" class="i">+		CurrentUserOrganization  *FeedLink  `json:&quot;current_user_organization,omitempty&quot;`
</a><a href="#h3-0-37" id="h3-0-37" class="i">+		CurrentUserOrganizations []FeedLink `json:&quot;current_user_organizations,omitempty&quot;`
</a><a href="#h3-0-38" id="h3-0-38" class="i">+	} `json:&quot;_links,omitempty&quot;`
</a><a href="#h3-0-39" id="h3-0-39" class="i">+}
</a><a href="#h3-0-40" id="h3-0-40" class="i">+
</a><a href="#h3-0-41" id="h3-0-41" class="i">+// ListFeeds lists all the feeds available to the authenticated user.
</a><a href="#h3-0-42" id="h3-0-42" class="i">+//
</a><a href="#h3-0-43" id="h3-0-43" class="i">+// GitHub provides several timeline resources in Atom format:
</a><a href="#h3-0-44" id="h3-0-44" class="i">+//     Timeline: The GitHub global public timeline
</a><a href="#h3-0-45" id="h3-0-45" class="i">+//     User: The public timeline for any user, using URI template
</a><a href="#h3-0-46" id="h3-0-46" class="i">+//     Current user public: The public timeline for the authenticated user
</a><a href="#h3-0-47" id="h3-0-47" class="i">+//     Current user: The private timeline for the authenticated user
</a><a href="#h3-0-48" id="h3-0-48" class="i">+//     Current user actor: The private timeline for activity created by the
</a><a href="#h3-0-49" id="h3-0-49" class="i">+//         authenticated user
</a><a href="#h3-0-50" id="h3-0-50" class="i">+//     Current user organizations: The private timeline for the organizations
</a><a href="#h3-0-51" id="h3-0-51" class="i">+//         the authenticated user is a member of.
</a><a href="#h3-0-52" id="h3-0-52" class="i">+//
</a><a href="#h3-0-53" id="h3-0-53" class="i">+// Note: Private feeds are only returned when authenticating via Basic Auth
</a><a href="#h3-0-54" id="h3-0-54" class="i">+// since current feed URIs use the older, non revocable auth tokens.
</a><a href="#h3-0-55" id="h3-0-55" class="i">+func (s *ActivityService) ListFeeds() (*Feeds, *Response, error) {
</a><a href="#h3-0-56" id="h3-0-56" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, &quot;feeds&quot;, nil)
</a><a href="#h3-0-57" id="h3-0-57" class="i">+	if err != nil {
</a><a href="#h3-0-58" id="h3-0-58" class="i">+		return nil, nil, err
</a><a href="#h3-0-59" id="h3-0-59" class="i">+	}
</a><a href="#h3-0-60" id="h3-0-60" class="i">+
</a><a href="#h3-0-61" id="h3-0-61" class="i">+	f := &amp;Feeds{}
</a><a href="#h3-0-62" id="h3-0-62" class="i">+	resp, err := s.client.Do(req, f)
</a><a href="#h3-0-63" id="h3-0-63" class="i">+	if err != nil {
</a><a href="#h3-0-64" id="h3-0-64" class="i">+		return nil, resp, err
</a><a href="#h3-0-65" id="h3-0-65" class="i">+	}
</a><a href="#h3-0-66" id="h3-0-66" class="i">+
</a><a href="#h3-0-67" id="h3-0-67" class="i">+	return f, resp, nil
</a><a href="#h3-0-68" id="h3-0-68" class="i">+}
</a><b>diff --git a/<a id="h4" href="../file/vendor/github.com/google/go-github/github/activity_events.go">vendor/github.com/google/go-github/github/activity_events.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/activity_events.go">vendor/github.com/google/go-github/github/activity_events.go</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -0,0 +1,245 @@
</a><a href="#h4-0-0" id="h4-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h4-0-1" id="h4-0-1" class="i">+//
</a><a href="#h4-0-2" id="h4-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h4-0-3" id="h4-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h4-0-4" id="h4-0-4" class="i">+
</a><a href="#h4-0-5" id="h4-0-5" class="i">+package github
</a><a href="#h4-0-6" id="h4-0-6" class="i">+
</a><a href="#h4-0-7" id="h4-0-7" class="i">+import (
</a><a href="#h4-0-8" id="h4-0-8" class="i">+	&quot;encoding/json&quot;
</a><a href="#h4-0-9" id="h4-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h4-0-10" id="h4-0-10" class="i">+	&quot;time&quot;
</a><a href="#h4-0-11" id="h4-0-11" class="i">+)
</a><a href="#h4-0-12" id="h4-0-12" class="i">+
</a><a href="#h4-0-13" id="h4-0-13" class="i">+// Event represents a GitHub event.
</a><a href="#h4-0-14" id="h4-0-14" class="i">+type Event struct {
</a><a href="#h4-0-15" id="h4-0-15" class="i">+	Type       *string          `json:&quot;type,omitempty&quot;`
</a><a href="#h4-0-16" id="h4-0-16" class="i">+	Public     *bool            `json:&quot;public&quot;`
</a><a href="#h4-0-17" id="h4-0-17" class="i">+	RawPayload *json.RawMessage `json:&quot;payload,omitempty&quot;`
</a><a href="#h4-0-18" id="h4-0-18" class="i">+	Repo       *Repository      `json:&quot;repo,omitempty&quot;`
</a><a href="#h4-0-19" id="h4-0-19" class="i">+	Actor      *User            `json:&quot;actor,omitempty&quot;`
</a><a href="#h4-0-20" id="h4-0-20" class="i">+	Org        *Organization    `json:&quot;org,omitempty&quot;`
</a><a href="#h4-0-21" id="h4-0-21" class="i">+	CreatedAt  *time.Time       `json:&quot;created_at,omitempty&quot;`
</a><a href="#h4-0-22" id="h4-0-22" class="i">+	ID         *string          `json:&quot;id,omitempty&quot;`
</a><a href="#h4-0-23" id="h4-0-23" class="i">+}
</a><a href="#h4-0-24" id="h4-0-24" class="i">+
</a><a href="#h4-0-25" id="h4-0-25" class="i">+func (e Event) String() string {
</a><a href="#h4-0-26" id="h4-0-26" class="i">+	return Stringify(e)
</a><a href="#h4-0-27" id="h4-0-27" class="i">+}
</a><a href="#h4-0-28" id="h4-0-28" class="i">+
</a><a href="#h4-0-29" id="h4-0-29" class="i">+// Payload returns the parsed event payload. For recognized event types
</a><a href="#h4-0-30" id="h4-0-30" class="i">+// (PushEvent), a value of the corresponding struct type will be returned.
</a><a href="#h4-0-31" id="h4-0-31" class="i">+func (e *Event) Payload() (payload interface{}) {
</a><a href="#h4-0-32" id="h4-0-32" class="i">+	switch *e.Type {
</a><a href="#h4-0-33" id="h4-0-33" class="i">+	case &quot;PushEvent&quot;:
</a><a href="#h4-0-34" id="h4-0-34" class="i">+		payload = &amp;PushEvent{}
</a><a href="#h4-0-35" id="h4-0-35" class="i">+	}
</a><a href="#h4-0-36" id="h4-0-36" class="i">+	if err := json.Unmarshal(*e.RawPayload, &amp;payload); err != nil {
</a><a href="#h4-0-37" id="h4-0-37" class="i">+		panic(err.Error())
</a><a href="#h4-0-38" id="h4-0-38" class="i">+	}
</a><a href="#h4-0-39" id="h4-0-39" class="i">+	return payload
</a><a href="#h4-0-40" id="h4-0-40" class="i">+}
</a><a href="#h4-0-41" id="h4-0-41" class="i">+
</a><a href="#h4-0-42" id="h4-0-42" class="i">+// ListEvents drinks from the firehose of all public events across GitHub.
</a><a href="#h4-0-43" id="h4-0-43" class="i">+//
</a><a href="#h4-0-44" id="h4-0-44" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-public-events
</a><a href="#h4-0-45" id="h4-0-45" class="i">+func (s *ActivityService) ListEvents(opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-46" id="h4-0-46" class="i">+	u, err := addOptions(&quot;events&quot;, opt)
</a><a href="#h4-0-47" id="h4-0-47" class="i">+	if err != nil {
</a><a href="#h4-0-48" id="h4-0-48" class="i">+		return nil, nil, err
</a><a href="#h4-0-49" id="h4-0-49" class="i">+	}
</a><a href="#h4-0-50" id="h4-0-50" class="i">+
</a><a href="#h4-0-51" id="h4-0-51" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-52" id="h4-0-52" class="i">+	if err != nil {
</a><a href="#h4-0-53" id="h4-0-53" class="i">+		return nil, nil, err
</a><a href="#h4-0-54" id="h4-0-54" class="i">+	}
</a><a href="#h4-0-55" id="h4-0-55" class="i">+
</a><a href="#h4-0-56" id="h4-0-56" class="i">+	events := new([]Event)
</a><a href="#h4-0-57" id="h4-0-57" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-58" id="h4-0-58" class="i">+	if err != nil {
</a><a href="#h4-0-59" id="h4-0-59" class="i">+		return nil, resp, err
</a><a href="#h4-0-60" id="h4-0-60" class="i">+	}
</a><a href="#h4-0-61" id="h4-0-61" class="i">+
</a><a href="#h4-0-62" id="h4-0-62" class="i">+	return *events, resp, err
</a><a href="#h4-0-63" id="h4-0-63" class="i">+}
</a><a href="#h4-0-64" id="h4-0-64" class="i">+
</a><a href="#h4-0-65" id="h4-0-65" class="i">+// ListRepositoryEvents lists events for a repository.
</a><a href="#h4-0-66" id="h4-0-66" class="i">+//
</a><a href="#h4-0-67" id="h4-0-67" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-repository-events
</a><a href="#h4-0-68" id="h4-0-68" class="i">+func (s *ActivityService) ListRepositoryEvents(owner, repo string, opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-69" id="h4-0-69" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/events&quot;, owner, repo)
</a><a href="#h4-0-70" id="h4-0-70" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h4-0-71" id="h4-0-71" class="i">+	if err != nil {
</a><a href="#h4-0-72" id="h4-0-72" class="i">+		return nil, nil, err
</a><a href="#h4-0-73" id="h4-0-73" class="i">+	}
</a><a href="#h4-0-74" id="h4-0-74" class="i">+
</a><a href="#h4-0-75" id="h4-0-75" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-76" id="h4-0-76" class="i">+	if err != nil {
</a><a href="#h4-0-77" id="h4-0-77" class="i">+		return nil, nil, err
</a><a href="#h4-0-78" id="h4-0-78" class="i">+	}
</a><a href="#h4-0-79" id="h4-0-79" class="i">+
</a><a href="#h4-0-80" id="h4-0-80" class="i">+	events := new([]Event)
</a><a href="#h4-0-81" id="h4-0-81" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-82" id="h4-0-82" class="i">+	if err != nil {
</a><a href="#h4-0-83" id="h4-0-83" class="i">+		return nil, resp, err
</a><a href="#h4-0-84" id="h4-0-84" class="i">+	}
</a><a href="#h4-0-85" id="h4-0-85" class="i">+
</a><a href="#h4-0-86" id="h4-0-86" class="i">+	return *events, resp, err
</a><a href="#h4-0-87" id="h4-0-87" class="i">+}
</a><a href="#h4-0-88" id="h4-0-88" class="i">+
</a><a href="#h4-0-89" id="h4-0-89" class="i">+// ListIssueEventsForRepository lists issue events for a repository.
</a><a href="#h4-0-90" id="h4-0-90" class="i">+//
</a><a href="#h4-0-91" id="h4-0-91" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-issue-events-for-a-repository
</a><a href="#h4-0-92" id="h4-0-92" class="i">+func (s *ActivityService) ListIssueEventsForRepository(owner, repo string, opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-93" id="h4-0-93" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/events&quot;, owner, repo)
</a><a href="#h4-0-94" id="h4-0-94" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h4-0-95" id="h4-0-95" class="i">+	if err != nil {
</a><a href="#h4-0-96" id="h4-0-96" class="i">+		return nil, nil, err
</a><a href="#h4-0-97" id="h4-0-97" class="i">+	}
</a><a href="#h4-0-98" id="h4-0-98" class="i">+
</a><a href="#h4-0-99" id="h4-0-99" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-100" id="h4-0-100" class="i">+	if err != nil {
</a><a href="#h4-0-101" id="h4-0-101" class="i">+		return nil, nil, err
</a><a href="#h4-0-102" id="h4-0-102" class="i">+	}
</a><a href="#h4-0-103" id="h4-0-103" class="i">+
</a><a href="#h4-0-104" id="h4-0-104" class="i">+	events := new([]Event)
</a><a href="#h4-0-105" id="h4-0-105" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-106" id="h4-0-106" class="i">+	if err != nil {
</a><a href="#h4-0-107" id="h4-0-107" class="i">+		return nil, resp, err
</a><a href="#h4-0-108" id="h4-0-108" class="i">+	}
</a><a href="#h4-0-109" id="h4-0-109" class="i">+
</a><a href="#h4-0-110" id="h4-0-110" class="i">+	return *events, resp, err
</a><a href="#h4-0-111" id="h4-0-111" class="i">+}
</a><a href="#h4-0-112" id="h4-0-112" class="i">+
</a><a href="#h4-0-113" id="h4-0-113" class="i">+// ListEventsForRepoNetwork lists public events for a network of repositories.
</a><a href="#h4-0-114" id="h4-0-114" class="i">+//
</a><a href="#h4-0-115" id="h4-0-115" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-public-events-for-a-network-of-repositories
</a><a href="#h4-0-116" id="h4-0-116" class="i">+func (s *ActivityService) ListEventsForRepoNetwork(owner, repo string, opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-117" id="h4-0-117" class="i">+	u := fmt.Sprintf(&quot;networks/%v/%v/events&quot;, owner, repo)
</a><a href="#h4-0-118" id="h4-0-118" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h4-0-119" id="h4-0-119" class="i">+	if err != nil {
</a><a href="#h4-0-120" id="h4-0-120" class="i">+		return nil, nil, err
</a><a href="#h4-0-121" id="h4-0-121" class="i">+	}
</a><a href="#h4-0-122" id="h4-0-122" class="i">+
</a><a href="#h4-0-123" id="h4-0-123" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-124" id="h4-0-124" class="i">+	if err != nil {
</a><a href="#h4-0-125" id="h4-0-125" class="i">+		return nil, nil, err
</a><a href="#h4-0-126" id="h4-0-126" class="i">+	}
</a><a href="#h4-0-127" id="h4-0-127" class="i">+
</a><a href="#h4-0-128" id="h4-0-128" class="i">+	events := new([]Event)
</a><a href="#h4-0-129" id="h4-0-129" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-130" id="h4-0-130" class="i">+	if err != nil {
</a><a href="#h4-0-131" id="h4-0-131" class="i">+		return nil, resp, err
</a><a href="#h4-0-132" id="h4-0-132" class="i">+	}
</a><a href="#h4-0-133" id="h4-0-133" class="i">+
</a><a href="#h4-0-134" id="h4-0-134" class="i">+	return *events, resp, err
</a><a href="#h4-0-135" id="h4-0-135" class="i">+}
</a><a href="#h4-0-136" id="h4-0-136" class="i">+
</a><a href="#h4-0-137" id="h4-0-137" class="i">+// ListEventsForOrganization lists public events for an organization.
</a><a href="#h4-0-138" id="h4-0-138" class="i">+//
</a><a href="#h4-0-139" id="h4-0-139" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-public-events-for-an-organization
</a><a href="#h4-0-140" id="h4-0-140" class="i">+func (s *ActivityService) ListEventsForOrganization(org string, opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-141" id="h4-0-141" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/events&quot;, org)
</a><a href="#h4-0-142" id="h4-0-142" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h4-0-143" id="h4-0-143" class="i">+	if err != nil {
</a><a href="#h4-0-144" id="h4-0-144" class="i">+		return nil, nil, err
</a><a href="#h4-0-145" id="h4-0-145" class="i">+	}
</a><a href="#h4-0-146" id="h4-0-146" class="i">+
</a><a href="#h4-0-147" id="h4-0-147" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-148" id="h4-0-148" class="i">+	if err != nil {
</a><a href="#h4-0-149" id="h4-0-149" class="i">+		return nil, nil, err
</a><a href="#h4-0-150" id="h4-0-150" class="i">+	}
</a><a href="#h4-0-151" id="h4-0-151" class="i">+
</a><a href="#h4-0-152" id="h4-0-152" class="i">+	events := new([]Event)
</a><a href="#h4-0-153" id="h4-0-153" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-154" id="h4-0-154" class="i">+	if err != nil {
</a><a href="#h4-0-155" id="h4-0-155" class="i">+		return nil, resp, err
</a><a href="#h4-0-156" id="h4-0-156" class="i">+	}
</a><a href="#h4-0-157" id="h4-0-157" class="i">+
</a><a href="#h4-0-158" id="h4-0-158" class="i">+	return *events, resp, err
</a><a href="#h4-0-159" id="h4-0-159" class="i">+}
</a><a href="#h4-0-160" id="h4-0-160" class="i">+
</a><a href="#h4-0-161" id="h4-0-161" class="i">+// ListEventsPerformedByUser lists the events performed by a user. If publicOnly is
</a><a href="#h4-0-162" id="h4-0-162" class="i">+// true, only public events will be returned.
</a><a href="#h4-0-163" id="h4-0-163" class="i">+//
</a><a href="#h4-0-164" id="h4-0-164" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-events-performed-by-a-user
</a><a href="#h4-0-165" id="h4-0-165" class="i">+func (s *ActivityService) ListEventsPerformedByUser(user string, publicOnly bool, opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-166" id="h4-0-166" class="i">+	var u string
</a><a href="#h4-0-167" id="h4-0-167" class="i">+	if publicOnly {
</a><a href="#h4-0-168" id="h4-0-168" class="i">+		u = fmt.Sprintf(&quot;users/%v/events/public&quot;, user)
</a><a href="#h4-0-169" id="h4-0-169" class="i">+	} else {
</a><a href="#h4-0-170" id="h4-0-170" class="i">+		u = fmt.Sprintf(&quot;users/%v/events&quot;, user)
</a><a href="#h4-0-171" id="h4-0-171" class="i">+	}
</a><a href="#h4-0-172" id="h4-0-172" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h4-0-173" id="h4-0-173" class="i">+	if err != nil {
</a><a href="#h4-0-174" id="h4-0-174" class="i">+		return nil, nil, err
</a><a href="#h4-0-175" id="h4-0-175" class="i">+	}
</a><a href="#h4-0-176" id="h4-0-176" class="i">+
</a><a href="#h4-0-177" id="h4-0-177" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-178" id="h4-0-178" class="i">+	if err != nil {
</a><a href="#h4-0-179" id="h4-0-179" class="i">+		return nil, nil, err
</a><a href="#h4-0-180" id="h4-0-180" class="i">+	}
</a><a href="#h4-0-181" id="h4-0-181" class="i">+
</a><a href="#h4-0-182" id="h4-0-182" class="i">+	events := new([]Event)
</a><a href="#h4-0-183" id="h4-0-183" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-184" id="h4-0-184" class="i">+	if err != nil {
</a><a href="#h4-0-185" id="h4-0-185" class="i">+		return nil, resp, err
</a><a href="#h4-0-186" id="h4-0-186" class="i">+	}
</a><a href="#h4-0-187" id="h4-0-187" class="i">+
</a><a href="#h4-0-188" id="h4-0-188" class="i">+	return *events, resp, err
</a><a href="#h4-0-189" id="h4-0-189" class="i">+}
</a><a href="#h4-0-190" id="h4-0-190" class="i">+
</a><a href="#h4-0-191" id="h4-0-191" class="i">+// ListEventsReceivedByUser lists the events received by a user. If publicOnly is
</a><a href="#h4-0-192" id="h4-0-192" class="i">+// true, only public events will be returned.
</a><a href="#h4-0-193" id="h4-0-193" class="i">+//
</a><a href="#h4-0-194" id="h4-0-194" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-events-that-a-user-has-received
</a><a href="#h4-0-195" id="h4-0-195" class="i">+func (s *ActivityService) ListEventsReceivedByUser(user string, publicOnly bool, opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-196" id="h4-0-196" class="i">+	var u string
</a><a href="#h4-0-197" id="h4-0-197" class="i">+	if publicOnly {
</a><a href="#h4-0-198" id="h4-0-198" class="i">+		u = fmt.Sprintf(&quot;users/%v/received_events/public&quot;, user)
</a><a href="#h4-0-199" id="h4-0-199" class="i">+	} else {
</a><a href="#h4-0-200" id="h4-0-200" class="i">+		u = fmt.Sprintf(&quot;users/%v/received_events&quot;, user)
</a><a href="#h4-0-201" id="h4-0-201" class="i">+	}
</a><a href="#h4-0-202" id="h4-0-202" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h4-0-203" id="h4-0-203" class="i">+	if err != nil {
</a><a href="#h4-0-204" id="h4-0-204" class="i">+		return nil, nil, err
</a><a href="#h4-0-205" id="h4-0-205" class="i">+	}
</a><a href="#h4-0-206" id="h4-0-206" class="i">+
</a><a href="#h4-0-207" id="h4-0-207" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-208" id="h4-0-208" class="i">+	if err != nil {
</a><a href="#h4-0-209" id="h4-0-209" class="i">+		return nil, nil, err
</a><a href="#h4-0-210" id="h4-0-210" class="i">+	}
</a><a href="#h4-0-211" id="h4-0-211" class="i">+
</a><a href="#h4-0-212" id="h4-0-212" class="i">+	events := new([]Event)
</a><a href="#h4-0-213" id="h4-0-213" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-214" id="h4-0-214" class="i">+	if err != nil {
</a><a href="#h4-0-215" id="h4-0-215" class="i">+		return nil, resp, err
</a><a href="#h4-0-216" id="h4-0-216" class="i">+	}
</a><a href="#h4-0-217" id="h4-0-217" class="i">+
</a><a href="#h4-0-218" id="h4-0-218" class="i">+	return *events, resp, err
</a><a href="#h4-0-219" id="h4-0-219" class="i">+}
</a><a href="#h4-0-220" id="h4-0-220" class="i">+
</a><a href="#h4-0-221" id="h4-0-221" class="i">+// ListUserEventsForOrganization provides the users organization dashboard. You
</a><a href="#h4-0-222" id="h4-0-222" class="i">+// must be authenticated as the user to view this.
</a><a href="#h4-0-223" id="h4-0-223" class="i">+//
</a><a href="#h4-0-224" id="h4-0-224" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/#list-events-for-an-organization
</a><a href="#h4-0-225" id="h4-0-225" class="i">+func (s *ActivityService) ListUserEventsForOrganization(org, user string, opt *ListOptions) ([]Event, *Response, error) {
</a><a href="#h4-0-226" id="h4-0-226" class="i">+	u := fmt.Sprintf(&quot;users/%v/events/orgs/%v&quot;, user, org)
</a><a href="#h4-0-227" id="h4-0-227" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h4-0-228" id="h4-0-228" class="i">+	if err != nil {
</a><a href="#h4-0-229" id="h4-0-229" class="i">+		return nil, nil, err
</a><a href="#h4-0-230" id="h4-0-230" class="i">+	}
</a><a href="#h4-0-231" id="h4-0-231" class="i">+
</a><a href="#h4-0-232" id="h4-0-232" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h4-0-233" id="h4-0-233" class="i">+	if err != nil {
</a><a href="#h4-0-234" id="h4-0-234" class="i">+		return nil, nil, err
</a><a href="#h4-0-235" id="h4-0-235" class="i">+	}
</a><a href="#h4-0-236" id="h4-0-236" class="i">+
</a><a href="#h4-0-237" id="h4-0-237" class="i">+	events := new([]Event)
</a><a href="#h4-0-238" id="h4-0-238" class="i">+	resp, err := s.client.Do(req, events)
</a><a href="#h4-0-239" id="h4-0-239" class="i">+	if err != nil {
</a><a href="#h4-0-240" id="h4-0-240" class="i">+		return nil, resp, err
</a><a href="#h4-0-241" id="h4-0-241" class="i">+	}
</a><a href="#h4-0-242" id="h4-0-242" class="i">+
</a><a href="#h4-0-243" id="h4-0-243" class="i">+	return *events, resp, err
</a><a href="#h4-0-244" id="h4-0-244" class="i">+}
</a><b>diff --git a/<a id="h5" href="../file/vendor/github.com/google/go-github/github/activity_notifications.go">vendor/github.com/google/go-github/github/activity_notifications.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/activity_notifications.go">vendor/github.com/google/go-github/github/activity_notifications.go</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -0,0 +1,225 @@
</a><a href="#h5-0-0" id="h5-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h5-0-1" id="h5-0-1" class="i">+//
</a><a href="#h5-0-2" id="h5-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h5-0-3" id="h5-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h5-0-4" id="h5-0-4" class="i">+
</a><a href="#h5-0-5" id="h5-0-5" class="i">+package github
</a><a href="#h5-0-6" id="h5-0-6" class="i">+
</a><a href="#h5-0-7" id="h5-0-7" class="i">+import (
</a><a href="#h5-0-8" id="h5-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h5-0-9" id="h5-0-9" class="i">+	&quot;time&quot;
</a><a href="#h5-0-10" id="h5-0-10" class="i">+)
</a><a href="#h5-0-11" id="h5-0-11" class="i">+
</a><a href="#h5-0-12" id="h5-0-12" class="i">+// Notification identifies a GitHub notification for a user.
</a><a href="#h5-0-13" id="h5-0-13" class="i">+type Notification struct {
</a><a href="#h5-0-14" id="h5-0-14" class="i">+	ID         *string              `json:&quot;id,omitempty&quot;`
</a><a href="#h5-0-15" id="h5-0-15" class="i">+	Repository *Repository          `json:&quot;repository,omitempty&quot;`
</a><a href="#h5-0-16" id="h5-0-16" class="i">+	Subject    *NotificationSubject `json:&quot;subject,omitempty&quot;`
</a><a href="#h5-0-17" id="h5-0-17" class="i">+
</a><a href="#h5-0-18" id="h5-0-18" class="i">+	// Reason identifies the event that triggered the notification.
</a><a href="#h5-0-19" id="h5-0-19" class="i">+	//
</a><a href="#h5-0-20" id="h5-0-20" class="i">+	// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#notification-reasons
</a><a href="#h5-0-21" id="h5-0-21" class="i">+	Reason *string `json:&quot;reason,omitempty&quot;`
</a><a href="#h5-0-22" id="h5-0-22" class="i">+
</a><a href="#h5-0-23" id="h5-0-23" class="i">+	Unread     *bool      `json:&quot;unread,omitempty&quot;`
</a><a href="#h5-0-24" id="h5-0-24" class="i">+	UpdatedAt  *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h5-0-25" id="h5-0-25" class="i">+	LastReadAt *time.Time `json:&quot;last_read_at,omitempty&quot;`
</a><a href="#h5-0-26" id="h5-0-26" class="i">+	URL        *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h5-0-27" id="h5-0-27" class="i">+}
</a><a href="#h5-0-28" id="h5-0-28" class="i">+
</a><a href="#h5-0-29" id="h5-0-29" class="i">+// NotificationSubject identifies the subject of a notification.
</a><a href="#h5-0-30" id="h5-0-30" class="i">+type NotificationSubject struct {
</a><a href="#h5-0-31" id="h5-0-31" class="i">+	Title            *string `json:&quot;title,omitempty&quot;`
</a><a href="#h5-0-32" id="h5-0-32" class="i">+	URL              *string `json:&quot;url,omitempty&quot;`
</a><a href="#h5-0-33" id="h5-0-33" class="i">+	LatestCommentURL *string `json:&quot;latest_comment_url,omitempty&quot;`
</a><a href="#h5-0-34" id="h5-0-34" class="i">+	Type             *string `json:&quot;type,omitempty&quot;`
</a><a href="#h5-0-35" id="h5-0-35" class="i">+}
</a><a href="#h5-0-36" id="h5-0-36" class="i">+
</a><a href="#h5-0-37" id="h5-0-37" class="i">+// NotificationListOptions specifies the optional parameters to the
</a><a href="#h5-0-38" id="h5-0-38" class="i">+// ActivityService.ListNotifications method.
</a><a href="#h5-0-39" id="h5-0-39" class="i">+type NotificationListOptions struct {
</a><a href="#h5-0-40" id="h5-0-40" class="i">+	All           bool      `url:&quot;all,omitempty&quot;`
</a><a href="#h5-0-41" id="h5-0-41" class="i">+	Participating bool      `url:&quot;participating,omitempty&quot;`
</a><a href="#h5-0-42" id="h5-0-42" class="i">+	Since         time.Time `url:&quot;since,omitempty&quot;`
</a><a href="#h5-0-43" id="h5-0-43" class="i">+	Before        time.Time `url:&quot;before,omitempty&quot;`
</a><a href="#h5-0-44" id="h5-0-44" class="i">+}
</a><a href="#h5-0-45" id="h5-0-45" class="i">+
</a><a href="#h5-0-46" id="h5-0-46" class="i">+// ListNotifications lists all notifications for the authenticated user.
</a><a href="#h5-0-47" id="h5-0-47" class="i">+//
</a><a href="#h5-0-48" id="h5-0-48" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#list-your-notifications
</a><a href="#h5-0-49" id="h5-0-49" class="i">+func (s *ActivityService) ListNotifications(opt *NotificationListOptions) ([]Notification, *Response, error) {
</a><a href="#h5-0-50" id="h5-0-50" class="i">+	u := fmt.Sprintf(&quot;notifications&quot;)
</a><a href="#h5-0-51" id="h5-0-51" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h5-0-52" id="h5-0-52" class="i">+	if err != nil {
</a><a href="#h5-0-53" id="h5-0-53" class="i">+		return nil, nil, err
</a><a href="#h5-0-54" id="h5-0-54" class="i">+	}
</a><a href="#h5-0-55" id="h5-0-55" class="i">+
</a><a href="#h5-0-56" id="h5-0-56" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h5-0-57" id="h5-0-57" class="i">+	if err != nil {
</a><a href="#h5-0-58" id="h5-0-58" class="i">+		return nil, nil, err
</a><a href="#h5-0-59" id="h5-0-59" class="i">+	}
</a><a href="#h5-0-60" id="h5-0-60" class="i">+
</a><a href="#h5-0-61" id="h5-0-61" class="i">+	var notifications []Notification
</a><a href="#h5-0-62" id="h5-0-62" class="i">+	resp, err := s.client.Do(req, &amp;notifications)
</a><a href="#h5-0-63" id="h5-0-63" class="i">+	if err != nil {
</a><a href="#h5-0-64" id="h5-0-64" class="i">+		return nil, resp, err
</a><a href="#h5-0-65" id="h5-0-65" class="i">+	}
</a><a href="#h5-0-66" id="h5-0-66" class="i">+
</a><a href="#h5-0-67" id="h5-0-67" class="i">+	return notifications, resp, err
</a><a href="#h5-0-68" id="h5-0-68" class="i">+}
</a><a href="#h5-0-69" id="h5-0-69" class="i">+
</a><a href="#h5-0-70" id="h5-0-70" class="i">+// ListRepositoryNotifications lists all notifications in a given repository
</a><a href="#h5-0-71" id="h5-0-71" class="i">+// for the authenticated user.
</a><a href="#h5-0-72" id="h5-0-72" class="i">+//
</a><a href="#h5-0-73" id="h5-0-73" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#list-your-notifications-in-a-repository
</a><a href="#h5-0-74" id="h5-0-74" class="i">+func (s *ActivityService) ListRepositoryNotifications(owner, repo string, opt *NotificationListOptions) ([]Notification, *Response, error) {
</a><a href="#h5-0-75" id="h5-0-75" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/notifications&quot;, owner, repo)
</a><a href="#h5-0-76" id="h5-0-76" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h5-0-77" id="h5-0-77" class="i">+	if err != nil {
</a><a href="#h5-0-78" id="h5-0-78" class="i">+		return nil, nil, err
</a><a href="#h5-0-79" id="h5-0-79" class="i">+	}
</a><a href="#h5-0-80" id="h5-0-80" class="i">+
</a><a href="#h5-0-81" id="h5-0-81" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h5-0-82" id="h5-0-82" class="i">+	if err != nil {
</a><a href="#h5-0-83" id="h5-0-83" class="i">+		return nil, nil, err
</a><a href="#h5-0-84" id="h5-0-84" class="i">+	}
</a><a href="#h5-0-85" id="h5-0-85" class="i">+
</a><a href="#h5-0-86" id="h5-0-86" class="i">+	var notifications []Notification
</a><a href="#h5-0-87" id="h5-0-87" class="i">+	resp, err := s.client.Do(req, &amp;notifications)
</a><a href="#h5-0-88" id="h5-0-88" class="i">+	if err != nil {
</a><a href="#h5-0-89" id="h5-0-89" class="i">+		return nil, resp, err
</a><a href="#h5-0-90" id="h5-0-90" class="i">+	}
</a><a href="#h5-0-91" id="h5-0-91" class="i">+
</a><a href="#h5-0-92" id="h5-0-92" class="i">+	return notifications, resp, err
</a><a href="#h5-0-93" id="h5-0-93" class="i">+}
</a><a href="#h5-0-94" id="h5-0-94" class="i">+
</a><a href="#h5-0-95" id="h5-0-95" class="i">+type markReadOptions struct {
</a><a href="#h5-0-96" id="h5-0-96" class="i">+	LastReadAt time.Time `url:&quot;last_read_at,omitempty&quot;`
</a><a href="#h5-0-97" id="h5-0-97" class="i">+}
</a><a href="#h5-0-98" id="h5-0-98" class="i">+
</a><a href="#h5-0-99" id="h5-0-99" class="i">+// MarkNotificationsRead marks all notifications up to lastRead as read.
</a><a href="#h5-0-100" id="h5-0-100" class="i">+//
</a><a href="#h5-0-101" id="h5-0-101" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#mark-as-read
</a><a href="#h5-0-102" id="h5-0-102" class="i">+func (s *ActivityService) MarkNotificationsRead(lastRead time.Time) (*Response, error) {
</a><a href="#h5-0-103" id="h5-0-103" class="i">+	u := fmt.Sprintf(&quot;notifications&quot;)
</a><a href="#h5-0-104" id="h5-0-104" class="i">+	u, err := addOptions(u, markReadOptions{lastRead})
</a><a href="#h5-0-105" id="h5-0-105" class="i">+	if err != nil {
</a><a href="#h5-0-106" id="h5-0-106" class="i">+		return nil, err
</a><a href="#h5-0-107" id="h5-0-107" class="i">+	}
</a><a href="#h5-0-108" id="h5-0-108" class="i">+
</a><a href="#h5-0-109" id="h5-0-109" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h5-0-110" id="h5-0-110" class="i">+	if err != nil {
</a><a href="#h5-0-111" id="h5-0-111" class="i">+		return nil, err
</a><a href="#h5-0-112" id="h5-0-112" class="i">+	}
</a><a href="#h5-0-113" id="h5-0-113" class="i">+
</a><a href="#h5-0-114" id="h5-0-114" class="i">+	return s.client.Do(req, nil)
</a><a href="#h5-0-115" id="h5-0-115" class="i">+}
</a><a href="#h5-0-116" id="h5-0-116" class="i">+
</a><a href="#h5-0-117" id="h5-0-117" class="i">+// MarkRepositoryNotificationsRead marks all notifications up to lastRead in
</a><a href="#h5-0-118" id="h5-0-118" class="i">+// the specified repository as read.
</a><a href="#h5-0-119" id="h5-0-119" class="i">+//
</a><a href="#h5-0-120" id="h5-0-120" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#mark-notifications-as-read-in-a-repository
</a><a href="#h5-0-121" id="h5-0-121" class="i">+func (s *ActivityService) MarkRepositoryNotificationsRead(owner, repo string, lastRead time.Time) (*Response, error) {
</a><a href="#h5-0-122" id="h5-0-122" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/notifications&quot;, owner, repo)
</a><a href="#h5-0-123" id="h5-0-123" class="i">+	u, err := addOptions(u, markReadOptions{lastRead})
</a><a href="#h5-0-124" id="h5-0-124" class="i">+	if err != nil {
</a><a href="#h5-0-125" id="h5-0-125" class="i">+		return nil, err
</a><a href="#h5-0-126" id="h5-0-126" class="i">+	}
</a><a href="#h5-0-127" id="h5-0-127" class="i">+
</a><a href="#h5-0-128" id="h5-0-128" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h5-0-129" id="h5-0-129" class="i">+	if err != nil {
</a><a href="#h5-0-130" id="h5-0-130" class="i">+		return nil, err
</a><a href="#h5-0-131" id="h5-0-131" class="i">+	}
</a><a href="#h5-0-132" id="h5-0-132" class="i">+
</a><a href="#h5-0-133" id="h5-0-133" class="i">+	return s.client.Do(req, nil)
</a><a href="#h5-0-134" id="h5-0-134" class="i">+}
</a><a href="#h5-0-135" id="h5-0-135" class="i">+
</a><a href="#h5-0-136" id="h5-0-136" class="i">+// GetThread gets the specified notification thread.
</a><a href="#h5-0-137" id="h5-0-137" class="i">+//
</a><a href="#h5-0-138" id="h5-0-138" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#view-a-single-thread
</a><a href="#h5-0-139" id="h5-0-139" class="i">+func (s *ActivityService) GetThread(id string) (*Notification, *Response, error) {
</a><a href="#h5-0-140" id="h5-0-140" class="i">+	u := fmt.Sprintf(&quot;notifications/threads/%v&quot;, id)
</a><a href="#h5-0-141" id="h5-0-141" class="i">+
</a><a href="#h5-0-142" id="h5-0-142" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h5-0-143" id="h5-0-143" class="i">+	if err != nil {
</a><a href="#h5-0-144" id="h5-0-144" class="i">+		return nil, nil, err
</a><a href="#h5-0-145" id="h5-0-145" class="i">+	}
</a><a href="#h5-0-146" id="h5-0-146" class="i">+
</a><a href="#h5-0-147" id="h5-0-147" class="i">+	notification := new(Notification)
</a><a href="#h5-0-148" id="h5-0-148" class="i">+	resp, err := s.client.Do(req, notification)
</a><a href="#h5-0-149" id="h5-0-149" class="i">+	if err != nil {
</a><a href="#h5-0-150" id="h5-0-150" class="i">+		return nil, resp, err
</a><a href="#h5-0-151" id="h5-0-151" class="i">+	}
</a><a href="#h5-0-152" id="h5-0-152" class="i">+
</a><a href="#h5-0-153" id="h5-0-153" class="i">+	return notification, resp, err
</a><a href="#h5-0-154" id="h5-0-154" class="i">+}
</a><a href="#h5-0-155" id="h5-0-155" class="i">+
</a><a href="#h5-0-156" id="h5-0-156" class="i">+// MarkThreadRead marks the specified thread as read.
</a><a href="#h5-0-157" id="h5-0-157" class="i">+//
</a><a href="#h5-0-158" id="h5-0-158" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#mark-a-thread-as-read
</a><a href="#h5-0-159" id="h5-0-159" class="i">+func (s *ActivityService) MarkThreadRead(id string) (*Response, error) {
</a><a href="#h5-0-160" id="h5-0-160" class="i">+	u := fmt.Sprintf(&quot;notifications/threads/%v&quot;, id)
</a><a href="#h5-0-161" id="h5-0-161" class="i">+
</a><a href="#h5-0-162" id="h5-0-162" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, nil)
</a><a href="#h5-0-163" id="h5-0-163" class="i">+	if err != nil {
</a><a href="#h5-0-164" id="h5-0-164" class="i">+		return nil, err
</a><a href="#h5-0-165" id="h5-0-165" class="i">+	}
</a><a href="#h5-0-166" id="h5-0-166" class="i">+
</a><a href="#h5-0-167" id="h5-0-167" class="i">+	return s.client.Do(req, nil)
</a><a href="#h5-0-168" id="h5-0-168" class="i">+}
</a><a href="#h5-0-169" id="h5-0-169" class="i">+
</a><a href="#h5-0-170" id="h5-0-170" class="i">+// GetThreadSubscription checks to see if the authenticated user is subscribed
</a><a href="#h5-0-171" id="h5-0-171" class="i">+// to a thread.
</a><a href="#h5-0-172" id="h5-0-172" class="i">+//
</a><a href="#h5-0-173" id="h5-0-173" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#get-a-thread-subscription
</a><a href="#h5-0-174" id="h5-0-174" class="i">+func (s *ActivityService) GetThreadSubscription(id string) (*Subscription, *Response, error) {
</a><a href="#h5-0-175" id="h5-0-175" class="i">+	u := fmt.Sprintf(&quot;notifications/threads/%v/subscription&quot;, id)
</a><a href="#h5-0-176" id="h5-0-176" class="i">+
</a><a href="#h5-0-177" id="h5-0-177" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h5-0-178" id="h5-0-178" class="i">+	if err != nil {
</a><a href="#h5-0-179" id="h5-0-179" class="i">+		return nil, nil, err
</a><a href="#h5-0-180" id="h5-0-180" class="i">+	}
</a><a href="#h5-0-181" id="h5-0-181" class="i">+
</a><a href="#h5-0-182" id="h5-0-182" class="i">+	sub := new(Subscription)
</a><a href="#h5-0-183" id="h5-0-183" class="i">+	resp, err := s.client.Do(req, sub)
</a><a href="#h5-0-184" id="h5-0-184" class="i">+	if err != nil {
</a><a href="#h5-0-185" id="h5-0-185" class="i">+		return nil, resp, err
</a><a href="#h5-0-186" id="h5-0-186" class="i">+	}
</a><a href="#h5-0-187" id="h5-0-187" class="i">+
</a><a href="#h5-0-188" id="h5-0-188" class="i">+	return sub, resp, err
</a><a href="#h5-0-189" id="h5-0-189" class="i">+}
</a><a href="#h5-0-190" id="h5-0-190" class="i">+
</a><a href="#h5-0-191" id="h5-0-191" class="i">+// SetThreadSubscription sets the subscription for the specified thread for the
</a><a href="#h5-0-192" id="h5-0-192" class="i">+// authenticated user.
</a><a href="#h5-0-193" id="h5-0-193" class="i">+//
</a><a href="#h5-0-194" id="h5-0-194" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#set-a-thread-subscription
</a><a href="#h5-0-195" id="h5-0-195" class="i">+func (s *ActivityService) SetThreadSubscription(id string, subscription *Subscription) (*Subscription, *Response, error) {
</a><a href="#h5-0-196" id="h5-0-196" class="i">+	u := fmt.Sprintf(&quot;notifications/threads/%v/subscription&quot;, id)
</a><a href="#h5-0-197" id="h5-0-197" class="i">+
</a><a href="#h5-0-198" id="h5-0-198" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, subscription)
</a><a href="#h5-0-199" id="h5-0-199" class="i">+	if err != nil {
</a><a href="#h5-0-200" id="h5-0-200" class="i">+		return nil, nil, err
</a><a href="#h5-0-201" id="h5-0-201" class="i">+	}
</a><a href="#h5-0-202" id="h5-0-202" class="i">+
</a><a href="#h5-0-203" id="h5-0-203" class="i">+	sub := new(Subscription)
</a><a href="#h5-0-204" id="h5-0-204" class="i">+	resp, err := s.client.Do(req, sub)
</a><a href="#h5-0-205" id="h5-0-205" class="i">+	if err != nil {
</a><a href="#h5-0-206" id="h5-0-206" class="i">+		return nil, resp, err
</a><a href="#h5-0-207" id="h5-0-207" class="i">+	}
</a><a href="#h5-0-208" id="h5-0-208" class="i">+
</a><a href="#h5-0-209" id="h5-0-209" class="i">+	return sub, resp, err
</a><a href="#h5-0-210" id="h5-0-210" class="i">+}
</a><a href="#h5-0-211" id="h5-0-211" class="i">+
</a><a href="#h5-0-212" id="h5-0-212" class="i">+// DeleteThreadSubscription deletes the subscription for the specified thread
</a><a href="#h5-0-213" id="h5-0-213" class="i">+// for the authenticated user.
</a><a href="#h5-0-214" id="h5-0-214" class="i">+//
</a><a href="#h5-0-215" id="h5-0-215" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription
</a><a href="#h5-0-216" id="h5-0-216" class="i">+func (s *ActivityService) DeleteThreadSubscription(id string) (*Response, error) {
</a><a href="#h5-0-217" id="h5-0-217" class="i">+	u := fmt.Sprintf(&quot;notifications/threads/%v/subscription&quot;, id)
</a><a href="#h5-0-218" id="h5-0-218" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h5-0-219" id="h5-0-219" class="i">+	if err != nil {
</a><a href="#h5-0-220" id="h5-0-220" class="i">+		return nil, err
</a><a href="#h5-0-221" id="h5-0-221" class="i">+	}
</a><a href="#h5-0-222" id="h5-0-222" class="i">+
</a><a href="#h5-0-223" id="h5-0-223" class="i">+	return s.client.Do(req, nil)
</a><a href="#h5-0-224" id="h5-0-224" class="i">+}
</a><b>diff --git a/<a id="h6" href="../file/vendor/github.com/google/go-github/github/activity_star.go">vendor/github.com/google/go-github/github/activity_star.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/activity_star.go">vendor/github.com/google/go-github/github/activity_star.go</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -0,0 +1,123 @@
</a><a href="#h6-0-0" id="h6-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h6-0-1" id="h6-0-1" class="i">+//
</a><a href="#h6-0-2" id="h6-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h6-0-3" id="h6-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h6-0-4" id="h6-0-4" class="i">+
</a><a href="#h6-0-5" id="h6-0-5" class="i">+package github
</a><a href="#h6-0-6" id="h6-0-6" class="i">+
</a><a href="#h6-0-7" id="h6-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h6-0-8" id="h6-0-8" class="i">+
</a><a href="#h6-0-9" id="h6-0-9" class="i">+// StarredRepository is returned by ListStarred.
</a><a href="#h6-0-10" id="h6-0-10" class="i">+type StarredRepository struct {
</a><a href="#h6-0-11" id="h6-0-11" class="i">+	StarredAt  *Timestamp  `json:&quot;starred_at,omitempty&quot;`
</a><a href="#h6-0-12" id="h6-0-12" class="i">+	Repository *Repository `json:&quot;repo,omitempty&quot;`
</a><a href="#h6-0-13" id="h6-0-13" class="i">+}
</a><a href="#h6-0-14" id="h6-0-14" class="i">+
</a><a href="#h6-0-15" id="h6-0-15" class="i">+// ListStargazers lists people who have starred the specified repo.
</a><a href="#h6-0-16" id="h6-0-16" class="i">+//
</a><a href="#h6-0-17" id="h6-0-17" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/starring/#list-stargazers
</a><a href="#h6-0-18" id="h6-0-18" class="i">+func (s *ActivityService) ListStargazers(owner, repo string, opt *ListOptions) ([]User, *Response, error) {
</a><a href="#h6-0-19" id="h6-0-19" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/stargazers&quot;, owner, repo)
</a><a href="#h6-0-20" id="h6-0-20" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h6-0-21" id="h6-0-21" class="i">+	if err != nil {
</a><a href="#h6-0-22" id="h6-0-22" class="i">+		return nil, nil, err
</a><a href="#h6-0-23" id="h6-0-23" class="i">+	}
</a><a href="#h6-0-24" id="h6-0-24" class="i">+
</a><a href="#h6-0-25" id="h6-0-25" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h6-0-26" id="h6-0-26" class="i">+	if err != nil {
</a><a href="#h6-0-27" id="h6-0-27" class="i">+		return nil, nil, err
</a><a href="#h6-0-28" id="h6-0-28" class="i">+	}
</a><a href="#h6-0-29" id="h6-0-29" class="i">+
</a><a href="#h6-0-30" id="h6-0-30" class="i">+	stargazers := new([]User)
</a><a href="#h6-0-31" id="h6-0-31" class="i">+	resp, err := s.client.Do(req, stargazers)
</a><a href="#h6-0-32" id="h6-0-32" class="i">+	if err != nil {
</a><a href="#h6-0-33" id="h6-0-33" class="i">+		return nil, resp, err
</a><a href="#h6-0-34" id="h6-0-34" class="i">+	}
</a><a href="#h6-0-35" id="h6-0-35" class="i">+
</a><a href="#h6-0-36" id="h6-0-36" class="i">+	return *stargazers, resp, err
</a><a href="#h6-0-37" id="h6-0-37" class="i">+}
</a><a href="#h6-0-38" id="h6-0-38" class="i">+
</a><a href="#h6-0-39" id="h6-0-39" class="i">+// ActivityListStarredOptions specifies the optional parameters to the
</a><a href="#h6-0-40" id="h6-0-40" class="i">+// ActivityService.ListStarred method.
</a><a href="#h6-0-41" id="h6-0-41" class="i">+type ActivityListStarredOptions struct {
</a><a href="#h6-0-42" id="h6-0-42" class="i">+	// How to sort the repository list.  Possible values are: created, updated,
</a><a href="#h6-0-43" id="h6-0-43" class="i">+	// pushed, full_name.  Default is &quot;full_name&quot;.
</a><a href="#h6-0-44" id="h6-0-44" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h6-0-45" id="h6-0-45" class="i">+
</a><a href="#h6-0-46" id="h6-0-46" class="i">+	// Direction in which to sort repositories.  Possible values are: asc, desc.
</a><a href="#h6-0-47" id="h6-0-47" class="i">+	// Default is &quot;asc&quot; when sort is &quot;full_name&quot;, otherwise default is &quot;desc&quot;.
</a><a href="#h6-0-48" id="h6-0-48" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h6-0-49" id="h6-0-49" class="i">+
</a><a href="#h6-0-50" id="h6-0-50" class="i">+	ListOptions
</a><a href="#h6-0-51" id="h6-0-51" class="i">+}
</a><a href="#h6-0-52" id="h6-0-52" class="i">+
</a><a href="#h6-0-53" id="h6-0-53" class="i">+// ListStarred lists all the repos starred by a user.  Passing the empty string
</a><a href="#h6-0-54" id="h6-0-54" class="i">+// will list the starred repositories for the authenticated user.
</a><a href="#h6-0-55" id="h6-0-55" class="i">+//
</a><a href="#h6-0-56" id="h6-0-56" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/starring/#list-repositories-being-starred
</a><a href="#h6-0-57" id="h6-0-57" class="i">+func (s *ActivityService) ListStarred(user string, opt *ActivityListStarredOptions) ([]StarredRepository, *Response, error) {
</a><a href="#h6-0-58" id="h6-0-58" class="i">+	var u string
</a><a href="#h6-0-59" id="h6-0-59" class="i">+	if user != &quot;&quot; {
</a><a href="#h6-0-60" id="h6-0-60" class="i">+		u = fmt.Sprintf(&quot;users/%v/starred&quot;, user)
</a><a href="#h6-0-61" id="h6-0-61" class="i">+	} else {
</a><a href="#h6-0-62" id="h6-0-62" class="i">+		u = &quot;user/starred&quot;
</a><a href="#h6-0-63" id="h6-0-63" class="i">+	}
</a><a href="#h6-0-64" id="h6-0-64" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h6-0-65" id="h6-0-65" class="i">+	if err != nil {
</a><a href="#h6-0-66" id="h6-0-66" class="i">+		return nil, nil, err
</a><a href="#h6-0-67" id="h6-0-67" class="i">+	}
</a><a href="#h6-0-68" id="h6-0-68" class="i">+
</a><a href="#h6-0-69" id="h6-0-69" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h6-0-70" id="h6-0-70" class="i">+	if err != nil {
</a><a href="#h6-0-71" id="h6-0-71" class="i">+		return nil, nil, err
</a><a href="#h6-0-72" id="h6-0-72" class="i">+	}
</a><a href="#h6-0-73" id="h6-0-73" class="i">+
</a><a href="#h6-0-74" id="h6-0-74" class="i">+	// TODO: remove custom Accept header when this API fully launches
</a><a href="#h6-0-75" id="h6-0-75" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeStarringPreview)
</a><a href="#h6-0-76" id="h6-0-76" class="i">+
</a><a href="#h6-0-77" id="h6-0-77" class="i">+	repos := new([]StarredRepository)
</a><a href="#h6-0-78" id="h6-0-78" class="i">+	resp, err := s.client.Do(req, repos)
</a><a href="#h6-0-79" id="h6-0-79" class="i">+	if err != nil {
</a><a href="#h6-0-80" id="h6-0-80" class="i">+		return nil, resp, err
</a><a href="#h6-0-81" id="h6-0-81" class="i">+	}
</a><a href="#h6-0-82" id="h6-0-82" class="i">+
</a><a href="#h6-0-83" id="h6-0-83" class="i">+	return *repos, resp, err
</a><a href="#h6-0-84" id="h6-0-84" class="i">+}
</a><a href="#h6-0-85" id="h6-0-85" class="i">+
</a><a href="#h6-0-86" id="h6-0-86" class="i">+// IsStarred checks if a repository is starred by authenticated user.
</a><a href="#h6-0-87" id="h6-0-87" class="i">+//
</a><a href="#h6-0-88" id="h6-0-88" class="i">+// GitHub API docs: https://developer.github.com/v3/activity/starring/#check-if-you-are-starring-a-repository
</a><a href="#h6-0-89" id="h6-0-89" class="i">+func (s *ActivityService) IsStarred(owner, repo string) (bool, *Response, error) {
</a><a href="#h6-0-90" id="h6-0-90" class="i">+	u := fmt.Sprintf(&quot;user/starred/%v/%v&quot;, owner, repo)
</a><a href="#h6-0-91" id="h6-0-91" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h6-0-92" id="h6-0-92" class="i">+	if err != nil {
</a><a href="#h6-0-93" id="h6-0-93" class="i">+		return false, nil, err
</a><a href="#h6-0-94" id="h6-0-94" class="i">+	}
</a><a href="#h6-0-95" id="h6-0-95" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h6-0-96" id="h6-0-96" class="i">+	starred, err := parseBoolResponse(err)
</a><a href="#h6-0-97" id="h6-0-97" class="i">+	return starred, resp, err
</a><a href="#h6-0-98" id="h6-0-98" class="i">+}
</a><a href="#h6-0-99" id="h6-0-99" class="i">+
</a><a href="#h6-0-100" id="h6-0-100" class="i">+// Star a repository as the authenticated user.
</a><a href="#h6-0-101" id="h6-0-101" class="i">+//
</a><a href="#h6-0-102" id="h6-0-102" class="i">+// GitHub API docs: https://developer.github.com/v3/activity/starring/#star-a-repository
</a><a href="#h6-0-103" id="h6-0-103" class="i">+func (s *ActivityService) Star(owner, repo string) (*Response, error) {
</a><a href="#h6-0-104" id="h6-0-104" class="i">+	u := fmt.Sprintf(&quot;user/starred/%v/%v&quot;, owner, repo)
</a><a href="#h6-0-105" id="h6-0-105" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h6-0-106" id="h6-0-106" class="i">+	if err != nil {
</a><a href="#h6-0-107" id="h6-0-107" class="i">+		return nil, err
</a><a href="#h6-0-108" id="h6-0-108" class="i">+	}
</a><a href="#h6-0-109" id="h6-0-109" class="i">+	return s.client.Do(req, nil)
</a><a href="#h6-0-110" id="h6-0-110" class="i">+}
</a><a href="#h6-0-111" id="h6-0-111" class="i">+
</a><a href="#h6-0-112" id="h6-0-112" class="i">+// Unstar a repository as the authenticated user.
</a><a href="#h6-0-113" id="h6-0-113" class="i">+//
</a><a href="#h6-0-114" id="h6-0-114" class="i">+// GitHub API docs: https://developer.github.com/v3/activity/starring/#unstar-a-repository
</a><a href="#h6-0-115" id="h6-0-115" class="i">+func (s *ActivityService) Unstar(owner, repo string) (*Response, error) {
</a><a href="#h6-0-116" id="h6-0-116" class="i">+	u := fmt.Sprintf(&quot;user/starred/%v/%v&quot;, owner, repo)
</a><a href="#h6-0-117" id="h6-0-117" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h6-0-118" id="h6-0-118" class="i">+	if err != nil {
</a><a href="#h6-0-119" id="h6-0-119" class="i">+		return nil, err
</a><a href="#h6-0-120" id="h6-0-120" class="i">+	}
</a><a href="#h6-0-121" id="h6-0-121" class="i">+	return s.client.Do(req, nil)
</a><a href="#h6-0-122" id="h6-0-122" class="i">+}
</a><b>diff --git a/<a id="h7" href="../file/vendor/github.com/google/go-github/github/activity_watching.go">vendor/github.com/google/go-github/github/activity_watching.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/activity_watching.go">vendor/github.com/google/go-github/github/activity_watching.go</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -0,0 +1,136 @@
</a><a href="#h7-0-0" id="h7-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h7-0-1" id="h7-0-1" class="i">+//
</a><a href="#h7-0-2" id="h7-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h7-0-3" id="h7-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h7-0-4" id="h7-0-4" class="i">+
</a><a href="#h7-0-5" id="h7-0-5" class="i">+package github
</a><a href="#h7-0-6" id="h7-0-6" class="i">+
</a><a href="#h7-0-7" id="h7-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h7-0-8" id="h7-0-8" class="i">+
</a><a href="#h7-0-9" id="h7-0-9" class="i">+// Subscription identifies a repository or thread subscription.
</a><a href="#h7-0-10" id="h7-0-10" class="i">+type Subscription struct {
</a><a href="#h7-0-11" id="h7-0-11" class="i">+	Subscribed *bool      `json:&quot;subscribed,omitempty&quot;`
</a><a href="#h7-0-12" id="h7-0-12" class="i">+	Ignored    *bool      `json:&quot;ignored,omitempty&quot;`
</a><a href="#h7-0-13" id="h7-0-13" class="i">+	Reason     *string    `json:&quot;reason,omitempty&quot;`
</a><a href="#h7-0-14" id="h7-0-14" class="i">+	CreatedAt  *Timestamp `json:&quot;created_at,omitempty&quot;`
</a><a href="#h7-0-15" id="h7-0-15" class="i">+	URL        *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h7-0-16" id="h7-0-16" class="i">+
</a><a href="#h7-0-17" id="h7-0-17" class="i">+	// only populated for repository subscriptions
</a><a href="#h7-0-18" id="h7-0-18" class="i">+	RepositoryURL *string `json:&quot;repository_url,omitempty&quot;`
</a><a href="#h7-0-19" id="h7-0-19" class="i">+
</a><a href="#h7-0-20" id="h7-0-20" class="i">+	// only populated for thread subscriptions
</a><a href="#h7-0-21" id="h7-0-21" class="i">+	ThreadURL *string `json:&quot;thread_url,omitempty&quot;`
</a><a href="#h7-0-22" id="h7-0-22" class="i">+}
</a><a href="#h7-0-23" id="h7-0-23" class="i">+
</a><a href="#h7-0-24" id="h7-0-24" class="i">+// ListWatchers lists watchers of a particular repo.
</a><a href="#h7-0-25" id="h7-0-25" class="i">+//
</a><a href="#h7-0-26" id="h7-0-26" class="i">+// GitHub API Docs: http://developer.github.com/v3/activity/watching/#list-watchers
</a><a href="#h7-0-27" id="h7-0-27" class="i">+func (s *ActivityService) ListWatchers(owner, repo string, opt *ListOptions) ([]User, *Response, error) {
</a><a href="#h7-0-28" id="h7-0-28" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/subscribers&quot;, owner, repo)
</a><a href="#h7-0-29" id="h7-0-29" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h7-0-30" id="h7-0-30" class="i">+	if err != nil {
</a><a href="#h7-0-31" id="h7-0-31" class="i">+		return nil, nil, err
</a><a href="#h7-0-32" id="h7-0-32" class="i">+	}
</a><a href="#h7-0-33" id="h7-0-33" class="i">+
</a><a href="#h7-0-34" id="h7-0-34" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h7-0-35" id="h7-0-35" class="i">+	if err != nil {
</a><a href="#h7-0-36" id="h7-0-36" class="i">+		return nil, nil, err
</a><a href="#h7-0-37" id="h7-0-37" class="i">+	}
</a><a href="#h7-0-38" id="h7-0-38" class="i">+
</a><a href="#h7-0-39" id="h7-0-39" class="i">+	watchers := new([]User)
</a><a href="#h7-0-40" id="h7-0-40" class="i">+	resp, err := s.client.Do(req, watchers)
</a><a href="#h7-0-41" id="h7-0-41" class="i">+	if err != nil {
</a><a href="#h7-0-42" id="h7-0-42" class="i">+		return nil, resp, err
</a><a href="#h7-0-43" id="h7-0-43" class="i">+	}
</a><a href="#h7-0-44" id="h7-0-44" class="i">+
</a><a href="#h7-0-45" id="h7-0-45" class="i">+	return *watchers, resp, err
</a><a href="#h7-0-46" id="h7-0-46" class="i">+}
</a><a href="#h7-0-47" id="h7-0-47" class="i">+
</a><a href="#h7-0-48" id="h7-0-48" class="i">+// ListWatched lists the repositories the specified user is watching.  Passing
</a><a href="#h7-0-49" id="h7-0-49" class="i">+// the empty string will fetch watched repos for the authenticated user.
</a><a href="#h7-0-50" id="h7-0-50" class="i">+//
</a><a href="#h7-0-51" id="h7-0-51" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/watching/#list-repositories-being-watched
</a><a href="#h7-0-52" id="h7-0-52" class="i">+func (s *ActivityService) ListWatched(user string, opt *ListOptions) ([]Repository, *Response, error) {
</a><a href="#h7-0-53" id="h7-0-53" class="i">+	var u string
</a><a href="#h7-0-54" id="h7-0-54" class="i">+	if user != &quot;&quot; {
</a><a href="#h7-0-55" id="h7-0-55" class="i">+		u = fmt.Sprintf(&quot;users/%v/subscriptions&quot;, user)
</a><a href="#h7-0-56" id="h7-0-56" class="i">+	} else {
</a><a href="#h7-0-57" id="h7-0-57" class="i">+		u = &quot;user/subscriptions&quot;
</a><a href="#h7-0-58" id="h7-0-58" class="i">+	}
</a><a href="#h7-0-59" id="h7-0-59" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h7-0-60" id="h7-0-60" class="i">+	if err != nil {
</a><a href="#h7-0-61" id="h7-0-61" class="i">+		return nil, nil, err
</a><a href="#h7-0-62" id="h7-0-62" class="i">+	}
</a><a href="#h7-0-63" id="h7-0-63" class="i">+
</a><a href="#h7-0-64" id="h7-0-64" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h7-0-65" id="h7-0-65" class="i">+	if err != nil {
</a><a href="#h7-0-66" id="h7-0-66" class="i">+		return nil, nil, err
</a><a href="#h7-0-67" id="h7-0-67" class="i">+	}
</a><a href="#h7-0-68" id="h7-0-68" class="i">+
</a><a href="#h7-0-69" id="h7-0-69" class="i">+	watched := new([]Repository)
</a><a href="#h7-0-70" id="h7-0-70" class="i">+	resp, err := s.client.Do(req, watched)
</a><a href="#h7-0-71" id="h7-0-71" class="i">+	if err != nil {
</a><a href="#h7-0-72" id="h7-0-72" class="i">+		return nil, resp, err
</a><a href="#h7-0-73" id="h7-0-73" class="i">+	}
</a><a href="#h7-0-74" id="h7-0-74" class="i">+
</a><a href="#h7-0-75" id="h7-0-75" class="i">+	return *watched, resp, err
</a><a href="#h7-0-76" id="h7-0-76" class="i">+}
</a><a href="#h7-0-77" id="h7-0-77" class="i">+
</a><a href="#h7-0-78" id="h7-0-78" class="i">+// GetRepositorySubscription returns the subscription for the specified
</a><a href="#h7-0-79" id="h7-0-79" class="i">+// repository for the authenticated user.  If the authenticated user is not
</a><a href="#h7-0-80" id="h7-0-80" class="i">+// watching the repository, a nil Subscription is returned.
</a><a href="#h7-0-81" id="h7-0-81" class="i">+//
</a><a href="#h7-0-82" id="h7-0-82" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/watching/#get-a-repository-subscription
</a><a href="#h7-0-83" id="h7-0-83" class="i">+func (s *ActivityService) GetRepositorySubscription(owner, repo string) (*Subscription, *Response, error) {
</a><a href="#h7-0-84" id="h7-0-84" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/subscription&quot;, owner, repo)
</a><a href="#h7-0-85" id="h7-0-85" class="i">+
</a><a href="#h7-0-86" id="h7-0-86" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h7-0-87" id="h7-0-87" class="i">+	if err != nil {
</a><a href="#h7-0-88" id="h7-0-88" class="i">+		return nil, nil, err
</a><a href="#h7-0-89" id="h7-0-89" class="i">+	}
</a><a href="#h7-0-90" id="h7-0-90" class="i">+
</a><a href="#h7-0-91" id="h7-0-91" class="i">+	sub := new(Subscription)
</a><a href="#h7-0-92" id="h7-0-92" class="i">+	resp, err := s.client.Do(req, sub)
</a><a href="#h7-0-93" id="h7-0-93" class="i">+	if err != nil {
</a><a href="#h7-0-94" id="h7-0-94" class="i">+		// if it&#39;s just a 404, don&#39;t return that as an error
</a><a href="#h7-0-95" id="h7-0-95" class="i">+		_, err = parseBoolResponse(err)
</a><a href="#h7-0-96" id="h7-0-96" class="i">+		return nil, resp, err
</a><a href="#h7-0-97" id="h7-0-97" class="i">+	}
</a><a href="#h7-0-98" id="h7-0-98" class="i">+
</a><a href="#h7-0-99" id="h7-0-99" class="i">+	return sub, resp, err
</a><a href="#h7-0-100" id="h7-0-100" class="i">+}
</a><a href="#h7-0-101" id="h7-0-101" class="i">+
</a><a href="#h7-0-102" id="h7-0-102" class="i">+// SetRepositorySubscription sets the subscription for the specified repository
</a><a href="#h7-0-103" id="h7-0-103" class="i">+// for the authenticated user.
</a><a href="#h7-0-104" id="h7-0-104" class="i">+//
</a><a href="#h7-0-105" id="h7-0-105" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/watching/#set-a-repository-subscription
</a><a href="#h7-0-106" id="h7-0-106" class="i">+func (s *ActivityService) SetRepositorySubscription(owner, repo string, subscription *Subscription) (*Subscription, *Response, error) {
</a><a href="#h7-0-107" id="h7-0-107" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/subscription&quot;, owner, repo)
</a><a href="#h7-0-108" id="h7-0-108" class="i">+
</a><a href="#h7-0-109" id="h7-0-109" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, subscription)
</a><a href="#h7-0-110" id="h7-0-110" class="i">+	if err != nil {
</a><a href="#h7-0-111" id="h7-0-111" class="i">+		return nil, nil, err
</a><a href="#h7-0-112" id="h7-0-112" class="i">+	}
</a><a href="#h7-0-113" id="h7-0-113" class="i">+
</a><a href="#h7-0-114" id="h7-0-114" class="i">+	sub := new(Subscription)
</a><a href="#h7-0-115" id="h7-0-115" class="i">+	resp, err := s.client.Do(req, sub)
</a><a href="#h7-0-116" id="h7-0-116" class="i">+	if err != nil {
</a><a href="#h7-0-117" id="h7-0-117" class="i">+		return nil, resp, err
</a><a href="#h7-0-118" id="h7-0-118" class="i">+	}
</a><a href="#h7-0-119" id="h7-0-119" class="i">+
</a><a href="#h7-0-120" id="h7-0-120" class="i">+	return sub, resp, err
</a><a href="#h7-0-121" id="h7-0-121" class="i">+}
</a><a href="#h7-0-122" id="h7-0-122" class="i">+
</a><a href="#h7-0-123" id="h7-0-123" class="i">+// DeleteRepositorySubscription deletes the subscription for the specified
</a><a href="#h7-0-124" id="h7-0-124" class="i">+// repository for the authenticated user.
</a><a href="#h7-0-125" id="h7-0-125" class="i">+//
</a><a href="#h7-0-126" id="h7-0-126" class="i">+// GitHub API Docs: https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription
</a><a href="#h7-0-127" id="h7-0-127" class="i">+func (s *ActivityService) DeleteRepositorySubscription(owner, repo string) (*Response, error) {
</a><a href="#h7-0-128" id="h7-0-128" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/subscription&quot;, owner, repo)
</a><a href="#h7-0-129" id="h7-0-129" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h7-0-130" id="h7-0-130" class="i">+	if err != nil {
</a><a href="#h7-0-131" id="h7-0-131" class="i">+		return nil, err
</a><a href="#h7-0-132" id="h7-0-132" class="i">+	}
</a><a href="#h7-0-133" id="h7-0-133" class="i">+
</a><a href="#h7-0-134" id="h7-0-134" class="i">+	return s.client.Do(req, nil)
</a><a href="#h7-0-135" id="h7-0-135" class="i">+}
</a><b>diff --git a/<a id="h8" href="../file/vendor/github.com/google/go-github/github/authorizations.go">vendor/github.com/google/go-github/github/authorizations.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/authorizations.go">vendor/github.com/google/go-github/github/authorizations.go</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -0,0 +1,320 @@
</a><a href="#h8-0-0" id="h8-0-0" class="i">+// Copyright 2015 The go-github AUTHORS. All rights reserved.
</a><a href="#h8-0-1" id="h8-0-1" class="i">+//
</a><a href="#h8-0-2" id="h8-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h8-0-3" id="h8-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h8-0-4" id="h8-0-4" class="i">+
</a><a href="#h8-0-5" id="h8-0-5" class="i">+package github
</a><a href="#h8-0-6" id="h8-0-6" class="i">+
</a><a href="#h8-0-7" id="h8-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h8-0-8" id="h8-0-8" class="i">+
</a><a href="#h8-0-9" id="h8-0-9" class="i">+// Scope models a GitHub authorization scope.
</a><a href="#h8-0-10" id="h8-0-10" class="i">+//
</a><a href="#h8-0-11" id="h8-0-11" class="i">+// GitHub API docs:https://developer.github.com/v3/oauth/#scopes
</a><a href="#h8-0-12" id="h8-0-12" class="i">+type Scope string
</a><a href="#h8-0-13" id="h8-0-13" class="i">+
</a><a href="#h8-0-14" id="h8-0-14" class="i">+// This is the set of scopes for GitHub API V3
</a><a href="#h8-0-15" id="h8-0-15" class="i">+const (
</a><a href="#h8-0-16" id="h8-0-16" class="i">+	ScopeNone           Scope = &quot;(no scope)&quot; // REVISIT: is this actually returned, or just a documentation artifact?
</a><a href="#h8-0-17" id="h8-0-17" class="i">+	ScopeUser           Scope = &quot;user&quot;
</a><a href="#h8-0-18" id="h8-0-18" class="i">+	ScopeUserEmail      Scope = &quot;user:email&quot;
</a><a href="#h8-0-19" id="h8-0-19" class="i">+	ScopeUserFollow     Scope = &quot;user:follow&quot;
</a><a href="#h8-0-20" id="h8-0-20" class="i">+	ScopePublicRepo     Scope = &quot;public_repo&quot;
</a><a href="#h8-0-21" id="h8-0-21" class="i">+	ScopeRepo           Scope = &quot;repo&quot;
</a><a href="#h8-0-22" id="h8-0-22" class="i">+	ScopeRepoDeployment Scope = &quot;repo_deployment&quot;
</a><a href="#h8-0-23" id="h8-0-23" class="i">+	ScopeRepoStatus     Scope = &quot;repo:status&quot;
</a><a href="#h8-0-24" id="h8-0-24" class="i">+	ScopeDeleteRepo     Scope = &quot;delete_repo&quot;
</a><a href="#h8-0-25" id="h8-0-25" class="i">+	ScopeNotifications  Scope = &quot;notifications&quot;
</a><a href="#h8-0-26" id="h8-0-26" class="i">+	ScopeGist           Scope = &quot;gist&quot;
</a><a href="#h8-0-27" id="h8-0-27" class="i">+	ScopeReadRepoHook   Scope = &quot;read:repo_hook&quot;
</a><a href="#h8-0-28" id="h8-0-28" class="i">+	ScopeWriteRepoHook  Scope = &quot;write:repo_hook&quot;
</a><a href="#h8-0-29" id="h8-0-29" class="i">+	ScopeAdminRepoHook  Scope = &quot;admin:repo_hook&quot;
</a><a href="#h8-0-30" id="h8-0-30" class="i">+	ScopeAdminOrgHook   Scope = &quot;admin:org_hook&quot;
</a><a href="#h8-0-31" id="h8-0-31" class="i">+	ScopeReadOrg        Scope = &quot;read:org&quot;
</a><a href="#h8-0-32" id="h8-0-32" class="i">+	ScopeWriteOrg       Scope = &quot;write:org&quot;
</a><a href="#h8-0-33" id="h8-0-33" class="i">+	ScopeAdminOrg       Scope = &quot;admin:org&quot;
</a><a href="#h8-0-34" id="h8-0-34" class="i">+	ScopeReadPublicKey  Scope = &quot;read:public_key&quot;
</a><a href="#h8-0-35" id="h8-0-35" class="i">+	ScopeWritePublicKey Scope = &quot;write:public_key&quot;
</a><a href="#h8-0-36" id="h8-0-36" class="i">+	ScopeAdminPublicKey Scope = &quot;admin:public_key&quot;
</a><a href="#h8-0-37" id="h8-0-37" class="i">+)
</a><a href="#h8-0-38" id="h8-0-38" class="i">+
</a><a href="#h8-0-39" id="h8-0-39" class="i">+// AuthorizationsService handles communication with the authorization related
</a><a href="#h8-0-40" id="h8-0-40" class="i">+// methods of the GitHub API.
</a><a href="#h8-0-41" id="h8-0-41" class="i">+//
</a><a href="#h8-0-42" id="h8-0-42" class="i">+// This service requires HTTP Basic Authentication; it cannot be accessed using
</a><a href="#h8-0-43" id="h8-0-43" class="i">+// an OAuth token.
</a><a href="#h8-0-44" id="h8-0-44" class="i">+//
</a><a href="#h8-0-45" id="h8-0-45" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/
</a><a href="#h8-0-46" id="h8-0-46" class="i">+type AuthorizationsService struct {
</a><a href="#h8-0-47" id="h8-0-47" class="i">+	client *Client
</a><a href="#h8-0-48" id="h8-0-48" class="i">+}
</a><a href="#h8-0-49" id="h8-0-49" class="i">+
</a><a href="#h8-0-50" id="h8-0-50" class="i">+// Authorization represents an individual GitHub authorization.
</a><a href="#h8-0-51" id="h8-0-51" class="i">+type Authorization struct {
</a><a href="#h8-0-52" id="h8-0-52" class="i">+	ID             *int              `json:&quot;id,omitempty&quot;`
</a><a href="#h8-0-53" id="h8-0-53" class="i">+	URL            *string           `json:&quot;url,omitempty&quot;`
</a><a href="#h8-0-54" id="h8-0-54" class="i">+	Scopes         []Scope           `json:&quot;scopes,omitempty&quot;`
</a><a href="#h8-0-55" id="h8-0-55" class="i">+	Token          *string           `json:&quot;token,omitempty&quot;`
</a><a href="#h8-0-56" id="h8-0-56" class="i">+	TokenLastEight *string           `json:&quot;token_last_eight,omitempty&quot;`
</a><a href="#h8-0-57" id="h8-0-57" class="i">+	HashedToken    *string           `json:&quot;hashed_token,omitempty&quot;`
</a><a href="#h8-0-58" id="h8-0-58" class="i">+	App            *AuthorizationApp `json:&quot;app,omitempty&quot;`
</a><a href="#h8-0-59" id="h8-0-59" class="i">+	Note           *string           `json:&quot;note,omitempty&quot;`
</a><a href="#h8-0-60" id="h8-0-60" class="i">+	NoteURL        *string           `json:&quot;note_url,omitempty&quot;`
</a><a href="#h8-0-61" id="h8-0-61" class="i">+	UpdateAt       *Timestamp        `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h8-0-62" id="h8-0-62" class="i">+	CreatedAt      *Timestamp        `json:&quot;created_at,omitempty&quot;`
</a><a href="#h8-0-63" id="h8-0-63" class="i">+	Fingerprint    *string           `json:&quot;fingerprint,omitempty&quot;`
</a><a href="#h8-0-64" id="h8-0-64" class="i">+
</a><a href="#h8-0-65" id="h8-0-65" class="i">+	// User is only populated by the Check and Reset methods.
</a><a href="#h8-0-66" id="h8-0-66" class="i">+	User *User `json:&quot;user,omitempty&quot;`
</a><a href="#h8-0-67" id="h8-0-67" class="i">+}
</a><a href="#h8-0-68" id="h8-0-68" class="i">+
</a><a href="#h8-0-69" id="h8-0-69" class="i">+func (a Authorization) String() string {
</a><a href="#h8-0-70" id="h8-0-70" class="i">+	return Stringify(a)
</a><a href="#h8-0-71" id="h8-0-71" class="i">+}
</a><a href="#h8-0-72" id="h8-0-72" class="i">+
</a><a href="#h8-0-73" id="h8-0-73" class="i">+// AuthorizationApp represents an individual GitHub app (in the context of authorization).
</a><a href="#h8-0-74" id="h8-0-74" class="i">+type AuthorizationApp struct {
</a><a href="#h8-0-75" id="h8-0-75" class="i">+	URL      *string `json:&quot;url,omitempty&quot;`
</a><a href="#h8-0-76" id="h8-0-76" class="i">+	Name     *string `json:&quot;name,omitempty&quot;`
</a><a href="#h8-0-77" id="h8-0-77" class="i">+	ClientID *string `json:&quot;client_id,omitempty&quot;`
</a><a href="#h8-0-78" id="h8-0-78" class="i">+}
</a><a href="#h8-0-79" id="h8-0-79" class="i">+
</a><a href="#h8-0-80" id="h8-0-80" class="i">+func (a AuthorizationApp) String() string {
</a><a href="#h8-0-81" id="h8-0-81" class="i">+	return Stringify(a)
</a><a href="#h8-0-82" id="h8-0-82" class="i">+}
</a><a href="#h8-0-83" id="h8-0-83" class="i">+
</a><a href="#h8-0-84" id="h8-0-84" class="i">+// AuthorizationRequest represents a request to create an authorization.
</a><a href="#h8-0-85" id="h8-0-85" class="i">+type AuthorizationRequest struct {
</a><a href="#h8-0-86" id="h8-0-86" class="i">+	Scopes       []Scope `json:&quot;scopes,omitempty&quot;`
</a><a href="#h8-0-87" id="h8-0-87" class="i">+	Note         *string `json:&quot;note,omitempty&quot;`
</a><a href="#h8-0-88" id="h8-0-88" class="i">+	NoteURL      *string `json:&quot;note_url,omitempty&quot;`
</a><a href="#h8-0-89" id="h8-0-89" class="i">+	ClientID     *string `json:&quot;client_id,omitempty&quot;`
</a><a href="#h8-0-90" id="h8-0-90" class="i">+	ClientSecret *string `json:&quot;client_secret,omitempty&quot;`
</a><a href="#h8-0-91" id="h8-0-91" class="i">+	Fingerprint  *string `json:&quot;fingerprint,omitempty&quot;`
</a><a href="#h8-0-92" id="h8-0-92" class="i">+}
</a><a href="#h8-0-93" id="h8-0-93" class="i">+
</a><a href="#h8-0-94" id="h8-0-94" class="i">+func (a AuthorizationRequest) String() string {
</a><a href="#h8-0-95" id="h8-0-95" class="i">+	return Stringify(a)
</a><a href="#h8-0-96" id="h8-0-96" class="i">+}
</a><a href="#h8-0-97" id="h8-0-97" class="i">+
</a><a href="#h8-0-98" id="h8-0-98" class="i">+// AuthorizationUpdateRequest represents a request to update an authorization.
</a><a href="#h8-0-99" id="h8-0-99" class="i">+//
</a><a href="#h8-0-100" id="h8-0-100" class="i">+// Note that for any one update, you must only provide one of the &quot;scopes&quot;
</a><a href="#h8-0-101" id="h8-0-101" class="i">+// fields.  That is, you may provide only one of &quot;Scopes&quot;, or &quot;AddScopes&quot;, or
</a><a href="#h8-0-102" id="h8-0-102" class="i">+// &quot;RemoveScopes&quot;.
</a><a href="#h8-0-103" id="h8-0-103" class="i">+//
</a><a href="#h8-0-104" id="h8-0-104" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
</a><a href="#h8-0-105" id="h8-0-105" class="i">+type AuthorizationUpdateRequest struct {
</a><a href="#h8-0-106" id="h8-0-106" class="i">+	Scopes       []string `json:&quot;scopes,omitempty&quot;`
</a><a href="#h8-0-107" id="h8-0-107" class="i">+	AddScopes    []string `json:&quot;add_scopes,omitempty&quot;`
</a><a href="#h8-0-108" id="h8-0-108" class="i">+	RemoveScopes []string `json:&quot;remove_scopes,omitempty&quot;`
</a><a href="#h8-0-109" id="h8-0-109" class="i">+	Note         *string  `json:&quot;note,omitempty&quot;`
</a><a href="#h8-0-110" id="h8-0-110" class="i">+	NoteURL      *string  `json:&quot;note_url,omitempty&quot;`
</a><a href="#h8-0-111" id="h8-0-111" class="i">+	Fingerprint  *string  `json:&quot;fingerprint,omitempty&quot;`
</a><a href="#h8-0-112" id="h8-0-112" class="i">+}
</a><a href="#h8-0-113" id="h8-0-113" class="i">+
</a><a href="#h8-0-114" id="h8-0-114" class="i">+func (a AuthorizationUpdateRequest) String() string {
</a><a href="#h8-0-115" id="h8-0-115" class="i">+	return Stringify(a)
</a><a href="#h8-0-116" id="h8-0-116" class="i">+}
</a><a href="#h8-0-117" id="h8-0-117" class="i">+
</a><a href="#h8-0-118" id="h8-0-118" class="i">+// List the authorizations for the authenticated user.
</a><a href="#h8-0-119" id="h8-0-119" class="i">+//
</a><a href="#h8-0-120" id="h8-0-120" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations
</a><a href="#h8-0-121" id="h8-0-121" class="i">+func (s *AuthorizationsService) List(opt *ListOptions) ([]Authorization, *Response, error) {
</a><a href="#h8-0-122" id="h8-0-122" class="i">+	u := &quot;authorizations&quot;
</a><a href="#h8-0-123" id="h8-0-123" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h8-0-124" id="h8-0-124" class="i">+	if err != nil {
</a><a href="#h8-0-125" id="h8-0-125" class="i">+		return nil, nil, err
</a><a href="#h8-0-126" id="h8-0-126" class="i">+	}
</a><a href="#h8-0-127" id="h8-0-127" class="i">+
</a><a href="#h8-0-128" id="h8-0-128" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h8-0-129" id="h8-0-129" class="i">+	if err != nil {
</a><a href="#h8-0-130" id="h8-0-130" class="i">+		return nil, nil, err
</a><a href="#h8-0-131" id="h8-0-131" class="i">+	}
</a><a href="#h8-0-132" id="h8-0-132" class="i">+
</a><a href="#h8-0-133" id="h8-0-133" class="i">+	auths := new([]Authorization)
</a><a href="#h8-0-134" id="h8-0-134" class="i">+	resp, err := s.client.Do(req, auths)
</a><a href="#h8-0-135" id="h8-0-135" class="i">+	if err != nil {
</a><a href="#h8-0-136" id="h8-0-136" class="i">+		return nil, resp, err
</a><a href="#h8-0-137" id="h8-0-137" class="i">+	}
</a><a href="#h8-0-138" id="h8-0-138" class="i">+	return *auths, resp, err
</a><a href="#h8-0-139" id="h8-0-139" class="i">+}
</a><a href="#h8-0-140" id="h8-0-140" class="i">+
</a><a href="#h8-0-141" id="h8-0-141" class="i">+// Get a single authorization.
</a><a href="#h8-0-142" id="h8-0-142" class="i">+//
</a><a href="#h8-0-143" id="h8-0-143" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization
</a><a href="#h8-0-144" id="h8-0-144" class="i">+func (s *AuthorizationsService) Get(id int) (*Authorization, *Response, error) {
</a><a href="#h8-0-145" id="h8-0-145" class="i">+	u := fmt.Sprintf(&quot;authorizations/%d&quot;, id)
</a><a href="#h8-0-146" id="h8-0-146" class="i">+
</a><a href="#h8-0-147" id="h8-0-147" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h8-0-148" id="h8-0-148" class="i">+	if err != nil {
</a><a href="#h8-0-149" id="h8-0-149" class="i">+		return nil, nil, err
</a><a href="#h8-0-150" id="h8-0-150" class="i">+	}
</a><a href="#h8-0-151" id="h8-0-151" class="i">+
</a><a href="#h8-0-152" id="h8-0-152" class="i">+	a := new(Authorization)
</a><a href="#h8-0-153" id="h8-0-153" class="i">+	resp, err := s.client.Do(req, a)
</a><a href="#h8-0-154" id="h8-0-154" class="i">+	if err != nil {
</a><a href="#h8-0-155" id="h8-0-155" class="i">+		return nil, resp, err
</a><a href="#h8-0-156" id="h8-0-156" class="i">+	}
</a><a href="#h8-0-157" id="h8-0-157" class="i">+	return a, resp, err
</a><a href="#h8-0-158" id="h8-0-158" class="i">+}
</a><a href="#h8-0-159" id="h8-0-159" class="i">+
</a><a href="#h8-0-160" id="h8-0-160" class="i">+// Create a new authorization for the specified OAuth application.
</a><a href="#h8-0-161" id="h8-0-161" class="i">+//
</a><a href="#h8-0-162" id="h8-0-162" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
</a><a href="#h8-0-163" id="h8-0-163" class="i">+func (s *AuthorizationsService) Create(auth *AuthorizationRequest) (*Authorization, *Response, error) {
</a><a href="#h8-0-164" id="h8-0-164" class="i">+	u := &quot;authorizations&quot;
</a><a href="#h8-0-165" id="h8-0-165" class="i">+
</a><a href="#h8-0-166" id="h8-0-166" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, auth)
</a><a href="#h8-0-167" id="h8-0-167" class="i">+	if err != nil {
</a><a href="#h8-0-168" id="h8-0-168" class="i">+		return nil, nil, err
</a><a href="#h8-0-169" id="h8-0-169" class="i">+	}
</a><a href="#h8-0-170" id="h8-0-170" class="i">+
</a><a href="#h8-0-171" id="h8-0-171" class="i">+	a := new(Authorization)
</a><a href="#h8-0-172" id="h8-0-172" class="i">+	resp, err := s.client.Do(req, a)
</a><a href="#h8-0-173" id="h8-0-173" class="i">+	if err != nil {
</a><a href="#h8-0-174" id="h8-0-174" class="i">+		return nil, resp, err
</a><a href="#h8-0-175" id="h8-0-175" class="i">+	}
</a><a href="#h8-0-176" id="h8-0-176" class="i">+	return a, resp, err
</a><a href="#h8-0-177" id="h8-0-177" class="i">+}
</a><a href="#h8-0-178" id="h8-0-178" class="i">+
</a><a href="#h8-0-179" id="h8-0-179" class="i">+// GetOrCreateForApp creates a new authorization for the specified OAuth
</a><a href="#h8-0-180" id="h8-0-180" class="i">+// application, only if an authorization for that application doesnt already
</a><a href="#h8-0-181" id="h8-0-181" class="i">+// exist for the user.
</a><a href="#h8-0-182" id="h8-0-182" class="i">+//
</a><a href="#h8-0-183" id="h8-0-183" class="i">+// If a new token is created, the HTTP status code will be &quot;201 Created&quot;, and
</a><a href="#h8-0-184" id="h8-0-184" class="i">+// the returned Authorization.Token field will be populated. If an existing
</a><a href="#h8-0-185" id="h8-0-185" class="i">+// token is returned, the status code will be &quot;200 OK&quot; and the
</a><a href="#h8-0-186" id="h8-0-186" class="i">+// Authorization.Token field will be empty.
</a><a href="#h8-0-187" id="h8-0-187" class="i">+//
</a><a href="#h8-0-188" id="h8-0-188" class="i">+// clientID is the OAuth Client ID with which to create the token.
</a><a href="#h8-0-189" id="h8-0-189" class="i">+//
</a><a href="#h8-0-190" id="h8-0-190" class="i">+// GitHub API docs:
</a><a href="#h8-0-191" id="h8-0-191" class="i">+// - https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app
</a><a href="#h8-0-192" id="h8-0-192" class="i">+// - https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint
</a><a href="#h8-0-193" id="h8-0-193" class="i">+func (s *AuthorizationsService) GetOrCreateForApp(clientID string, auth *AuthorizationRequest) (*Authorization, *Response, error) {
</a><a href="#h8-0-194" id="h8-0-194" class="i">+	var u string
</a><a href="#h8-0-195" id="h8-0-195" class="i">+	if auth.Fingerprint == nil || *auth.Fingerprint == &quot;&quot; {
</a><a href="#h8-0-196" id="h8-0-196" class="i">+		u = fmt.Sprintf(&quot;authorizations/clients/%v&quot;, clientID)
</a><a href="#h8-0-197" id="h8-0-197" class="i">+	} else {
</a><a href="#h8-0-198" id="h8-0-198" class="i">+		u = fmt.Sprintf(&quot;authorizations/clients/%v/%v&quot;, clientID, *auth.Fingerprint)
</a><a href="#h8-0-199" id="h8-0-199" class="i">+	}
</a><a href="#h8-0-200" id="h8-0-200" class="i">+
</a><a href="#h8-0-201" id="h8-0-201" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, auth)
</a><a href="#h8-0-202" id="h8-0-202" class="i">+	if err != nil {
</a><a href="#h8-0-203" id="h8-0-203" class="i">+		return nil, nil, err
</a><a href="#h8-0-204" id="h8-0-204" class="i">+	}
</a><a href="#h8-0-205" id="h8-0-205" class="i">+
</a><a href="#h8-0-206" id="h8-0-206" class="i">+	a := new(Authorization)
</a><a href="#h8-0-207" id="h8-0-207" class="i">+	resp, err := s.client.Do(req, a)
</a><a href="#h8-0-208" id="h8-0-208" class="i">+	if err != nil {
</a><a href="#h8-0-209" id="h8-0-209" class="i">+		return nil, resp, err
</a><a href="#h8-0-210" id="h8-0-210" class="i">+	}
</a><a href="#h8-0-211" id="h8-0-211" class="i">+
</a><a href="#h8-0-212" id="h8-0-212" class="i">+	return a, resp, err
</a><a href="#h8-0-213" id="h8-0-213" class="i">+}
</a><a href="#h8-0-214" id="h8-0-214" class="i">+
</a><a href="#h8-0-215" id="h8-0-215" class="i">+// Edit a single authorization.
</a><a href="#h8-0-216" id="h8-0-216" class="i">+//
</a><a href="#h8-0-217" id="h8-0-217" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization
</a><a href="#h8-0-218" id="h8-0-218" class="i">+func (s *AuthorizationsService) Edit(id int, auth *AuthorizationUpdateRequest) (*Authorization, *Response, error) {
</a><a href="#h8-0-219" id="h8-0-219" class="i">+	u := fmt.Sprintf(&quot;authorizations/%d&quot;, id)
</a><a href="#h8-0-220" id="h8-0-220" class="i">+
</a><a href="#h8-0-221" id="h8-0-221" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, auth)
</a><a href="#h8-0-222" id="h8-0-222" class="i">+	if err != nil {
</a><a href="#h8-0-223" id="h8-0-223" class="i">+		return nil, nil, err
</a><a href="#h8-0-224" id="h8-0-224" class="i">+	}
</a><a href="#h8-0-225" id="h8-0-225" class="i">+
</a><a href="#h8-0-226" id="h8-0-226" class="i">+	a := new(Authorization)
</a><a href="#h8-0-227" id="h8-0-227" class="i">+	resp, err := s.client.Do(req, a)
</a><a href="#h8-0-228" id="h8-0-228" class="i">+	if err != nil {
</a><a href="#h8-0-229" id="h8-0-229" class="i">+		return nil, resp, err
</a><a href="#h8-0-230" id="h8-0-230" class="i">+	}
</a><a href="#h8-0-231" id="h8-0-231" class="i">+
</a><a href="#h8-0-232" id="h8-0-232" class="i">+	return a, resp, err
</a><a href="#h8-0-233" id="h8-0-233" class="i">+}
</a><a href="#h8-0-234" id="h8-0-234" class="i">+
</a><a href="#h8-0-235" id="h8-0-235" class="i">+// Delete a single authorization.
</a><a href="#h8-0-236" id="h8-0-236" class="i">+//
</a><a href="#h8-0-237" id="h8-0-237" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization
</a><a href="#h8-0-238" id="h8-0-238" class="i">+func (s *AuthorizationsService) Delete(id int) (*Response, error) {
</a><a href="#h8-0-239" id="h8-0-239" class="i">+	u := fmt.Sprintf(&quot;authorizations/%d&quot;, id)
</a><a href="#h8-0-240" id="h8-0-240" class="i">+
</a><a href="#h8-0-241" id="h8-0-241" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h8-0-242" id="h8-0-242" class="i">+	if err != nil {
</a><a href="#h8-0-243" id="h8-0-243" class="i">+		return nil, err
</a><a href="#h8-0-244" id="h8-0-244" class="i">+	}
</a><a href="#h8-0-245" id="h8-0-245" class="i">+
</a><a href="#h8-0-246" id="h8-0-246" class="i">+	return s.client.Do(req, nil)
</a><a href="#h8-0-247" id="h8-0-247" class="i">+}
</a><a href="#h8-0-248" id="h8-0-248" class="i">+
</a><a href="#h8-0-249" id="h8-0-249" class="i">+// Check if an OAuth token is valid for a specific app.
</a><a href="#h8-0-250" id="h8-0-250" class="i">+//
</a><a href="#h8-0-251" id="h8-0-251" class="i">+// Note that this operation requires the use of BasicAuth, but where the
</a><a href="#h8-0-252" id="h8-0-252" class="i">+// username is the OAuth application clientID, and the password is its
</a><a href="#h8-0-253" id="h8-0-253" class="i">+// clientSecret. Invalid tokens will return a 404 Not Found.
</a><a href="#h8-0-254" id="h8-0-254" class="i">+//
</a><a href="#h8-0-255" id="h8-0-255" class="i">+// The returned Authorization.User field will be populated.
</a><a href="#h8-0-256" id="h8-0-256" class="i">+//
</a><a href="#h8-0-257" id="h8-0-257" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#check-an-authorization
</a><a href="#h8-0-258" id="h8-0-258" class="i">+func (s *AuthorizationsService) Check(clientID string, token string) (*Authorization, *Response, error) {
</a><a href="#h8-0-259" id="h8-0-259" class="i">+	u := fmt.Sprintf(&quot;applications/%v/tokens/%v&quot;, clientID, token)
</a><a href="#h8-0-260" id="h8-0-260" class="i">+
</a><a href="#h8-0-261" id="h8-0-261" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h8-0-262" id="h8-0-262" class="i">+	if err != nil {
</a><a href="#h8-0-263" id="h8-0-263" class="i">+		return nil, nil, err
</a><a href="#h8-0-264" id="h8-0-264" class="i">+	}
</a><a href="#h8-0-265" id="h8-0-265" class="i">+
</a><a href="#h8-0-266" id="h8-0-266" class="i">+	a := new(Authorization)
</a><a href="#h8-0-267" id="h8-0-267" class="i">+	resp, err := s.client.Do(req, a)
</a><a href="#h8-0-268" id="h8-0-268" class="i">+	if err != nil {
</a><a href="#h8-0-269" id="h8-0-269" class="i">+		return nil, resp, err
</a><a href="#h8-0-270" id="h8-0-270" class="i">+	}
</a><a href="#h8-0-271" id="h8-0-271" class="i">+
</a><a href="#h8-0-272" id="h8-0-272" class="i">+	return a, resp, err
</a><a href="#h8-0-273" id="h8-0-273" class="i">+}
</a><a href="#h8-0-274" id="h8-0-274" class="i">+
</a><a href="#h8-0-275" id="h8-0-275" class="i">+// Reset is used to reset a valid OAuth token without end user involvement.
</a><a href="#h8-0-276" id="h8-0-276" class="i">+// Applications must save the &quot;token&quot; property in the response, because changes
</a><a href="#h8-0-277" id="h8-0-277" class="i">+// take effect immediately.
</a><a href="#h8-0-278" id="h8-0-278" class="i">+//
</a><a href="#h8-0-279" id="h8-0-279" class="i">+// Note that this operation requires the use of BasicAuth, but where the
</a><a href="#h8-0-280" id="h8-0-280" class="i">+// username is the OAuth application clientID, and the password is its
</a><a href="#h8-0-281" id="h8-0-281" class="i">+// clientSecret. Invalid tokens will return a 404 Not Found.
</a><a href="#h8-0-282" id="h8-0-282" class="i">+//
</a><a href="#h8-0-283" id="h8-0-283" class="i">+// The returned Authorization.User field will be populated.
</a><a href="#h8-0-284" id="h8-0-284" class="i">+//
</a><a href="#h8-0-285" id="h8-0-285" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#reset-an-authorization
</a><a href="#h8-0-286" id="h8-0-286" class="i">+func (s *AuthorizationsService) Reset(clientID string, token string) (*Authorization, *Response, error) {
</a><a href="#h8-0-287" id="h8-0-287" class="i">+	u := fmt.Sprintf(&quot;applications/%v/tokens/%v&quot;, clientID, token)
</a><a href="#h8-0-288" id="h8-0-288" class="i">+
</a><a href="#h8-0-289" id="h8-0-289" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, nil)
</a><a href="#h8-0-290" id="h8-0-290" class="i">+	if err != nil {
</a><a href="#h8-0-291" id="h8-0-291" class="i">+		return nil, nil, err
</a><a href="#h8-0-292" id="h8-0-292" class="i">+	}
</a><a href="#h8-0-293" id="h8-0-293" class="i">+
</a><a href="#h8-0-294" id="h8-0-294" class="i">+	a := new(Authorization)
</a><a href="#h8-0-295" id="h8-0-295" class="i">+	resp, err := s.client.Do(req, a)
</a><a href="#h8-0-296" id="h8-0-296" class="i">+	if err != nil {
</a><a href="#h8-0-297" id="h8-0-297" class="i">+		return nil, resp, err
</a><a href="#h8-0-298" id="h8-0-298" class="i">+	}
</a><a href="#h8-0-299" id="h8-0-299" class="i">+
</a><a href="#h8-0-300" id="h8-0-300" class="i">+	return a, resp, err
</a><a href="#h8-0-301" id="h8-0-301" class="i">+}
</a><a href="#h8-0-302" id="h8-0-302" class="i">+
</a><a href="#h8-0-303" id="h8-0-303" class="i">+// Revoke an authorization for an application.
</a><a href="#h8-0-304" id="h8-0-304" class="i">+//
</a><a href="#h8-0-305" id="h8-0-305" class="i">+// Note that this operation requires the use of BasicAuth, but where the
</a><a href="#h8-0-306" id="h8-0-306" class="i">+// username is the OAuth application clientID, and the password is its
</a><a href="#h8-0-307" id="h8-0-307" class="i">+// clientSecret. Invalid tokens will return a 404 Not Found.
</a><a href="#h8-0-308" id="h8-0-308" class="i">+//
</a><a href="#h8-0-309" id="h8-0-309" class="i">+// GitHub API docs: https://developer.github.com/v3/oauth_authorizations/#revoke-an-authorization-for-an-application
</a><a href="#h8-0-310" id="h8-0-310" class="i">+func (s *AuthorizationsService) Revoke(clientID string, token string) (*Response, error) {
</a><a href="#h8-0-311" id="h8-0-311" class="i">+	u := fmt.Sprintf(&quot;applications/%v/tokens/%v&quot;, clientID, token)
</a><a href="#h8-0-312" id="h8-0-312" class="i">+
</a><a href="#h8-0-313" id="h8-0-313" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h8-0-314" id="h8-0-314" class="i">+	if err != nil {
</a><a href="#h8-0-315" id="h8-0-315" class="i">+		return nil, err
</a><a href="#h8-0-316" id="h8-0-316" class="i">+	}
</a><a href="#h8-0-317" id="h8-0-317" class="i">+
</a><a href="#h8-0-318" id="h8-0-318" class="i">+	return s.client.Do(req, nil)
</a><a href="#h8-0-319" id="h8-0-319" class="i">+}
</a><b>diff --git a/<a id="h9" href="../file/vendor/github.com/google/go-github/github/doc.go">vendor/github.com/google/go-github/github/doc.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/doc.go">vendor/github.com/google/go-github/github/doc.go</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -0,0 +1,133 @@
</a><a href="#h9-0-0" id="h9-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h9-0-1" id="h9-0-1" class="i">+//
</a><a href="#h9-0-2" id="h9-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h9-0-3" id="h9-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h9-0-4" id="h9-0-4" class="i">+
</a><a href="#h9-0-5" id="h9-0-5" class="i">+/*
</a><a href="#h9-0-6" id="h9-0-6" class="i">+Package github provides a client for using the GitHub API.
</a><a href="#h9-0-7" id="h9-0-7" class="i">+
</a><a href="#h9-0-8" id="h9-0-8" class="i">+Construct a new GitHub client, then use the various services on the client to
</a><a href="#h9-0-9" id="h9-0-9" class="i">+access different parts of the GitHub API. For example:
</a><a href="#h9-0-10" id="h9-0-10" class="i">+
</a><a href="#h9-0-11" id="h9-0-11" class="i">+	client := github.NewClient(nil)
</a><a href="#h9-0-12" id="h9-0-12" class="i">+
</a><a href="#h9-0-13" id="h9-0-13" class="i">+	// list all organizations for user &quot;willnorris&quot;
</a><a href="#h9-0-14" id="h9-0-14" class="i">+	orgs, _, err := client.Organizations.List(&quot;willnorris&quot;, nil)
</a><a href="#h9-0-15" id="h9-0-15" class="i">+
</a><a href="#h9-0-16" id="h9-0-16" class="i">+Set optional parameters for an API method by passing an Options object.
</a><a href="#h9-0-17" id="h9-0-17" class="i">+
</a><a href="#h9-0-18" id="h9-0-18" class="i">+	// list recently updated repositories for org &quot;github&quot;
</a><a href="#h9-0-19" id="h9-0-19" class="i">+	opt := &amp;github.RepositoryListByOrgOptions{Sort: &quot;updated&quot;}
</a><a href="#h9-0-20" id="h9-0-20" class="i">+	repos, _, err := client.Repositories.ListByOrg(&quot;github&quot;, opt)
</a><a href="#h9-0-21" id="h9-0-21" class="i">+
</a><a href="#h9-0-22" id="h9-0-22" class="i">+The services of a client divide the API into logical chunks and correspond to
</a><a href="#h9-0-23" id="h9-0-23" class="i">+the structure of the GitHub API documentation at
</a><a href="#h9-0-24" id="h9-0-24" class="i">+http://developer.github.com/v3/.
</a><a href="#h9-0-25" id="h9-0-25" class="i">+
</a><a href="#h9-0-26" id="h9-0-26" class="i">+Authentication
</a><a href="#h9-0-27" id="h9-0-27" class="i">+
</a><a href="#h9-0-28" id="h9-0-28" class="i">+The go-github library does not directly handle authentication. Instead, when
</a><a href="#h9-0-29" id="h9-0-29" class="i">+creating a new client, pass an http.Client that can handle authentication for
</a><a href="#h9-0-30" id="h9-0-30" class="i">+you. The easiest and recommended way to do this is using the golang.org/x/oauth2
</a><a href="#h9-0-31" id="h9-0-31" class="i">+library, but you can always use any other library that provides an http.Client.
</a><a href="#h9-0-32" id="h9-0-32" class="i">+If you have an OAuth2 access token (for example, a personal API token), you can
</a><a href="#h9-0-33" id="h9-0-33" class="i">+use it with the oauth2 library using:
</a><a href="#h9-0-34" id="h9-0-34" class="i">+
</a><a href="#h9-0-35" id="h9-0-35" class="i">+	import &quot;golang.org/x/oauth2&quot;
</a><a href="#h9-0-36" id="h9-0-36" class="i">+
</a><a href="#h9-0-37" id="h9-0-37" class="i">+	func main() {
</a><a href="#h9-0-38" id="h9-0-38" class="i">+		ts := oauth2.StaticTokenSource(
</a><a href="#h9-0-39" id="h9-0-39" class="i">+			&amp;oauth2.Token{AccessToken: &quot;... your access token ...&quot;},
</a><a href="#h9-0-40" id="h9-0-40" class="i">+		)
</a><a href="#h9-0-41" id="h9-0-41" class="i">+		tc := oauth2.NewClient(oauth2.NoContext, ts)
</a><a href="#h9-0-42" id="h9-0-42" class="i">+
</a><a href="#h9-0-43" id="h9-0-43" class="i">+		client := github.NewClient(tc)
</a><a href="#h9-0-44" id="h9-0-44" class="i">+
</a><a href="#h9-0-45" id="h9-0-45" class="i">+		// list all repositories for the authenticated user
</a><a href="#h9-0-46" id="h9-0-46" class="i">+		repos, _, err := client.Repositories.List(&quot;&quot;, nil)
</a><a href="#h9-0-47" id="h9-0-47" class="i">+	}
</a><a href="#h9-0-48" id="h9-0-48" class="i">+
</a><a href="#h9-0-49" id="h9-0-49" class="i">+Note that when using an authenticated Client, all calls made by the client will
</a><a href="#h9-0-50" id="h9-0-50" class="i">+include the specified OAuth token. Therefore, authenticated clients should
</a><a href="#h9-0-51" id="h9-0-51" class="i">+almost never be shared between different users.
</a><a href="#h9-0-52" id="h9-0-52" class="i">+
</a><a href="#h9-0-53" id="h9-0-53" class="i">+Rate Limiting
</a><a href="#h9-0-54" id="h9-0-54" class="i">+
</a><a href="#h9-0-55" id="h9-0-55" class="i">+GitHub imposes a rate limit on all API clients.  Unauthenticated clients are
</a><a href="#h9-0-56" id="h9-0-56" class="i">+limited to 60 requests per hour, while authenticated clients can make up to
</a><a href="#h9-0-57" id="h9-0-57" class="i">+5,000 requests per hour.  To receive the higher rate limit when making calls
</a><a href="#h9-0-58" id="h9-0-58" class="i">+that are not issued on behalf of a user, use the
</a><a href="#h9-0-59" id="h9-0-59" class="i">+UnauthenticatedRateLimitedTransport.
</a><a href="#h9-0-60" id="h9-0-60" class="i">+
</a><a href="#h9-0-61" id="h9-0-61" class="i">+The Rate method on a client returns the rate limit information based on the most
</a><a href="#h9-0-62" id="h9-0-62" class="i">+recent API call.  This is updated on every call, but may be out of date if it&#39;s
</a><a href="#h9-0-63" id="h9-0-63" class="i">+been some time since the last API call and other clients have made subsequent
</a><a href="#h9-0-64" id="h9-0-64" class="i">+requests since then.  You can always call RateLimits() directly to get the most
</a><a href="#h9-0-65" id="h9-0-65" class="i">+up-to-date rate limit data for the client.
</a><a href="#h9-0-66" id="h9-0-66" class="i">+
</a><a href="#h9-0-67" id="h9-0-67" class="i">+To detect an API rate limit error, you can check if its type is *github.RateLimitError:
</a><a href="#h9-0-68" id="h9-0-68" class="i">+
</a><a href="#h9-0-69" id="h9-0-69" class="i">+	repos, _, err := client.Repositories.List(&quot;&quot;, nil)
</a><a href="#h9-0-70" id="h9-0-70" class="i">+	if _, ok := err.(*github.RateLimitError); ok {
</a><a href="#h9-0-71" id="h9-0-71" class="i">+		log.Println(&quot;hit rate limit&quot;)
</a><a href="#h9-0-72" id="h9-0-72" class="i">+	}
</a><a href="#h9-0-73" id="h9-0-73" class="i">+
</a><a href="#h9-0-74" id="h9-0-74" class="i">+Learn more about GitHub rate limiting at
</a><a href="#h9-0-75" id="h9-0-75" class="i">+http://developer.github.com/v3/#rate-limiting.
</a><a href="#h9-0-76" id="h9-0-76" class="i">+
</a><a href="#h9-0-77" id="h9-0-77" class="i">+Conditional Requests
</a><a href="#h9-0-78" id="h9-0-78" class="i">+
</a><a href="#h9-0-79" id="h9-0-79" class="i">+The GitHub API has good support for conditional requests which will help
</a><a href="#h9-0-80" id="h9-0-80" class="i">+prevent you from burning through your rate limit, as well as help speed up your
</a><a href="#h9-0-81" id="h9-0-81" class="i">+application.  go-github does not handle conditional requests directly, but is
</a><a href="#h9-0-82" id="h9-0-82" class="i">+instead designed to work with a caching http.Transport.  We recommend using
</a><a href="#h9-0-83" id="h9-0-83" class="i">+https://github.com/gregjones/httpcache, which can be used in conjunction with
</a><a href="#h9-0-84" id="h9-0-84" class="i">+https://github.com/sourcegraph/apiproxy to provide additional flexibility and
</a><a href="#h9-0-85" id="h9-0-85" class="i">+control of caching rules.
</a><a href="#h9-0-86" id="h9-0-86" class="i">+
</a><a href="#h9-0-87" id="h9-0-87" class="i">+Learn more about GitHub conditional requests at
</a><a href="#h9-0-88" id="h9-0-88" class="i">+https://developer.github.com/v3/#conditional-requests.
</a><a href="#h9-0-89" id="h9-0-89" class="i">+
</a><a href="#h9-0-90" id="h9-0-90" class="i">+Creating and Updating Resources
</a><a href="#h9-0-91" id="h9-0-91" class="i">+
</a><a href="#h9-0-92" id="h9-0-92" class="i">+All structs for GitHub resources use pointer values for all non-repeated fields.
</a><a href="#h9-0-93" id="h9-0-93" class="i">+This allows distinguishing between unset fields and those set to a zero-value.
</a><a href="#h9-0-94" id="h9-0-94" class="i">+Helper functions have been provided to easily create these pointers for string,
</a><a href="#h9-0-95" id="h9-0-95" class="i">+bool, and int values.  For example:
</a><a href="#h9-0-96" id="h9-0-96" class="i">+
</a><a href="#h9-0-97" id="h9-0-97" class="i">+	// create a new private repository named &quot;foo&quot;
</a><a href="#h9-0-98" id="h9-0-98" class="i">+	repo := &amp;github.Repository{
</a><a href="#h9-0-99" id="h9-0-99" class="i">+		Name:    github.String(&quot;foo&quot;),
</a><a href="#h9-0-100" id="h9-0-100" class="i">+		Private: github.Bool(true),
</a><a href="#h9-0-101" id="h9-0-101" class="i">+	}
</a><a href="#h9-0-102" id="h9-0-102" class="i">+	client.Repositories.Create(&quot;&quot;, repo)
</a><a href="#h9-0-103" id="h9-0-103" class="i">+
</a><a href="#h9-0-104" id="h9-0-104" class="i">+Users who have worked with protocol buffers should find this pattern familiar.
</a><a href="#h9-0-105" id="h9-0-105" class="i">+
</a><a href="#h9-0-106" id="h9-0-106" class="i">+Pagination
</a><a href="#h9-0-107" id="h9-0-107" class="i">+
</a><a href="#h9-0-108" id="h9-0-108" class="i">+All requests for resource collections (repos, pull requests, issues, etc)
</a><a href="#h9-0-109" id="h9-0-109" class="i">+support pagination. Pagination options are described in the
</a><a href="#h9-0-110" id="h9-0-110" class="i">+ListOptions struct and passed to the list methods directly or as an
</a><a href="#h9-0-111" id="h9-0-111" class="i">+embedded type of a more specific list options struct (for example
</a><a href="#h9-0-112" id="h9-0-112" class="i">+PullRequestListOptions).  Pages information is available via Response struct.
</a><a href="#h9-0-113" id="h9-0-113" class="i">+
</a><a href="#h9-0-114" id="h9-0-114" class="i">+	opt := &amp;github.RepositoryListByOrgOptions{
</a><a href="#h9-0-115" id="h9-0-115" class="i">+		ListOptions: github.ListOptions{PerPage: 10},
</a><a href="#h9-0-116" id="h9-0-116" class="i">+	}
</a><a href="#h9-0-117" id="h9-0-117" class="i">+	// get all pages of results
</a><a href="#h9-0-118" id="h9-0-118" class="i">+	var allRepos []github.Repository
</a><a href="#h9-0-119" id="h9-0-119" class="i">+	for {
</a><a href="#h9-0-120" id="h9-0-120" class="i">+		repos, resp, err := client.Repositories.ListByOrg(&quot;github&quot;, opt)
</a><a href="#h9-0-121" id="h9-0-121" class="i">+		if err != nil {
</a><a href="#h9-0-122" id="h9-0-122" class="i">+			return err
</a><a href="#h9-0-123" id="h9-0-123" class="i">+		}
</a><a href="#h9-0-124" id="h9-0-124" class="i">+		allRepos = append(allRepos, repos...)
</a><a href="#h9-0-125" id="h9-0-125" class="i">+		if resp.NextPage == 0 {
</a><a href="#h9-0-126" id="h9-0-126" class="i">+			break
</a><a href="#h9-0-127" id="h9-0-127" class="i">+		}
</a><a href="#h9-0-128" id="h9-0-128" class="i">+		opt.ListOptions.Page = resp.NextPage
</a><a href="#h9-0-129" id="h9-0-129" class="i">+	}
</a><a href="#h9-0-130" id="h9-0-130" class="i">+
</a><a href="#h9-0-131" id="h9-0-131" class="i">+*/
</a><a href="#h9-0-132" id="h9-0-132" class="i">+package github
</a><b>diff --git a/<a id="h10" href="../file/vendor/github.com/google/go-github/github/event_types.go">vendor/github.com/google/go-github/github/event_types.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/event_types.go">vendor/github.com/google/go-github/github/event_types.go</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -0,0 +1,444 @@
</a><a href="#h10-0-0" id="h10-0-0" class="i">+// Copyright 2016 The go-github AUTHORS. All rights reserved.
</a><a href="#h10-0-1" id="h10-0-1" class="i">+//
</a><a href="#h10-0-2" id="h10-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h10-0-3" id="h10-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h10-0-4" id="h10-0-4" class="i">+
</a><a href="#h10-0-5" id="h10-0-5" class="i">+// These event types are shared between the Events API and used as Webhook payloads.
</a><a href="#h10-0-6" id="h10-0-6" class="i">+
</a><a href="#h10-0-7" id="h10-0-7" class="i">+package github
</a><a href="#h10-0-8" id="h10-0-8" class="i">+
</a><a href="#h10-0-9" id="h10-0-9" class="i">+// CommitCommentEvent is triggered when a commit comment is created.
</a><a href="#h10-0-10" id="h10-0-10" class="i">+// The Webhook event name is &quot;commit_comment&quot;.
</a><a href="#h10-0-11" id="h10-0-11" class="i">+//
</a><a href="#h10-0-12" id="h10-0-12" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#commitcommentevent
</a><a href="#h10-0-13" id="h10-0-13" class="i">+type CommitCommentEvent struct {
</a><a href="#h10-0-14" id="h10-0-14" class="i">+	Comment *RepositoryComment `json:&quot;comment,omitempty&quot;`
</a><a href="#h10-0-15" id="h10-0-15" class="i">+
</a><a href="#h10-0-16" id="h10-0-16" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-17" id="h10-0-17" class="i">+	Action *string     `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-18" id="h10-0-18" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-19" id="h10-0-19" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-20" id="h10-0-20" class="i">+}
</a><a href="#h10-0-21" id="h10-0-21" class="i">+
</a><a href="#h10-0-22" id="h10-0-22" class="i">+// CreateEvent represents a created repository, branch, or tag.
</a><a href="#h10-0-23" id="h10-0-23" class="i">+// The Webhook event name is &quot;create&quot;.
</a><a href="#h10-0-24" id="h10-0-24" class="i">+//
</a><a href="#h10-0-25" id="h10-0-25" class="i">+// Note: webhooks will not receive this event for created repositories.
</a><a href="#h10-0-26" id="h10-0-26" class="i">+// Additionally, webhooks will not receive this event for tags if more
</a><a href="#h10-0-27" id="h10-0-27" class="i">+// than three tags are pushed at once.
</a><a href="#h10-0-28" id="h10-0-28" class="i">+//
</a><a href="#h10-0-29" id="h10-0-29" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#createevent
</a><a href="#h10-0-30" id="h10-0-30" class="i">+type CreateEvent struct {
</a><a href="#h10-0-31" id="h10-0-31" class="i">+	Ref *string `json:&quot;ref,omitempty&quot;`
</a><a href="#h10-0-32" id="h10-0-32" class="i">+	// RefType is the object that was created. Possible values are: &quot;repository&quot;, &quot;branch&quot;, &quot;tag&quot;.
</a><a href="#h10-0-33" id="h10-0-33" class="i">+	RefType      *string `json:&quot;ref_type,omitempty&quot;`
</a><a href="#h10-0-34" id="h10-0-34" class="i">+	MasterBranch *string `json:&quot;master_branch,omitempty&quot;`
</a><a href="#h10-0-35" id="h10-0-35" class="i">+	Description  *string `json:&quot;description,omitempty&quot;`
</a><a href="#h10-0-36" id="h10-0-36" class="i">+
</a><a href="#h10-0-37" id="h10-0-37" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-38" id="h10-0-38" class="i">+	PusherType *string     `json:&quot;pusher_type,omitempty&quot;`
</a><a href="#h10-0-39" id="h10-0-39" class="i">+	Repo       *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-40" id="h10-0-40" class="i">+	Sender     *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-41" id="h10-0-41" class="i">+}
</a><a href="#h10-0-42" id="h10-0-42" class="i">+
</a><a href="#h10-0-43" id="h10-0-43" class="i">+// DeleteEvent represents a deleted branch or tag.
</a><a href="#h10-0-44" id="h10-0-44" class="i">+// The Webhook event name is &quot;delete&quot;.
</a><a href="#h10-0-45" id="h10-0-45" class="i">+//
</a><a href="#h10-0-46" id="h10-0-46" class="i">+// Note: webhooks will not receive this event for tags if more than three tags
</a><a href="#h10-0-47" id="h10-0-47" class="i">+// are deleted at once.
</a><a href="#h10-0-48" id="h10-0-48" class="i">+//
</a><a href="#h10-0-49" id="h10-0-49" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#deleteevent
</a><a href="#h10-0-50" id="h10-0-50" class="i">+type DeleteEvent struct {
</a><a href="#h10-0-51" id="h10-0-51" class="i">+	Ref *string `json:&quot;ref,omitempty&quot;`
</a><a href="#h10-0-52" id="h10-0-52" class="i">+	// RefType is the object that was deleted. Possible values are: &quot;branch&quot;, &quot;tag&quot;.
</a><a href="#h10-0-53" id="h10-0-53" class="i">+	RefType *string `json:&quot;ref_type,omitempty&quot;`
</a><a href="#h10-0-54" id="h10-0-54" class="i">+
</a><a href="#h10-0-55" id="h10-0-55" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-56" id="h10-0-56" class="i">+	PusherType *string     `json:&quot;pusher_type,omitempty&quot;`
</a><a href="#h10-0-57" id="h10-0-57" class="i">+	Repo       *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-58" id="h10-0-58" class="i">+	Sender     *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-59" id="h10-0-59" class="i">+}
</a><a href="#h10-0-60" id="h10-0-60" class="i">+
</a><a href="#h10-0-61" id="h10-0-61" class="i">+// DeploymentEvent represents a deployment.
</a><a href="#h10-0-62" id="h10-0-62" class="i">+// The Webhook event name is &quot;deployment&quot;.
</a><a href="#h10-0-63" id="h10-0-63" class="i">+//
</a><a href="#h10-0-64" id="h10-0-64" class="i">+// Events of this type are not visible in timelines, they are only used to trigger hooks.
</a><a href="#h10-0-65" id="h10-0-65" class="i">+//
</a><a href="#h10-0-66" id="h10-0-66" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#deploymentevent
</a><a href="#h10-0-67" id="h10-0-67" class="i">+type DeploymentEvent struct {
</a><a href="#h10-0-68" id="h10-0-68" class="i">+	Deployment *Deployment `json:&quot;deployment,omitempty&quot;`
</a><a href="#h10-0-69" id="h10-0-69" class="i">+	Repo       *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-70" id="h10-0-70" class="i">+
</a><a href="#h10-0-71" id="h10-0-71" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-72" id="h10-0-72" class="i">+	Sender *User `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-73" id="h10-0-73" class="i">+}
</a><a href="#h10-0-74" id="h10-0-74" class="i">+
</a><a href="#h10-0-75" id="h10-0-75" class="i">+// DeploymentStatusEvent represents a deployment status.
</a><a href="#h10-0-76" id="h10-0-76" class="i">+// The Webhook event name is &quot;deployment_status&quot;.
</a><a href="#h10-0-77" id="h10-0-77" class="i">+//
</a><a href="#h10-0-78" id="h10-0-78" class="i">+// Events of this type are not visible in timelines, they are only used to trigger hooks.
</a><a href="#h10-0-79" id="h10-0-79" class="i">+//
</a><a href="#h10-0-80" id="h10-0-80" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#deploymentstatusevent
</a><a href="#h10-0-81" id="h10-0-81" class="i">+type DeploymentStatusEvent struct {
</a><a href="#h10-0-82" id="h10-0-82" class="i">+	Deployment       *Deployment       `json:&quot;deployment,omitempty&quot;`
</a><a href="#h10-0-83" id="h10-0-83" class="i">+	DeploymentStatus *DeploymentStatus `json:&quot;deployment_status,omitempty&quot;`
</a><a href="#h10-0-84" id="h10-0-84" class="i">+	Repo             *Repository       `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-85" id="h10-0-85" class="i">+
</a><a href="#h10-0-86" id="h10-0-86" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-87" id="h10-0-87" class="i">+	Sender *User `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-88" id="h10-0-88" class="i">+}
</a><a href="#h10-0-89" id="h10-0-89" class="i">+
</a><a href="#h10-0-90" id="h10-0-90" class="i">+// ForkEvent is triggered when a user forks a repository.
</a><a href="#h10-0-91" id="h10-0-91" class="i">+// The Webhook event name is &quot;fork&quot;.
</a><a href="#h10-0-92" id="h10-0-92" class="i">+//
</a><a href="#h10-0-93" id="h10-0-93" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#forkevent
</a><a href="#h10-0-94" id="h10-0-94" class="i">+type ForkEvent struct {
</a><a href="#h10-0-95" id="h10-0-95" class="i">+	// Forkee is the created repository.
</a><a href="#h10-0-96" id="h10-0-96" class="i">+	Forkee *Repository `json:&quot;forkee,omitempty&quot;`
</a><a href="#h10-0-97" id="h10-0-97" class="i">+
</a><a href="#h10-0-98" id="h10-0-98" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-99" id="h10-0-99" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-100" id="h10-0-100" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-101" id="h10-0-101" class="i">+}
</a><a href="#h10-0-102" id="h10-0-102" class="i">+
</a><a href="#h10-0-103" id="h10-0-103" class="i">+// Page represents a single Wiki page.
</a><a href="#h10-0-104" id="h10-0-104" class="i">+type Page struct {
</a><a href="#h10-0-105" id="h10-0-105" class="i">+	PageName *string `json:&quot;page_name,omitempty&quot;`
</a><a href="#h10-0-106" id="h10-0-106" class="i">+	Title    *string `json:&quot;title,omitempty&quot;`
</a><a href="#h10-0-107" id="h10-0-107" class="i">+	Summary  *string `json:&quot;summary,omitempty&quot;`
</a><a href="#h10-0-108" id="h10-0-108" class="i">+	Action   *string `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-109" id="h10-0-109" class="i">+	SHA      *string `json:&quot;sha,omitempty&quot;`
</a><a href="#h10-0-110" id="h10-0-110" class="i">+	HTMLURL  *string `json:&quot;html_url,omitempty&quot;`
</a><a href="#h10-0-111" id="h10-0-111" class="i">+}
</a><a href="#h10-0-112" id="h10-0-112" class="i">+
</a><a href="#h10-0-113" id="h10-0-113" class="i">+// GollumEvent is triggered when a Wiki page is created or updated.
</a><a href="#h10-0-114" id="h10-0-114" class="i">+// The Webhook event name is &quot;gollum&quot;.
</a><a href="#h10-0-115" id="h10-0-115" class="i">+//
</a><a href="#h10-0-116" id="h10-0-116" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#gollumevent
</a><a href="#h10-0-117" id="h10-0-117" class="i">+type GollumEvent struct {
</a><a href="#h10-0-118" id="h10-0-118" class="i">+	Pages []*Page `json:&quot;pages,omitempty&quot;`
</a><a href="#h10-0-119" id="h10-0-119" class="i">+
</a><a href="#h10-0-120" id="h10-0-120" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-121" id="h10-0-121" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-122" id="h10-0-122" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-123" id="h10-0-123" class="i">+}
</a><a href="#h10-0-124" id="h10-0-124" class="i">+
</a><a href="#h10-0-125" id="h10-0-125" class="i">+// DEPRECATED: IssueActivityEvent represents the payload delivered by Issue webhook
</a><a href="#h10-0-126" id="h10-0-126" class="i">+// Use IssuesEvent instead.
</a><a href="#h10-0-127" id="h10-0-127" class="i">+type IssueActivityEvent struct {
</a><a href="#h10-0-128" id="h10-0-128" class="i">+	Action *string `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-129" id="h10-0-129" class="i">+	Issue  *Issue  `json:&quot;issue,omitempty&quot;`
</a><a href="#h10-0-130" id="h10-0-130" class="i">+
</a><a href="#h10-0-131" id="h10-0-131" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-132" id="h10-0-132" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-133" id="h10-0-133" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-134" id="h10-0-134" class="i">+}
</a><a href="#h10-0-135" id="h10-0-135" class="i">+
</a><a href="#h10-0-136" id="h10-0-136" class="i">+// IssueCommentEvent is triggered when an issue comment is created on an issue
</a><a href="#h10-0-137" id="h10-0-137" class="i">+// or pull request.
</a><a href="#h10-0-138" id="h10-0-138" class="i">+// The Webhook event name is &quot;issue_comment&quot;.
</a><a href="#h10-0-139" id="h10-0-139" class="i">+//
</a><a href="#h10-0-140" id="h10-0-140" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#issuecommentevent
</a><a href="#h10-0-141" id="h10-0-141" class="i">+type IssueCommentEvent struct {
</a><a href="#h10-0-142" id="h10-0-142" class="i">+	// Action is the action that was performed on the comment.
</a><a href="#h10-0-143" id="h10-0-143" class="i">+	// Possible value is: &quot;created&quot;.
</a><a href="#h10-0-144" id="h10-0-144" class="i">+	Action  *string       `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-145" id="h10-0-145" class="i">+	Issue   *Issue        `json:&quot;issue,omitempty&quot;`
</a><a href="#h10-0-146" id="h10-0-146" class="i">+	Comment *IssueComment `json:&quot;comment,omitempty&quot;`
</a><a href="#h10-0-147" id="h10-0-147" class="i">+
</a><a href="#h10-0-148" id="h10-0-148" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-149" id="h10-0-149" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-150" id="h10-0-150" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-151" id="h10-0-151" class="i">+}
</a><a href="#h10-0-152" id="h10-0-152" class="i">+
</a><a href="#h10-0-153" id="h10-0-153" class="i">+// IssuesEvent is triggered when an issue is assigned, unassigned, labeled,
</a><a href="#h10-0-154" id="h10-0-154" class="i">+// unlabeled, opened, closed, or reopened.
</a><a href="#h10-0-155" id="h10-0-155" class="i">+// The Webhook event name is &quot;issues&quot;.
</a><a href="#h10-0-156" id="h10-0-156" class="i">+//
</a><a href="#h10-0-157" id="h10-0-157" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#issuesevent
</a><a href="#h10-0-158" id="h10-0-158" class="i">+type IssuesEvent struct {
</a><a href="#h10-0-159" id="h10-0-159" class="i">+	// Action is the action that was performed. Possible values are: &quot;assigned&quot;,
</a><a href="#h10-0-160" id="h10-0-160" class="i">+	// &quot;unassigned&quot;, &quot;labeled&quot;, &quot;unlabeled&quot;, &quot;opened&quot;, &quot;closed&quot;, &quot;reopened&quot;.
</a><a href="#h10-0-161" id="h10-0-161" class="i">+	Action   *string `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-162" id="h10-0-162" class="i">+	Issue    *Issue  `json:&quot;issue,omitempty&quot;`
</a><a href="#h10-0-163" id="h10-0-163" class="i">+	Assignee *User   `json:&quot;assignee,omitempty&quot;`
</a><a href="#h10-0-164" id="h10-0-164" class="i">+	Label    *Label  `json:&quot;label,omitempty&quot;`
</a><a href="#h10-0-165" id="h10-0-165" class="i">+
</a><a href="#h10-0-166" id="h10-0-166" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-167" id="h10-0-167" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-168" id="h10-0-168" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-169" id="h10-0-169" class="i">+}
</a><a href="#h10-0-170" id="h10-0-170" class="i">+
</a><a href="#h10-0-171" id="h10-0-171" class="i">+// MemberEvent is triggered when a user is added as a collaborator to a repository.
</a><a href="#h10-0-172" id="h10-0-172" class="i">+// The Webhook event name is &quot;member&quot;.
</a><a href="#h10-0-173" id="h10-0-173" class="i">+//
</a><a href="#h10-0-174" id="h10-0-174" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#memberevent
</a><a href="#h10-0-175" id="h10-0-175" class="i">+type MemberEvent struct {
</a><a href="#h10-0-176" id="h10-0-176" class="i">+	// Action is the action that was performed. Possible value is: &quot;added&quot;.
</a><a href="#h10-0-177" id="h10-0-177" class="i">+	Action *string `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-178" id="h10-0-178" class="i">+	Member *User   `json:&quot;member,omitempty&quot;`
</a><a href="#h10-0-179" id="h10-0-179" class="i">+
</a><a href="#h10-0-180" id="h10-0-180" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-181" id="h10-0-181" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-182" id="h10-0-182" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-183" id="h10-0-183" class="i">+}
</a><a href="#h10-0-184" id="h10-0-184" class="i">+
</a><a href="#h10-0-185" id="h10-0-185" class="i">+// MembershipEvent is triggered when a user is added or removed from a team.
</a><a href="#h10-0-186" id="h10-0-186" class="i">+// The Webhook event name is &quot;membership&quot;.
</a><a href="#h10-0-187" id="h10-0-187" class="i">+//
</a><a href="#h10-0-188" id="h10-0-188" class="i">+// Events of this type are not visible in timelines, they are only used to
</a><a href="#h10-0-189" id="h10-0-189" class="i">+// trigger organization webhooks.
</a><a href="#h10-0-190" id="h10-0-190" class="i">+//
</a><a href="#h10-0-191" id="h10-0-191" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#membershipevent
</a><a href="#h10-0-192" id="h10-0-192" class="i">+type MembershipEvent struct {
</a><a href="#h10-0-193" id="h10-0-193" class="i">+	// Action is the action that was performed. Possible values are: &quot;added&quot;, &quot;removed&quot;.
</a><a href="#h10-0-194" id="h10-0-194" class="i">+	Action *string `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-195" id="h10-0-195" class="i">+	// Scope is the scope of the membership. Possible value is: &quot;team&quot;.
</a><a href="#h10-0-196" id="h10-0-196" class="i">+	Scope  *string `json:&quot;scope,omitempty&quot;`
</a><a href="#h10-0-197" id="h10-0-197" class="i">+	Member *User   `json:&quot;member,omitempty&quot;`
</a><a href="#h10-0-198" id="h10-0-198" class="i">+	Team   *Team   `json:&quot;team,omitempty&quot;`
</a><a href="#h10-0-199" id="h10-0-199" class="i">+
</a><a href="#h10-0-200" id="h10-0-200" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-201" id="h10-0-201" class="i">+	Org    *Organization `json:&quot;organization,omitempty&quot;`
</a><a href="#h10-0-202" id="h10-0-202" class="i">+	Sender *User         `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-203" id="h10-0-203" class="i">+}
</a><a href="#h10-0-204" id="h10-0-204" class="i">+
</a><a href="#h10-0-205" id="h10-0-205" class="i">+// PageBuildEvent represents an attempted build of a GitHub Pages site, whether
</a><a href="#h10-0-206" id="h10-0-206" class="i">+// successful or not.
</a><a href="#h10-0-207" id="h10-0-207" class="i">+// The Webhook event name is &quot;page_build&quot;.
</a><a href="#h10-0-208" id="h10-0-208" class="i">+//
</a><a href="#h10-0-209" id="h10-0-209" class="i">+// This event is triggered on push to a GitHub Pages enabled branch (gh-pages
</a><a href="#h10-0-210" id="h10-0-210" class="i">+// for project pages, master for user and organization pages).
</a><a href="#h10-0-211" id="h10-0-211" class="i">+//
</a><a href="#h10-0-212" id="h10-0-212" class="i">+// Events of this type are not visible in timelines, they are only used to trigger hooks.
</a><a href="#h10-0-213" id="h10-0-213" class="i">+//
</a><a href="#h10-0-214" id="h10-0-214" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#pagebuildevent
</a><a href="#h10-0-215" id="h10-0-215" class="i">+type PageBuildEvent struct {
</a><a href="#h10-0-216" id="h10-0-216" class="i">+	Build *PagesBuild `json:&quot;build,omitempty&quot;`
</a><a href="#h10-0-217" id="h10-0-217" class="i">+
</a><a href="#h10-0-218" id="h10-0-218" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-219" id="h10-0-219" class="i">+	ID     *int        `json:&quot;id,omitempty&quot;`
</a><a href="#h10-0-220" id="h10-0-220" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-221" id="h10-0-221" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-222" id="h10-0-222" class="i">+}
</a><a href="#h10-0-223" id="h10-0-223" class="i">+
</a><a href="#h10-0-224" id="h10-0-224" class="i">+// PublicEvent is triggered when a private repository is open sourced.
</a><a href="#h10-0-225" id="h10-0-225" class="i">+// According to GitHub: &quot;Without a doubt: the best GitHub event.&quot;
</a><a href="#h10-0-226" id="h10-0-226" class="i">+// The Webhook event name is &quot;public&quot;.
</a><a href="#h10-0-227" id="h10-0-227" class="i">+//
</a><a href="#h10-0-228" id="h10-0-228" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#publicevent
</a><a href="#h10-0-229" id="h10-0-229" class="i">+type PublicEvent struct {
</a><a href="#h10-0-230" id="h10-0-230" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-231" id="h10-0-231" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-232" id="h10-0-232" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-233" id="h10-0-233" class="i">+}
</a><a href="#h10-0-234" id="h10-0-234" class="i">+
</a><a href="#h10-0-235" id="h10-0-235" class="i">+// PullRequestEvent is triggered when a pull request is assigned, unassigned,
</a><a href="#h10-0-236" id="h10-0-236" class="i">+// labeled, unlabeled, opened, closed, reopened, or synchronized.
</a><a href="#h10-0-237" id="h10-0-237" class="i">+// The Webhook event name is &quot;pull_request&quot;.
</a><a href="#h10-0-238" id="h10-0-238" class="i">+//
</a><a href="#h10-0-239" id="h10-0-239" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#pullrequestevent
</a><a href="#h10-0-240" id="h10-0-240" class="i">+type PullRequestEvent struct {
</a><a href="#h10-0-241" id="h10-0-241" class="i">+	// Action is the action that was performed. Possible values are: &quot;assigned&quot;,
</a><a href="#h10-0-242" id="h10-0-242" class="i">+	// &quot;unassigned&quot;, &quot;labeled&quot;, &quot;unlabeled&quot;, &quot;opened&quot;, &quot;closed&quot;, or &quot;reopened&quot;,
</a><a href="#h10-0-243" id="h10-0-243" class="i">+	// &quot;synchronize&quot;. If the action is &quot;closed&quot; and the merged key is false, the
</a><a href="#h10-0-244" id="h10-0-244" class="i">+	// pull request was closed with unmerged commits. If the action is &quot;closed&quot; and
</a><a href="#h10-0-245" id="h10-0-245" class="i">+	// the merged key is true, the pull request was merged.
</a><a href="#h10-0-246" id="h10-0-246" class="i">+	Action      *string      `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-247" id="h10-0-247" class="i">+	Number      *int         `json:&quot;number,omitempty&quot;`
</a><a href="#h10-0-248" id="h10-0-248" class="i">+	PullRequest *PullRequest `json:&quot;pull_request,omitempty&quot;`
</a><a href="#h10-0-249" id="h10-0-249" class="i">+
</a><a href="#h10-0-250" id="h10-0-250" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-251" id="h10-0-251" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-252" id="h10-0-252" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-253" id="h10-0-253" class="i">+}
</a><a href="#h10-0-254" id="h10-0-254" class="i">+
</a><a href="#h10-0-255" id="h10-0-255" class="i">+// PullRequestReviewCommentEvent is triggered when a comment is created on a
</a><a href="#h10-0-256" id="h10-0-256" class="i">+// portion of the unified diff of a pull request.
</a><a href="#h10-0-257" id="h10-0-257" class="i">+// The Webhook event name is &quot;pull_request_review_comment&quot;.
</a><a href="#h10-0-258" id="h10-0-258" class="i">+//
</a><a href="#h10-0-259" id="h10-0-259" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#pullrequestreviewcommentevent
</a><a href="#h10-0-260" id="h10-0-260" class="i">+type PullRequestReviewCommentEvent struct {
</a><a href="#h10-0-261" id="h10-0-261" class="i">+	// Action is the action that was performed on the comment.
</a><a href="#h10-0-262" id="h10-0-262" class="i">+	// Possible value is: &quot;created&quot;.
</a><a href="#h10-0-263" id="h10-0-263" class="i">+	Action      *string             `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-264" id="h10-0-264" class="i">+	PullRequest *PullRequest        `json:&quot;pull_request,omitempty&quot;`
</a><a href="#h10-0-265" id="h10-0-265" class="i">+	Comment     *PullRequestComment `json:&quot;comment,omitempty&quot;`
</a><a href="#h10-0-266" id="h10-0-266" class="i">+
</a><a href="#h10-0-267" id="h10-0-267" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-268" id="h10-0-268" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-269" id="h10-0-269" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-270" id="h10-0-270" class="i">+}
</a><a href="#h10-0-271" id="h10-0-271" class="i">+
</a><a href="#h10-0-272" id="h10-0-272" class="i">+// PushEvent represents a git push to a GitHub repository.
</a><a href="#h10-0-273" id="h10-0-273" class="i">+//
</a><a href="#h10-0-274" id="h10-0-274" class="i">+// GitHub API docs: http://developer.github.com/v3/activity/events/types/#pushevent
</a><a href="#h10-0-275" id="h10-0-275" class="i">+type PushEvent struct {
</a><a href="#h10-0-276" id="h10-0-276" class="i">+	PushID       *int                 `json:&quot;push_id,omitempty&quot;`
</a><a href="#h10-0-277" id="h10-0-277" class="i">+	Head         *string              `json:&quot;head,omitempty&quot;`
</a><a href="#h10-0-278" id="h10-0-278" class="i">+	Ref          *string              `json:&quot;ref,omitempty&quot;`
</a><a href="#h10-0-279" id="h10-0-279" class="i">+	Size         *int                 `json:&quot;size,omitempty&quot;`
</a><a href="#h10-0-280" id="h10-0-280" class="i">+	Commits      []PushEventCommit    `json:&quot;commits,omitempty&quot;`
</a><a href="#h10-0-281" id="h10-0-281" class="i">+	Repo         *PushEventRepository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-282" id="h10-0-282" class="i">+	Before       *string              `json:&quot;before,omitempty&quot;`
</a><a href="#h10-0-283" id="h10-0-283" class="i">+	DistinctSize *int                 `json:&quot;distinct_size,omitempty&quot;`
</a><a href="#h10-0-284" id="h10-0-284" class="i">+
</a><a href="#h10-0-285" id="h10-0-285" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-286" id="h10-0-286" class="i">+	After      *string          `json:&quot;after,omitempty&quot;`
</a><a href="#h10-0-287" id="h10-0-287" class="i">+	Created    *bool            `json:&quot;created,omitempty&quot;`
</a><a href="#h10-0-288" id="h10-0-288" class="i">+	Deleted    *bool            `json:&quot;deleted,omitempty&quot;`
</a><a href="#h10-0-289" id="h10-0-289" class="i">+	Forced     *bool            `json:&quot;forced,omitempty&quot;`
</a><a href="#h10-0-290" id="h10-0-290" class="i">+	BaseRef    *string          `json:&quot;base_ref,omitempty&quot;`
</a><a href="#h10-0-291" id="h10-0-291" class="i">+	Compare    *string          `json:&quot;compare,omitempty&quot;`
</a><a href="#h10-0-292" id="h10-0-292" class="i">+	HeadCommit *PushEventCommit `json:&quot;head_commit,omitempty&quot;`
</a><a href="#h10-0-293" id="h10-0-293" class="i">+	Pusher     *User            `json:&quot;pusher,omitempty&quot;`
</a><a href="#h10-0-294" id="h10-0-294" class="i">+	Sender     *User            `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-295" id="h10-0-295" class="i">+}
</a><a href="#h10-0-296" id="h10-0-296" class="i">+
</a><a href="#h10-0-297" id="h10-0-297" class="i">+func (p PushEvent) String() string {
</a><a href="#h10-0-298" id="h10-0-298" class="i">+	return Stringify(p)
</a><a href="#h10-0-299" id="h10-0-299" class="i">+}
</a><a href="#h10-0-300" id="h10-0-300" class="i">+
</a><a href="#h10-0-301" id="h10-0-301" class="i">+// PushEventCommit represents a git commit in a GitHub PushEvent.
</a><a href="#h10-0-302" id="h10-0-302" class="i">+type PushEventCommit struct {
</a><a href="#h10-0-303" id="h10-0-303" class="i">+	SHA       *string       `json:&quot;sha,omitempty&quot;`
</a><a href="#h10-0-304" id="h10-0-304" class="i">+	Message   *string       `json:&quot;message,omitempty&quot;`
</a><a href="#h10-0-305" id="h10-0-305" class="i">+	Author    *CommitAuthor `json:&quot;author,omitempty&quot;`
</a><a href="#h10-0-306" id="h10-0-306" class="i">+	Committer *CommitAuthor `json:&quot;committer,omitempty&quot;`
</a><a href="#h10-0-307" id="h10-0-307" class="i">+	URL       *string       `json:&quot;url,omitempty&quot;`
</a><a href="#h10-0-308" id="h10-0-308" class="i">+	Distinct  *bool         `json:&quot;distinct,omitempty&quot;`
</a><a href="#h10-0-309" id="h10-0-309" class="i">+	Added     []string      `json:&quot;added,omitempty&quot;`
</a><a href="#h10-0-310" id="h10-0-310" class="i">+	Removed   []string      `json:&quot;removed,omitempty&quot;`
</a><a href="#h10-0-311" id="h10-0-311" class="i">+	Modified  []string      `json:&quot;modified,omitempty&quot;`
</a><a href="#h10-0-312" id="h10-0-312" class="i">+}
</a><a href="#h10-0-313" id="h10-0-313" class="i">+
</a><a href="#h10-0-314" id="h10-0-314" class="i">+func (p PushEventCommit) String() string {
</a><a href="#h10-0-315" id="h10-0-315" class="i">+	return Stringify(p)
</a><a href="#h10-0-316" id="h10-0-316" class="i">+}
</a><a href="#h10-0-317" id="h10-0-317" class="i">+
</a><a href="#h10-0-318" id="h10-0-318" class="i">+// PushEventRepository represents the repo object in a PushEvent payload
</a><a href="#h10-0-319" id="h10-0-319" class="i">+type PushEventRepository struct {
</a><a href="#h10-0-320" id="h10-0-320" class="i">+	ID              *int                `json:&quot;id,omitempty&quot;`
</a><a href="#h10-0-321" id="h10-0-321" class="i">+	Name            *string             `json:&quot;name,omitempty&quot;`
</a><a href="#h10-0-322" id="h10-0-322" class="i">+	FullName        *string             `json:&quot;full_name,omitempty&quot;`
</a><a href="#h10-0-323" id="h10-0-323" class="i">+	Owner           *PushEventRepoOwner `json:&quot;owner,omitempty&quot;`
</a><a href="#h10-0-324" id="h10-0-324" class="i">+	Private         *bool               `json:&quot;private,omitempty&quot;`
</a><a href="#h10-0-325" id="h10-0-325" class="i">+	Description     *string             `json:&quot;description,omitempty&quot;`
</a><a href="#h10-0-326" id="h10-0-326" class="i">+	Fork            *bool               `json:&quot;fork,omitempty&quot;`
</a><a href="#h10-0-327" id="h10-0-327" class="i">+	CreatedAt       *Timestamp          `json:&quot;created_at,omitempty&quot;`
</a><a href="#h10-0-328" id="h10-0-328" class="i">+	PushedAt        *Timestamp          `json:&quot;pushed_at,omitempty&quot;`
</a><a href="#h10-0-329" id="h10-0-329" class="i">+	UpdatedAt       *Timestamp          `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h10-0-330" id="h10-0-330" class="i">+	Homepage        *string             `json:&quot;homepage,omitempty&quot;`
</a><a href="#h10-0-331" id="h10-0-331" class="i">+	Size            *int                `json:&quot;size,omitempty&quot;`
</a><a href="#h10-0-332" id="h10-0-332" class="i">+	StargazersCount *int                `json:&quot;stargazers_count,omitempty&quot;`
</a><a href="#h10-0-333" id="h10-0-333" class="i">+	WatchersCount   *int                `json:&quot;watchers_count,omitempty&quot;`
</a><a href="#h10-0-334" id="h10-0-334" class="i">+	Language        *string             `json:&quot;language,omitempty&quot;`
</a><a href="#h10-0-335" id="h10-0-335" class="i">+	HasIssues       *bool               `json:&quot;has_issues,omitempty&quot;`
</a><a href="#h10-0-336" id="h10-0-336" class="i">+	HasDownloads    *bool               `json:&quot;has_downloads,omitempty&quot;`
</a><a href="#h10-0-337" id="h10-0-337" class="i">+	HasWiki         *bool               `json:&quot;has_wiki,omitempty&quot;`
</a><a href="#h10-0-338" id="h10-0-338" class="i">+	HasPages        *bool               `json:&quot;has_pages,omitempty&quot;`
</a><a href="#h10-0-339" id="h10-0-339" class="i">+	ForksCount      *int                `json:&quot;forks_count,omitempty&quot;`
</a><a href="#h10-0-340" id="h10-0-340" class="i">+	OpenIssuesCount *int                `json:&quot;open_issues_count,omitempty&quot;`
</a><a href="#h10-0-341" id="h10-0-341" class="i">+	DefaultBranch   *string             `json:&quot;default_branch,omitempty&quot;`
</a><a href="#h10-0-342" id="h10-0-342" class="i">+	MasterBranch    *string             `json:&quot;master_branch,omitempty&quot;`
</a><a href="#h10-0-343" id="h10-0-343" class="i">+	Organization    *string             `json:&quot;organization,omitempty&quot;`
</a><a href="#h10-0-344" id="h10-0-344" class="i">+
</a><a href="#h10-0-345" id="h10-0-345" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-346" id="h10-0-346" class="i">+	URL     *string `json:&quot;url,omitempty&quot;`
</a><a href="#h10-0-347" id="h10-0-347" class="i">+	HTMLURL *string `json:&quot;html_url,omitempty&quot;`
</a><a href="#h10-0-348" id="h10-0-348" class="i">+}
</a><a href="#h10-0-349" id="h10-0-349" class="i">+
</a><a href="#h10-0-350" id="h10-0-350" class="i">+// PushEventRepoOwner is a basic reporesntation of user/org in a PushEvent payload
</a><a href="#h10-0-351" id="h10-0-351" class="i">+type PushEventRepoOwner struct {
</a><a href="#h10-0-352" id="h10-0-352" class="i">+	Name  *string `json:&quot;name,omitempty&quot;`
</a><a href="#h10-0-353" id="h10-0-353" class="i">+	Email *string `json:&quot;email,omitempty&quot;`
</a><a href="#h10-0-354" id="h10-0-354" class="i">+}
</a><a href="#h10-0-355" id="h10-0-355" class="i">+
</a><a href="#h10-0-356" id="h10-0-356" class="i">+// ReleaseEvent is triggered when a release is published.
</a><a href="#h10-0-357" id="h10-0-357" class="i">+// The Webhook event name is &quot;release&quot;.
</a><a href="#h10-0-358" id="h10-0-358" class="i">+//
</a><a href="#h10-0-359" id="h10-0-359" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#releaseevent
</a><a href="#h10-0-360" id="h10-0-360" class="i">+type ReleaseEvent struct {
</a><a href="#h10-0-361" id="h10-0-361" class="i">+	// Action is the action that was performed. Possible value is: &quot;published&quot;.
</a><a href="#h10-0-362" id="h10-0-362" class="i">+	Action  *string            `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-363" id="h10-0-363" class="i">+	Release *RepositoryRelease `json:&quot;release,omitempty&quot;`
</a><a href="#h10-0-364" id="h10-0-364" class="i">+
</a><a href="#h10-0-365" id="h10-0-365" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-366" id="h10-0-366" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-367" id="h10-0-367" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-368" id="h10-0-368" class="i">+}
</a><a href="#h10-0-369" id="h10-0-369" class="i">+
</a><a href="#h10-0-370" id="h10-0-370" class="i">+// RepositoryEvent is triggered when a repository is created.
</a><a href="#h10-0-371" id="h10-0-371" class="i">+// The Webhook event name is &quot;repository&quot;.
</a><a href="#h10-0-372" id="h10-0-372" class="i">+//
</a><a href="#h10-0-373" id="h10-0-373" class="i">+// Events of this type are not visible in timelines, they are only used to
</a><a href="#h10-0-374" id="h10-0-374" class="i">+// trigger organization webhooks.
</a><a href="#h10-0-375" id="h10-0-375" class="i">+//
</a><a href="#h10-0-376" id="h10-0-376" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#repositoryevent
</a><a href="#h10-0-377" id="h10-0-377" class="i">+type RepositoryEvent struct {
</a><a href="#h10-0-378" id="h10-0-378" class="i">+	// Action is the action that was performed. Possible value is: &quot;created&quot;.
</a><a href="#h10-0-379" id="h10-0-379" class="i">+	Action *string     `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-380" id="h10-0-380" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-381" id="h10-0-381" class="i">+
</a><a href="#h10-0-382" id="h10-0-382" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-383" id="h10-0-383" class="i">+	Org    *Organization `json:&quot;organization,omitempty&quot;`
</a><a href="#h10-0-384" id="h10-0-384" class="i">+	Sender *User         `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-385" id="h10-0-385" class="i">+}
</a><a href="#h10-0-386" id="h10-0-386" class="i">+
</a><a href="#h10-0-387" id="h10-0-387" class="i">+// StatusEvent is triggered when the status of a Git commit changes.
</a><a href="#h10-0-388" id="h10-0-388" class="i">+// The Webhook event name is &quot;status&quot;.
</a><a href="#h10-0-389" id="h10-0-389" class="i">+//
</a><a href="#h10-0-390" id="h10-0-390" class="i">+// Events of this type are not visible in timelines, they are only used to
</a><a href="#h10-0-391" id="h10-0-391" class="i">+// trigger hooks.
</a><a href="#h10-0-392" id="h10-0-392" class="i">+//
</a><a href="#h10-0-393" id="h10-0-393" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#statusevent
</a><a href="#h10-0-394" id="h10-0-394" class="i">+type StatusEvent struct {
</a><a href="#h10-0-395" id="h10-0-395" class="i">+	SHA *string `json:&quot;sha,omitempty&quot;`
</a><a href="#h10-0-396" id="h10-0-396" class="i">+	// State is the new state. Possible values are: &quot;pending&quot;, &quot;success&quot;, &quot;failure&quot;, &quot;error&quot;.
</a><a href="#h10-0-397" id="h10-0-397" class="i">+	State       *string   `json:&quot;state,omitempty&quot;`
</a><a href="#h10-0-398" id="h10-0-398" class="i">+	Description *string   `json:&quot;description,omitempty&quot;`
</a><a href="#h10-0-399" id="h10-0-399" class="i">+	TargetURL   *string   `json:&quot;target_url,omitempty&quot;`
</a><a href="#h10-0-400" id="h10-0-400" class="i">+	Branches    []*Branch `json:&quot;branches,omitempty&quot;`
</a><a href="#h10-0-401" id="h10-0-401" class="i">+
</a><a href="#h10-0-402" id="h10-0-402" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-403" id="h10-0-403" class="i">+	ID        *int             `json:&quot;id,omitempty&quot;`
</a><a href="#h10-0-404" id="h10-0-404" class="i">+	Name      *string          `json:&quot;name,omitempty&quot;`
</a><a href="#h10-0-405" id="h10-0-405" class="i">+	Context   *string          `json:&quot;context,omitempty&quot;`
</a><a href="#h10-0-406" id="h10-0-406" class="i">+	Commit    *PushEventCommit `json:&quot;commit,omitempty&quot;`
</a><a href="#h10-0-407" id="h10-0-407" class="i">+	CreatedAt *Timestamp       `json:&quot;created_at,omitempty&quot;`
</a><a href="#h10-0-408" id="h10-0-408" class="i">+	UpdatedAt *Timestamp       `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h10-0-409" id="h10-0-409" class="i">+	Repo      *Repository      `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-410" id="h10-0-410" class="i">+	Sender    *User            `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-411" id="h10-0-411" class="i">+}
</a><a href="#h10-0-412" id="h10-0-412" class="i">+
</a><a href="#h10-0-413" id="h10-0-413" class="i">+// TeamAddEvent is triggered when a repository is added to a team.
</a><a href="#h10-0-414" id="h10-0-414" class="i">+// The Webhook event name is &quot;team_add&quot;.
</a><a href="#h10-0-415" id="h10-0-415" class="i">+//
</a><a href="#h10-0-416" id="h10-0-416" class="i">+// Events of this type are not visible in timelines. These events are only used
</a><a href="#h10-0-417" id="h10-0-417" class="i">+// to trigger hooks.
</a><a href="#h10-0-418" id="h10-0-418" class="i">+//
</a><a href="#h10-0-419" id="h10-0-419" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#teamaddevent
</a><a href="#h10-0-420" id="h10-0-420" class="i">+type TeamAddEvent struct {
</a><a href="#h10-0-421" id="h10-0-421" class="i">+	Team *Team       `json:&quot;team,omitempty&quot;`
</a><a href="#h10-0-422" id="h10-0-422" class="i">+	Repo *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-423" id="h10-0-423" class="i">+
</a><a href="#h10-0-424" id="h10-0-424" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-425" id="h10-0-425" class="i">+	Org    *Organization `json:&quot;organization,omitempty&quot;`
</a><a href="#h10-0-426" id="h10-0-426" class="i">+	Sender *User         `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-427" id="h10-0-427" class="i">+}
</a><a href="#h10-0-428" id="h10-0-428" class="i">+
</a><a href="#h10-0-429" id="h10-0-429" class="i">+// WatchEvent is related to starring a repository, not watching. See this API
</a><a href="#h10-0-430" id="h10-0-430" class="i">+// blog post for an explanation: https://developer.github.com/changes/2012-09-05-watcher-api/
</a><a href="#h10-0-431" id="h10-0-431" class="i">+//
</a><a href="#h10-0-432" id="h10-0-432" class="i">+// The events actor is the user who starred a repository, and the events
</a><a href="#h10-0-433" id="h10-0-433" class="i">+// repository is the repository that was starred.
</a><a href="#h10-0-434" id="h10-0-434" class="i">+//
</a><a href="#h10-0-435" id="h10-0-435" class="i">+// GitHub docs: https://developer.github.com/v3/activity/events/types/#watchevent
</a><a href="#h10-0-436" id="h10-0-436" class="i">+type WatchEvent struct {
</a><a href="#h10-0-437" id="h10-0-437" class="i">+	// Action is the action that was performed. Possible value is: &quot;started&quot;.
</a><a href="#h10-0-438" id="h10-0-438" class="i">+	Action *string `json:&quot;action,omitempty&quot;`
</a><a href="#h10-0-439" id="h10-0-439" class="i">+
</a><a href="#h10-0-440" id="h10-0-440" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h10-0-441" id="h10-0-441" class="i">+	Repo   *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h10-0-442" id="h10-0-442" class="i">+	Sender *User       `json:&quot;sender,omitempty&quot;`
</a><a href="#h10-0-443" id="h10-0-443" class="i">+}
</a><b>diff --git a/<a id="h11" href="../file/vendor/github.com/google/go-github/github/gists.go">vendor/github.com/google/go-github/github/gists.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/gists.go">vendor/github.com/google/go-github/github/gists.go</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -0,0 +1,281 @@
</a><a href="#h11-0-0" id="h11-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h11-0-1" id="h11-0-1" class="i">+//
</a><a href="#h11-0-2" id="h11-0-2" class="i">+// Use of this source code is governed by BSD-style
</a><a href="#h11-0-3" id="h11-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h11-0-4" id="h11-0-4" class="i">+
</a><a href="#h11-0-5" id="h11-0-5" class="i">+package github
</a><a href="#h11-0-6" id="h11-0-6" class="i">+
</a><a href="#h11-0-7" id="h11-0-7" class="i">+import (
</a><a href="#h11-0-8" id="h11-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h11-0-9" id="h11-0-9" class="i">+	&quot;time&quot;
</a><a href="#h11-0-10" id="h11-0-10" class="i">+)
</a><a href="#h11-0-11" id="h11-0-11" class="i">+
</a><a href="#h11-0-12" id="h11-0-12" class="i">+// GistsService handles communication with the Gist related
</a><a href="#h11-0-13" id="h11-0-13" class="i">+// methods of the GitHub API.
</a><a href="#h11-0-14" id="h11-0-14" class="i">+//
</a><a href="#h11-0-15" id="h11-0-15" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/
</a><a href="#h11-0-16" id="h11-0-16" class="i">+type GistsService struct {
</a><a href="#h11-0-17" id="h11-0-17" class="i">+	client *Client
</a><a href="#h11-0-18" id="h11-0-18" class="i">+}
</a><a href="#h11-0-19" id="h11-0-19" class="i">+
</a><a href="#h11-0-20" id="h11-0-20" class="i">+// Gist represents a GitHub&#39;s gist.
</a><a href="#h11-0-21" id="h11-0-21" class="i">+type Gist struct {
</a><a href="#h11-0-22" id="h11-0-22" class="i">+	ID          *string                   `json:&quot;id,omitempty&quot;`
</a><a href="#h11-0-23" id="h11-0-23" class="i">+	Description *string                   `json:&quot;description,omitempty&quot;`
</a><a href="#h11-0-24" id="h11-0-24" class="i">+	Public      *bool                     `json:&quot;public,omitempty&quot;`
</a><a href="#h11-0-25" id="h11-0-25" class="i">+	Owner       *User                     `json:&quot;owner,omitempty&quot;`
</a><a href="#h11-0-26" id="h11-0-26" class="i">+	Files       map[GistFilename]GistFile `json:&quot;files,omitempty&quot;`
</a><a href="#h11-0-27" id="h11-0-27" class="i">+	Comments    *int                      `json:&quot;comments,omitempty&quot;`
</a><a href="#h11-0-28" id="h11-0-28" class="i">+	HTMLURL     *string                   `json:&quot;html_url,omitempty&quot;`
</a><a href="#h11-0-29" id="h11-0-29" class="i">+	GitPullURL  *string                   `json:&quot;git_pull_url,omitempty&quot;`
</a><a href="#h11-0-30" id="h11-0-30" class="i">+	GitPushURL  *string                   `json:&quot;git_push_url,omitempty&quot;`
</a><a href="#h11-0-31" id="h11-0-31" class="i">+	CreatedAt   *time.Time                `json:&quot;created_at,omitempty&quot;`
</a><a href="#h11-0-32" id="h11-0-32" class="i">+	UpdatedAt   *time.Time                `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h11-0-33" id="h11-0-33" class="i">+}
</a><a href="#h11-0-34" id="h11-0-34" class="i">+
</a><a href="#h11-0-35" id="h11-0-35" class="i">+func (g Gist) String() string {
</a><a href="#h11-0-36" id="h11-0-36" class="i">+	return Stringify(g)
</a><a href="#h11-0-37" id="h11-0-37" class="i">+}
</a><a href="#h11-0-38" id="h11-0-38" class="i">+
</a><a href="#h11-0-39" id="h11-0-39" class="i">+// GistFilename represents filename on a gist.
</a><a href="#h11-0-40" id="h11-0-40" class="i">+type GistFilename string
</a><a href="#h11-0-41" id="h11-0-41" class="i">+
</a><a href="#h11-0-42" id="h11-0-42" class="i">+// GistFile represents a file on a gist.
</a><a href="#h11-0-43" id="h11-0-43" class="i">+type GistFile struct {
</a><a href="#h11-0-44" id="h11-0-44" class="i">+	Size     *int    `json:&quot;size,omitempty&quot;`
</a><a href="#h11-0-45" id="h11-0-45" class="i">+	Filename *string `json:&quot;filename,omitempty&quot;`
</a><a href="#h11-0-46" id="h11-0-46" class="i">+	RawURL   *string `json:&quot;raw_url,omitempty&quot;`
</a><a href="#h11-0-47" id="h11-0-47" class="i">+	Content  *string `json:&quot;content,omitempty&quot;`
</a><a href="#h11-0-48" id="h11-0-48" class="i">+}
</a><a href="#h11-0-49" id="h11-0-49" class="i">+
</a><a href="#h11-0-50" id="h11-0-50" class="i">+func (g GistFile) String() string {
</a><a href="#h11-0-51" id="h11-0-51" class="i">+	return Stringify(g)
</a><a href="#h11-0-52" id="h11-0-52" class="i">+}
</a><a href="#h11-0-53" id="h11-0-53" class="i">+
</a><a href="#h11-0-54" id="h11-0-54" class="i">+// GistListOptions specifies the optional parameters to the
</a><a href="#h11-0-55" id="h11-0-55" class="i">+// GistsService.List, GistsService.ListAll, and GistsService.ListStarred methods.
</a><a href="#h11-0-56" id="h11-0-56" class="i">+type GistListOptions struct {
</a><a href="#h11-0-57" id="h11-0-57" class="i">+	// Since filters Gists by time.
</a><a href="#h11-0-58" id="h11-0-58" class="i">+	Since time.Time `url:&quot;since,omitempty&quot;`
</a><a href="#h11-0-59" id="h11-0-59" class="i">+
</a><a href="#h11-0-60" id="h11-0-60" class="i">+	ListOptions
</a><a href="#h11-0-61" id="h11-0-61" class="i">+}
</a><a href="#h11-0-62" id="h11-0-62" class="i">+
</a><a href="#h11-0-63" id="h11-0-63" class="i">+// List gists for a user. Passing the empty string will list
</a><a href="#h11-0-64" id="h11-0-64" class="i">+// all public gists if called anonymously. However, if the call
</a><a href="#h11-0-65" id="h11-0-65" class="i">+// is authenticated, it will returns all gists for the authenticated
</a><a href="#h11-0-66" id="h11-0-66" class="i">+// user.
</a><a href="#h11-0-67" id="h11-0-67" class="i">+//
</a><a href="#h11-0-68" id="h11-0-68" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#list-gists
</a><a href="#h11-0-69" id="h11-0-69" class="i">+func (s *GistsService) List(user string, opt *GistListOptions) ([]Gist, *Response, error) {
</a><a href="#h11-0-70" id="h11-0-70" class="i">+	var u string
</a><a href="#h11-0-71" id="h11-0-71" class="i">+	if user != &quot;&quot; {
</a><a href="#h11-0-72" id="h11-0-72" class="i">+		u = fmt.Sprintf(&quot;users/%v/gists&quot;, user)
</a><a href="#h11-0-73" id="h11-0-73" class="i">+	} else {
</a><a href="#h11-0-74" id="h11-0-74" class="i">+		u = &quot;gists&quot;
</a><a href="#h11-0-75" id="h11-0-75" class="i">+	}
</a><a href="#h11-0-76" id="h11-0-76" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h11-0-77" id="h11-0-77" class="i">+	if err != nil {
</a><a href="#h11-0-78" id="h11-0-78" class="i">+		return nil, nil, err
</a><a href="#h11-0-79" id="h11-0-79" class="i">+	}
</a><a href="#h11-0-80" id="h11-0-80" class="i">+
</a><a href="#h11-0-81" id="h11-0-81" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h11-0-82" id="h11-0-82" class="i">+	if err != nil {
</a><a href="#h11-0-83" id="h11-0-83" class="i">+		return nil, nil, err
</a><a href="#h11-0-84" id="h11-0-84" class="i">+	}
</a><a href="#h11-0-85" id="h11-0-85" class="i">+
</a><a href="#h11-0-86" id="h11-0-86" class="i">+	gists := new([]Gist)
</a><a href="#h11-0-87" id="h11-0-87" class="i">+	resp, err := s.client.Do(req, gists)
</a><a href="#h11-0-88" id="h11-0-88" class="i">+	if err != nil {
</a><a href="#h11-0-89" id="h11-0-89" class="i">+		return nil, resp, err
</a><a href="#h11-0-90" id="h11-0-90" class="i">+	}
</a><a href="#h11-0-91" id="h11-0-91" class="i">+
</a><a href="#h11-0-92" id="h11-0-92" class="i">+	return *gists, resp, err
</a><a href="#h11-0-93" id="h11-0-93" class="i">+}
</a><a href="#h11-0-94" id="h11-0-94" class="i">+
</a><a href="#h11-0-95" id="h11-0-95" class="i">+// ListAll lists all public gists.
</a><a href="#h11-0-96" id="h11-0-96" class="i">+//
</a><a href="#h11-0-97" id="h11-0-97" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#list-gists
</a><a href="#h11-0-98" id="h11-0-98" class="i">+func (s *GistsService) ListAll(opt *GistListOptions) ([]Gist, *Response, error) {
</a><a href="#h11-0-99" id="h11-0-99" class="i">+	u, err := addOptions(&quot;gists/public&quot;, opt)
</a><a href="#h11-0-100" id="h11-0-100" class="i">+	if err != nil {
</a><a href="#h11-0-101" id="h11-0-101" class="i">+		return nil, nil, err
</a><a href="#h11-0-102" id="h11-0-102" class="i">+	}
</a><a href="#h11-0-103" id="h11-0-103" class="i">+
</a><a href="#h11-0-104" id="h11-0-104" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h11-0-105" id="h11-0-105" class="i">+	if err != nil {
</a><a href="#h11-0-106" id="h11-0-106" class="i">+		return nil, nil, err
</a><a href="#h11-0-107" id="h11-0-107" class="i">+	}
</a><a href="#h11-0-108" id="h11-0-108" class="i">+
</a><a href="#h11-0-109" id="h11-0-109" class="i">+	gists := new([]Gist)
</a><a href="#h11-0-110" id="h11-0-110" class="i">+	resp, err := s.client.Do(req, gists)
</a><a href="#h11-0-111" id="h11-0-111" class="i">+	if err != nil {
</a><a href="#h11-0-112" id="h11-0-112" class="i">+		return nil, resp, err
</a><a href="#h11-0-113" id="h11-0-113" class="i">+	}
</a><a href="#h11-0-114" id="h11-0-114" class="i">+
</a><a href="#h11-0-115" id="h11-0-115" class="i">+	return *gists, resp, err
</a><a href="#h11-0-116" id="h11-0-116" class="i">+}
</a><a href="#h11-0-117" id="h11-0-117" class="i">+
</a><a href="#h11-0-118" id="h11-0-118" class="i">+// ListStarred lists starred gists of authenticated user.
</a><a href="#h11-0-119" id="h11-0-119" class="i">+//
</a><a href="#h11-0-120" id="h11-0-120" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#list-gists
</a><a href="#h11-0-121" id="h11-0-121" class="i">+func (s *GistsService) ListStarred(opt *GistListOptions) ([]Gist, *Response, error) {
</a><a href="#h11-0-122" id="h11-0-122" class="i">+	u, err := addOptions(&quot;gists/starred&quot;, opt)
</a><a href="#h11-0-123" id="h11-0-123" class="i">+	if err != nil {
</a><a href="#h11-0-124" id="h11-0-124" class="i">+		return nil, nil, err
</a><a href="#h11-0-125" id="h11-0-125" class="i">+	}
</a><a href="#h11-0-126" id="h11-0-126" class="i">+
</a><a href="#h11-0-127" id="h11-0-127" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h11-0-128" id="h11-0-128" class="i">+	if err != nil {
</a><a href="#h11-0-129" id="h11-0-129" class="i">+		return nil, nil, err
</a><a href="#h11-0-130" id="h11-0-130" class="i">+	}
</a><a href="#h11-0-131" id="h11-0-131" class="i">+
</a><a href="#h11-0-132" id="h11-0-132" class="i">+	gists := new([]Gist)
</a><a href="#h11-0-133" id="h11-0-133" class="i">+	resp, err := s.client.Do(req, gists)
</a><a href="#h11-0-134" id="h11-0-134" class="i">+	if err != nil {
</a><a href="#h11-0-135" id="h11-0-135" class="i">+		return nil, resp, err
</a><a href="#h11-0-136" id="h11-0-136" class="i">+	}
</a><a href="#h11-0-137" id="h11-0-137" class="i">+
</a><a href="#h11-0-138" id="h11-0-138" class="i">+	return *gists, resp, err
</a><a href="#h11-0-139" id="h11-0-139" class="i">+}
</a><a href="#h11-0-140" id="h11-0-140" class="i">+
</a><a href="#h11-0-141" id="h11-0-141" class="i">+// Get a single gist.
</a><a href="#h11-0-142" id="h11-0-142" class="i">+//
</a><a href="#h11-0-143" id="h11-0-143" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#get-a-single-gist
</a><a href="#h11-0-144" id="h11-0-144" class="i">+func (s *GistsService) Get(id string) (*Gist, *Response, error) {
</a><a href="#h11-0-145" id="h11-0-145" class="i">+	u := fmt.Sprintf(&quot;gists/%v&quot;, id)
</a><a href="#h11-0-146" id="h11-0-146" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h11-0-147" id="h11-0-147" class="i">+	if err != nil {
</a><a href="#h11-0-148" id="h11-0-148" class="i">+		return nil, nil, err
</a><a href="#h11-0-149" id="h11-0-149" class="i">+	}
</a><a href="#h11-0-150" id="h11-0-150" class="i">+	gist := new(Gist)
</a><a href="#h11-0-151" id="h11-0-151" class="i">+	resp, err := s.client.Do(req, gist)
</a><a href="#h11-0-152" id="h11-0-152" class="i">+	if err != nil {
</a><a href="#h11-0-153" id="h11-0-153" class="i">+		return nil, resp, err
</a><a href="#h11-0-154" id="h11-0-154" class="i">+	}
</a><a href="#h11-0-155" id="h11-0-155" class="i">+
</a><a href="#h11-0-156" id="h11-0-156" class="i">+	return gist, resp, err
</a><a href="#h11-0-157" id="h11-0-157" class="i">+}
</a><a href="#h11-0-158" id="h11-0-158" class="i">+
</a><a href="#h11-0-159" id="h11-0-159" class="i">+// GetRevision gets a specific revision of a gist.
</a><a href="#h11-0-160" id="h11-0-160" class="i">+//
</a><a href="#h11-0-161" id="h11-0-161" class="i">+// GitHub API docs: https://developer.github.com/v3/gists/#get-a-specific-revision-of-a-gist
</a><a href="#h11-0-162" id="h11-0-162" class="i">+func (s *GistsService) GetRevision(id, sha string) (*Gist, *Response, error) {
</a><a href="#h11-0-163" id="h11-0-163" class="i">+	u := fmt.Sprintf(&quot;gists/%v/%v&quot;, id, sha)
</a><a href="#h11-0-164" id="h11-0-164" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h11-0-165" id="h11-0-165" class="i">+	if err != nil {
</a><a href="#h11-0-166" id="h11-0-166" class="i">+		return nil, nil, err
</a><a href="#h11-0-167" id="h11-0-167" class="i">+	}
</a><a href="#h11-0-168" id="h11-0-168" class="i">+	gist := new(Gist)
</a><a href="#h11-0-169" id="h11-0-169" class="i">+	resp, err := s.client.Do(req, gist)
</a><a href="#h11-0-170" id="h11-0-170" class="i">+	if err != nil {
</a><a href="#h11-0-171" id="h11-0-171" class="i">+		return nil, resp, err
</a><a href="#h11-0-172" id="h11-0-172" class="i">+	}
</a><a href="#h11-0-173" id="h11-0-173" class="i">+
</a><a href="#h11-0-174" id="h11-0-174" class="i">+	return gist, resp, err
</a><a href="#h11-0-175" id="h11-0-175" class="i">+}
</a><a href="#h11-0-176" id="h11-0-176" class="i">+
</a><a href="#h11-0-177" id="h11-0-177" class="i">+// Create a gist for authenticated user.
</a><a href="#h11-0-178" id="h11-0-178" class="i">+//
</a><a href="#h11-0-179" id="h11-0-179" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#create-a-gist
</a><a href="#h11-0-180" id="h11-0-180" class="i">+func (s *GistsService) Create(gist *Gist) (*Gist, *Response, error) {
</a><a href="#h11-0-181" id="h11-0-181" class="i">+	u := &quot;gists&quot;
</a><a href="#h11-0-182" id="h11-0-182" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, gist)
</a><a href="#h11-0-183" id="h11-0-183" class="i">+	if err != nil {
</a><a href="#h11-0-184" id="h11-0-184" class="i">+		return nil, nil, err
</a><a href="#h11-0-185" id="h11-0-185" class="i">+	}
</a><a href="#h11-0-186" id="h11-0-186" class="i">+	g := new(Gist)
</a><a href="#h11-0-187" id="h11-0-187" class="i">+	resp, err := s.client.Do(req, g)
</a><a href="#h11-0-188" id="h11-0-188" class="i">+	if err != nil {
</a><a href="#h11-0-189" id="h11-0-189" class="i">+		return nil, resp, err
</a><a href="#h11-0-190" id="h11-0-190" class="i">+	}
</a><a href="#h11-0-191" id="h11-0-191" class="i">+
</a><a href="#h11-0-192" id="h11-0-192" class="i">+	return g, resp, err
</a><a href="#h11-0-193" id="h11-0-193" class="i">+}
</a><a href="#h11-0-194" id="h11-0-194" class="i">+
</a><a href="#h11-0-195" id="h11-0-195" class="i">+// Edit a gist.
</a><a href="#h11-0-196" id="h11-0-196" class="i">+//
</a><a href="#h11-0-197" id="h11-0-197" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#edit-a-gist
</a><a href="#h11-0-198" id="h11-0-198" class="i">+func (s *GistsService) Edit(id string, gist *Gist) (*Gist, *Response, error) {
</a><a href="#h11-0-199" id="h11-0-199" class="i">+	u := fmt.Sprintf(&quot;gists/%v&quot;, id)
</a><a href="#h11-0-200" id="h11-0-200" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, gist)
</a><a href="#h11-0-201" id="h11-0-201" class="i">+	if err != nil {
</a><a href="#h11-0-202" id="h11-0-202" class="i">+		return nil, nil, err
</a><a href="#h11-0-203" id="h11-0-203" class="i">+	}
</a><a href="#h11-0-204" id="h11-0-204" class="i">+	g := new(Gist)
</a><a href="#h11-0-205" id="h11-0-205" class="i">+	resp, err := s.client.Do(req, g)
</a><a href="#h11-0-206" id="h11-0-206" class="i">+	if err != nil {
</a><a href="#h11-0-207" id="h11-0-207" class="i">+		return nil, resp, err
</a><a href="#h11-0-208" id="h11-0-208" class="i">+	}
</a><a href="#h11-0-209" id="h11-0-209" class="i">+
</a><a href="#h11-0-210" id="h11-0-210" class="i">+	return g, resp, err
</a><a href="#h11-0-211" id="h11-0-211" class="i">+}
</a><a href="#h11-0-212" id="h11-0-212" class="i">+
</a><a href="#h11-0-213" id="h11-0-213" class="i">+// Delete a gist.
</a><a href="#h11-0-214" id="h11-0-214" class="i">+//
</a><a href="#h11-0-215" id="h11-0-215" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#delete-a-gist
</a><a href="#h11-0-216" id="h11-0-216" class="i">+func (s *GistsService) Delete(id string) (*Response, error) {
</a><a href="#h11-0-217" id="h11-0-217" class="i">+	u := fmt.Sprintf(&quot;gists/%v&quot;, id)
</a><a href="#h11-0-218" id="h11-0-218" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h11-0-219" id="h11-0-219" class="i">+	if err != nil {
</a><a href="#h11-0-220" id="h11-0-220" class="i">+		return nil, err
</a><a href="#h11-0-221" id="h11-0-221" class="i">+	}
</a><a href="#h11-0-222" id="h11-0-222" class="i">+	return s.client.Do(req, nil)
</a><a href="#h11-0-223" id="h11-0-223" class="i">+}
</a><a href="#h11-0-224" id="h11-0-224" class="i">+
</a><a href="#h11-0-225" id="h11-0-225" class="i">+// Star a gist on behalf of authenticated user.
</a><a href="#h11-0-226" id="h11-0-226" class="i">+//
</a><a href="#h11-0-227" id="h11-0-227" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#star-a-gist
</a><a href="#h11-0-228" id="h11-0-228" class="i">+func (s *GistsService) Star(id string) (*Response, error) {
</a><a href="#h11-0-229" id="h11-0-229" class="i">+	u := fmt.Sprintf(&quot;gists/%v/star&quot;, id)
</a><a href="#h11-0-230" id="h11-0-230" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h11-0-231" id="h11-0-231" class="i">+	if err != nil {
</a><a href="#h11-0-232" id="h11-0-232" class="i">+		return nil, err
</a><a href="#h11-0-233" id="h11-0-233" class="i">+	}
</a><a href="#h11-0-234" id="h11-0-234" class="i">+	return s.client.Do(req, nil)
</a><a href="#h11-0-235" id="h11-0-235" class="i">+}
</a><a href="#h11-0-236" id="h11-0-236" class="i">+
</a><a href="#h11-0-237" id="h11-0-237" class="i">+// Unstar a gist on a behalf of authenticated user.
</a><a href="#h11-0-238" id="h11-0-238" class="i">+//
</a><a href="#h11-0-239" id="h11-0-239" class="i">+// Github API docs: http://developer.github.com/v3/gists/#unstar-a-gist
</a><a href="#h11-0-240" id="h11-0-240" class="i">+func (s *GistsService) Unstar(id string) (*Response, error) {
</a><a href="#h11-0-241" id="h11-0-241" class="i">+	u := fmt.Sprintf(&quot;gists/%v/star&quot;, id)
</a><a href="#h11-0-242" id="h11-0-242" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h11-0-243" id="h11-0-243" class="i">+	if err != nil {
</a><a href="#h11-0-244" id="h11-0-244" class="i">+		return nil, err
</a><a href="#h11-0-245" id="h11-0-245" class="i">+	}
</a><a href="#h11-0-246" id="h11-0-246" class="i">+	return s.client.Do(req, nil)
</a><a href="#h11-0-247" id="h11-0-247" class="i">+}
</a><a href="#h11-0-248" id="h11-0-248" class="i">+
</a><a href="#h11-0-249" id="h11-0-249" class="i">+// IsStarred checks if a gist is starred by authenticated user.
</a><a href="#h11-0-250" id="h11-0-250" class="i">+//
</a><a href="#h11-0-251" id="h11-0-251" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#check-if-a-gist-is-starred
</a><a href="#h11-0-252" id="h11-0-252" class="i">+func (s *GistsService) IsStarred(id string) (bool, *Response, error) {
</a><a href="#h11-0-253" id="h11-0-253" class="i">+	u := fmt.Sprintf(&quot;gists/%v/star&quot;, id)
</a><a href="#h11-0-254" id="h11-0-254" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h11-0-255" id="h11-0-255" class="i">+	if err != nil {
</a><a href="#h11-0-256" id="h11-0-256" class="i">+		return false, nil, err
</a><a href="#h11-0-257" id="h11-0-257" class="i">+	}
</a><a href="#h11-0-258" id="h11-0-258" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h11-0-259" id="h11-0-259" class="i">+	starred, err := parseBoolResponse(err)
</a><a href="#h11-0-260" id="h11-0-260" class="i">+	return starred, resp, err
</a><a href="#h11-0-261" id="h11-0-261" class="i">+}
</a><a href="#h11-0-262" id="h11-0-262" class="i">+
</a><a href="#h11-0-263" id="h11-0-263" class="i">+// Fork a gist.
</a><a href="#h11-0-264" id="h11-0-264" class="i">+//
</a><a href="#h11-0-265" id="h11-0-265" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/#fork-a-gist
</a><a href="#h11-0-266" id="h11-0-266" class="i">+func (s *GistsService) Fork(id string) (*Gist, *Response, error) {
</a><a href="#h11-0-267" id="h11-0-267" class="i">+	u := fmt.Sprintf(&quot;gists/%v/forks&quot;, id)
</a><a href="#h11-0-268" id="h11-0-268" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, nil)
</a><a href="#h11-0-269" id="h11-0-269" class="i">+	if err != nil {
</a><a href="#h11-0-270" id="h11-0-270" class="i">+		return nil, nil, err
</a><a href="#h11-0-271" id="h11-0-271" class="i">+	}
</a><a href="#h11-0-272" id="h11-0-272" class="i">+
</a><a href="#h11-0-273" id="h11-0-273" class="i">+	g := new(Gist)
</a><a href="#h11-0-274" id="h11-0-274" class="i">+	resp, err := s.client.Do(req, g)
</a><a href="#h11-0-275" id="h11-0-275" class="i">+	if err != nil {
</a><a href="#h11-0-276" id="h11-0-276" class="i">+		return nil, resp, err
</a><a href="#h11-0-277" id="h11-0-277" class="i">+	}
</a><a href="#h11-0-278" id="h11-0-278" class="i">+
</a><a href="#h11-0-279" id="h11-0-279" class="i">+	return g, resp, err
</a><a href="#h11-0-280" id="h11-0-280" class="i">+}
</a><b>diff --git a/<a id="h12" href="../file/vendor/github.com/google/go-github/github/gists_comments.go">vendor/github.com/google/go-github/github/gists_comments.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/gists_comments.go">vendor/github.com/google/go-github/github/gists_comments.go</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -0,0 +1,118 @@
</a><a href="#h12-0-0" id="h12-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h12-0-1" id="h12-0-1" class="i">+//
</a><a href="#h12-0-2" id="h12-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h12-0-3" id="h12-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h12-0-4" id="h12-0-4" class="i">+
</a><a href="#h12-0-5" id="h12-0-5" class="i">+package github
</a><a href="#h12-0-6" id="h12-0-6" class="i">+
</a><a href="#h12-0-7" id="h12-0-7" class="i">+import (
</a><a href="#h12-0-8" id="h12-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h12-0-9" id="h12-0-9" class="i">+	&quot;time&quot;
</a><a href="#h12-0-10" id="h12-0-10" class="i">+)
</a><a href="#h12-0-11" id="h12-0-11" class="i">+
</a><a href="#h12-0-12" id="h12-0-12" class="i">+// GistComment represents a Gist comment.
</a><a href="#h12-0-13" id="h12-0-13" class="i">+type GistComment struct {
</a><a href="#h12-0-14" id="h12-0-14" class="i">+	ID        *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h12-0-15" id="h12-0-15" class="i">+	URL       *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h12-0-16" id="h12-0-16" class="i">+	Body      *string    `json:&quot;body,omitempty&quot;`
</a><a href="#h12-0-17" id="h12-0-17" class="i">+	User      *User      `json:&quot;user,omitempty&quot;`
</a><a href="#h12-0-18" id="h12-0-18" class="i">+	CreatedAt *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h12-0-19" id="h12-0-19" class="i">+}
</a><a href="#h12-0-20" id="h12-0-20" class="i">+
</a><a href="#h12-0-21" id="h12-0-21" class="i">+func (g GistComment) String() string {
</a><a href="#h12-0-22" id="h12-0-22" class="i">+	return Stringify(g)
</a><a href="#h12-0-23" id="h12-0-23" class="i">+}
</a><a href="#h12-0-24" id="h12-0-24" class="i">+
</a><a href="#h12-0-25" id="h12-0-25" class="i">+// ListComments lists all comments for a gist.
</a><a href="#h12-0-26" id="h12-0-26" class="i">+//
</a><a href="#h12-0-27" id="h12-0-27" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/comments/#list-comments-on-a-gist
</a><a href="#h12-0-28" id="h12-0-28" class="i">+func (s *GistsService) ListComments(gistID string, opt *ListOptions) ([]GistComment, *Response, error) {
</a><a href="#h12-0-29" id="h12-0-29" class="i">+	u := fmt.Sprintf(&quot;gists/%v/comments&quot;, gistID)
</a><a href="#h12-0-30" id="h12-0-30" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h12-0-31" id="h12-0-31" class="i">+	if err != nil {
</a><a href="#h12-0-32" id="h12-0-32" class="i">+		return nil, nil, err
</a><a href="#h12-0-33" id="h12-0-33" class="i">+	}
</a><a href="#h12-0-34" id="h12-0-34" class="i">+
</a><a href="#h12-0-35" id="h12-0-35" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h12-0-36" id="h12-0-36" class="i">+	if err != nil {
</a><a href="#h12-0-37" id="h12-0-37" class="i">+		return nil, nil, err
</a><a href="#h12-0-38" id="h12-0-38" class="i">+	}
</a><a href="#h12-0-39" id="h12-0-39" class="i">+
</a><a href="#h12-0-40" id="h12-0-40" class="i">+	comments := new([]GistComment)
</a><a href="#h12-0-41" id="h12-0-41" class="i">+	resp, err := s.client.Do(req, comments)
</a><a href="#h12-0-42" id="h12-0-42" class="i">+	if err != nil {
</a><a href="#h12-0-43" id="h12-0-43" class="i">+		return nil, resp, err
</a><a href="#h12-0-44" id="h12-0-44" class="i">+	}
</a><a href="#h12-0-45" id="h12-0-45" class="i">+
</a><a href="#h12-0-46" id="h12-0-46" class="i">+	return *comments, resp, err
</a><a href="#h12-0-47" id="h12-0-47" class="i">+}
</a><a href="#h12-0-48" id="h12-0-48" class="i">+
</a><a href="#h12-0-49" id="h12-0-49" class="i">+// GetComment retrieves a single comment from a gist.
</a><a href="#h12-0-50" id="h12-0-50" class="i">+//
</a><a href="#h12-0-51" id="h12-0-51" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/comments/#get-a-single-comment
</a><a href="#h12-0-52" id="h12-0-52" class="i">+func (s *GistsService) GetComment(gistID string, commentID int) (*GistComment, *Response, error) {
</a><a href="#h12-0-53" id="h12-0-53" class="i">+	u := fmt.Sprintf(&quot;gists/%v/comments/%v&quot;, gistID, commentID)
</a><a href="#h12-0-54" id="h12-0-54" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h12-0-55" id="h12-0-55" class="i">+	if err != nil {
</a><a href="#h12-0-56" id="h12-0-56" class="i">+		return nil, nil, err
</a><a href="#h12-0-57" id="h12-0-57" class="i">+	}
</a><a href="#h12-0-58" id="h12-0-58" class="i">+
</a><a href="#h12-0-59" id="h12-0-59" class="i">+	c := new(GistComment)
</a><a href="#h12-0-60" id="h12-0-60" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h12-0-61" id="h12-0-61" class="i">+	if err != nil {
</a><a href="#h12-0-62" id="h12-0-62" class="i">+		return nil, resp, err
</a><a href="#h12-0-63" id="h12-0-63" class="i">+	}
</a><a href="#h12-0-64" id="h12-0-64" class="i">+
</a><a href="#h12-0-65" id="h12-0-65" class="i">+	return c, resp, err
</a><a href="#h12-0-66" id="h12-0-66" class="i">+}
</a><a href="#h12-0-67" id="h12-0-67" class="i">+
</a><a href="#h12-0-68" id="h12-0-68" class="i">+// CreateComment creates a comment for a gist.
</a><a href="#h12-0-69" id="h12-0-69" class="i">+//
</a><a href="#h12-0-70" id="h12-0-70" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/comments/#create-a-comment
</a><a href="#h12-0-71" id="h12-0-71" class="i">+func (s *GistsService) CreateComment(gistID string, comment *GistComment) (*GistComment, *Response, error) {
</a><a href="#h12-0-72" id="h12-0-72" class="i">+	u := fmt.Sprintf(&quot;gists/%v/comments&quot;, gistID)
</a><a href="#h12-0-73" id="h12-0-73" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, comment)
</a><a href="#h12-0-74" id="h12-0-74" class="i">+	if err != nil {
</a><a href="#h12-0-75" id="h12-0-75" class="i">+		return nil, nil, err
</a><a href="#h12-0-76" id="h12-0-76" class="i">+	}
</a><a href="#h12-0-77" id="h12-0-77" class="i">+
</a><a href="#h12-0-78" id="h12-0-78" class="i">+	c := new(GistComment)
</a><a href="#h12-0-79" id="h12-0-79" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h12-0-80" id="h12-0-80" class="i">+	if err != nil {
</a><a href="#h12-0-81" id="h12-0-81" class="i">+		return nil, resp, err
</a><a href="#h12-0-82" id="h12-0-82" class="i">+	}
</a><a href="#h12-0-83" id="h12-0-83" class="i">+
</a><a href="#h12-0-84" id="h12-0-84" class="i">+	return c, resp, err
</a><a href="#h12-0-85" id="h12-0-85" class="i">+}
</a><a href="#h12-0-86" id="h12-0-86" class="i">+
</a><a href="#h12-0-87" id="h12-0-87" class="i">+// EditComment edits an existing gist comment.
</a><a href="#h12-0-88" id="h12-0-88" class="i">+//
</a><a href="#h12-0-89" id="h12-0-89" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/comments/#edit-a-comment
</a><a href="#h12-0-90" id="h12-0-90" class="i">+func (s *GistsService) EditComment(gistID string, commentID int, comment *GistComment) (*GistComment, *Response, error) {
</a><a href="#h12-0-91" id="h12-0-91" class="i">+	u := fmt.Sprintf(&quot;gists/%v/comments/%v&quot;, gistID, commentID)
</a><a href="#h12-0-92" id="h12-0-92" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, comment)
</a><a href="#h12-0-93" id="h12-0-93" class="i">+	if err != nil {
</a><a href="#h12-0-94" id="h12-0-94" class="i">+		return nil, nil, err
</a><a href="#h12-0-95" id="h12-0-95" class="i">+	}
</a><a href="#h12-0-96" id="h12-0-96" class="i">+
</a><a href="#h12-0-97" id="h12-0-97" class="i">+	c := new(GistComment)
</a><a href="#h12-0-98" id="h12-0-98" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h12-0-99" id="h12-0-99" class="i">+	if err != nil {
</a><a href="#h12-0-100" id="h12-0-100" class="i">+		return nil, resp, err
</a><a href="#h12-0-101" id="h12-0-101" class="i">+	}
</a><a href="#h12-0-102" id="h12-0-102" class="i">+
</a><a href="#h12-0-103" id="h12-0-103" class="i">+	return c, resp, err
</a><a href="#h12-0-104" id="h12-0-104" class="i">+}
</a><a href="#h12-0-105" id="h12-0-105" class="i">+
</a><a href="#h12-0-106" id="h12-0-106" class="i">+// DeleteComment deletes a gist comment.
</a><a href="#h12-0-107" id="h12-0-107" class="i">+//
</a><a href="#h12-0-108" id="h12-0-108" class="i">+// GitHub API docs: http://developer.github.com/v3/gists/comments/#delete-a-comment
</a><a href="#h12-0-109" id="h12-0-109" class="i">+func (s *GistsService) DeleteComment(gistID string, commentID int) (*Response, error) {
</a><a href="#h12-0-110" id="h12-0-110" class="i">+	u := fmt.Sprintf(&quot;gists/%v/comments/%v&quot;, gistID, commentID)
</a><a href="#h12-0-111" id="h12-0-111" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h12-0-112" id="h12-0-112" class="i">+	if err != nil {
</a><a href="#h12-0-113" id="h12-0-113" class="i">+		return nil, err
</a><a href="#h12-0-114" id="h12-0-114" class="i">+	}
</a><a href="#h12-0-115" id="h12-0-115" class="i">+
</a><a href="#h12-0-116" id="h12-0-116" class="i">+	return s.client.Do(req, nil)
</a><a href="#h12-0-117" id="h12-0-117" class="i">+}
</a><b>diff --git a/<a id="h13" href="../file/vendor/github.com/google/go-github/github/git.go">vendor/github.com/google/go-github/github/git.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/git.go">vendor/github.com/google/go-github/github/git.go</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -0,0 +1,14 @@
</a><a href="#h13-0-0" id="h13-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h13-0-1" id="h13-0-1" class="i">+//
</a><a href="#h13-0-2" id="h13-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h13-0-3" id="h13-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h13-0-4" id="h13-0-4" class="i">+
</a><a href="#h13-0-5" id="h13-0-5" class="i">+package github
</a><a href="#h13-0-6" id="h13-0-6" class="i">+
</a><a href="#h13-0-7" id="h13-0-7" class="i">+// GitService handles communication with the git data related
</a><a href="#h13-0-8" id="h13-0-8" class="i">+// methods of the GitHub API.
</a><a href="#h13-0-9" id="h13-0-9" class="i">+//
</a><a href="#h13-0-10" id="h13-0-10" class="i">+// GitHub API docs: http://developer.github.com/v3/git/
</a><a href="#h13-0-11" id="h13-0-11" class="i">+type GitService struct {
</a><a href="#h13-0-12" id="h13-0-12" class="i">+	client *Client
</a><a href="#h13-0-13" id="h13-0-13" class="i">+}
</a><b>diff --git a/<a id="h14" href="../file/vendor/github.com/google/go-github/github/git_blobs.go">vendor/github.com/google/go-github/github/git_blobs.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/git_blobs.go">vendor/github.com/google/go-github/github/git_blobs.go</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -0,0 +1,47 @@
</a><a href="#h14-0-0" id="h14-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h14-0-1" id="h14-0-1" class="i">+//
</a><a href="#h14-0-2" id="h14-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h14-0-3" id="h14-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h14-0-4" id="h14-0-4" class="i">+
</a><a href="#h14-0-5" id="h14-0-5" class="i">+package github
</a><a href="#h14-0-6" id="h14-0-6" class="i">+
</a><a href="#h14-0-7" id="h14-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h14-0-8" id="h14-0-8" class="i">+
</a><a href="#h14-0-9" id="h14-0-9" class="i">+// Blob represents a blob object.
</a><a href="#h14-0-10" id="h14-0-10" class="i">+type Blob struct {
</a><a href="#h14-0-11" id="h14-0-11" class="i">+	Content  *string `json:&quot;content,omitempty&quot;`
</a><a href="#h14-0-12" id="h14-0-12" class="i">+	Encoding *string `json:&quot;encoding,omitempty&quot;`
</a><a href="#h14-0-13" id="h14-0-13" class="i">+	SHA      *string `json:&quot;sha,omitempty&quot;`
</a><a href="#h14-0-14" id="h14-0-14" class="i">+	Size     *int    `json:&quot;size,omitempty&quot;`
</a><a href="#h14-0-15" id="h14-0-15" class="i">+	URL      *string `json:&quot;url,omitempty&quot;`
</a><a href="#h14-0-16" id="h14-0-16" class="i">+}
</a><a href="#h14-0-17" id="h14-0-17" class="i">+
</a><a href="#h14-0-18" id="h14-0-18" class="i">+// GetBlob fetchs a blob from a repo given a SHA.
</a><a href="#h14-0-19" id="h14-0-19" class="i">+//
</a><a href="#h14-0-20" id="h14-0-20" class="i">+// GitHub API docs: http://developer.github.com/v3/git/blobs/#get-a-blob
</a><a href="#h14-0-21" id="h14-0-21" class="i">+func (s *GitService) GetBlob(owner string, repo string, sha string) (*Blob, *Response, error) {
</a><a href="#h14-0-22" id="h14-0-22" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/blobs/%v&quot;, owner, repo, sha)
</a><a href="#h14-0-23" id="h14-0-23" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h14-0-24" id="h14-0-24" class="i">+	if err != nil {
</a><a href="#h14-0-25" id="h14-0-25" class="i">+		return nil, nil, err
</a><a href="#h14-0-26" id="h14-0-26" class="i">+	}
</a><a href="#h14-0-27" id="h14-0-27" class="i">+
</a><a href="#h14-0-28" id="h14-0-28" class="i">+	blob := new(Blob)
</a><a href="#h14-0-29" id="h14-0-29" class="i">+	resp, err := s.client.Do(req, blob)
</a><a href="#h14-0-30" id="h14-0-30" class="i">+	return blob, resp, err
</a><a href="#h14-0-31" id="h14-0-31" class="i">+}
</a><a href="#h14-0-32" id="h14-0-32" class="i">+
</a><a href="#h14-0-33" id="h14-0-33" class="i">+// CreateBlob creates a blob object.
</a><a href="#h14-0-34" id="h14-0-34" class="i">+//
</a><a href="#h14-0-35" id="h14-0-35" class="i">+// GitHub API docs: https://developer.github.com/v3/git/blobs/#create-a-blob
</a><a href="#h14-0-36" id="h14-0-36" class="i">+func (s *GitService) CreateBlob(owner string, repo string, blob *Blob) (*Blob, *Response, error) {
</a><a href="#h14-0-37" id="h14-0-37" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/blobs&quot;, owner, repo)
</a><a href="#h14-0-38" id="h14-0-38" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, blob)
</a><a href="#h14-0-39" id="h14-0-39" class="i">+	if err != nil {
</a><a href="#h14-0-40" id="h14-0-40" class="i">+		return nil, nil, err
</a><a href="#h14-0-41" id="h14-0-41" class="i">+	}
</a><a href="#h14-0-42" id="h14-0-42" class="i">+
</a><a href="#h14-0-43" id="h14-0-43" class="i">+	t := new(Blob)
</a><a href="#h14-0-44" id="h14-0-44" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h14-0-45" id="h14-0-45" class="i">+	return t, resp, err
</a><a href="#h14-0-46" id="h14-0-46" class="i">+}
</a><b>diff --git a/<a id="h15" href="../file/vendor/github.com/google/go-github/github/git_commits.go">vendor/github.com/google/go-github/github/git_commits.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/git_commits.go">vendor/github.com/google/go-github/github/git_commits.go</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -0,0 +1,115 @@
</a><a href="#h15-0-0" id="h15-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h15-0-1" id="h15-0-1" class="i">+//
</a><a href="#h15-0-2" id="h15-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h15-0-3" id="h15-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h15-0-4" id="h15-0-4" class="i">+
</a><a href="#h15-0-5" id="h15-0-5" class="i">+package github
</a><a href="#h15-0-6" id="h15-0-6" class="i">+
</a><a href="#h15-0-7" id="h15-0-7" class="i">+import (
</a><a href="#h15-0-8" id="h15-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h15-0-9" id="h15-0-9" class="i">+	&quot;time&quot;
</a><a href="#h15-0-10" id="h15-0-10" class="i">+)
</a><a href="#h15-0-11" id="h15-0-11" class="i">+
</a><a href="#h15-0-12" id="h15-0-12" class="i">+// Commit represents a GitHub commit.
</a><a href="#h15-0-13" id="h15-0-13" class="i">+type Commit struct {
</a><a href="#h15-0-14" id="h15-0-14" class="i">+	SHA       *string       `json:&quot;sha,omitempty&quot;`
</a><a href="#h15-0-15" id="h15-0-15" class="i">+	Author    *CommitAuthor `json:&quot;author,omitempty&quot;`
</a><a href="#h15-0-16" id="h15-0-16" class="i">+	Committer *CommitAuthor `json:&quot;committer,omitempty&quot;`
</a><a href="#h15-0-17" id="h15-0-17" class="i">+	Message   *string       `json:&quot;message,omitempty&quot;`
</a><a href="#h15-0-18" id="h15-0-18" class="i">+	Tree      *Tree         `json:&quot;tree,omitempty&quot;`
</a><a href="#h15-0-19" id="h15-0-19" class="i">+	Parents   []Commit      `json:&quot;parents,omitempty&quot;`
</a><a href="#h15-0-20" id="h15-0-20" class="i">+	Stats     *CommitStats  `json:&quot;stats,omitempty&quot;`
</a><a href="#h15-0-21" id="h15-0-21" class="i">+	URL       *string       `json:&quot;url,omitempty&quot;`
</a><a href="#h15-0-22" id="h15-0-22" class="i">+
</a><a href="#h15-0-23" id="h15-0-23" class="i">+	// CommentCount is the number of GitHub comments on the commit.  This
</a><a href="#h15-0-24" id="h15-0-24" class="i">+	// is only populated for requests that fetch GitHub data like
</a><a href="#h15-0-25" id="h15-0-25" class="i">+	// Pulls.ListCommits, Repositories.ListCommits, etc.
</a><a href="#h15-0-26" id="h15-0-26" class="i">+	CommentCount *int `json:&quot;comment_count,omitempty&quot;`
</a><a href="#h15-0-27" id="h15-0-27" class="i">+}
</a><a href="#h15-0-28" id="h15-0-28" class="i">+
</a><a href="#h15-0-29" id="h15-0-29" class="i">+func (c Commit) String() string {
</a><a href="#h15-0-30" id="h15-0-30" class="i">+	return Stringify(c)
</a><a href="#h15-0-31" id="h15-0-31" class="i">+}
</a><a href="#h15-0-32" id="h15-0-32" class="i">+
</a><a href="#h15-0-33" id="h15-0-33" class="i">+// CommitAuthor represents the author or committer of a commit.  The commit
</a><a href="#h15-0-34" id="h15-0-34" class="i">+// author may not correspond to a GitHub User.
</a><a href="#h15-0-35" id="h15-0-35" class="i">+type CommitAuthor struct {
</a><a href="#h15-0-36" id="h15-0-36" class="i">+	Date  *time.Time `json:&quot;date,omitempty&quot;`
</a><a href="#h15-0-37" id="h15-0-37" class="i">+	Name  *string    `json:&quot;name,omitempty&quot;`
</a><a href="#h15-0-38" id="h15-0-38" class="i">+	Email *string    `json:&quot;email,omitempty&quot;`
</a><a href="#h15-0-39" id="h15-0-39" class="i">+
</a><a href="#h15-0-40" id="h15-0-40" class="i">+	// The following fields are only populated by Webhook events.
</a><a href="#h15-0-41" id="h15-0-41" class="i">+	Login *string `json:&quot;username,omitempty&quot;` // Renamed for go-github consistency.
</a><a href="#h15-0-42" id="h15-0-42" class="i">+}
</a><a href="#h15-0-43" id="h15-0-43" class="i">+
</a><a href="#h15-0-44" id="h15-0-44" class="i">+func (c CommitAuthor) String() string {
</a><a href="#h15-0-45" id="h15-0-45" class="i">+	return Stringify(c)
</a><a href="#h15-0-46" id="h15-0-46" class="i">+}
</a><a href="#h15-0-47" id="h15-0-47" class="i">+
</a><a href="#h15-0-48" id="h15-0-48" class="i">+// GetCommit fetchs the Commit object for a given SHA.
</a><a href="#h15-0-49" id="h15-0-49" class="i">+//
</a><a href="#h15-0-50" id="h15-0-50" class="i">+// GitHub API docs: http://developer.github.com/v3/git/commits/#get-a-commit
</a><a href="#h15-0-51" id="h15-0-51" class="i">+func (s *GitService) GetCommit(owner string, repo string, sha string) (*Commit, *Response, error) {
</a><a href="#h15-0-52" id="h15-0-52" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/commits/%v&quot;, owner, repo, sha)
</a><a href="#h15-0-53" id="h15-0-53" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h15-0-54" id="h15-0-54" class="i">+	if err != nil {
</a><a href="#h15-0-55" id="h15-0-55" class="i">+		return nil, nil, err
</a><a href="#h15-0-56" id="h15-0-56" class="i">+	}
</a><a href="#h15-0-57" id="h15-0-57" class="i">+
</a><a href="#h15-0-58" id="h15-0-58" class="i">+	c := new(Commit)
</a><a href="#h15-0-59" id="h15-0-59" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h15-0-60" id="h15-0-60" class="i">+	if err != nil {
</a><a href="#h15-0-61" id="h15-0-61" class="i">+		return nil, resp, err
</a><a href="#h15-0-62" id="h15-0-62" class="i">+	}
</a><a href="#h15-0-63" id="h15-0-63" class="i">+
</a><a href="#h15-0-64" id="h15-0-64" class="i">+	return c, resp, err
</a><a href="#h15-0-65" id="h15-0-65" class="i">+}
</a><a href="#h15-0-66" id="h15-0-66" class="i">+
</a><a href="#h15-0-67" id="h15-0-67" class="i">+// createCommit represents the body of a CreateCommit request.
</a><a href="#h15-0-68" id="h15-0-68" class="i">+type createCommit struct {
</a><a href="#h15-0-69" id="h15-0-69" class="i">+	Author    *CommitAuthor `json:&quot;author,omitempty&quot;`
</a><a href="#h15-0-70" id="h15-0-70" class="i">+	Committer *CommitAuthor `json:&quot;committer,omitempty&quot;`
</a><a href="#h15-0-71" id="h15-0-71" class="i">+	Message   *string       `json:&quot;message,omitempty&quot;`
</a><a href="#h15-0-72" id="h15-0-72" class="i">+	Tree      *string       `json:&quot;tree,omitempty&quot;`
</a><a href="#h15-0-73" id="h15-0-73" class="i">+	Parents   []string      `json:&quot;parents,omitempty&quot;`
</a><a href="#h15-0-74" id="h15-0-74" class="i">+}
</a><a href="#h15-0-75" id="h15-0-75" class="i">+
</a><a href="#h15-0-76" id="h15-0-76" class="i">+// CreateCommit creates a new commit in a repository.
</a><a href="#h15-0-77" id="h15-0-77" class="i">+//
</a><a href="#h15-0-78" id="h15-0-78" class="i">+// The commit.Committer is optional and will be filled with the commit.Author
</a><a href="#h15-0-79" id="h15-0-79" class="i">+// data if omitted. If the commit.Author is omitted, it will be filled in with
</a><a href="#h15-0-80" id="h15-0-80" class="i">+// the authenticated users information and the current date.
</a><a href="#h15-0-81" id="h15-0-81" class="i">+//
</a><a href="#h15-0-82" id="h15-0-82" class="i">+// GitHub API docs: http://developer.github.com/v3/git/commits/#create-a-commit
</a><a href="#h15-0-83" id="h15-0-83" class="i">+func (s *GitService) CreateCommit(owner string, repo string, commit *Commit) (*Commit, *Response, error) {
</a><a href="#h15-0-84" id="h15-0-84" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/commits&quot;, owner, repo)
</a><a href="#h15-0-85" id="h15-0-85" class="i">+
</a><a href="#h15-0-86" id="h15-0-86" class="i">+	body := &amp;createCommit{}
</a><a href="#h15-0-87" id="h15-0-87" class="i">+	if commit != nil {
</a><a href="#h15-0-88" id="h15-0-88" class="i">+		parents := make([]string, len(commit.Parents))
</a><a href="#h15-0-89" id="h15-0-89" class="i">+		for i, parent := range commit.Parents {
</a><a href="#h15-0-90" id="h15-0-90" class="i">+			parents[i] = *parent.SHA
</a><a href="#h15-0-91" id="h15-0-91" class="i">+		}
</a><a href="#h15-0-92" id="h15-0-92" class="i">+
</a><a href="#h15-0-93" id="h15-0-93" class="i">+		body = &amp;createCommit{
</a><a href="#h15-0-94" id="h15-0-94" class="i">+			Author:    commit.Author,
</a><a href="#h15-0-95" id="h15-0-95" class="i">+			Committer: commit.Committer,
</a><a href="#h15-0-96" id="h15-0-96" class="i">+			Message:   commit.Message,
</a><a href="#h15-0-97" id="h15-0-97" class="i">+			Tree:      commit.Tree.SHA,
</a><a href="#h15-0-98" id="h15-0-98" class="i">+			Parents:   parents,
</a><a href="#h15-0-99" id="h15-0-99" class="i">+		}
</a><a href="#h15-0-100" id="h15-0-100" class="i">+	}
</a><a href="#h15-0-101" id="h15-0-101" class="i">+
</a><a href="#h15-0-102" id="h15-0-102" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, body)
</a><a href="#h15-0-103" id="h15-0-103" class="i">+	if err != nil {
</a><a href="#h15-0-104" id="h15-0-104" class="i">+		return nil, nil, err
</a><a href="#h15-0-105" id="h15-0-105" class="i">+	}
</a><a href="#h15-0-106" id="h15-0-106" class="i">+
</a><a href="#h15-0-107" id="h15-0-107" class="i">+	c := new(Commit)
</a><a href="#h15-0-108" id="h15-0-108" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h15-0-109" id="h15-0-109" class="i">+	if err != nil {
</a><a href="#h15-0-110" id="h15-0-110" class="i">+		return nil, resp, err
</a><a href="#h15-0-111" id="h15-0-111" class="i">+	}
</a><a href="#h15-0-112" id="h15-0-112" class="i">+
</a><a href="#h15-0-113" id="h15-0-113" class="i">+	return c, resp, err
</a><a href="#h15-0-114" id="h15-0-114" class="i">+}
</a><b>diff --git a/<a id="h16" href="../file/vendor/github.com/google/go-github/github/git_refs.go">vendor/github.com/google/go-github/github/git_refs.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/git_refs.go">vendor/github.com/google/go-github/github/git_refs.go</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -0,0 +1,162 @@
</a><a href="#h16-0-0" id="h16-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h16-0-1" id="h16-0-1" class="i">+//
</a><a href="#h16-0-2" id="h16-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h16-0-3" id="h16-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h16-0-4" id="h16-0-4" class="i">+
</a><a href="#h16-0-5" id="h16-0-5" class="i">+package github
</a><a href="#h16-0-6" id="h16-0-6" class="i">+
</a><a href="#h16-0-7" id="h16-0-7" class="i">+import (
</a><a href="#h16-0-8" id="h16-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h16-0-9" id="h16-0-9" class="i">+	&quot;strings&quot;
</a><a href="#h16-0-10" id="h16-0-10" class="i">+)
</a><a href="#h16-0-11" id="h16-0-11" class="i">+
</a><a href="#h16-0-12" id="h16-0-12" class="i">+// Reference represents a GitHub reference.
</a><a href="#h16-0-13" id="h16-0-13" class="i">+type Reference struct {
</a><a href="#h16-0-14" id="h16-0-14" class="i">+	Ref    *string    `json:&quot;ref&quot;`
</a><a href="#h16-0-15" id="h16-0-15" class="i">+	URL    *string    `json:&quot;url&quot;`
</a><a href="#h16-0-16" id="h16-0-16" class="i">+	Object *GitObject `json:&quot;object&quot;`
</a><a href="#h16-0-17" id="h16-0-17" class="i">+}
</a><a href="#h16-0-18" id="h16-0-18" class="i">+
</a><a href="#h16-0-19" id="h16-0-19" class="i">+func (r Reference) String() string {
</a><a href="#h16-0-20" id="h16-0-20" class="i">+	return Stringify(r)
</a><a href="#h16-0-21" id="h16-0-21" class="i">+}
</a><a href="#h16-0-22" id="h16-0-22" class="i">+
</a><a href="#h16-0-23" id="h16-0-23" class="i">+// GitObject represents a Git object.
</a><a href="#h16-0-24" id="h16-0-24" class="i">+type GitObject struct {
</a><a href="#h16-0-25" id="h16-0-25" class="i">+	Type *string `json:&quot;type&quot;`
</a><a href="#h16-0-26" id="h16-0-26" class="i">+	SHA  *string `json:&quot;sha&quot;`
</a><a href="#h16-0-27" id="h16-0-27" class="i">+	URL  *string `json:&quot;url&quot;`
</a><a href="#h16-0-28" id="h16-0-28" class="i">+}
</a><a href="#h16-0-29" id="h16-0-29" class="i">+
</a><a href="#h16-0-30" id="h16-0-30" class="i">+func (o GitObject) String() string {
</a><a href="#h16-0-31" id="h16-0-31" class="i">+	return Stringify(o)
</a><a href="#h16-0-32" id="h16-0-32" class="i">+}
</a><a href="#h16-0-33" id="h16-0-33" class="i">+
</a><a href="#h16-0-34" id="h16-0-34" class="i">+// createRefRequest represents the payload for creating a reference.
</a><a href="#h16-0-35" id="h16-0-35" class="i">+type createRefRequest struct {
</a><a href="#h16-0-36" id="h16-0-36" class="i">+	Ref *string `json:&quot;ref&quot;`
</a><a href="#h16-0-37" id="h16-0-37" class="i">+	SHA *string `json:&quot;sha&quot;`
</a><a href="#h16-0-38" id="h16-0-38" class="i">+}
</a><a href="#h16-0-39" id="h16-0-39" class="i">+
</a><a href="#h16-0-40" id="h16-0-40" class="i">+// updateRefRequest represents the payload for updating a reference.
</a><a href="#h16-0-41" id="h16-0-41" class="i">+type updateRefRequest struct {
</a><a href="#h16-0-42" id="h16-0-42" class="i">+	SHA   *string `json:&quot;sha&quot;`
</a><a href="#h16-0-43" id="h16-0-43" class="i">+	Force *bool   `json:&quot;force&quot;`
</a><a href="#h16-0-44" id="h16-0-44" class="i">+}
</a><a href="#h16-0-45" id="h16-0-45" class="i">+
</a><a href="#h16-0-46" id="h16-0-46" class="i">+// GetRef fetches the Reference object for a given Git ref.
</a><a href="#h16-0-47" id="h16-0-47" class="i">+//
</a><a href="#h16-0-48" id="h16-0-48" class="i">+// GitHub API docs: http://developer.github.com/v3/git/refs/#get-a-reference
</a><a href="#h16-0-49" id="h16-0-49" class="i">+func (s *GitService) GetRef(owner string, repo string, ref string) (*Reference, *Response, error) {
</a><a href="#h16-0-50" id="h16-0-50" class="i">+	ref = strings.TrimPrefix(ref, &quot;refs/&quot;)
</a><a href="#h16-0-51" id="h16-0-51" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/refs/%v&quot;, owner, repo, ref)
</a><a href="#h16-0-52" id="h16-0-52" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h16-0-53" id="h16-0-53" class="i">+	if err != nil {
</a><a href="#h16-0-54" id="h16-0-54" class="i">+		return nil, nil, err
</a><a href="#h16-0-55" id="h16-0-55" class="i">+	}
</a><a href="#h16-0-56" id="h16-0-56" class="i">+
</a><a href="#h16-0-57" id="h16-0-57" class="i">+	r := new(Reference)
</a><a href="#h16-0-58" id="h16-0-58" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h16-0-59" id="h16-0-59" class="i">+	if err != nil {
</a><a href="#h16-0-60" id="h16-0-60" class="i">+		return nil, resp, err
</a><a href="#h16-0-61" id="h16-0-61" class="i">+	}
</a><a href="#h16-0-62" id="h16-0-62" class="i">+
</a><a href="#h16-0-63" id="h16-0-63" class="i">+	return r, resp, err
</a><a href="#h16-0-64" id="h16-0-64" class="i">+}
</a><a href="#h16-0-65" id="h16-0-65" class="i">+
</a><a href="#h16-0-66" id="h16-0-66" class="i">+// ReferenceListOptions specifies optional parameters to the
</a><a href="#h16-0-67" id="h16-0-67" class="i">+// GitService.ListRefs method.
</a><a href="#h16-0-68" id="h16-0-68" class="i">+type ReferenceListOptions struct {
</a><a href="#h16-0-69" id="h16-0-69" class="i">+	Type string `url:&quot;-&quot;`
</a><a href="#h16-0-70" id="h16-0-70" class="i">+
</a><a href="#h16-0-71" id="h16-0-71" class="i">+	ListOptions
</a><a href="#h16-0-72" id="h16-0-72" class="i">+}
</a><a href="#h16-0-73" id="h16-0-73" class="i">+
</a><a href="#h16-0-74" id="h16-0-74" class="i">+// ListRefs lists all refs in a repository.
</a><a href="#h16-0-75" id="h16-0-75" class="i">+//
</a><a href="#h16-0-76" id="h16-0-76" class="i">+// GitHub API docs: http://developer.github.com/v3/git/refs/#get-all-references
</a><a href="#h16-0-77" id="h16-0-77" class="i">+func (s *GitService) ListRefs(owner, repo string, opt *ReferenceListOptions) ([]Reference, *Response, error) {
</a><a href="#h16-0-78" id="h16-0-78" class="i">+	var u string
</a><a href="#h16-0-79" id="h16-0-79" class="i">+	if opt != nil &amp;&amp; opt.Type != &quot;&quot; {
</a><a href="#h16-0-80" id="h16-0-80" class="i">+		u = fmt.Sprintf(&quot;repos/%v/%v/git/refs/%v&quot;, owner, repo, opt.Type)
</a><a href="#h16-0-81" id="h16-0-81" class="i">+	} else {
</a><a href="#h16-0-82" id="h16-0-82" class="i">+		u = fmt.Sprintf(&quot;repos/%v/%v/git/refs&quot;, owner, repo)
</a><a href="#h16-0-83" id="h16-0-83" class="i">+	}
</a><a href="#h16-0-84" id="h16-0-84" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h16-0-85" id="h16-0-85" class="i">+	if err != nil {
</a><a href="#h16-0-86" id="h16-0-86" class="i">+		return nil, nil, err
</a><a href="#h16-0-87" id="h16-0-87" class="i">+	}
</a><a href="#h16-0-88" id="h16-0-88" class="i">+
</a><a href="#h16-0-89" id="h16-0-89" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h16-0-90" id="h16-0-90" class="i">+	if err != nil {
</a><a href="#h16-0-91" id="h16-0-91" class="i">+		return nil, nil, err
</a><a href="#h16-0-92" id="h16-0-92" class="i">+	}
</a><a href="#h16-0-93" id="h16-0-93" class="i">+
</a><a href="#h16-0-94" id="h16-0-94" class="i">+	var rs []Reference
</a><a href="#h16-0-95" id="h16-0-95" class="i">+	resp, err := s.client.Do(req, &amp;rs)
</a><a href="#h16-0-96" id="h16-0-96" class="i">+	if err != nil {
</a><a href="#h16-0-97" id="h16-0-97" class="i">+		return nil, resp, err
</a><a href="#h16-0-98" id="h16-0-98" class="i">+	}
</a><a href="#h16-0-99" id="h16-0-99" class="i">+
</a><a href="#h16-0-100" id="h16-0-100" class="i">+	return rs, resp, err
</a><a href="#h16-0-101" id="h16-0-101" class="i">+}
</a><a href="#h16-0-102" id="h16-0-102" class="i">+
</a><a href="#h16-0-103" id="h16-0-103" class="i">+// CreateRef creates a new ref in a repository.
</a><a href="#h16-0-104" id="h16-0-104" class="i">+//
</a><a href="#h16-0-105" id="h16-0-105" class="i">+// GitHub API docs: http://developer.github.com/v3/git/refs/#create-a-reference
</a><a href="#h16-0-106" id="h16-0-106" class="i">+func (s *GitService) CreateRef(owner string, repo string, ref *Reference) (*Reference, *Response, error) {
</a><a href="#h16-0-107" id="h16-0-107" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/refs&quot;, owner, repo)
</a><a href="#h16-0-108" id="h16-0-108" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, &amp;createRefRequest{
</a><a href="#h16-0-109" id="h16-0-109" class="i">+		// back-compat with previous behavior that didn&#39;t require &#39;refs/&#39; prefix
</a><a href="#h16-0-110" id="h16-0-110" class="i">+		Ref: String(&quot;refs/&quot; + strings.TrimPrefix(*ref.Ref, &quot;refs/&quot;)),
</a><a href="#h16-0-111" id="h16-0-111" class="i">+		SHA: ref.Object.SHA,
</a><a href="#h16-0-112" id="h16-0-112" class="i">+	})
</a><a href="#h16-0-113" id="h16-0-113" class="i">+	if err != nil {
</a><a href="#h16-0-114" id="h16-0-114" class="i">+		return nil, nil, err
</a><a href="#h16-0-115" id="h16-0-115" class="i">+	}
</a><a href="#h16-0-116" id="h16-0-116" class="i">+
</a><a href="#h16-0-117" id="h16-0-117" class="i">+	r := new(Reference)
</a><a href="#h16-0-118" id="h16-0-118" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h16-0-119" id="h16-0-119" class="i">+	if err != nil {
</a><a href="#h16-0-120" id="h16-0-120" class="i">+		return nil, resp, err
</a><a href="#h16-0-121" id="h16-0-121" class="i">+	}
</a><a href="#h16-0-122" id="h16-0-122" class="i">+
</a><a href="#h16-0-123" id="h16-0-123" class="i">+	return r, resp, err
</a><a href="#h16-0-124" id="h16-0-124" class="i">+}
</a><a href="#h16-0-125" id="h16-0-125" class="i">+
</a><a href="#h16-0-126" id="h16-0-126" class="i">+// UpdateRef updates an existing ref in a repository.
</a><a href="#h16-0-127" id="h16-0-127" class="i">+//
</a><a href="#h16-0-128" id="h16-0-128" class="i">+// GitHub API docs: http://developer.github.com/v3/git/refs/#update-a-reference
</a><a href="#h16-0-129" id="h16-0-129" class="i">+func (s *GitService) UpdateRef(owner string, repo string, ref *Reference, force bool) (*Reference, *Response, error) {
</a><a href="#h16-0-130" id="h16-0-130" class="i">+	refPath := strings.TrimPrefix(*ref.Ref, &quot;refs/&quot;)
</a><a href="#h16-0-131" id="h16-0-131" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/refs/%v&quot;, owner, repo, refPath)
</a><a href="#h16-0-132" id="h16-0-132" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, &amp;updateRefRequest{
</a><a href="#h16-0-133" id="h16-0-133" class="i">+		SHA:   ref.Object.SHA,
</a><a href="#h16-0-134" id="h16-0-134" class="i">+		Force: &amp;force,
</a><a href="#h16-0-135" id="h16-0-135" class="i">+	})
</a><a href="#h16-0-136" id="h16-0-136" class="i">+	if err != nil {
</a><a href="#h16-0-137" id="h16-0-137" class="i">+		return nil, nil, err
</a><a href="#h16-0-138" id="h16-0-138" class="i">+	}
</a><a href="#h16-0-139" id="h16-0-139" class="i">+
</a><a href="#h16-0-140" id="h16-0-140" class="i">+	r := new(Reference)
</a><a href="#h16-0-141" id="h16-0-141" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h16-0-142" id="h16-0-142" class="i">+	if err != nil {
</a><a href="#h16-0-143" id="h16-0-143" class="i">+		return nil, resp, err
</a><a href="#h16-0-144" id="h16-0-144" class="i">+	}
</a><a href="#h16-0-145" id="h16-0-145" class="i">+
</a><a href="#h16-0-146" id="h16-0-146" class="i">+	return r, resp, err
</a><a href="#h16-0-147" id="h16-0-147" class="i">+}
</a><a href="#h16-0-148" id="h16-0-148" class="i">+
</a><a href="#h16-0-149" id="h16-0-149" class="i">+// DeleteRef deletes a ref from a repository.
</a><a href="#h16-0-150" id="h16-0-150" class="i">+//
</a><a href="#h16-0-151" id="h16-0-151" class="i">+// GitHub API docs: http://developer.github.com/v3/git/refs/#delete-a-reference
</a><a href="#h16-0-152" id="h16-0-152" class="i">+func (s *GitService) DeleteRef(owner string, repo string, ref string) (*Response, error) {
</a><a href="#h16-0-153" id="h16-0-153" class="i">+	ref = strings.TrimPrefix(ref, &quot;refs/&quot;)
</a><a href="#h16-0-154" id="h16-0-154" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/refs/%v&quot;, owner, repo, ref)
</a><a href="#h16-0-155" id="h16-0-155" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h16-0-156" id="h16-0-156" class="i">+	if err != nil {
</a><a href="#h16-0-157" id="h16-0-157" class="i">+		return nil, err
</a><a href="#h16-0-158" id="h16-0-158" class="i">+	}
</a><a href="#h16-0-159" id="h16-0-159" class="i">+
</a><a href="#h16-0-160" id="h16-0-160" class="i">+	return s.client.Do(req, nil)
</a><a href="#h16-0-161" id="h16-0-161" class="i">+}
</a><b>diff --git a/<a id="h17" href="../file/vendor/github.com/google/go-github/github/git_tags.go">vendor/github.com/google/go-github/github/git_tags.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/git_tags.go">vendor/github.com/google/go-github/github/git_tags.go</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -0,0 +1,73 @@
</a><a href="#h17-0-0" id="h17-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h17-0-1" id="h17-0-1" class="i">+//
</a><a href="#h17-0-2" id="h17-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h17-0-3" id="h17-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h17-0-4" id="h17-0-4" class="i">+
</a><a href="#h17-0-5" id="h17-0-5" class="i">+package github
</a><a href="#h17-0-6" id="h17-0-6" class="i">+
</a><a href="#h17-0-7" id="h17-0-7" class="i">+import (
</a><a href="#h17-0-8" id="h17-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h17-0-9" id="h17-0-9" class="i">+)
</a><a href="#h17-0-10" id="h17-0-10" class="i">+
</a><a href="#h17-0-11" id="h17-0-11" class="i">+// Tag represents a tag object.
</a><a href="#h17-0-12" id="h17-0-12" class="i">+type Tag struct {
</a><a href="#h17-0-13" id="h17-0-13" class="i">+	Tag     *string       `json:&quot;tag,omitempty&quot;`
</a><a href="#h17-0-14" id="h17-0-14" class="i">+	SHA     *string       `json:&quot;sha,omitempty&quot;`
</a><a href="#h17-0-15" id="h17-0-15" class="i">+	URL     *string       `json:&quot;url,omitempty&quot;`
</a><a href="#h17-0-16" id="h17-0-16" class="i">+	Message *string       `json:&quot;message,omitempty&quot;`
</a><a href="#h17-0-17" id="h17-0-17" class="i">+	Tagger  *CommitAuthor `json:&quot;tagger,omitempty&quot;`
</a><a href="#h17-0-18" id="h17-0-18" class="i">+	Object  *GitObject    `json:&quot;object,omitempty&quot;`
</a><a href="#h17-0-19" id="h17-0-19" class="i">+}
</a><a href="#h17-0-20" id="h17-0-20" class="i">+
</a><a href="#h17-0-21" id="h17-0-21" class="i">+// createTagRequest represents the body of a CreateTag request.  This is mostly
</a><a href="#h17-0-22" id="h17-0-22" class="i">+// identical to Tag with the exception that the object SHA and Type are
</a><a href="#h17-0-23" id="h17-0-23" class="i">+// top-level fields, rather than being nested inside a JSON object.
</a><a href="#h17-0-24" id="h17-0-24" class="i">+type createTagRequest struct {
</a><a href="#h17-0-25" id="h17-0-25" class="i">+	Tag     *string       `json:&quot;tag,omitempty&quot;`
</a><a href="#h17-0-26" id="h17-0-26" class="i">+	Message *string       `json:&quot;message,omitempty&quot;`
</a><a href="#h17-0-27" id="h17-0-27" class="i">+	Object  *string       `json:&quot;object,omitempty&quot;`
</a><a href="#h17-0-28" id="h17-0-28" class="i">+	Type    *string       `json:&quot;type,omitempty&quot;`
</a><a href="#h17-0-29" id="h17-0-29" class="i">+	Tagger  *CommitAuthor `json:&quot;tagger,omitempty&quot;`
</a><a href="#h17-0-30" id="h17-0-30" class="i">+}
</a><a href="#h17-0-31" id="h17-0-31" class="i">+
</a><a href="#h17-0-32" id="h17-0-32" class="i">+// GetTag fetchs a tag from a repo given a SHA.
</a><a href="#h17-0-33" id="h17-0-33" class="i">+//
</a><a href="#h17-0-34" id="h17-0-34" class="i">+// GitHub API docs: http://developer.github.com/v3/git/tags/#get-a-tag
</a><a href="#h17-0-35" id="h17-0-35" class="i">+func (s *GitService) GetTag(owner string, repo string, sha string) (*Tag, *Response, error) {
</a><a href="#h17-0-36" id="h17-0-36" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/tags/%v&quot;, owner, repo, sha)
</a><a href="#h17-0-37" id="h17-0-37" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h17-0-38" id="h17-0-38" class="i">+	if err != nil {
</a><a href="#h17-0-39" id="h17-0-39" class="i">+		return nil, nil, err
</a><a href="#h17-0-40" id="h17-0-40" class="i">+	}
</a><a href="#h17-0-41" id="h17-0-41" class="i">+
</a><a href="#h17-0-42" id="h17-0-42" class="i">+	tag := new(Tag)
</a><a href="#h17-0-43" id="h17-0-43" class="i">+	resp, err := s.client.Do(req, tag)
</a><a href="#h17-0-44" id="h17-0-44" class="i">+	return tag, resp, err
</a><a href="#h17-0-45" id="h17-0-45" class="i">+}
</a><a href="#h17-0-46" id="h17-0-46" class="i">+
</a><a href="#h17-0-47" id="h17-0-47" class="i">+// CreateTag creates a tag object.
</a><a href="#h17-0-48" id="h17-0-48" class="i">+//
</a><a href="#h17-0-49" id="h17-0-49" class="i">+// GitHub API docs: http://developer.github.com/v3/git/tags/#create-a-tag-object
</a><a href="#h17-0-50" id="h17-0-50" class="i">+func (s *GitService) CreateTag(owner string, repo string, tag *Tag) (*Tag, *Response, error) {
</a><a href="#h17-0-51" id="h17-0-51" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/tags&quot;, owner, repo)
</a><a href="#h17-0-52" id="h17-0-52" class="i">+
</a><a href="#h17-0-53" id="h17-0-53" class="i">+	// convert Tag into a createTagRequest
</a><a href="#h17-0-54" id="h17-0-54" class="i">+	tagRequest := &amp;createTagRequest{
</a><a href="#h17-0-55" id="h17-0-55" class="i">+		Tag:     tag.Tag,
</a><a href="#h17-0-56" id="h17-0-56" class="i">+		Message: tag.Message,
</a><a href="#h17-0-57" id="h17-0-57" class="i">+		Tagger:  tag.Tagger,
</a><a href="#h17-0-58" id="h17-0-58" class="i">+	}
</a><a href="#h17-0-59" id="h17-0-59" class="i">+	if tag.Object != nil {
</a><a href="#h17-0-60" id="h17-0-60" class="i">+		tagRequest.Object = tag.Object.SHA
</a><a href="#h17-0-61" id="h17-0-61" class="i">+		tagRequest.Type = tag.Object.Type
</a><a href="#h17-0-62" id="h17-0-62" class="i">+	}
</a><a href="#h17-0-63" id="h17-0-63" class="i">+
</a><a href="#h17-0-64" id="h17-0-64" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, tagRequest)
</a><a href="#h17-0-65" id="h17-0-65" class="i">+	if err != nil {
</a><a href="#h17-0-66" id="h17-0-66" class="i">+		return nil, nil, err
</a><a href="#h17-0-67" id="h17-0-67" class="i">+	}
</a><a href="#h17-0-68" id="h17-0-68" class="i">+
</a><a href="#h17-0-69" id="h17-0-69" class="i">+	t := new(Tag)
</a><a href="#h17-0-70" id="h17-0-70" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h17-0-71" id="h17-0-71" class="i">+	return t, resp, err
</a><a href="#h17-0-72" id="h17-0-72" class="i">+}
</a><b>diff --git a/<a id="h18" href="../file/vendor/github.com/google/go-github/github/git_trees.go">vendor/github.com/google/go-github/github/git_trees.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/git_trees.go">vendor/github.com/google/go-github/github/git_trees.go</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -0,0 +1,89 @@
</a><a href="#h18-0-0" id="h18-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h18-0-1" id="h18-0-1" class="i">+//
</a><a href="#h18-0-2" id="h18-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h18-0-3" id="h18-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h18-0-4" id="h18-0-4" class="i">+
</a><a href="#h18-0-5" id="h18-0-5" class="i">+package github
</a><a href="#h18-0-6" id="h18-0-6" class="i">+
</a><a href="#h18-0-7" id="h18-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h18-0-8" id="h18-0-8" class="i">+
</a><a href="#h18-0-9" id="h18-0-9" class="i">+// Tree represents a GitHub tree.
</a><a href="#h18-0-10" id="h18-0-10" class="i">+type Tree struct {
</a><a href="#h18-0-11" id="h18-0-11" class="i">+	SHA     *string     `json:&quot;sha,omitempty&quot;`
</a><a href="#h18-0-12" id="h18-0-12" class="i">+	Entries []TreeEntry `json:&quot;tree,omitempty&quot;`
</a><a href="#h18-0-13" id="h18-0-13" class="i">+}
</a><a href="#h18-0-14" id="h18-0-14" class="i">+
</a><a href="#h18-0-15" id="h18-0-15" class="i">+func (t Tree) String() string {
</a><a href="#h18-0-16" id="h18-0-16" class="i">+	return Stringify(t)
</a><a href="#h18-0-17" id="h18-0-17" class="i">+}
</a><a href="#h18-0-18" id="h18-0-18" class="i">+
</a><a href="#h18-0-19" id="h18-0-19" class="i">+// TreeEntry represents the contents of a tree structure.  TreeEntry can
</a><a href="#h18-0-20" id="h18-0-20" class="i">+// represent either a blob, a commit (in the case of a submodule), or another
</a><a href="#h18-0-21" id="h18-0-21" class="i">+// tree.
</a><a href="#h18-0-22" id="h18-0-22" class="i">+type TreeEntry struct {
</a><a href="#h18-0-23" id="h18-0-23" class="i">+	SHA     *string `json:&quot;sha,omitempty&quot;`
</a><a href="#h18-0-24" id="h18-0-24" class="i">+	Path    *string `json:&quot;path,omitempty&quot;`
</a><a href="#h18-0-25" id="h18-0-25" class="i">+	Mode    *string `json:&quot;mode,omitempty&quot;`
</a><a href="#h18-0-26" id="h18-0-26" class="i">+	Type    *string `json:&quot;type,omitempty&quot;`
</a><a href="#h18-0-27" id="h18-0-27" class="i">+	Size    *int    `json:&quot;size,omitempty&quot;`
</a><a href="#h18-0-28" id="h18-0-28" class="i">+	Content *string `json:&quot;content,omitempty&quot;`
</a><a href="#h18-0-29" id="h18-0-29" class="i">+}
</a><a href="#h18-0-30" id="h18-0-30" class="i">+
</a><a href="#h18-0-31" id="h18-0-31" class="i">+func (t TreeEntry) String() string {
</a><a href="#h18-0-32" id="h18-0-32" class="i">+	return Stringify(t)
</a><a href="#h18-0-33" id="h18-0-33" class="i">+}
</a><a href="#h18-0-34" id="h18-0-34" class="i">+
</a><a href="#h18-0-35" id="h18-0-35" class="i">+// GetTree fetches the Tree object for a given sha hash from a repository.
</a><a href="#h18-0-36" id="h18-0-36" class="i">+//
</a><a href="#h18-0-37" id="h18-0-37" class="i">+// GitHub API docs: http://developer.github.com/v3/git/trees/#get-a-tree
</a><a href="#h18-0-38" id="h18-0-38" class="i">+func (s *GitService) GetTree(owner string, repo string, sha string, recursive bool) (*Tree, *Response, error) {
</a><a href="#h18-0-39" id="h18-0-39" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/trees/%v&quot;, owner, repo, sha)
</a><a href="#h18-0-40" id="h18-0-40" class="i">+	if recursive {
</a><a href="#h18-0-41" id="h18-0-41" class="i">+		u += &quot;?recursive=1&quot;
</a><a href="#h18-0-42" id="h18-0-42" class="i">+	}
</a><a href="#h18-0-43" id="h18-0-43" class="i">+
</a><a href="#h18-0-44" id="h18-0-44" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h18-0-45" id="h18-0-45" class="i">+	if err != nil {
</a><a href="#h18-0-46" id="h18-0-46" class="i">+		return nil, nil, err
</a><a href="#h18-0-47" id="h18-0-47" class="i">+	}
</a><a href="#h18-0-48" id="h18-0-48" class="i">+
</a><a href="#h18-0-49" id="h18-0-49" class="i">+	t := new(Tree)
</a><a href="#h18-0-50" id="h18-0-50" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h18-0-51" id="h18-0-51" class="i">+	if err != nil {
</a><a href="#h18-0-52" id="h18-0-52" class="i">+		return nil, resp, err
</a><a href="#h18-0-53" id="h18-0-53" class="i">+	}
</a><a href="#h18-0-54" id="h18-0-54" class="i">+
</a><a href="#h18-0-55" id="h18-0-55" class="i">+	return t, resp, err
</a><a href="#h18-0-56" id="h18-0-56" class="i">+}
</a><a href="#h18-0-57" id="h18-0-57" class="i">+
</a><a href="#h18-0-58" id="h18-0-58" class="i">+// createTree represents the body of a CreateTree request.
</a><a href="#h18-0-59" id="h18-0-59" class="i">+type createTree struct {
</a><a href="#h18-0-60" id="h18-0-60" class="i">+	BaseTree string      `json:&quot;base_tree,omitempty&quot;`
</a><a href="#h18-0-61" id="h18-0-61" class="i">+	Entries  []TreeEntry `json:&quot;tree&quot;`
</a><a href="#h18-0-62" id="h18-0-62" class="i">+}
</a><a href="#h18-0-63" id="h18-0-63" class="i">+
</a><a href="#h18-0-64" id="h18-0-64" class="i">+// CreateTree creates a new tree in a repository.  If both a tree and a nested
</a><a href="#h18-0-65" id="h18-0-65" class="i">+// path modifying that tree are specified, it will overwrite the contents of
</a><a href="#h18-0-66" id="h18-0-66" class="i">+// that tree with the new path contents and write a new tree out.
</a><a href="#h18-0-67" id="h18-0-67" class="i">+//
</a><a href="#h18-0-68" id="h18-0-68" class="i">+// GitHub API docs: http://developer.github.com/v3/git/trees/#create-a-tree
</a><a href="#h18-0-69" id="h18-0-69" class="i">+func (s *GitService) CreateTree(owner string, repo string, baseTree string, entries []TreeEntry) (*Tree, *Response, error) {
</a><a href="#h18-0-70" id="h18-0-70" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/git/trees&quot;, owner, repo)
</a><a href="#h18-0-71" id="h18-0-71" class="i">+
</a><a href="#h18-0-72" id="h18-0-72" class="i">+	body := &amp;createTree{
</a><a href="#h18-0-73" id="h18-0-73" class="i">+		BaseTree: baseTree,
</a><a href="#h18-0-74" id="h18-0-74" class="i">+		Entries:  entries,
</a><a href="#h18-0-75" id="h18-0-75" class="i">+	}
</a><a href="#h18-0-76" id="h18-0-76" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, body)
</a><a href="#h18-0-77" id="h18-0-77" class="i">+	if err != nil {
</a><a href="#h18-0-78" id="h18-0-78" class="i">+		return nil, nil, err
</a><a href="#h18-0-79" id="h18-0-79" class="i">+	}
</a><a href="#h18-0-80" id="h18-0-80" class="i">+
</a><a href="#h18-0-81" id="h18-0-81" class="i">+	t := new(Tree)
</a><a href="#h18-0-82" id="h18-0-82" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h18-0-83" id="h18-0-83" class="i">+	if err != nil {
</a><a href="#h18-0-84" id="h18-0-84" class="i">+		return nil, resp, err
</a><a href="#h18-0-85" id="h18-0-85" class="i">+	}
</a><a href="#h18-0-86" id="h18-0-86" class="i">+
</a><a href="#h18-0-87" id="h18-0-87" class="i">+	return t, resp, err
</a><a href="#h18-0-88" id="h18-0-88" class="i">+}
</a><b>diff --git a/<a id="h19" href="../file/vendor/github.com/google/go-github/github/github.go">vendor/github.com/google/go-github/github/github.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/github.go">vendor/github.com/google/go-github/github/github.go</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -0,0 +1,712 @@
</a><a href="#h19-0-0" id="h19-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h19-0-1" id="h19-0-1" class="i">+//
</a><a href="#h19-0-2" id="h19-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h19-0-3" id="h19-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h19-0-4" id="h19-0-4" class="i">+
</a><a href="#h19-0-5" id="h19-0-5" class="i">+package github
</a><a href="#h19-0-6" id="h19-0-6" class="i">+
</a><a href="#h19-0-7" id="h19-0-7" class="i">+import (
</a><a href="#h19-0-8" id="h19-0-8" class="i">+	&quot;bytes&quot;
</a><a href="#h19-0-9" id="h19-0-9" class="i">+	&quot;encoding/json&quot;
</a><a href="#h19-0-10" id="h19-0-10" class="i">+	&quot;errors&quot;
</a><a href="#h19-0-11" id="h19-0-11" class="i">+	&quot;fmt&quot;
</a><a href="#h19-0-12" id="h19-0-12" class="i">+	&quot;io&quot;
</a><a href="#h19-0-13" id="h19-0-13" class="i">+	&quot;io/ioutil&quot;
</a><a href="#h19-0-14" id="h19-0-14" class="i">+	&quot;net/http&quot;
</a><a href="#h19-0-15" id="h19-0-15" class="i">+	&quot;net/url&quot;
</a><a href="#h19-0-16" id="h19-0-16" class="i">+	&quot;reflect&quot;
</a><a href="#h19-0-17" id="h19-0-17" class="i">+	&quot;strconv&quot;
</a><a href="#h19-0-18" id="h19-0-18" class="i">+	&quot;strings&quot;
</a><a href="#h19-0-19" id="h19-0-19" class="i">+	&quot;sync&quot;
</a><a href="#h19-0-20" id="h19-0-20" class="i">+	&quot;time&quot;
</a><a href="#h19-0-21" id="h19-0-21" class="i">+
</a><a href="#h19-0-22" id="h19-0-22" class="i">+	&quot;github.com/google/go-querystring/query&quot;
</a><a href="#h19-0-23" id="h19-0-23" class="i">+)
</a><a href="#h19-0-24" id="h19-0-24" class="i">+
</a><a href="#h19-0-25" id="h19-0-25" class="i">+const (
</a><a href="#h19-0-26" id="h19-0-26" class="i">+	// StatusUnprocessableEntity is the status code returned when sending a request with invalid fields.
</a><a href="#h19-0-27" id="h19-0-27" class="i">+	StatusUnprocessableEntity = 422
</a><a href="#h19-0-28" id="h19-0-28" class="i">+)
</a><a href="#h19-0-29" id="h19-0-29" class="i">+
</a><a href="#h19-0-30" id="h19-0-30" class="i">+const (
</a><a href="#h19-0-31" id="h19-0-31" class="i">+	libraryVersion = &quot;0.1&quot;
</a><a href="#h19-0-32" id="h19-0-32" class="i">+	defaultBaseURL = &quot;https://api.github.com/&quot;
</a><a href="#h19-0-33" id="h19-0-33" class="i">+	uploadBaseURL  = &quot;https://uploads.github.com/&quot;
</a><a href="#h19-0-34" id="h19-0-34" class="i">+	userAgent      = &quot;go-github/&quot; + libraryVersion
</a><a href="#h19-0-35" id="h19-0-35" class="i">+
</a><a href="#h19-0-36" id="h19-0-36" class="i">+	headerRateLimit     = &quot;X-RateLimit-Limit&quot;
</a><a href="#h19-0-37" id="h19-0-37" class="i">+	headerRateRemaining = &quot;X-RateLimit-Remaining&quot;
</a><a href="#h19-0-38" id="h19-0-38" class="i">+	headerRateReset     = &quot;X-RateLimit-Reset&quot;
</a><a href="#h19-0-39" id="h19-0-39" class="i">+	headerOTP           = &quot;X-GitHub-OTP&quot;
</a><a href="#h19-0-40" id="h19-0-40" class="i">+
</a><a href="#h19-0-41" id="h19-0-41" class="i">+	mediaTypeV3      = &quot;application/vnd.github.v3+json&quot;
</a><a href="#h19-0-42" id="h19-0-42" class="i">+	defaultMediaType = &quot;application/octet-stream&quot;
</a><a href="#h19-0-43" id="h19-0-43" class="i">+
</a><a href="#h19-0-44" id="h19-0-44" class="i">+	// Media Type values to access preview APIs
</a><a href="#h19-0-45" id="h19-0-45" class="i">+
</a><a href="#h19-0-46" id="h19-0-46" class="i">+	// https://developer.github.com/changes/2015-03-09-licenses-api/
</a><a href="#h19-0-47" id="h19-0-47" class="i">+	mediaTypeLicensesPreview = &quot;application/vnd.github.drax-preview+json&quot;
</a><a href="#h19-0-48" id="h19-0-48" class="i">+
</a><a href="#h19-0-49" id="h19-0-49" class="i">+	// https://developer.github.com/changes/2014-12-09-new-attributes-for-stars-api/
</a><a href="#h19-0-50" id="h19-0-50" class="i">+	mediaTypeStarringPreview = &quot;application/vnd.github.v3.star+json&quot;
</a><a href="#h19-0-51" id="h19-0-51" class="i">+
</a><a href="#h19-0-52" id="h19-0-52" class="i">+	// https://developer.github.com/changes/2015-06-24-api-enhancements-for-working-with-organization-permissions/
</a><a href="#h19-0-53" id="h19-0-53" class="i">+	mediaTypeOrgPermissionPreview     = &quot;application/vnd.github.ironman-preview+json&quot;
</a><a href="#h19-0-54" id="h19-0-54" class="i">+	mediaTypeOrgPermissionRepoPreview = &quot;application/vnd.github.ironman-preview.repository+json&quot;
</a><a href="#h19-0-55" id="h19-0-55" class="i">+
</a><a href="#h19-0-56" id="h19-0-56" class="i">+	// https://developer.github.com/changes/2015-11-11-protected-branches-api/
</a><a href="#h19-0-57" id="h19-0-57" class="i">+	mediaTypeProtectedBranchesPreview = &quot;application/vnd.github.loki-preview+json&quot;
</a><a href="#h19-0-58" id="h19-0-58" class="i">+
</a><a href="#h19-0-59" id="h19-0-59" class="i">+	// https://developer.github.com/changes/2016-02-11-issue-locking-api/
</a><a href="#h19-0-60" id="h19-0-60" class="i">+	mediaTypeIssueLockingPreview = &quot;application/vnd.github.the-key-preview+json&quot;
</a><a href="#h19-0-61" id="h19-0-61" class="i">+
</a><a href="#h19-0-62" id="h19-0-62" class="i">+	// https://developer.github.com/changes/2016-02-24-commit-reference-sha-api/
</a><a href="#h19-0-63" id="h19-0-63" class="i">+	mediaTypeCommitReferenceSHAPreview = &quot;application/vnd.github.chitauri-preview+sha&quot;
</a><a href="#h19-0-64" id="h19-0-64" class="i">+
</a><a href="#h19-0-65" id="h19-0-65" class="i">+	// https://help.github.com/enterprise/2.4/admin/guides/migrations/exporting-the-github-com-organization-s-repositories/
</a><a href="#h19-0-66" id="h19-0-66" class="i">+	mediaTypeMigrationsPreview = &quot;application/vnd.github.wyandotte-preview+json&quot;
</a><a href="#h19-0-67" id="h19-0-67" class="i">+)
</a><a href="#h19-0-68" id="h19-0-68" class="i">+
</a><a href="#h19-0-69" id="h19-0-69" class="i">+// A Client manages communication with the GitHub API.
</a><a href="#h19-0-70" id="h19-0-70" class="i">+type Client struct {
</a><a href="#h19-0-71" id="h19-0-71" class="i">+	// HTTP client used to communicate with the API.
</a><a href="#h19-0-72" id="h19-0-72" class="i">+	client *http.Client
</a><a href="#h19-0-73" id="h19-0-73" class="i">+	// clientMu protects the client during calls that modify the CheckRedirect func.
</a><a href="#h19-0-74" id="h19-0-74" class="i">+	clientMu sync.Mutex
</a><a href="#h19-0-75" id="h19-0-75" class="i">+
</a><a href="#h19-0-76" id="h19-0-76" class="i">+	// Base URL for API requests.  Defaults to the public GitHub API, but can be
</a><a href="#h19-0-77" id="h19-0-77" class="i">+	// set to a domain endpoint to use with GitHub Enterprise.  BaseURL should
</a><a href="#h19-0-78" id="h19-0-78" class="i">+	// always be specified with a trailing slash.
</a><a href="#h19-0-79" id="h19-0-79" class="i">+	BaseURL *url.URL
</a><a href="#h19-0-80" id="h19-0-80" class="i">+
</a><a href="#h19-0-81" id="h19-0-81" class="i">+	// Base URL for uploading files.
</a><a href="#h19-0-82" id="h19-0-82" class="i">+	UploadURL *url.URL
</a><a href="#h19-0-83" id="h19-0-83" class="i">+
</a><a href="#h19-0-84" id="h19-0-84" class="i">+	// User agent used when communicating with the GitHub API.
</a><a href="#h19-0-85" id="h19-0-85" class="i">+	UserAgent string
</a><a href="#h19-0-86" id="h19-0-86" class="i">+
</a><a href="#h19-0-87" id="h19-0-87" class="i">+	rateMu sync.Mutex
</a><a href="#h19-0-88" id="h19-0-88" class="i">+	rate   Rate // Rate limit for the client as determined by the most recent API call.
</a><a href="#h19-0-89" id="h19-0-89" class="i">+
</a><a href="#h19-0-90" id="h19-0-90" class="i">+	// Services used for talking to different parts of the GitHub API.
</a><a href="#h19-0-91" id="h19-0-91" class="i">+	Activity       *ActivityService
</a><a href="#h19-0-92" id="h19-0-92" class="i">+	Authorizations *AuthorizationsService
</a><a href="#h19-0-93" id="h19-0-93" class="i">+	Gists          *GistsService
</a><a href="#h19-0-94" id="h19-0-94" class="i">+	Git            *GitService
</a><a href="#h19-0-95" id="h19-0-95" class="i">+	Gitignores     *GitignoresService
</a><a href="#h19-0-96" id="h19-0-96" class="i">+	Issues         *IssuesService
</a><a href="#h19-0-97" id="h19-0-97" class="i">+	Organizations  *OrganizationsService
</a><a href="#h19-0-98" id="h19-0-98" class="i">+	PullRequests   *PullRequestsService
</a><a href="#h19-0-99" id="h19-0-99" class="i">+	Repositories   *RepositoriesService
</a><a href="#h19-0-100" id="h19-0-100" class="i">+	Search         *SearchService
</a><a href="#h19-0-101" id="h19-0-101" class="i">+	Users          *UsersService
</a><a href="#h19-0-102" id="h19-0-102" class="i">+	Licenses       *LicensesService
</a><a href="#h19-0-103" id="h19-0-103" class="i">+	Migrations     *MigrationService
</a><a href="#h19-0-104" id="h19-0-104" class="i">+}
</a><a href="#h19-0-105" id="h19-0-105" class="i">+
</a><a href="#h19-0-106" id="h19-0-106" class="i">+// ListOptions specifies the optional parameters to various List methods that
</a><a href="#h19-0-107" id="h19-0-107" class="i">+// support pagination.
</a><a href="#h19-0-108" id="h19-0-108" class="i">+type ListOptions struct {
</a><a href="#h19-0-109" id="h19-0-109" class="i">+	// For paginated result sets, page of results to retrieve.
</a><a href="#h19-0-110" id="h19-0-110" class="i">+	Page int `url:&quot;page,omitempty&quot;`
</a><a href="#h19-0-111" id="h19-0-111" class="i">+
</a><a href="#h19-0-112" id="h19-0-112" class="i">+	// For paginated result sets, the number of results to include per page.
</a><a href="#h19-0-113" id="h19-0-113" class="i">+	PerPage int `url:&quot;per_page,omitempty&quot;`
</a><a href="#h19-0-114" id="h19-0-114" class="i">+}
</a><a href="#h19-0-115" id="h19-0-115" class="i">+
</a><a href="#h19-0-116" id="h19-0-116" class="i">+// UploadOptions specifies the parameters to methods that support uploads.
</a><a href="#h19-0-117" id="h19-0-117" class="i">+type UploadOptions struct {
</a><a href="#h19-0-118" id="h19-0-118" class="i">+	Name string `url:&quot;name,omitempty&quot;`
</a><a href="#h19-0-119" id="h19-0-119" class="i">+}
</a><a href="#h19-0-120" id="h19-0-120" class="i">+
</a><a href="#h19-0-121" id="h19-0-121" class="i">+// addOptions adds the parameters in opt as URL query parameters to s.  opt
</a><a href="#h19-0-122" id="h19-0-122" class="i">+// must be a struct whose fields may contain &quot;url&quot; tags.
</a><a href="#h19-0-123" id="h19-0-123" class="i">+func addOptions(s string, opt interface{}) (string, error) {
</a><a href="#h19-0-124" id="h19-0-124" class="i">+	v := reflect.ValueOf(opt)
</a><a href="#h19-0-125" id="h19-0-125" class="i">+	if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() {
</a><a href="#h19-0-126" id="h19-0-126" class="i">+		return s, nil
</a><a href="#h19-0-127" id="h19-0-127" class="i">+	}
</a><a href="#h19-0-128" id="h19-0-128" class="i">+
</a><a href="#h19-0-129" id="h19-0-129" class="i">+	u, err := url.Parse(s)
</a><a href="#h19-0-130" id="h19-0-130" class="i">+	if err != nil {
</a><a href="#h19-0-131" id="h19-0-131" class="i">+		return s, err
</a><a href="#h19-0-132" id="h19-0-132" class="i">+	}
</a><a href="#h19-0-133" id="h19-0-133" class="i">+
</a><a href="#h19-0-134" id="h19-0-134" class="i">+	qs, err := query.Values(opt)
</a><a href="#h19-0-135" id="h19-0-135" class="i">+	if err != nil {
</a><a href="#h19-0-136" id="h19-0-136" class="i">+		return s, err
</a><a href="#h19-0-137" id="h19-0-137" class="i">+	}
</a><a href="#h19-0-138" id="h19-0-138" class="i">+
</a><a href="#h19-0-139" id="h19-0-139" class="i">+	u.RawQuery = qs.Encode()
</a><a href="#h19-0-140" id="h19-0-140" class="i">+	return u.String(), nil
</a><a href="#h19-0-141" id="h19-0-141" class="i">+}
</a><a href="#h19-0-142" id="h19-0-142" class="i">+
</a><a href="#h19-0-143" id="h19-0-143" class="i">+// NewClient returns a new GitHub API client.  If a nil httpClient is
</a><a href="#h19-0-144" id="h19-0-144" class="i">+// provided, http.DefaultClient will be used.  To use API methods which require
</a><a href="#h19-0-145" id="h19-0-145" class="i">+// authentication, provide an http.Client that will perform the authentication
</a><a href="#h19-0-146" id="h19-0-146" class="i">+// for you (such as that provided by the golang.org/x/oauth2 library).
</a><a href="#h19-0-147" id="h19-0-147" class="i">+func NewClient(httpClient *http.Client) *Client {
</a><a href="#h19-0-148" id="h19-0-148" class="i">+	if httpClient == nil {
</a><a href="#h19-0-149" id="h19-0-149" class="i">+		httpClient = http.DefaultClient
</a><a href="#h19-0-150" id="h19-0-150" class="i">+	}
</a><a href="#h19-0-151" id="h19-0-151" class="i">+	baseURL, _ := url.Parse(defaultBaseURL)
</a><a href="#h19-0-152" id="h19-0-152" class="i">+	uploadURL, _ := url.Parse(uploadBaseURL)
</a><a href="#h19-0-153" id="h19-0-153" class="i">+
</a><a href="#h19-0-154" id="h19-0-154" class="i">+	c := &amp;Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}
</a><a href="#h19-0-155" id="h19-0-155" class="i">+	c.Activity = &amp;ActivityService{client: c}
</a><a href="#h19-0-156" id="h19-0-156" class="i">+	c.Authorizations = &amp;AuthorizationsService{client: c}
</a><a href="#h19-0-157" id="h19-0-157" class="i">+	c.Gists = &amp;GistsService{client: c}
</a><a href="#h19-0-158" id="h19-0-158" class="i">+	c.Git = &amp;GitService{client: c}
</a><a href="#h19-0-159" id="h19-0-159" class="i">+	c.Gitignores = &amp;GitignoresService{client: c}
</a><a href="#h19-0-160" id="h19-0-160" class="i">+	c.Issues = &amp;IssuesService{client: c}
</a><a href="#h19-0-161" id="h19-0-161" class="i">+	c.Organizations = &amp;OrganizationsService{client: c}
</a><a href="#h19-0-162" id="h19-0-162" class="i">+	c.PullRequests = &amp;PullRequestsService{client: c}
</a><a href="#h19-0-163" id="h19-0-163" class="i">+	c.Repositories = &amp;RepositoriesService{client: c}
</a><a href="#h19-0-164" id="h19-0-164" class="i">+	c.Search = &amp;SearchService{client: c}
</a><a href="#h19-0-165" id="h19-0-165" class="i">+	c.Users = &amp;UsersService{client: c}
</a><a href="#h19-0-166" id="h19-0-166" class="i">+	c.Licenses = &amp;LicensesService{client: c}
</a><a href="#h19-0-167" id="h19-0-167" class="i">+	c.Migrations = &amp;MigrationService{client: c}
</a><a href="#h19-0-168" id="h19-0-168" class="i">+	return c
</a><a href="#h19-0-169" id="h19-0-169" class="i">+}
</a><a href="#h19-0-170" id="h19-0-170" class="i">+
</a><a href="#h19-0-171" id="h19-0-171" class="i">+// NewRequest creates an API request. A relative URL can be provided in urlStr,
</a><a href="#h19-0-172" id="h19-0-172" class="i">+// in which case it is resolved relative to the BaseURL of the Client.
</a><a href="#h19-0-173" id="h19-0-173" class="i">+// Relative URLs should always be specified without a preceding slash.  If
</a><a href="#h19-0-174" id="h19-0-174" class="i">+// specified, the value pointed to by body is JSON encoded and included as the
</a><a href="#h19-0-175" id="h19-0-175" class="i">+// request body.
</a><a href="#h19-0-176" id="h19-0-176" class="i">+func (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {
</a><a href="#h19-0-177" id="h19-0-177" class="i">+	rel, err := url.Parse(urlStr)
</a><a href="#h19-0-178" id="h19-0-178" class="i">+	if err != nil {
</a><a href="#h19-0-179" id="h19-0-179" class="i">+		return nil, err
</a><a href="#h19-0-180" id="h19-0-180" class="i">+	}
</a><a href="#h19-0-181" id="h19-0-181" class="i">+
</a><a href="#h19-0-182" id="h19-0-182" class="i">+	u := c.BaseURL.ResolveReference(rel)
</a><a href="#h19-0-183" id="h19-0-183" class="i">+
</a><a href="#h19-0-184" id="h19-0-184" class="i">+	var buf io.ReadWriter
</a><a href="#h19-0-185" id="h19-0-185" class="i">+	if body != nil {
</a><a href="#h19-0-186" id="h19-0-186" class="i">+		buf = new(bytes.Buffer)
</a><a href="#h19-0-187" id="h19-0-187" class="i">+		err := json.NewEncoder(buf).Encode(body)
</a><a href="#h19-0-188" id="h19-0-188" class="i">+		if err != nil {
</a><a href="#h19-0-189" id="h19-0-189" class="i">+			return nil, err
</a><a href="#h19-0-190" id="h19-0-190" class="i">+		}
</a><a href="#h19-0-191" id="h19-0-191" class="i">+	}
</a><a href="#h19-0-192" id="h19-0-192" class="i">+
</a><a href="#h19-0-193" id="h19-0-193" class="i">+	req, err := http.NewRequest(method, u.String(), buf)
</a><a href="#h19-0-194" id="h19-0-194" class="i">+	if err != nil {
</a><a href="#h19-0-195" id="h19-0-195" class="i">+		return nil, err
</a><a href="#h19-0-196" id="h19-0-196" class="i">+	}
</a><a href="#h19-0-197" id="h19-0-197" class="i">+
</a><a href="#h19-0-198" id="h19-0-198" class="i">+	req.Header.Add(&quot;Accept&quot;, mediaTypeV3)
</a><a href="#h19-0-199" id="h19-0-199" class="i">+	if c.UserAgent != &quot;&quot; {
</a><a href="#h19-0-200" id="h19-0-200" class="i">+		req.Header.Add(&quot;User-Agent&quot;, c.UserAgent)
</a><a href="#h19-0-201" id="h19-0-201" class="i">+	}
</a><a href="#h19-0-202" id="h19-0-202" class="i">+	return req, nil
</a><a href="#h19-0-203" id="h19-0-203" class="i">+}
</a><a href="#h19-0-204" id="h19-0-204" class="i">+
</a><a href="#h19-0-205" id="h19-0-205" class="i">+// NewUploadRequest creates an upload request. A relative URL can be provided in
</a><a href="#h19-0-206" id="h19-0-206" class="i">+// urlStr, in which case it is resolved relative to the UploadURL of the Client.
</a><a href="#h19-0-207" id="h19-0-207" class="i">+// Relative URLs should always be specified without a preceding slash.
</a><a href="#h19-0-208" id="h19-0-208" class="i">+func (c *Client) NewUploadRequest(urlStr string, reader io.Reader, size int64, mediaType string) (*http.Request, error) {
</a><a href="#h19-0-209" id="h19-0-209" class="i">+	rel, err := url.Parse(urlStr)
</a><a href="#h19-0-210" id="h19-0-210" class="i">+	if err != nil {
</a><a href="#h19-0-211" id="h19-0-211" class="i">+		return nil, err
</a><a href="#h19-0-212" id="h19-0-212" class="i">+	}
</a><a href="#h19-0-213" id="h19-0-213" class="i">+
</a><a href="#h19-0-214" id="h19-0-214" class="i">+	u := c.UploadURL.ResolveReference(rel)
</a><a href="#h19-0-215" id="h19-0-215" class="i">+	req, err := http.NewRequest(&quot;POST&quot;, u.String(), reader)
</a><a href="#h19-0-216" id="h19-0-216" class="i">+	if err != nil {
</a><a href="#h19-0-217" id="h19-0-217" class="i">+		return nil, err
</a><a href="#h19-0-218" id="h19-0-218" class="i">+	}
</a><a href="#h19-0-219" id="h19-0-219" class="i">+	req.ContentLength = size
</a><a href="#h19-0-220" id="h19-0-220" class="i">+
</a><a href="#h19-0-221" id="h19-0-221" class="i">+	if len(mediaType) == 0 {
</a><a href="#h19-0-222" id="h19-0-222" class="i">+		mediaType = defaultMediaType
</a><a href="#h19-0-223" id="h19-0-223" class="i">+	}
</a><a href="#h19-0-224" id="h19-0-224" class="i">+	req.Header.Add(&quot;Content-Type&quot;, mediaType)
</a><a href="#h19-0-225" id="h19-0-225" class="i">+	req.Header.Add(&quot;Accept&quot;, mediaTypeV3)
</a><a href="#h19-0-226" id="h19-0-226" class="i">+	req.Header.Add(&quot;User-Agent&quot;, c.UserAgent)
</a><a href="#h19-0-227" id="h19-0-227" class="i">+	return req, nil
</a><a href="#h19-0-228" id="h19-0-228" class="i">+}
</a><a href="#h19-0-229" id="h19-0-229" class="i">+
</a><a href="#h19-0-230" id="h19-0-230" class="i">+// Response is a GitHub API response.  This wraps the standard http.Response
</a><a href="#h19-0-231" id="h19-0-231" class="i">+// returned from GitHub and provides convenient access to things like
</a><a href="#h19-0-232" id="h19-0-232" class="i">+// pagination links.
</a><a href="#h19-0-233" id="h19-0-233" class="i">+type Response struct {
</a><a href="#h19-0-234" id="h19-0-234" class="i">+	*http.Response
</a><a href="#h19-0-235" id="h19-0-235" class="i">+
</a><a href="#h19-0-236" id="h19-0-236" class="i">+	// These fields provide the page values for paginating through a set of
</a><a href="#h19-0-237" id="h19-0-237" class="i">+	// results.  Any or all of these may be set to the zero value for
</a><a href="#h19-0-238" id="h19-0-238" class="i">+	// responses that are not part of a paginated set, or for which there
</a><a href="#h19-0-239" id="h19-0-239" class="i">+	// are no additional pages.
</a><a href="#h19-0-240" id="h19-0-240" class="i">+
</a><a href="#h19-0-241" id="h19-0-241" class="i">+	NextPage  int
</a><a href="#h19-0-242" id="h19-0-242" class="i">+	PrevPage  int
</a><a href="#h19-0-243" id="h19-0-243" class="i">+	FirstPage int
</a><a href="#h19-0-244" id="h19-0-244" class="i">+	LastPage  int
</a><a href="#h19-0-245" id="h19-0-245" class="i">+
</a><a href="#h19-0-246" id="h19-0-246" class="i">+	Rate
</a><a href="#h19-0-247" id="h19-0-247" class="i">+}
</a><a href="#h19-0-248" id="h19-0-248" class="i">+
</a><a href="#h19-0-249" id="h19-0-249" class="i">+// newResponse creates a new Response for the provided http.Response.
</a><a href="#h19-0-250" id="h19-0-250" class="i">+func newResponse(r *http.Response) *Response {
</a><a href="#h19-0-251" id="h19-0-251" class="i">+	response := &amp;Response{Response: r}
</a><a href="#h19-0-252" id="h19-0-252" class="i">+	response.populatePageValues()
</a><a href="#h19-0-253" id="h19-0-253" class="i">+	response.Rate = parseRate(r)
</a><a href="#h19-0-254" id="h19-0-254" class="i">+	return response
</a><a href="#h19-0-255" id="h19-0-255" class="i">+}
</a><a href="#h19-0-256" id="h19-0-256" class="i">+
</a><a href="#h19-0-257" id="h19-0-257" class="i">+// populatePageValues parses the HTTP Link response headers and populates the
</a><a href="#h19-0-258" id="h19-0-258" class="i">+// various pagination link values in the Response.
</a><a href="#h19-0-259" id="h19-0-259" class="i">+func (r *Response) populatePageValues() {
</a><a href="#h19-0-260" id="h19-0-260" class="i">+	if links, ok := r.Response.Header[&quot;Link&quot;]; ok &amp;&amp; len(links) &gt; 0 {
</a><a href="#h19-0-261" id="h19-0-261" class="i">+		for _, link := range strings.Split(links[0], &quot;,&quot;) {
</a><a href="#h19-0-262" id="h19-0-262" class="i">+			segments := strings.Split(strings.TrimSpace(link), &quot;;&quot;)
</a><a href="#h19-0-263" id="h19-0-263" class="i">+
</a><a href="#h19-0-264" id="h19-0-264" class="i">+			// link must at least have href and rel
</a><a href="#h19-0-265" id="h19-0-265" class="i">+			if len(segments) &lt; 2 {
</a><a href="#h19-0-266" id="h19-0-266" class="i">+				continue
</a><a href="#h19-0-267" id="h19-0-267" class="i">+			}
</a><a href="#h19-0-268" id="h19-0-268" class="i">+
</a><a href="#h19-0-269" id="h19-0-269" class="i">+			// ensure href is properly formatted
</a><a href="#h19-0-270" id="h19-0-270" class="i">+			if !strings.HasPrefix(segments[0], &quot;&lt;&quot;) || !strings.HasSuffix(segments[0], &quot;&gt;&quot;) {
</a><a href="#h19-0-271" id="h19-0-271" class="i">+				continue
</a><a href="#h19-0-272" id="h19-0-272" class="i">+			}
</a><a href="#h19-0-273" id="h19-0-273" class="i">+
</a><a href="#h19-0-274" id="h19-0-274" class="i">+			// try to pull out page parameter
</a><a href="#h19-0-275" id="h19-0-275" class="i">+			url, err := url.Parse(segments[0][1 : len(segments[0])-1])
</a><a href="#h19-0-276" id="h19-0-276" class="i">+			if err != nil {
</a><a href="#h19-0-277" id="h19-0-277" class="i">+				continue
</a><a href="#h19-0-278" id="h19-0-278" class="i">+			}
</a><a href="#h19-0-279" id="h19-0-279" class="i">+			page := url.Query().Get(&quot;page&quot;)
</a><a href="#h19-0-280" id="h19-0-280" class="i">+			if page == &quot;&quot; {
</a><a href="#h19-0-281" id="h19-0-281" class="i">+				continue
</a><a href="#h19-0-282" id="h19-0-282" class="i">+			}
</a><a href="#h19-0-283" id="h19-0-283" class="i">+
</a><a href="#h19-0-284" id="h19-0-284" class="i">+			for _, segment := range segments[1:] {
</a><a href="#h19-0-285" id="h19-0-285" class="i">+				switch strings.TrimSpace(segment) {
</a><a href="#h19-0-286" id="h19-0-286" class="i">+				case `rel=&quot;next&quot;`:
</a><a href="#h19-0-287" id="h19-0-287" class="i">+					r.NextPage, _ = strconv.Atoi(page)
</a><a href="#h19-0-288" id="h19-0-288" class="i">+				case `rel=&quot;prev&quot;`:
</a><a href="#h19-0-289" id="h19-0-289" class="i">+					r.PrevPage, _ = strconv.Atoi(page)
</a><a href="#h19-0-290" id="h19-0-290" class="i">+				case `rel=&quot;first&quot;`:
</a><a href="#h19-0-291" id="h19-0-291" class="i">+					r.FirstPage, _ = strconv.Atoi(page)
</a><a href="#h19-0-292" id="h19-0-292" class="i">+				case `rel=&quot;last&quot;`:
</a><a href="#h19-0-293" id="h19-0-293" class="i">+					r.LastPage, _ = strconv.Atoi(page)
</a><a href="#h19-0-294" id="h19-0-294" class="i">+				}
</a><a href="#h19-0-295" id="h19-0-295" class="i">+
</a><a href="#h19-0-296" id="h19-0-296" class="i">+			}
</a><a href="#h19-0-297" id="h19-0-297" class="i">+		}
</a><a href="#h19-0-298" id="h19-0-298" class="i">+	}
</a><a href="#h19-0-299" id="h19-0-299" class="i">+}
</a><a href="#h19-0-300" id="h19-0-300" class="i">+
</a><a href="#h19-0-301" id="h19-0-301" class="i">+// parseRate parses the rate related headers.
</a><a href="#h19-0-302" id="h19-0-302" class="i">+func parseRate(r *http.Response) Rate {
</a><a href="#h19-0-303" id="h19-0-303" class="i">+	var rate Rate
</a><a href="#h19-0-304" id="h19-0-304" class="i">+	if limit := r.Header.Get(headerRateLimit); limit != &quot;&quot; {
</a><a href="#h19-0-305" id="h19-0-305" class="i">+		rate.Limit, _ = strconv.Atoi(limit)
</a><a href="#h19-0-306" id="h19-0-306" class="i">+	}
</a><a href="#h19-0-307" id="h19-0-307" class="i">+	if remaining := r.Header.Get(headerRateRemaining); remaining != &quot;&quot; {
</a><a href="#h19-0-308" id="h19-0-308" class="i">+		rate.Remaining, _ = strconv.Atoi(remaining)
</a><a href="#h19-0-309" id="h19-0-309" class="i">+	}
</a><a href="#h19-0-310" id="h19-0-310" class="i">+	if reset := r.Header.Get(headerRateReset); reset != &quot;&quot; {
</a><a href="#h19-0-311" id="h19-0-311" class="i">+		if v, _ := strconv.ParseInt(reset, 10, 64); v != 0 {
</a><a href="#h19-0-312" id="h19-0-312" class="i">+			rate.Reset = Timestamp{time.Unix(v, 0)}
</a><a href="#h19-0-313" id="h19-0-313" class="i">+		}
</a><a href="#h19-0-314" id="h19-0-314" class="i">+	}
</a><a href="#h19-0-315" id="h19-0-315" class="i">+	return rate
</a><a href="#h19-0-316" id="h19-0-316" class="i">+}
</a><a href="#h19-0-317" id="h19-0-317" class="i">+
</a><a href="#h19-0-318" id="h19-0-318" class="i">+// Rate specifies the current rate limit for the client as determined by the
</a><a href="#h19-0-319" id="h19-0-319" class="i">+// most recent API call.  If the client is used in a multi-user application,
</a><a href="#h19-0-320" id="h19-0-320" class="i">+// this rate may not always be up-to-date.  Call RateLimits() to check the
</a><a href="#h19-0-321" id="h19-0-321" class="i">+// current rate.
</a><a href="#h19-0-322" id="h19-0-322" class="i">+func (c *Client) Rate() Rate {
</a><a href="#h19-0-323" id="h19-0-323" class="i">+	c.rateMu.Lock()
</a><a href="#h19-0-324" id="h19-0-324" class="i">+	rate := c.rate
</a><a href="#h19-0-325" id="h19-0-325" class="i">+	c.rateMu.Unlock()
</a><a href="#h19-0-326" id="h19-0-326" class="i">+	return rate
</a><a href="#h19-0-327" id="h19-0-327" class="i">+}
</a><a href="#h19-0-328" id="h19-0-328" class="i">+
</a><a href="#h19-0-329" id="h19-0-329" class="i">+// Do sends an API request and returns the API response.  The API response is
</a><a href="#h19-0-330" id="h19-0-330" class="i">+// JSON decoded and stored in the value pointed to by v, or returned as an
</a><a href="#h19-0-331" id="h19-0-331" class="i">+// error if an API error has occurred.  If v implements the io.Writer
</a><a href="#h19-0-332" id="h19-0-332" class="i">+// interface, the raw response body will be written to v, without attempting to
</a><a href="#h19-0-333" id="h19-0-333" class="i">+// first decode it.
</a><a href="#h19-0-334" id="h19-0-334" class="i">+func (c *Client) Do(req *http.Request, v interface{}) (*Response, error) {
</a><a href="#h19-0-335" id="h19-0-335" class="i">+	resp, err := c.client.Do(req)
</a><a href="#h19-0-336" id="h19-0-336" class="i">+	if err != nil {
</a><a href="#h19-0-337" id="h19-0-337" class="i">+		return nil, err
</a><a href="#h19-0-338" id="h19-0-338" class="i">+	}
</a><a href="#h19-0-339" id="h19-0-339" class="i">+
</a><a href="#h19-0-340" id="h19-0-340" class="i">+	defer func() {
</a><a href="#h19-0-341" id="h19-0-341" class="i">+		// Drain up to 512 bytes and close the body to let the Transport reuse the connection
</a><a href="#h19-0-342" id="h19-0-342" class="i">+		io.CopyN(ioutil.Discard, resp.Body, 512)
</a><a href="#h19-0-343" id="h19-0-343" class="i">+		resp.Body.Close()
</a><a href="#h19-0-344" id="h19-0-344" class="i">+	}()
</a><a href="#h19-0-345" id="h19-0-345" class="i">+
</a><a href="#h19-0-346" id="h19-0-346" class="i">+	response := newResponse(resp)
</a><a href="#h19-0-347" id="h19-0-347" class="i">+
</a><a href="#h19-0-348" id="h19-0-348" class="i">+	c.rateMu.Lock()
</a><a href="#h19-0-349" id="h19-0-349" class="i">+	c.rate = response.Rate
</a><a href="#h19-0-350" id="h19-0-350" class="i">+	c.rateMu.Unlock()
</a><a href="#h19-0-351" id="h19-0-351" class="i">+
</a><a href="#h19-0-352" id="h19-0-352" class="i">+	err = CheckResponse(resp)
</a><a href="#h19-0-353" id="h19-0-353" class="i">+	if err != nil {
</a><a href="#h19-0-354" id="h19-0-354" class="i">+		// even though there was an error, we still return the response
</a><a href="#h19-0-355" id="h19-0-355" class="i">+		// in case the caller wants to inspect it further
</a><a href="#h19-0-356" id="h19-0-356" class="i">+		return response, err
</a><a href="#h19-0-357" id="h19-0-357" class="i">+	}
</a><a href="#h19-0-358" id="h19-0-358" class="i">+
</a><a href="#h19-0-359" id="h19-0-359" class="i">+	if v != nil {
</a><a href="#h19-0-360" id="h19-0-360" class="i">+		if w, ok := v.(io.Writer); ok {
</a><a href="#h19-0-361" id="h19-0-361" class="i">+			io.Copy(w, resp.Body)
</a><a href="#h19-0-362" id="h19-0-362" class="i">+		} else {
</a><a href="#h19-0-363" id="h19-0-363" class="i">+			err = json.NewDecoder(resp.Body).Decode(v)
</a><a href="#h19-0-364" id="h19-0-364" class="i">+			if err == io.EOF {
</a><a href="#h19-0-365" id="h19-0-365" class="i">+				err = nil // ignore EOF errors caused by empty response body
</a><a href="#h19-0-366" id="h19-0-366" class="i">+			}
</a><a href="#h19-0-367" id="h19-0-367" class="i">+		}
</a><a href="#h19-0-368" id="h19-0-368" class="i">+	}
</a><a href="#h19-0-369" id="h19-0-369" class="i">+
</a><a href="#h19-0-370" id="h19-0-370" class="i">+	return response, err
</a><a href="#h19-0-371" id="h19-0-371" class="i">+}
</a><a href="#h19-0-372" id="h19-0-372" class="i">+
</a><a href="#h19-0-373" id="h19-0-373" class="i">+/*
</a><a href="#h19-0-374" id="h19-0-374" class="i">+An ErrorResponse reports one or more errors caused by an API request.
</a><a href="#h19-0-375" id="h19-0-375" class="i">+
</a><a href="#h19-0-376" id="h19-0-376" class="i">+GitHub API docs: http://developer.github.com/v3/#client-errors
</a><a href="#h19-0-377" id="h19-0-377" class="i">+*/
</a><a href="#h19-0-378" id="h19-0-378" class="i">+type ErrorResponse struct {
</a><a href="#h19-0-379" id="h19-0-379" class="i">+	Response *http.Response // HTTP response that caused this error
</a><a href="#h19-0-380" id="h19-0-380" class="i">+	Message  string         `json:&quot;message&quot;` // error message
</a><a href="#h19-0-381" id="h19-0-381" class="i">+	Errors   []Error        `json:&quot;errors&quot;`  // more detail on individual errors
</a><a href="#h19-0-382" id="h19-0-382" class="i">+	// Block is only populated on certain types of errors such as code 451.
</a><a href="#h19-0-383" id="h19-0-383" class="i">+	// See https://developer.github.com/changes/2016-03-17-the-451-status-code-is-now-supported/
</a><a href="#h19-0-384" id="h19-0-384" class="i">+	// for more information.
</a><a href="#h19-0-385" id="h19-0-385" class="i">+	Block *struct {
</a><a href="#h19-0-386" id="h19-0-386" class="i">+		Reason    string     `json:&quot;reason,omitempty&quot;`
</a><a href="#h19-0-387" id="h19-0-387" class="i">+		CreatedAt *Timestamp `json:&quot;created_at,omitempty&quot;`
</a><a href="#h19-0-388" id="h19-0-388" class="i">+	} `json:&quot;block,omitempty&quot;`
</a><a href="#h19-0-389" id="h19-0-389" class="i">+}
</a><a href="#h19-0-390" id="h19-0-390" class="i">+
</a><a href="#h19-0-391" id="h19-0-391" class="i">+func (r *ErrorResponse) Error() string {
</a><a href="#h19-0-392" id="h19-0-392" class="i">+	return fmt.Sprintf(&quot;%v %v: %d %v %+v&quot;,
</a><a href="#h19-0-393" id="h19-0-393" class="i">+		r.Response.Request.Method, sanitizeURL(r.Response.Request.URL),
</a><a href="#h19-0-394" id="h19-0-394" class="i">+		r.Response.StatusCode, r.Message, r.Errors)
</a><a href="#h19-0-395" id="h19-0-395" class="i">+}
</a><a href="#h19-0-396" id="h19-0-396" class="i">+
</a><a href="#h19-0-397" id="h19-0-397" class="i">+// TwoFactorAuthError occurs when using HTTP Basic Authentication for a user
</a><a href="#h19-0-398" id="h19-0-398" class="i">+// that has two-factor authentication enabled.  The request can be reattempted
</a><a href="#h19-0-399" id="h19-0-399" class="i">+// by providing a one-time password in the request.
</a><a href="#h19-0-400" id="h19-0-400" class="i">+type TwoFactorAuthError ErrorResponse
</a><a href="#h19-0-401" id="h19-0-401" class="i">+
</a><a href="#h19-0-402" id="h19-0-402" class="i">+func (r *TwoFactorAuthError) Error() string { return (*ErrorResponse)(r).Error() }
</a><a href="#h19-0-403" id="h19-0-403" class="i">+
</a><a href="#h19-0-404" id="h19-0-404" class="i">+// RateLimitError occurs when GitHub returns 403 Forbidden response with a rate limit
</a><a href="#h19-0-405" id="h19-0-405" class="i">+// remaining value of 0, and error message starts with &quot;API rate limit exceeded for &quot;.
</a><a href="#h19-0-406" id="h19-0-406" class="i">+type RateLimitError struct {
</a><a href="#h19-0-407" id="h19-0-407" class="i">+	Rate     Rate           // Rate specifies last known rate limit for the client
</a><a href="#h19-0-408" id="h19-0-408" class="i">+	Response *http.Response // HTTP response that caused this error
</a><a href="#h19-0-409" id="h19-0-409" class="i">+	Message  string         `json:&quot;message&quot;` // error message
</a><a href="#h19-0-410" id="h19-0-410" class="i">+}
</a><a href="#h19-0-411" id="h19-0-411" class="i">+
</a><a href="#h19-0-412" id="h19-0-412" class="i">+func (r *RateLimitError) Error() string {
</a><a href="#h19-0-413" id="h19-0-413" class="i">+	return fmt.Sprintf(&quot;%v %v: %d %v; rate reset in %v&quot;,
</a><a href="#h19-0-414" id="h19-0-414" class="i">+		r.Response.Request.Method, sanitizeURL(r.Response.Request.URL),
</a><a href="#h19-0-415" id="h19-0-415" class="i">+		r.Response.StatusCode, r.Message, r.Rate.Reset.Time.Sub(time.Now()))
</a><a href="#h19-0-416" id="h19-0-416" class="i">+}
</a><a href="#h19-0-417" id="h19-0-417" class="i">+
</a><a href="#h19-0-418" id="h19-0-418" class="i">+// sanitizeURL redacts the client_secret parameter from the URL which may be
</a><a href="#h19-0-419" id="h19-0-419" class="i">+// exposed to the user, specifically in the ErrorResponse error message.
</a><a href="#h19-0-420" id="h19-0-420" class="i">+func sanitizeURL(uri *url.URL) *url.URL {
</a><a href="#h19-0-421" id="h19-0-421" class="i">+	if uri == nil {
</a><a href="#h19-0-422" id="h19-0-422" class="i">+		return nil
</a><a href="#h19-0-423" id="h19-0-423" class="i">+	}
</a><a href="#h19-0-424" id="h19-0-424" class="i">+	params := uri.Query()
</a><a href="#h19-0-425" id="h19-0-425" class="i">+	if len(params.Get(&quot;client_secret&quot;)) &gt; 0 {
</a><a href="#h19-0-426" id="h19-0-426" class="i">+		params.Set(&quot;client_secret&quot;, &quot;REDACTED&quot;)
</a><a href="#h19-0-427" id="h19-0-427" class="i">+		uri.RawQuery = params.Encode()
</a><a href="#h19-0-428" id="h19-0-428" class="i">+	}
</a><a href="#h19-0-429" id="h19-0-429" class="i">+	return uri
</a><a href="#h19-0-430" id="h19-0-430" class="i">+}
</a><a href="#h19-0-431" id="h19-0-431" class="i">+
</a><a href="#h19-0-432" id="h19-0-432" class="i">+/*
</a><a href="#h19-0-433" id="h19-0-433" class="i">+An Error reports more details on an individual error in an ErrorResponse.
</a><a href="#h19-0-434" id="h19-0-434" class="i">+These are the possible validation error codes:
</a><a href="#h19-0-435" id="h19-0-435" class="i">+
</a><a href="#h19-0-436" id="h19-0-436" class="i">+    missing:
</a><a href="#h19-0-437" id="h19-0-437" class="i">+        resource does not exist
</a><a href="#h19-0-438" id="h19-0-438" class="i">+    missing_field:
</a><a href="#h19-0-439" id="h19-0-439" class="i">+        a required field on a resource has not been set
</a><a href="#h19-0-440" id="h19-0-440" class="i">+    invalid:
</a><a href="#h19-0-441" id="h19-0-441" class="i">+        the formatting of a field is invalid
</a><a href="#h19-0-442" id="h19-0-442" class="i">+    already_exists:
</a><a href="#h19-0-443" id="h19-0-443" class="i">+        another resource has the same valid as this field
</a><a href="#h19-0-444" id="h19-0-444" class="i">+
</a><a href="#h19-0-445" id="h19-0-445" class="i">+GitHub API docs: http://developer.github.com/v3/#client-errors
</a><a href="#h19-0-446" id="h19-0-446" class="i">+*/
</a><a href="#h19-0-447" id="h19-0-447" class="i">+type Error struct {
</a><a href="#h19-0-448" id="h19-0-448" class="i">+	Resource string `json:&quot;resource&quot;` // resource on which the error occurred
</a><a href="#h19-0-449" id="h19-0-449" class="i">+	Field    string `json:&quot;field&quot;`    // field on which the error occurred
</a><a href="#h19-0-450" id="h19-0-450" class="i">+	Code     string `json:&quot;code&quot;`     // validation error code
</a><a href="#h19-0-451" id="h19-0-451" class="i">+}
</a><a href="#h19-0-452" id="h19-0-452" class="i">+
</a><a href="#h19-0-453" id="h19-0-453" class="i">+func (e *Error) Error() string {
</a><a href="#h19-0-454" id="h19-0-454" class="i">+	return fmt.Sprintf(&quot;%v error caused by %v field on %v resource&quot;,
</a><a href="#h19-0-455" id="h19-0-455" class="i">+		e.Code, e.Field, e.Resource)
</a><a href="#h19-0-456" id="h19-0-456" class="i">+}
</a><a href="#h19-0-457" id="h19-0-457" class="i">+
</a><a href="#h19-0-458" id="h19-0-458" class="i">+// CheckResponse checks the API response for errors, and returns them if
</a><a href="#h19-0-459" id="h19-0-459" class="i">+// present.  A response is considered an error if it has a status code outside
</a><a href="#h19-0-460" id="h19-0-460" class="i">+// the 200 range.  API error responses are expected to have either no response
</a><a href="#h19-0-461" id="h19-0-461" class="i">+// body, or a JSON response body that maps to ErrorResponse.  Any other
</a><a href="#h19-0-462" id="h19-0-462" class="i">+// response body will be silently ignored.
</a><a href="#h19-0-463" id="h19-0-463" class="i">+//
</a><a href="#h19-0-464" id="h19-0-464" class="i">+// The error type will be *RateLimitError for rate limit exceeded errors,
</a><a href="#h19-0-465" id="h19-0-465" class="i">+// and *TwoFactorAuthError for two-factor authentication errors.
</a><a href="#h19-0-466" id="h19-0-466" class="i">+func CheckResponse(r *http.Response) error {
</a><a href="#h19-0-467" id="h19-0-467" class="i">+	if c := r.StatusCode; 200 &lt;= c &amp;&amp; c &lt;= 299 {
</a><a href="#h19-0-468" id="h19-0-468" class="i">+		return nil
</a><a href="#h19-0-469" id="h19-0-469" class="i">+	}
</a><a href="#h19-0-470" id="h19-0-470" class="i">+	errorResponse := &amp;ErrorResponse{Response: r}
</a><a href="#h19-0-471" id="h19-0-471" class="i">+	data, err := ioutil.ReadAll(r.Body)
</a><a href="#h19-0-472" id="h19-0-472" class="i">+	if err == nil &amp;&amp; data != nil {
</a><a href="#h19-0-473" id="h19-0-473" class="i">+		json.Unmarshal(data, errorResponse)
</a><a href="#h19-0-474" id="h19-0-474" class="i">+	}
</a><a href="#h19-0-475" id="h19-0-475" class="i">+	switch {
</a><a href="#h19-0-476" id="h19-0-476" class="i">+	case r.StatusCode == http.StatusUnauthorized &amp;&amp; strings.HasPrefix(r.Header.Get(headerOTP), &quot;required&quot;):
</a><a href="#h19-0-477" id="h19-0-477" class="i">+		return (*TwoFactorAuthError)(errorResponse)
</a><a href="#h19-0-478" id="h19-0-478" class="i">+	case r.StatusCode == http.StatusForbidden &amp;&amp; r.Header.Get(headerRateRemaining) == &quot;0&quot; &amp;&amp; strings.HasPrefix(errorResponse.Message, &quot;API rate limit exceeded for &quot;):
</a><a href="#h19-0-479" id="h19-0-479" class="i">+		return &amp;RateLimitError{
</a><a href="#h19-0-480" id="h19-0-480" class="i">+			Rate:     parseRate(r),
</a><a href="#h19-0-481" id="h19-0-481" class="i">+			Response: errorResponse.Response,
</a><a href="#h19-0-482" id="h19-0-482" class="i">+			Message:  errorResponse.Message,
</a><a href="#h19-0-483" id="h19-0-483" class="i">+		}
</a><a href="#h19-0-484" id="h19-0-484" class="i">+	default:
</a><a href="#h19-0-485" id="h19-0-485" class="i">+		return errorResponse
</a><a href="#h19-0-486" id="h19-0-486" class="i">+	}
</a><a href="#h19-0-487" id="h19-0-487" class="i">+}
</a><a href="#h19-0-488" id="h19-0-488" class="i">+
</a><a href="#h19-0-489" id="h19-0-489" class="i">+// parseBoolResponse determines the boolean result from a GitHub API response.
</a><a href="#h19-0-490" id="h19-0-490" class="i">+// Several GitHub API methods return boolean responses indicated by the HTTP
</a><a href="#h19-0-491" id="h19-0-491" class="i">+// status code in the response (true indicated by a 204, false indicated by a
</a><a href="#h19-0-492" id="h19-0-492" class="i">+// 404).  This helper function will determine that result and hide the 404
</a><a href="#h19-0-493" id="h19-0-493" class="i">+// error if present.  Any other error will be returned through as-is.
</a><a href="#h19-0-494" id="h19-0-494" class="i">+func parseBoolResponse(err error) (bool, error) {
</a><a href="#h19-0-495" id="h19-0-495" class="i">+	if err == nil {
</a><a href="#h19-0-496" id="h19-0-496" class="i">+		return true, nil
</a><a href="#h19-0-497" id="h19-0-497" class="i">+	}
</a><a href="#h19-0-498" id="h19-0-498" class="i">+
</a><a href="#h19-0-499" id="h19-0-499" class="i">+	if err, ok := err.(*ErrorResponse); ok &amp;&amp; err.Response.StatusCode == http.StatusNotFound {
</a><a href="#h19-0-500" id="h19-0-500" class="i">+		// Simply false.  In this one case, we do not pass the error through.
</a><a href="#h19-0-501" id="h19-0-501" class="i">+		return false, nil
</a><a href="#h19-0-502" id="h19-0-502" class="i">+	}
</a><a href="#h19-0-503" id="h19-0-503" class="i">+
</a><a href="#h19-0-504" id="h19-0-504" class="i">+	// some other real error occurred
</a><a href="#h19-0-505" id="h19-0-505" class="i">+	return false, err
</a><a href="#h19-0-506" id="h19-0-506" class="i">+}
</a><a href="#h19-0-507" id="h19-0-507" class="i">+
</a><a href="#h19-0-508" id="h19-0-508" class="i">+// Rate represents the rate limit for the current client.
</a><a href="#h19-0-509" id="h19-0-509" class="i">+type Rate struct {
</a><a href="#h19-0-510" id="h19-0-510" class="i">+	// The number of requests per hour the client is currently limited to.
</a><a href="#h19-0-511" id="h19-0-511" class="i">+	Limit int `json:&quot;limit&quot;`
</a><a href="#h19-0-512" id="h19-0-512" class="i">+
</a><a href="#h19-0-513" id="h19-0-513" class="i">+	// The number of remaining requests the client can make this hour.
</a><a href="#h19-0-514" id="h19-0-514" class="i">+	Remaining int `json:&quot;remaining&quot;`
</a><a href="#h19-0-515" id="h19-0-515" class="i">+
</a><a href="#h19-0-516" id="h19-0-516" class="i">+	// The time at which the current rate limit will reset.
</a><a href="#h19-0-517" id="h19-0-517" class="i">+	Reset Timestamp `json:&quot;reset&quot;`
</a><a href="#h19-0-518" id="h19-0-518" class="i">+}
</a><a href="#h19-0-519" id="h19-0-519" class="i">+
</a><a href="#h19-0-520" id="h19-0-520" class="i">+func (r Rate) String() string {
</a><a href="#h19-0-521" id="h19-0-521" class="i">+	return Stringify(r)
</a><a href="#h19-0-522" id="h19-0-522" class="i">+}
</a><a href="#h19-0-523" id="h19-0-523" class="i">+
</a><a href="#h19-0-524" id="h19-0-524" class="i">+// RateLimits represents the rate limits for the current client.
</a><a href="#h19-0-525" id="h19-0-525" class="i">+type RateLimits struct {
</a><a href="#h19-0-526" id="h19-0-526" class="i">+	// The rate limit for non-search API requests.  Unauthenticated
</a><a href="#h19-0-527" id="h19-0-527" class="i">+	// requests are limited to 60 per hour.  Authenticated requests are
</a><a href="#h19-0-528" id="h19-0-528" class="i">+	// limited to 5,000 per hour.
</a><a href="#h19-0-529" id="h19-0-529" class="i">+	Core *Rate `json:&quot;core&quot;`
</a><a href="#h19-0-530" id="h19-0-530" class="i">+
</a><a href="#h19-0-531" id="h19-0-531" class="i">+	// The rate limit for search API requests.  Unauthenticated requests
</a><a href="#h19-0-532" id="h19-0-532" class="i">+	// are limited to 5 requests per minutes.  Authenticated requests are
</a><a href="#h19-0-533" id="h19-0-533" class="i">+	// limited to 20 per minute.
</a><a href="#h19-0-534" id="h19-0-534" class="i">+	//
</a><a href="#h19-0-535" id="h19-0-535" class="i">+	// GitHub API docs: https://developer.github.com/v3/search/#rate-limit
</a><a href="#h19-0-536" id="h19-0-536" class="i">+	Search *Rate `json:&quot;search&quot;`
</a><a href="#h19-0-537" id="h19-0-537" class="i">+}
</a><a href="#h19-0-538" id="h19-0-538" class="i">+
</a><a href="#h19-0-539" id="h19-0-539" class="i">+func (r RateLimits) String() string {
</a><a href="#h19-0-540" id="h19-0-540" class="i">+	return Stringify(r)
</a><a href="#h19-0-541" id="h19-0-541" class="i">+}
</a><a href="#h19-0-542" id="h19-0-542" class="i">+
</a><a href="#h19-0-543" id="h19-0-543" class="i">+// Deprecated: RateLimit is deprecated, use RateLimits instead.
</a><a href="#h19-0-544" id="h19-0-544" class="i">+func (c *Client) RateLimit() (*Rate, *Response, error) {
</a><a href="#h19-0-545" id="h19-0-545" class="i">+	limits, resp, err := c.RateLimits()
</a><a href="#h19-0-546" id="h19-0-546" class="i">+	if limits == nil {
</a><a href="#h19-0-547" id="h19-0-547" class="i">+		return nil, nil, err
</a><a href="#h19-0-548" id="h19-0-548" class="i">+	}
</a><a href="#h19-0-549" id="h19-0-549" class="i">+
</a><a href="#h19-0-550" id="h19-0-550" class="i">+	return limits.Core, resp, err
</a><a href="#h19-0-551" id="h19-0-551" class="i">+}
</a><a href="#h19-0-552" id="h19-0-552" class="i">+
</a><a href="#h19-0-553" id="h19-0-553" class="i">+// RateLimits returns the rate limits for the current client.
</a><a href="#h19-0-554" id="h19-0-554" class="i">+func (c *Client) RateLimits() (*RateLimits, *Response, error) {
</a><a href="#h19-0-555" id="h19-0-555" class="i">+	req, err := c.NewRequest(&quot;GET&quot;, &quot;rate_limit&quot;, nil)
</a><a href="#h19-0-556" id="h19-0-556" class="i">+	if err != nil {
</a><a href="#h19-0-557" id="h19-0-557" class="i">+		return nil, nil, err
</a><a href="#h19-0-558" id="h19-0-558" class="i">+	}
</a><a href="#h19-0-559" id="h19-0-559" class="i">+
</a><a href="#h19-0-560" id="h19-0-560" class="i">+	response := new(struct {
</a><a href="#h19-0-561" id="h19-0-561" class="i">+		Resources *RateLimits `json:&quot;resources&quot;`
</a><a href="#h19-0-562" id="h19-0-562" class="i">+	})
</a><a href="#h19-0-563" id="h19-0-563" class="i">+	resp, err := c.Do(req, response)
</a><a href="#h19-0-564" id="h19-0-564" class="i">+	if err != nil {
</a><a href="#h19-0-565" id="h19-0-565" class="i">+		return nil, nil, err
</a><a href="#h19-0-566" id="h19-0-566" class="i">+	}
</a><a href="#h19-0-567" id="h19-0-567" class="i">+
</a><a href="#h19-0-568" id="h19-0-568" class="i">+	return response.Resources, resp, err
</a><a href="#h19-0-569" id="h19-0-569" class="i">+}
</a><a href="#h19-0-570" id="h19-0-570" class="i">+
</a><a href="#h19-0-571" id="h19-0-571" class="i">+/*
</a><a href="#h19-0-572" id="h19-0-572" class="i">+UnauthenticatedRateLimitedTransport allows you to make unauthenticated calls
</a><a href="#h19-0-573" id="h19-0-573" class="i">+that need to use a higher rate limit associated with your OAuth application.
</a><a href="#h19-0-574" id="h19-0-574" class="i">+
</a><a href="#h19-0-575" id="h19-0-575" class="i">+	t := &amp;github.UnauthenticatedRateLimitedTransport{
</a><a href="#h19-0-576" id="h19-0-576" class="i">+		ClientID:     &quot;your app&#39;s client ID&quot;,
</a><a href="#h19-0-577" id="h19-0-577" class="i">+		ClientSecret: &quot;your app&#39;s client secret&quot;,
</a><a href="#h19-0-578" id="h19-0-578" class="i">+	}
</a><a href="#h19-0-579" id="h19-0-579" class="i">+	client := github.NewClient(t.Client())
</a><a href="#h19-0-580" id="h19-0-580" class="i">+
</a><a href="#h19-0-581" id="h19-0-581" class="i">+This will append the querystring params client_id=xxx&amp;client_secret=yyy to all
</a><a href="#h19-0-582" id="h19-0-582" class="i">+requests.
</a><a href="#h19-0-583" id="h19-0-583" class="i">+
</a><a href="#h19-0-584" id="h19-0-584" class="i">+See http://developer.github.com/v3/#unauthenticated-rate-limited-requests for
</a><a href="#h19-0-585" id="h19-0-585" class="i">+more information.
</a><a href="#h19-0-586" id="h19-0-586" class="i">+*/
</a><a href="#h19-0-587" id="h19-0-587" class="i">+type UnauthenticatedRateLimitedTransport struct {
</a><a href="#h19-0-588" id="h19-0-588" class="i">+	// ClientID is the GitHub OAuth client ID of the current application, which
</a><a href="#h19-0-589" id="h19-0-589" class="i">+	// can be found by selecting its entry in the list at
</a><a href="#h19-0-590" id="h19-0-590" class="i">+	// https://github.com/settings/applications.
</a><a href="#h19-0-591" id="h19-0-591" class="i">+	ClientID string
</a><a href="#h19-0-592" id="h19-0-592" class="i">+
</a><a href="#h19-0-593" id="h19-0-593" class="i">+	// ClientSecret is the GitHub OAuth client secret of the current
</a><a href="#h19-0-594" id="h19-0-594" class="i">+	// application.
</a><a href="#h19-0-595" id="h19-0-595" class="i">+	ClientSecret string
</a><a href="#h19-0-596" id="h19-0-596" class="i">+
</a><a href="#h19-0-597" id="h19-0-597" class="i">+	// Transport is the underlying HTTP transport to use when making requests.
</a><a href="#h19-0-598" id="h19-0-598" class="i">+	// It will default to http.DefaultTransport if nil.
</a><a href="#h19-0-599" id="h19-0-599" class="i">+	Transport http.RoundTripper
</a><a href="#h19-0-600" id="h19-0-600" class="i">+}
</a><a href="#h19-0-601" id="h19-0-601" class="i">+
</a><a href="#h19-0-602" id="h19-0-602" class="i">+// RoundTrip implements the RoundTripper interface.
</a><a href="#h19-0-603" id="h19-0-603" class="i">+func (t *UnauthenticatedRateLimitedTransport) RoundTrip(req *http.Request) (*http.Response, error) {
</a><a href="#h19-0-604" id="h19-0-604" class="i">+	if t.ClientID == &quot;&quot; {
</a><a href="#h19-0-605" id="h19-0-605" class="i">+		return nil, errors.New(&quot;t.ClientID is empty&quot;)
</a><a href="#h19-0-606" id="h19-0-606" class="i">+	}
</a><a href="#h19-0-607" id="h19-0-607" class="i">+	if t.ClientSecret == &quot;&quot; {
</a><a href="#h19-0-608" id="h19-0-608" class="i">+		return nil, errors.New(&quot;t.ClientSecret is empty&quot;)
</a><a href="#h19-0-609" id="h19-0-609" class="i">+	}
</a><a href="#h19-0-610" id="h19-0-610" class="i">+
</a><a href="#h19-0-611" id="h19-0-611" class="i">+	// To set extra querystring params, we must make a copy of the Request so
</a><a href="#h19-0-612" id="h19-0-612" class="i">+	// that we don&#39;t modify the Request we were given. This is required by the
</a><a href="#h19-0-613" id="h19-0-613" class="i">+	// specification of http.RoundTripper.
</a><a href="#h19-0-614" id="h19-0-614" class="i">+	req = cloneRequest(req)
</a><a href="#h19-0-615" id="h19-0-615" class="i">+	q := req.URL.Query()
</a><a href="#h19-0-616" id="h19-0-616" class="i">+	q.Set(&quot;client_id&quot;, t.ClientID)
</a><a href="#h19-0-617" id="h19-0-617" class="i">+	q.Set(&quot;client_secret&quot;, t.ClientSecret)
</a><a href="#h19-0-618" id="h19-0-618" class="i">+	req.URL.RawQuery = q.Encode()
</a><a href="#h19-0-619" id="h19-0-619" class="i">+
</a><a href="#h19-0-620" id="h19-0-620" class="i">+	// Make the HTTP request.
</a><a href="#h19-0-621" id="h19-0-621" class="i">+	return t.transport().RoundTrip(req)
</a><a href="#h19-0-622" id="h19-0-622" class="i">+}
</a><a href="#h19-0-623" id="h19-0-623" class="i">+
</a><a href="#h19-0-624" id="h19-0-624" class="i">+// Client returns an *http.Client that makes requests which are subject to the
</a><a href="#h19-0-625" id="h19-0-625" class="i">+// rate limit of your OAuth application.
</a><a href="#h19-0-626" id="h19-0-626" class="i">+func (t *UnauthenticatedRateLimitedTransport) Client() *http.Client {
</a><a href="#h19-0-627" id="h19-0-627" class="i">+	return &amp;http.Client{Transport: t}
</a><a href="#h19-0-628" id="h19-0-628" class="i">+}
</a><a href="#h19-0-629" id="h19-0-629" class="i">+
</a><a href="#h19-0-630" id="h19-0-630" class="i">+func (t *UnauthenticatedRateLimitedTransport) transport() http.RoundTripper {
</a><a href="#h19-0-631" id="h19-0-631" class="i">+	if t.Transport != nil {
</a><a href="#h19-0-632" id="h19-0-632" class="i">+		return t.Transport
</a><a href="#h19-0-633" id="h19-0-633" class="i">+	}
</a><a href="#h19-0-634" id="h19-0-634" class="i">+	return http.DefaultTransport
</a><a href="#h19-0-635" id="h19-0-635" class="i">+}
</a><a href="#h19-0-636" id="h19-0-636" class="i">+
</a><a href="#h19-0-637" id="h19-0-637" class="i">+// BasicAuthTransport is an http.RoundTripper that authenticates all requests
</a><a href="#h19-0-638" id="h19-0-638" class="i">+// using HTTP Basic Authentication with the provided username and password.  It
</a><a href="#h19-0-639" id="h19-0-639" class="i">+// additionally supports users who have two-factor authentication enabled on
</a><a href="#h19-0-640" id="h19-0-640" class="i">+// their GitHub account.
</a><a href="#h19-0-641" id="h19-0-641" class="i">+type BasicAuthTransport struct {
</a><a href="#h19-0-642" id="h19-0-642" class="i">+	Username string // GitHub username
</a><a href="#h19-0-643" id="h19-0-643" class="i">+	Password string // GitHub password
</a><a href="#h19-0-644" id="h19-0-644" class="i">+	OTP      string // one-time password for users with two-factor auth enabled
</a><a href="#h19-0-645" id="h19-0-645" class="i">+
</a><a href="#h19-0-646" id="h19-0-646" class="i">+	// Transport is the underlying HTTP transport to use when making requests.
</a><a href="#h19-0-647" id="h19-0-647" class="i">+	// It will default to http.DefaultTransport if nil.
</a><a href="#h19-0-648" id="h19-0-648" class="i">+	Transport http.RoundTripper
</a><a href="#h19-0-649" id="h19-0-649" class="i">+}
</a><a href="#h19-0-650" id="h19-0-650" class="i">+
</a><a href="#h19-0-651" id="h19-0-651" class="i">+// RoundTrip implements the RoundTripper interface.
</a><a href="#h19-0-652" id="h19-0-652" class="i">+func (t *BasicAuthTransport) RoundTrip(req *http.Request) (*http.Response, error) {
</a><a href="#h19-0-653" id="h19-0-653" class="i">+	req = cloneRequest(req) // per RoundTrip contract
</a><a href="#h19-0-654" id="h19-0-654" class="i">+	req.SetBasicAuth(t.Username, t.Password)
</a><a href="#h19-0-655" id="h19-0-655" class="i">+	if t.OTP != &quot;&quot; {
</a><a href="#h19-0-656" id="h19-0-656" class="i">+		req.Header.Add(headerOTP, t.OTP)
</a><a href="#h19-0-657" id="h19-0-657" class="i">+	}
</a><a href="#h19-0-658" id="h19-0-658" class="i">+	return t.transport().RoundTrip(req)
</a><a href="#h19-0-659" id="h19-0-659" class="i">+}
</a><a href="#h19-0-660" id="h19-0-660" class="i">+
</a><a href="#h19-0-661" id="h19-0-661" class="i">+// Client returns an *http.Client that makes requests that are authenticated
</a><a href="#h19-0-662" id="h19-0-662" class="i">+// using HTTP Basic Authentication.
</a><a href="#h19-0-663" id="h19-0-663" class="i">+func (t *BasicAuthTransport) Client() *http.Client {
</a><a href="#h19-0-664" id="h19-0-664" class="i">+	return &amp;http.Client{Transport: t}
</a><a href="#h19-0-665" id="h19-0-665" class="i">+}
</a><a href="#h19-0-666" id="h19-0-666" class="i">+
</a><a href="#h19-0-667" id="h19-0-667" class="i">+func (t *BasicAuthTransport) transport() http.RoundTripper {
</a><a href="#h19-0-668" id="h19-0-668" class="i">+	if t.Transport != nil {
</a><a href="#h19-0-669" id="h19-0-669" class="i">+		return t.Transport
</a><a href="#h19-0-670" id="h19-0-670" class="i">+	}
</a><a href="#h19-0-671" id="h19-0-671" class="i">+	return http.DefaultTransport
</a><a href="#h19-0-672" id="h19-0-672" class="i">+}
</a><a href="#h19-0-673" id="h19-0-673" class="i">+
</a><a href="#h19-0-674" id="h19-0-674" class="i">+// cloneRequest returns a clone of the provided *http.Request. The clone is a
</a><a href="#h19-0-675" id="h19-0-675" class="i">+// shallow copy of the struct and its Header map.
</a><a href="#h19-0-676" id="h19-0-676" class="i">+func cloneRequest(r *http.Request) *http.Request {
</a><a href="#h19-0-677" id="h19-0-677" class="i">+	// shallow copy of the struct
</a><a href="#h19-0-678" id="h19-0-678" class="i">+	r2 := new(http.Request)
</a><a href="#h19-0-679" id="h19-0-679" class="i">+	*r2 = *r
</a><a href="#h19-0-680" id="h19-0-680" class="i">+	// deep copy of the Header
</a><a href="#h19-0-681" id="h19-0-681" class="i">+	r2.Header = make(http.Header, len(r.Header))
</a><a href="#h19-0-682" id="h19-0-682" class="i">+	for k, s := range r.Header {
</a><a href="#h19-0-683" id="h19-0-683" class="i">+		r2.Header[k] = append([]string(nil), s...)
</a><a href="#h19-0-684" id="h19-0-684" class="i">+	}
</a><a href="#h19-0-685" id="h19-0-685" class="i">+	return r2
</a><a href="#h19-0-686" id="h19-0-686" class="i">+}
</a><a href="#h19-0-687" id="h19-0-687" class="i">+
</a><a href="#h19-0-688" id="h19-0-688" class="i">+// Bool is a helper routine that allocates a new bool value
</a><a href="#h19-0-689" id="h19-0-689" class="i">+// to store v and returns a pointer to it.
</a><a href="#h19-0-690" id="h19-0-690" class="i">+func Bool(v bool) *bool {
</a><a href="#h19-0-691" id="h19-0-691" class="i">+	p := new(bool)
</a><a href="#h19-0-692" id="h19-0-692" class="i">+	*p = v
</a><a href="#h19-0-693" id="h19-0-693" class="i">+	return p
</a><a href="#h19-0-694" id="h19-0-694" class="i">+}
</a><a href="#h19-0-695" id="h19-0-695" class="i">+
</a><a href="#h19-0-696" id="h19-0-696" class="i">+// Int is a helper routine that allocates a new int32 value
</a><a href="#h19-0-697" id="h19-0-697" class="i">+// to store v and returns a pointer to it, but unlike Int32
</a><a href="#h19-0-698" id="h19-0-698" class="i">+// its argument value is an int.
</a><a href="#h19-0-699" id="h19-0-699" class="i">+func Int(v int) *int {
</a><a href="#h19-0-700" id="h19-0-700" class="i">+	p := new(int)
</a><a href="#h19-0-701" id="h19-0-701" class="i">+	*p = v
</a><a href="#h19-0-702" id="h19-0-702" class="i">+	return p
</a><a href="#h19-0-703" id="h19-0-703" class="i">+}
</a><a href="#h19-0-704" id="h19-0-704" class="i">+
</a><a href="#h19-0-705" id="h19-0-705" class="i">+// String is a helper routine that allocates a new string value
</a><a href="#h19-0-706" id="h19-0-706" class="i">+// to store v and returns a pointer to it.
</a><a href="#h19-0-707" id="h19-0-707" class="i">+func String(v string) *string {
</a><a href="#h19-0-708" id="h19-0-708" class="i">+	p := new(string)
</a><a href="#h19-0-709" id="h19-0-709" class="i">+	*p = v
</a><a href="#h19-0-710" id="h19-0-710" class="i">+	return p
</a><a href="#h19-0-711" id="h19-0-711" class="i">+}
</a><b>diff --git a/<a id="h20" href="../file/vendor/github.com/google/go-github/github/gitignore.go">vendor/github.com/google/go-github/github/gitignore.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/gitignore.go">vendor/github.com/google/go-github/github/gitignore.go</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -0,0 +1,63 @@
</a><a href="#h20-0-0" id="h20-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h20-0-1" id="h20-0-1" class="i">+//
</a><a href="#h20-0-2" id="h20-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h20-0-3" id="h20-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h20-0-4" id="h20-0-4" class="i">+
</a><a href="#h20-0-5" id="h20-0-5" class="i">+package github
</a><a href="#h20-0-6" id="h20-0-6" class="i">+
</a><a href="#h20-0-7" id="h20-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h20-0-8" id="h20-0-8" class="i">+
</a><a href="#h20-0-9" id="h20-0-9" class="i">+// GitignoresService provides access to the gitignore related functions in the
</a><a href="#h20-0-10" id="h20-0-10" class="i">+// GitHub API.
</a><a href="#h20-0-11" id="h20-0-11" class="i">+//
</a><a href="#h20-0-12" id="h20-0-12" class="i">+// GitHub API docs: http://developer.github.com/v3/gitignore/
</a><a href="#h20-0-13" id="h20-0-13" class="i">+type GitignoresService struct {
</a><a href="#h20-0-14" id="h20-0-14" class="i">+	client *Client
</a><a href="#h20-0-15" id="h20-0-15" class="i">+}
</a><a href="#h20-0-16" id="h20-0-16" class="i">+
</a><a href="#h20-0-17" id="h20-0-17" class="i">+// Gitignore represents a .gitignore file as returned by the GitHub API.
</a><a href="#h20-0-18" id="h20-0-18" class="i">+type Gitignore struct {
</a><a href="#h20-0-19" id="h20-0-19" class="i">+	Name   *string `json:&quot;name,omitempty&quot;`
</a><a href="#h20-0-20" id="h20-0-20" class="i">+	Source *string `json:&quot;source,omitempty&quot;`
</a><a href="#h20-0-21" id="h20-0-21" class="i">+}
</a><a href="#h20-0-22" id="h20-0-22" class="i">+
</a><a href="#h20-0-23" id="h20-0-23" class="i">+func (g Gitignore) String() string {
</a><a href="#h20-0-24" id="h20-0-24" class="i">+	return Stringify(g)
</a><a href="#h20-0-25" id="h20-0-25" class="i">+}
</a><a href="#h20-0-26" id="h20-0-26" class="i">+
</a><a href="#h20-0-27" id="h20-0-27" class="i">+// List all available Gitignore templates.
</a><a href="#h20-0-28" id="h20-0-28" class="i">+//
</a><a href="#h20-0-29" id="h20-0-29" class="i">+// http://developer.github.com/v3/gitignore/#listing-available-templates
</a><a href="#h20-0-30" id="h20-0-30" class="i">+func (s GitignoresService) List() ([]string, *Response, error) {
</a><a href="#h20-0-31" id="h20-0-31" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, &quot;gitignore/templates&quot;, nil)
</a><a href="#h20-0-32" id="h20-0-32" class="i">+	if err != nil {
</a><a href="#h20-0-33" id="h20-0-33" class="i">+		return nil, nil, err
</a><a href="#h20-0-34" id="h20-0-34" class="i">+	}
</a><a href="#h20-0-35" id="h20-0-35" class="i">+
</a><a href="#h20-0-36" id="h20-0-36" class="i">+	availableTemplates := new([]string)
</a><a href="#h20-0-37" id="h20-0-37" class="i">+	resp, err := s.client.Do(req, availableTemplates)
</a><a href="#h20-0-38" id="h20-0-38" class="i">+	if err != nil {
</a><a href="#h20-0-39" id="h20-0-39" class="i">+		return nil, resp, err
</a><a href="#h20-0-40" id="h20-0-40" class="i">+	}
</a><a href="#h20-0-41" id="h20-0-41" class="i">+
</a><a href="#h20-0-42" id="h20-0-42" class="i">+	return *availableTemplates, resp, err
</a><a href="#h20-0-43" id="h20-0-43" class="i">+}
</a><a href="#h20-0-44" id="h20-0-44" class="i">+
</a><a href="#h20-0-45" id="h20-0-45" class="i">+// Get a Gitignore by name.
</a><a href="#h20-0-46" id="h20-0-46" class="i">+//
</a><a href="#h20-0-47" id="h20-0-47" class="i">+// http://developer.github.com/v3/gitignore/#get-a-single-template
</a><a href="#h20-0-48" id="h20-0-48" class="i">+func (s GitignoresService) Get(name string) (*Gitignore, *Response, error) {
</a><a href="#h20-0-49" id="h20-0-49" class="i">+	u := fmt.Sprintf(&quot;gitignore/templates/%v&quot;, name)
</a><a href="#h20-0-50" id="h20-0-50" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h20-0-51" id="h20-0-51" class="i">+	if err != nil {
</a><a href="#h20-0-52" id="h20-0-52" class="i">+		return nil, nil, err
</a><a href="#h20-0-53" id="h20-0-53" class="i">+	}
</a><a href="#h20-0-54" id="h20-0-54" class="i">+
</a><a href="#h20-0-55" id="h20-0-55" class="i">+	gitignore := new(Gitignore)
</a><a href="#h20-0-56" id="h20-0-56" class="i">+	resp, err := s.client.Do(req, gitignore)
</a><a href="#h20-0-57" id="h20-0-57" class="i">+	if err != nil {
</a><a href="#h20-0-58" id="h20-0-58" class="i">+		return nil, resp, err
</a><a href="#h20-0-59" id="h20-0-59" class="i">+	}
</a><a href="#h20-0-60" id="h20-0-60" class="i">+
</a><a href="#h20-0-61" id="h20-0-61" class="i">+	return gitignore, resp, err
</a><a href="#h20-0-62" id="h20-0-62" class="i">+}
</a><b>diff --git a/<a id="h21" href="../file/vendor/github.com/google/go-github/github/issues.go">vendor/github.com/google/go-github/github/issues.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/issues.go">vendor/github.com/google/go-github/github/issues.go</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -0,0 +1,294 @@
</a><a href="#h21-0-0" id="h21-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h21-0-1" id="h21-0-1" class="i">+//
</a><a href="#h21-0-2" id="h21-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h21-0-3" id="h21-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h21-0-4" id="h21-0-4" class="i">+
</a><a href="#h21-0-5" id="h21-0-5" class="i">+package github
</a><a href="#h21-0-6" id="h21-0-6" class="i">+
</a><a href="#h21-0-7" id="h21-0-7" class="i">+import (
</a><a href="#h21-0-8" id="h21-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h21-0-9" id="h21-0-9" class="i">+	&quot;time&quot;
</a><a href="#h21-0-10" id="h21-0-10" class="i">+)
</a><a href="#h21-0-11" id="h21-0-11" class="i">+
</a><a href="#h21-0-12" id="h21-0-12" class="i">+// IssuesService handles communication with the issue related
</a><a href="#h21-0-13" id="h21-0-13" class="i">+// methods of the GitHub API.
</a><a href="#h21-0-14" id="h21-0-14" class="i">+//
</a><a href="#h21-0-15" id="h21-0-15" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/
</a><a href="#h21-0-16" id="h21-0-16" class="i">+type IssuesService struct {
</a><a href="#h21-0-17" id="h21-0-17" class="i">+	client *Client
</a><a href="#h21-0-18" id="h21-0-18" class="i">+}
</a><a href="#h21-0-19" id="h21-0-19" class="i">+
</a><a href="#h21-0-20" id="h21-0-20" class="i">+// Issue represents a GitHub issue on a repository.
</a><a href="#h21-0-21" id="h21-0-21" class="i">+type Issue struct {
</a><a href="#h21-0-22" id="h21-0-22" class="i">+	Number           *int              `json:&quot;number,omitempty&quot;`
</a><a href="#h21-0-23" id="h21-0-23" class="i">+	State            *string           `json:&quot;state,omitempty&quot;`
</a><a href="#h21-0-24" id="h21-0-24" class="i">+	Title            *string           `json:&quot;title,omitempty&quot;`
</a><a href="#h21-0-25" id="h21-0-25" class="i">+	Body             *string           `json:&quot;body,omitempty&quot;`
</a><a href="#h21-0-26" id="h21-0-26" class="i">+	User             *User             `json:&quot;user,omitempty&quot;`
</a><a href="#h21-0-27" id="h21-0-27" class="i">+	Labels           []Label           `json:&quot;labels,omitempty&quot;`
</a><a href="#h21-0-28" id="h21-0-28" class="i">+	Assignee         *User             `json:&quot;assignee,omitempty&quot;`
</a><a href="#h21-0-29" id="h21-0-29" class="i">+	Comments         *int              `json:&quot;comments,omitempty&quot;`
</a><a href="#h21-0-30" id="h21-0-30" class="i">+	ClosedAt         *time.Time        `json:&quot;closed_at,omitempty&quot;`
</a><a href="#h21-0-31" id="h21-0-31" class="i">+	CreatedAt        *time.Time        `json:&quot;created_at,omitempty&quot;`
</a><a href="#h21-0-32" id="h21-0-32" class="i">+	UpdatedAt        *time.Time        `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h21-0-33" id="h21-0-33" class="i">+	URL              *string           `json:&quot;url,omitempty&quot;`
</a><a href="#h21-0-34" id="h21-0-34" class="i">+	HTMLURL          *string           `json:&quot;html_url,omitempty&quot;`
</a><a href="#h21-0-35" id="h21-0-35" class="i">+	Milestone        *Milestone        `json:&quot;milestone,omitempty&quot;`
</a><a href="#h21-0-36" id="h21-0-36" class="i">+	PullRequestLinks *PullRequestLinks `json:&quot;pull_request,omitempty&quot;`
</a><a href="#h21-0-37" id="h21-0-37" class="i">+	Repository       *Repository       `json:&quot;repository,omitempty&quot;`
</a><a href="#h21-0-38" id="h21-0-38" class="i">+
</a><a href="#h21-0-39" id="h21-0-39" class="i">+	// TextMatches is only populated from search results that request text matches
</a><a href="#h21-0-40" id="h21-0-40" class="i">+	// See: search.go and https://developer.github.com/v3/search/#text-match-metadata
</a><a href="#h21-0-41" id="h21-0-41" class="i">+	TextMatches []TextMatch `json:&quot;text_matches,omitempty&quot;`
</a><a href="#h21-0-42" id="h21-0-42" class="i">+}
</a><a href="#h21-0-43" id="h21-0-43" class="i">+
</a><a href="#h21-0-44" id="h21-0-44" class="i">+func (i Issue) String() string {
</a><a href="#h21-0-45" id="h21-0-45" class="i">+	return Stringify(i)
</a><a href="#h21-0-46" id="h21-0-46" class="i">+}
</a><a href="#h21-0-47" id="h21-0-47" class="i">+
</a><a href="#h21-0-48" id="h21-0-48" class="i">+// IssueRequest represents a request to create/edit an issue.
</a><a href="#h21-0-49" id="h21-0-49" class="i">+// It is separate from Issue above because otherwise Labels
</a><a href="#h21-0-50" id="h21-0-50" class="i">+// and Assignee fail to serialize to the correct JSON.
</a><a href="#h21-0-51" id="h21-0-51" class="i">+type IssueRequest struct {
</a><a href="#h21-0-52" id="h21-0-52" class="i">+	Title     *string   `json:&quot;title,omitempty&quot;`
</a><a href="#h21-0-53" id="h21-0-53" class="i">+	Body      *string   `json:&quot;body,omitempty&quot;`
</a><a href="#h21-0-54" id="h21-0-54" class="i">+	Labels    *[]string `json:&quot;labels,omitempty&quot;`
</a><a href="#h21-0-55" id="h21-0-55" class="i">+	Assignee  *string   `json:&quot;assignee,omitempty&quot;`
</a><a href="#h21-0-56" id="h21-0-56" class="i">+	State     *string   `json:&quot;state,omitempty&quot;`
</a><a href="#h21-0-57" id="h21-0-57" class="i">+	Milestone *int      `json:&quot;milestone,omitempty&quot;`
</a><a href="#h21-0-58" id="h21-0-58" class="i">+}
</a><a href="#h21-0-59" id="h21-0-59" class="i">+
</a><a href="#h21-0-60" id="h21-0-60" class="i">+// IssueListOptions specifies the optional parameters to the IssuesService.List
</a><a href="#h21-0-61" id="h21-0-61" class="i">+// and IssuesService.ListByOrg methods.
</a><a href="#h21-0-62" id="h21-0-62" class="i">+type IssueListOptions struct {
</a><a href="#h21-0-63" id="h21-0-63" class="i">+	// Filter specifies which issues to list.  Possible values are: assigned,
</a><a href="#h21-0-64" id="h21-0-64" class="i">+	// created, mentioned, subscribed, all.  Default is &quot;assigned&quot;.
</a><a href="#h21-0-65" id="h21-0-65" class="i">+	Filter string `url:&quot;filter,omitempty&quot;`
</a><a href="#h21-0-66" id="h21-0-66" class="i">+
</a><a href="#h21-0-67" id="h21-0-67" class="i">+	// State filters issues based on their state.  Possible values are: open,
</a><a href="#h21-0-68" id="h21-0-68" class="i">+	// closed, all.  Default is &quot;open&quot;.
</a><a href="#h21-0-69" id="h21-0-69" class="i">+	State string `url:&quot;state,omitempty&quot;`
</a><a href="#h21-0-70" id="h21-0-70" class="i">+
</a><a href="#h21-0-71" id="h21-0-71" class="i">+	// Labels filters issues based on their label.
</a><a href="#h21-0-72" id="h21-0-72" class="i">+	Labels []string `url:&quot;labels,comma,omitempty&quot;`
</a><a href="#h21-0-73" id="h21-0-73" class="i">+
</a><a href="#h21-0-74" id="h21-0-74" class="i">+	// Sort specifies how to sort issues.  Possible values are: created, updated,
</a><a href="#h21-0-75" id="h21-0-75" class="i">+	// and comments.  Default value is &quot;created&quot;.
</a><a href="#h21-0-76" id="h21-0-76" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h21-0-77" id="h21-0-77" class="i">+
</a><a href="#h21-0-78" id="h21-0-78" class="i">+	// Direction in which to sort issues.  Possible values are: asc, desc.
</a><a href="#h21-0-79" id="h21-0-79" class="i">+	// Default is &quot;desc&quot;.
</a><a href="#h21-0-80" id="h21-0-80" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h21-0-81" id="h21-0-81" class="i">+
</a><a href="#h21-0-82" id="h21-0-82" class="i">+	// Since filters issues by time.
</a><a href="#h21-0-83" id="h21-0-83" class="i">+	Since time.Time `url:&quot;since,omitempty&quot;`
</a><a href="#h21-0-84" id="h21-0-84" class="i">+
</a><a href="#h21-0-85" id="h21-0-85" class="i">+	ListOptions
</a><a href="#h21-0-86" id="h21-0-86" class="i">+}
</a><a href="#h21-0-87" id="h21-0-87" class="i">+
</a><a href="#h21-0-88" id="h21-0-88" class="i">+// PullRequestLinks object is added to the Issue object when it&#39;s an issue included
</a><a href="#h21-0-89" id="h21-0-89" class="i">+// in the IssueCommentEvent webhook payload, if the webhooks is fired by a comment on a PR
</a><a href="#h21-0-90" id="h21-0-90" class="i">+type PullRequestLinks struct {
</a><a href="#h21-0-91" id="h21-0-91" class="i">+	URL      *string `json:&quot;url,omitempty&quot;`
</a><a href="#h21-0-92" id="h21-0-92" class="i">+	HTMLURL  *string `json:&quot;html_url,omitempty&quot;`
</a><a href="#h21-0-93" id="h21-0-93" class="i">+	DiffURL  *string `json:&quot;diff_url,omitempty&quot;`
</a><a href="#h21-0-94" id="h21-0-94" class="i">+	PatchURL *string `json:&quot;patch_url,omitempty&quot;`
</a><a href="#h21-0-95" id="h21-0-95" class="i">+}
</a><a href="#h21-0-96" id="h21-0-96" class="i">+
</a><a href="#h21-0-97" id="h21-0-97" class="i">+// List the issues for the authenticated user.  If all is true, list issues
</a><a href="#h21-0-98" id="h21-0-98" class="i">+// across all the user&#39;s visible repositories including owned, member, and
</a><a href="#h21-0-99" id="h21-0-99" class="i">+// organization repositories; if false, list only owned and member
</a><a href="#h21-0-100" id="h21-0-100" class="i">+// repositories.
</a><a href="#h21-0-101" id="h21-0-101" class="i">+//
</a><a href="#h21-0-102" id="h21-0-102" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/#list-issues
</a><a href="#h21-0-103" id="h21-0-103" class="i">+func (s *IssuesService) List(all bool, opt *IssueListOptions) ([]Issue, *Response, error) {
</a><a href="#h21-0-104" id="h21-0-104" class="i">+	var u string
</a><a href="#h21-0-105" id="h21-0-105" class="i">+	if all {
</a><a href="#h21-0-106" id="h21-0-106" class="i">+		u = &quot;issues&quot;
</a><a href="#h21-0-107" id="h21-0-107" class="i">+	} else {
</a><a href="#h21-0-108" id="h21-0-108" class="i">+		u = &quot;user/issues&quot;
</a><a href="#h21-0-109" id="h21-0-109" class="i">+	}
</a><a href="#h21-0-110" id="h21-0-110" class="i">+	return s.listIssues(u, opt)
</a><a href="#h21-0-111" id="h21-0-111" class="i">+}
</a><a href="#h21-0-112" id="h21-0-112" class="i">+
</a><a href="#h21-0-113" id="h21-0-113" class="i">+// ListByOrg fetches the issues in the specified organization for the
</a><a href="#h21-0-114" id="h21-0-114" class="i">+// authenticated user.
</a><a href="#h21-0-115" id="h21-0-115" class="i">+//
</a><a href="#h21-0-116" id="h21-0-116" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/#list-issues
</a><a href="#h21-0-117" id="h21-0-117" class="i">+func (s *IssuesService) ListByOrg(org string, opt *IssueListOptions) ([]Issue, *Response, error) {
</a><a href="#h21-0-118" id="h21-0-118" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/issues&quot;, org)
</a><a href="#h21-0-119" id="h21-0-119" class="i">+	return s.listIssues(u, opt)
</a><a href="#h21-0-120" id="h21-0-120" class="i">+}
</a><a href="#h21-0-121" id="h21-0-121" class="i">+
</a><a href="#h21-0-122" id="h21-0-122" class="i">+func (s *IssuesService) listIssues(u string, opt *IssueListOptions) ([]Issue, *Response, error) {
</a><a href="#h21-0-123" id="h21-0-123" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h21-0-124" id="h21-0-124" class="i">+	if err != nil {
</a><a href="#h21-0-125" id="h21-0-125" class="i">+		return nil, nil, err
</a><a href="#h21-0-126" id="h21-0-126" class="i">+	}
</a><a href="#h21-0-127" id="h21-0-127" class="i">+
</a><a href="#h21-0-128" id="h21-0-128" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h21-0-129" id="h21-0-129" class="i">+	if err != nil {
</a><a href="#h21-0-130" id="h21-0-130" class="i">+		return nil, nil, err
</a><a href="#h21-0-131" id="h21-0-131" class="i">+	}
</a><a href="#h21-0-132" id="h21-0-132" class="i">+
</a><a href="#h21-0-133" id="h21-0-133" class="i">+	issues := new([]Issue)
</a><a href="#h21-0-134" id="h21-0-134" class="i">+	resp, err := s.client.Do(req, issues)
</a><a href="#h21-0-135" id="h21-0-135" class="i">+	if err != nil {
</a><a href="#h21-0-136" id="h21-0-136" class="i">+		return nil, resp, err
</a><a href="#h21-0-137" id="h21-0-137" class="i">+	}
</a><a href="#h21-0-138" id="h21-0-138" class="i">+
</a><a href="#h21-0-139" id="h21-0-139" class="i">+	return *issues, resp, err
</a><a href="#h21-0-140" id="h21-0-140" class="i">+}
</a><a href="#h21-0-141" id="h21-0-141" class="i">+
</a><a href="#h21-0-142" id="h21-0-142" class="i">+// IssueListByRepoOptions specifies the optional parameters to the
</a><a href="#h21-0-143" id="h21-0-143" class="i">+// IssuesService.ListByRepo method.
</a><a href="#h21-0-144" id="h21-0-144" class="i">+type IssueListByRepoOptions struct {
</a><a href="#h21-0-145" id="h21-0-145" class="i">+	// Milestone limits issues for the specified milestone.  Possible values are
</a><a href="#h21-0-146" id="h21-0-146" class="i">+	// a milestone number, &quot;none&quot; for issues with no milestone, &quot;*&quot; for issues
</a><a href="#h21-0-147" id="h21-0-147" class="i">+	// with any milestone.
</a><a href="#h21-0-148" id="h21-0-148" class="i">+	Milestone string `url:&quot;milestone,omitempty&quot;`
</a><a href="#h21-0-149" id="h21-0-149" class="i">+
</a><a href="#h21-0-150" id="h21-0-150" class="i">+	// State filters issues based on their state.  Possible values are: open,
</a><a href="#h21-0-151" id="h21-0-151" class="i">+	// closed, all.  Default is &quot;open&quot;.
</a><a href="#h21-0-152" id="h21-0-152" class="i">+	State string `url:&quot;state,omitempty&quot;`
</a><a href="#h21-0-153" id="h21-0-153" class="i">+
</a><a href="#h21-0-154" id="h21-0-154" class="i">+	// Assignee filters issues based on their assignee.  Possible values are a
</a><a href="#h21-0-155" id="h21-0-155" class="i">+	// user name, &quot;none&quot; for issues that are not assigned, &quot;*&quot; for issues with
</a><a href="#h21-0-156" id="h21-0-156" class="i">+	// any assigned user.
</a><a href="#h21-0-157" id="h21-0-157" class="i">+	Assignee string `url:&quot;assignee,omitempty&quot;`
</a><a href="#h21-0-158" id="h21-0-158" class="i">+
</a><a href="#h21-0-159" id="h21-0-159" class="i">+	// Creator filters issues based on their creator.
</a><a href="#h21-0-160" id="h21-0-160" class="i">+	Creator string `url:&quot;creator,omitempty&quot;`
</a><a href="#h21-0-161" id="h21-0-161" class="i">+
</a><a href="#h21-0-162" id="h21-0-162" class="i">+	// Mentioned filters issues to those mentioned a specific user.
</a><a href="#h21-0-163" id="h21-0-163" class="i">+	Mentioned string `url:&quot;mentioned,omitempty&quot;`
</a><a href="#h21-0-164" id="h21-0-164" class="i">+
</a><a href="#h21-0-165" id="h21-0-165" class="i">+	// Labels filters issues based on their label.
</a><a href="#h21-0-166" id="h21-0-166" class="i">+	Labels []string `url:&quot;labels,omitempty,comma&quot;`
</a><a href="#h21-0-167" id="h21-0-167" class="i">+
</a><a href="#h21-0-168" id="h21-0-168" class="i">+	// Sort specifies how to sort issues.  Possible values are: created, updated,
</a><a href="#h21-0-169" id="h21-0-169" class="i">+	// and comments.  Default value is &quot;created&quot;.
</a><a href="#h21-0-170" id="h21-0-170" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h21-0-171" id="h21-0-171" class="i">+
</a><a href="#h21-0-172" id="h21-0-172" class="i">+	// Direction in which to sort issues.  Possible values are: asc, desc.
</a><a href="#h21-0-173" id="h21-0-173" class="i">+	// Default is &quot;desc&quot;.
</a><a href="#h21-0-174" id="h21-0-174" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h21-0-175" id="h21-0-175" class="i">+
</a><a href="#h21-0-176" id="h21-0-176" class="i">+	// Since filters issues by time.
</a><a href="#h21-0-177" id="h21-0-177" class="i">+	Since time.Time `url:&quot;since,omitempty&quot;`
</a><a href="#h21-0-178" id="h21-0-178" class="i">+
</a><a href="#h21-0-179" id="h21-0-179" class="i">+	ListOptions
</a><a href="#h21-0-180" id="h21-0-180" class="i">+}
</a><a href="#h21-0-181" id="h21-0-181" class="i">+
</a><a href="#h21-0-182" id="h21-0-182" class="i">+// ListByRepo lists the issues for the specified repository.
</a><a href="#h21-0-183" id="h21-0-183" class="i">+//
</a><a href="#h21-0-184" id="h21-0-184" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/#list-issues-for-a-repository
</a><a href="#h21-0-185" id="h21-0-185" class="i">+func (s *IssuesService) ListByRepo(owner string, repo string, opt *IssueListByRepoOptions) ([]Issue, *Response, error) {
</a><a href="#h21-0-186" id="h21-0-186" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues&quot;, owner, repo)
</a><a href="#h21-0-187" id="h21-0-187" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h21-0-188" id="h21-0-188" class="i">+	if err != nil {
</a><a href="#h21-0-189" id="h21-0-189" class="i">+		return nil, nil, err
</a><a href="#h21-0-190" id="h21-0-190" class="i">+	}
</a><a href="#h21-0-191" id="h21-0-191" class="i">+
</a><a href="#h21-0-192" id="h21-0-192" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h21-0-193" id="h21-0-193" class="i">+	if err != nil {
</a><a href="#h21-0-194" id="h21-0-194" class="i">+		return nil, nil, err
</a><a href="#h21-0-195" id="h21-0-195" class="i">+	}
</a><a href="#h21-0-196" id="h21-0-196" class="i">+
</a><a href="#h21-0-197" id="h21-0-197" class="i">+	issues := new([]Issue)
</a><a href="#h21-0-198" id="h21-0-198" class="i">+	resp, err := s.client.Do(req, issues)
</a><a href="#h21-0-199" id="h21-0-199" class="i">+	if err != nil {
</a><a href="#h21-0-200" id="h21-0-200" class="i">+		return nil, resp, err
</a><a href="#h21-0-201" id="h21-0-201" class="i">+	}
</a><a href="#h21-0-202" id="h21-0-202" class="i">+
</a><a href="#h21-0-203" id="h21-0-203" class="i">+	return *issues, resp, err
</a><a href="#h21-0-204" id="h21-0-204" class="i">+}
</a><a href="#h21-0-205" id="h21-0-205" class="i">+
</a><a href="#h21-0-206" id="h21-0-206" class="i">+// Get a single issue.
</a><a href="#h21-0-207" id="h21-0-207" class="i">+//
</a><a href="#h21-0-208" id="h21-0-208" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/#get-a-single-issue
</a><a href="#h21-0-209" id="h21-0-209" class="i">+func (s *IssuesService) Get(owner string, repo string, number int) (*Issue, *Response, error) {
</a><a href="#h21-0-210" id="h21-0-210" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d&quot;, owner, repo, number)
</a><a href="#h21-0-211" id="h21-0-211" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h21-0-212" id="h21-0-212" class="i">+	if err != nil {
</a><a href="#h21-0-213" id="h21-0-213" class="i">+		return nil, nil, err
</a><a href="#h21-0-214" id="h21-0-214" class="i">+	}
</a><a href="#h21-0-215" id="h21-0-215" class="i">+
</a><a href="#h21-0-216" id="h21-0-216" class="i">+	issue := new(Issue)
</a><a href="#h21-0-217" id="h21-0-217" class="i">+	resp, err := s.client.Do(req, issue)
</a><a href="#h21-0-218" id="h21-0-218" class="i">+	if err != nil {
</a><a href="#h21-0-219" id="h21-0-219" class="i">+		return nil, resp, err
</a><a href="#h21-0-220" id="h21-0-220" class="i">+	}
</a><a href="#h21-0-221" id="h21-0-221" class="i">+
</a><a href="#h21-0-222" id="h21-0-222" class="i">+	return issue, resp, err
</a><a href="#h21-0-223" id="h21-0-223" class="i">+}
</a><a href="#h21-0-224" id="h21-0-224" class="i">+
</a><a href="#h21-0-225" id="h21-0-225" class="i">+// Create a new issue on the specified repository.
</a><a href="#h21-0-226" id="h21-0-226" class="i">+//
</a><a href="#h21-0-227" id="h21-0-227" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/#create-an-issue
</a><a href="#h21-0-228" id="h21-0-228" class="i">+func (s *IssuesService) Create(owner string, repo string, issue *IssueRequest) (*Issue, *Response, error) {
</a><a href="#h21-0-229" id="h21-0-229" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues&quot;, owner, repo)
</a><a href="#h21-0-230" id="h21-0-230" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, issue)
</a><a href="#h21-0-231" id="h21-0-231" class="i">+	if err != nil {
</a><a href="#h21-0-232" id="h21-0-232" class="i">+		return nil, nil, err
</a><a href="#h21-0-233" id="h21-0-233" class="i">+	}
</a><a href="#h21-0-234" id="h21-0-234" class="i">+
</a><a href="#h21-0-235" id="h21-0-235" class="i">+	i := new(Issue)
</a><a href="#h21-0-236" id="h21-0-236" class="i">+	resp, err := s.client.Do(req, i)
</a><a href="#h21-0-237" id="h21-0-237" class="i">+	if err != nil {
</a><a href="#h21-0-238" id="h21-0-238" class="i">+		return nil, resp, err
</a><a href="#h21-0-239" id="h21-0-239" class="i">+	}
</a><a href="#h21-0-240" id="h21-0-240" class="i">+
</a><a href="#h21-0-241" id="h21-0-241" class="i">+	return i, resp, err
</a><a href="#h21-0-242" id="h21-0-242" class="i">+}
</a><a href="#h21-0-243" id="h21-0-243" class="i">+
</a><a href="#h21-0-244" id="h21-0-244" class="i">+// Edit an issue.
</a><a href="#h21-0-245" id="h21-0-245" class="i">+//
</a><a href="#h21-0-246" id="h21-0-246" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/#edit-an-issue
</a><a href="#h21-0-247" id="h21-0-247" class="i">+func (s *IssuesService) Edit(owner string, repo string, number int, issue *IssueRequest) (*Issue, *Response, error) {
</a><a href="#h21-0-248" id="h21-0-248" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d&quot;, owner, repo, number)
</a><a href="#h21-0-249" id="h21-0-249" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, issue)
</a><a href="#h21-0-250" id="h21-0-250" class="i">+	if err != nil {
</a><a href="#h21-0-251" id="h21-0-251" class="i">+		return nil, nil, err
</a><a href="#h21-0-252" id="h21-0-252" class="i">+	}
</a><a href="#h21-0-253" id="h21-0-253" class="i">+
</a><a href="#h21-0-254" id="h21-0-254" class="i">+	i := new(Issue)
</a><a href="#h21-0-255" id="h21-0-255" class="i">+	resp, err := s.client.Do(req, i)
</a><a href="#h21-0-256" id="h21-0-256" class="i">+	if err != nil {
</a><a href="#h21-0-257" id="h21-0-257" class="i">+		return nil, resp, err
</a><a href="#h21-0-258" id="h21-0-258" class="i">+	}
</a><a href="#h21-0-259" id="h21-0-259" class="i">+
</a><a href="#h21-0-260" id="h21-0-260" class="i">+	return i, resp, err
</a><a href="#h21-0-261" id="h21-0-261" class="i">+}
</a><a href="#h21-0-262" id="h21-0-262" class="i">+
</a><a href="#h21-0-263" id="h21-0-263" class="i">+// Lock an issue&#39;s conversation.
</a><a href="#h21-0-264" id="h21-0-264" class="i">+//
</a><a href="#h21-0-265" id="h21-0-265" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/#lock-an-issue
</a><a href="#h21-0-266" id="h21-0-266" class="i">+func (s *IssuesService) Lock(owner string, repo string, number int) (*Response, error) {
</a><a href="#h21-0-267" id="h21-0-267" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/lock&quot;, owner, repo, number)
</a><a href="#h21-0-268" id="h21-0-268" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h21-0-269" id="h21-0-269" class="i">+	if err != nil {
</a><a href="#h21-0-270" id="h21-0-270" class="i">+		return nil, err
</a><a href="#h21-0-271" id="h21-0-271" class="i">+	}
</a><a href="#h21-0-272" id="h21-0-272" class="i">+
</a><a href="#h21-0-273" id="h21-0-273" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h21-0-274" id="h21-0-274" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeIssueLockingPreview)
</a><a href="#h21-0-275" id="h21-0-275" class="i">+
</a><a href="#h21-0-276" id="h21-0-276" class="i">+	return s.client.Do(req, nil)
</a><a href="#h21-0-277" id="h21-0-277" class="i">+}
</a><a href="#h21-0-278" id="h21-0-278" class="i">+
</a><a href="#h21-0-279" id="h21-0-279" class="i">+// Unlock an issue&#39;s conversation.
</a><a href="#h21-0-280" id="h21-0-280" class="i">+//
</a><a href="#h21-0-281" id="h21-0-281" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/#unlock-an-issue
</a><a href="#h21-0-282" id="h21-0-282" class="i">+func (s *IssuesService) Unlock(owner string, repo string, number int) (*Response, error) {
</a><a href="#h21-0-283" id="h21-0-283" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/lock&quot;, owner, repo, number)
</a><a href="#h21-0-284" id="h21-0-284" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h21-0-285" id="h21-0-285" class="i">+	if err != nil {
</a><a href="#h21-0-286" id="h21-0-286" class="i">+		return nil, err
</a><a href="#h21-0-287" id="h21-0-287" class="i">+	}
</a><a href="#h21-0-288" id="h21-0-288" class="i">+
</a><a href="#h21-0-289" id="h21-0-289" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h21-0-290" id="h21-0-290" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeIssueLockingPreview)
</a><a href="#h21-0-291" id="h21-0-291" class="i">+
</a><a href="#h21-0-292" id="h21-0-292" class="i">+	return s.client.Do(req, nil)
</a><a href="#h21-0-293" id="h21-0-293" class="i">+}
</a><b>diff --git a/<a id="h22" href="../file/vendor/github.com/google/go-github/github/issues_assignees.go">vendor/github.com/google/go-github/github/issues_assignees.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/issues_assignees.go">vendor/github.com/google/go-github/github/issues_assignees.go</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -0,0 +1,46 @@
</a><a href="#h22-0-0" id="h22-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h22-0-1" id="h22-0-1" class="i">+//
</a><a href="#h22-0-2" id="h22-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h22-0-3" id="h22-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h22-0-4" id="h22-0-4" class="i">+
</a><a href="#h22-0-5" id="h22-0-5" class="i">+package github
</a><a href="#h22-0-6" id="h22-0-6" class="i">+
</a><a href="#h22-0-7" id="h22-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h22-0-8" id="h22-0-8" class="i">+
</a><a href="#h22-0-9" id="h22-0-9" class="i">+// ListAssignees fetches all available assignees (owners and collaborators) to
</a><a href="#h22-0-10" id="h22-0-10" class="i">+// which issues may be assigned.
</a><a href="#h22-0-11" id="h22-0-11" class="i">+//
</a><a href="#h22-0-12" id="h22-0-12" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/assignees/#list-assignees
</a><a href="#h22-0-13" id="h22-0-13" class="i">+func (s *IssuesService) ListAssignees(owner string, repo string, opt *ListOptions) ([]User, *Response, error) {
</a><a href="#h22-0-14" id="h22-0-14" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/assignees&quot;, owner, repo)
</a><a href="#h22-0-15" id="h22-0-15" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h22-0-16" id="h22-0-16" class="i">+	if err != nil {
</a><a href="#h22-0-17" id="h22-0-17" class="i">+		return nil, nil, err
</a><a href="#h22-0-18" id="h22-0-18" class="i">+	}
</a><a href="#h22-0-19" id="h22-0-19" class="i">+
</a><a href="#h22-0-20" id="h22-0-20" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h22-0-21" id="h22-0-21" class="i">+	if err != nil {
</a><a href="#h22-0-22" id="h22-0-22" class="i">+		return nil, nil, err
</a><a href="#h22-0-23" id="h22-0-23" class="i">+	}
</a><a href="#h22-0-24" id="h22-0-24" class="i">+	assignees := new([]User)
</a><a href="#h22-0-25" id="h22-0-25" class="i">+	resp, err := s.client.Do(req, assignees)
</a><a href="#h22-0-26" id="h22-0-26" class="i">+	if err != nil {
</a><a href="#h22-0-27" id="h22-0-27" class="i">+		return nil, resp, err
</a><a href="#h22-0-28" id="h22-0-28" class="i">+	}
</a><a href="#h22-0-29" id="h22-0-29" class="i">+
</a><a href="#h22-0-30" id="h22-0-30" class="i">+	return *assignees, resp, err
</a><a href="#h22-0-31" id="h22-0-31" class="i">+}
</a><a href="#h22-0-32" id="h22-0-32" class="i">+
</a><a href="#h22-0-33" id="h22-0-33" class="i">+// IsAssignee checks if a user is an assignee for the specified repository.
</a><a href="#h22-0-34" id="h22-0-34" class="i">+//
</a><a href="#h22-0-35" id="h22-0-35" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/assignees/#check-assignee
</a><a href="#h22-0-36" id="h22-0-36" class="i">+func (s *IssuesService) IsAssignee(owner string, repo string, user string) (bool, *Response, error) {
</a><a href="#h22-0-37" id="h22-0-37" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/assignees/%v&quot;, owner, repo, user)
</a><a href="#h22-0-38" id="h22-0-38" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h22-0-39" id="h22-0-39" class="i">+	if err != nil {
</a><a href="#h22-0-40" id="h22-0-40" class="i">+		return false, nil, err
</a><a href="#h22-0-41" id="h22-0-41" class="i">+	}
</a><a href="#h22-0-42" id="h22-0-42" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h22-0-43" id="h22-0-43" class="i">+	assignee, err := parseBoolResponse(err)
</a><a href="#h22-0-44" id="h22-0-44" class="i">+	return assignee, resp, err
</a><a href="#h22-0-45" id="h22-0-45" class="i">+}
</a><b>diff --git a/<a id="h23" href="../file/vendor/github.com/google/go-github/github/issues_comments.go">vendor/github.com/google/go-github/github/issues_comments.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/issues_comments.go">vendor/github.com/google/go-github/github/issues_comments.go</a></b>
<a href="#h23-0" id="h23-0" class="h">@@ -0,0 +1,138 @@
</a><a href="#h23-0-0" id="h23-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h23-0-1" id="h23-0-1" class="i">+//
</a><a href="#h23-0-2" id="h23-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h23-0-3" id="h23-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h23-0-4" id="h23-0-4" class="i">+
</a><a href="#h23-0-5" id="h23-0-5" class="i">+package github
</a><a href="#h23-0-6" id="h23-0-6" class="i">+
</a><a href="#h23-0-7" id="h23-0-7" class="i">+import (
</a><a href="#h23-0-8" id="h23-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h23-0-9" id="h23-0-9" class="i">+	&quot;time&quot;
</a><a href="#h23-0-10" id="h23-0-10" class="i">+)
</a><a href="#h23-0-11" id="h23-0-11" class="i">+
</a><a href="#h23-0-12" id="h23-0-12" class="i">+// IssueComment represents a comment left on an issue.
</a><a href="#h23-0-13" id="h23-0-13" class="i">+type IssueComment struct {
</a><a href="#h23-0-14" id="h23-0-14" class="i">+	ID        *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h23-0-15" id="h23-0-15" class="i">+	Body      *string    `json:&quot;body,omitempty&quot;`
</a><a href="#h23-0-16" id="h23-0-16" class="i">+	User      *User      `json:&quot;user,omitempty&quot;`
</a><a href="#h23-0-17" id="h23-0-17" class="i">+	CreatedAt *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h23-0-18" id="h23-0-18" class="i">+	UpdatedAt *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h23-0-19" id="h23-0-19" class="i">+	URL       *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h23-0-20" id="h23-0-20" class="i">+	HTMLURL   *string    `json:&quot;html_url,omitempty&quot;`
</a><a href="#h23-0-21" id="h23-0-21" class="i">+	IssueURL  *string    `json:&quot;issue_url,omitempty&quot;`
</a><a href="#h23-0-22" id="h23-0-22" class="i">+}
</a><a href="#h23-0-23" id="h23-0-23" class="i">+
</a><a href="#h23-0-24" id="h23-0-24" class="i">+func (i IssueComment) String() string {
</a><a href="#h23-0-25" id="h23-0-25" class="i">+	return Stringify(i)
</a><a href="#h23-0-26" id="h23-0-26" class="i">+}
</a><a href="#h23-0-27" id="h23-0-27" class="i">+
</a><a href="#h23-0-28" id="h23-0-28" class="i">+// IssueListCommentsOptions specifies the optional parameters to the
</a><a href="#h23-0-29" id="h23-0-29" class="i">+// IssuesService.ListComments method.
</a><a href="#h23-0-30" id="h23-0-30" class="i">+type IssueListCommentsOptions struct {
</a><a href="#h23-0-31" id="h23-0-31" class="i">+	// Sort specifies how to sort comments.  Possible values are: created, updated.
</a><a href="#h23-0-32" id="h23-0-32" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h23-0-33" id="h23-0-33" class="i">+
</a><a href="#h23-0-34" id="h23-0-34" class="i">+	// Direction in which to sort comments.  Possible values are: asc, desc.
</a><a href="#h23-0-35" id="h23-0-35" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h23-0-36" id="h23-0-36" class="i">+
</a><a href="#h23-0-37" id="h23-0-37" class="i">+	// Since filters comments by time.
</a><a href="#h23-0-38" id="h23-0-38" class="i">+	Since time.Time `url:&quot;since,omitempty&quot;`
</a><a href="#h23-0-39" id="h23-0-39" class="i">+
</a><a href="#h23-0-40" id="h23-0-40" class="i">+	ListOptions
</a><a href="#h23-0-41" id="h23-0-41" class="i">+}
</a><a href="#h23-0-42" id="h23-0-42" class="i">+
</a><a href="#h23-0-43" id="h23-0-43" class="i">+// ListComments lists all comments on the specified issue.  Specifying an issue
</a><a href="#h23-0-44" id="h23-0-44" class="i">+// number of 0 will return all comments on all issues for the repository.
</a><a href="#h23-0-45" id="h23-0-45" class="i">+//
</a><a href="#h23-0-46" id="h23-0-46" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/comments/#list-comments-on-an-issue
</a><a href="#h23-0-47" id="h23-0-47" class="i">+func (s *IssuesService) ListComments(owner string, repo string, number int, opt *IssueListCommentsOptions) ([]IssueComment, *Response, error) {
</a><a href="#h23-0-48" id="h23-0-48" class="i">+	var u string
</a><a href="#h23-0-49" id="h23-0-49" class="i">+	if number == 0 {
</a><a href="#h23-0-50" id="h23-0-50" class="i">+		u = fmt.Sprintf(&quot;repos/%v/%v/issues/comments&quot;, owner, repo)
</a><a href="#h23-0-51" id="h23-0-51" class="i">+	} else {
</a><a href="#h23-0-52" id="h23-0-52" class="i">+		u = fmt.Sprintf(&quot;repos/%v/%v/issues/%d/comments&quot;, owner, repo, number)
</a><a href="#h23-0-53" id="h23-0-53" class="i">+	}
</a><a href="#h23-0-54" id="h23-0-54" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h23-0-55" id="h23-0-55" class="i">+	if err != nil {
</a><a href="#h23-0-56" id="h23-0-56" class="i">+		return nil, nil, err
</a><a href="#h23-0-57" id="h23-0-57" class="i">+	}
</a><a href="#h23-0-58" id="h23-0-58" class="i">+
</a><a href="#h23-0-59" id="h23-0-59" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h23-0-60" id="h23-0-60" class="i">+	if err != nil {
</a><a href="#h23-0-61" id="h23-0-61" class="i">+		return nil, nil, err
</a><a href="#h23-0-62" id="h23-0-62" class="i">+	}
</a><a href="#h23-0-63" id="h23-0-63" class="i">+	comments := new([]IssueComment)
</a><a href="#h23-0-64" id="h23-0-64" class="i">+	resp, err := s.client.Do(req, comments)
</a><a href="#h23-0-65" id="h23-0-65" class="i">+	if err != nil {
</a><a href="#h23-0-66" id="h23-0-66" class="i">+		return nil, resp, err
</a><a href="#h23-0-67" id="h23-0-67" class="i">+	}
</a><a href="#h23-0-68" id="h23-0-68" class="i">+
</a><a href="#h23-0-69" id="h23-0-69" class="i">+	return *comments, resp, err
</a><a href="#h23-0-70" id="h23-0-70" class="i">+}
</a><a href="#h23-0-71" id="h23-0-71" class="i">+
</a><a href="#h23-0-72" id="h23-0-72" class="i">+// GetComment fetches the specified issue comment.
</a><a href="#h23-0-73" id="h23-0-73" class="i">+//
</a><a href="#h23-0-74" id="h23-0-74" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/comments/#get-a-single-comment
</a><a href="#h23-0-75" id="h23-0-75" class="i">+func (s *IssuesService) GetComment(owner string, repo string, id int) (*IssueComment, *Response, error) {
</a><a href="#h23-0-76" id="h23-0-76" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/comments/%d&quot;, owner, repo, id)
</a><a href="#h23-0-77" id="h23-0-77" class="i">+
</a><a href="#h23-0-78" id="h23-0-78" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h23-0-79" id="h23-0-79" class="i">+	if err != nil {
</a><a href="#h23-0-80" id="h23-0-80" class="i">+		return nil, nil, err
</a><a href="#h23-0-81" id="h23-0-81" class="i">+	}
</a><a href="#h23-0-82" id="h23-0-82" class="i">+	comment := new(IssueComment)
</a><a href="#h23-0-83" id="h23-0-83" class="i">+	resp, err := s.client.Do(req, comment)
</a><a href="#h23-0-84" id="h23-0-84" class="i">+	if err != nil {
</a><a href="#h23-0-85" id="h23-0-85" class="i">+		return nil, resp, err
</a><a href="#h23-0-86" id="h23-0-86" class="i">+	}
</a><a href="#h23-0-87" id="h23-0-87" class="i">+
</a><a href="#h23-0-88" id="h23-0-88" class="i">+	return comment, resp, err
</a><a href="#h23-0-89" id="h23-0-89" class="i">+}
</a><a href="#h23-0-90" id="h23-0-90" class="i">+
</a><a href="#h23-0-91" id="h23-0-91" class="i">+// CreateComment creates a new comment on the specified issue.
</a><a href="#h23-0-92" id="h23-0-92" class="i">+//
</a><a href="#h23-0-93" id="h23-0-93" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/comments/#create-a-comment
</a><a href="#h23-0-94" id="h23-0-94" class="i">+func (s *IssuesService) CreateComment(owner string, repo string, number int, comment *IssueComment) (*IssueComment, *Response, error) {
</a><a href="#h23-0-95" id="h23-0-95" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/comments&quot;, owner, repo, number)
</a><a href="#h23-0-96" id="h23-0-96" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, comment)
</a><a href="#h23-0-97" id="h23-0-97" class="i">+	if err != nil {
</a><a href="#h23-0-98" id="h23-0-98" class="i">+		return nil, nil, err
</a><a href="#h23-0-99" id="h23-0-99" class="i">+	}
</a><a href="#h23-0-100" id="h23-0-100" class="i">+	c := new(IssueComment)
</a><a href="#h23-0-101" id="h23-0-101" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h23-0-102" id="h23-0-102" class="i">+	if err != nil {
</a><a href="#h23-0-103" id="h23-0-103" class="i">+		return nil, resp, err
</a><a href="#h23-0-104" id="h23-0-104" class="i">+	}
</a><a href="#h23-0-105" id="h23-0-105" class="i">+
</a><a href="#h23-0-106" id="h23-0-106" class="i">+	return c, resp, err
</a><a href="#h23-0-107" id="h23-0-107" class="i">+}
</a><a href="#h23-0-108" id="h23-0-108" class="i">+
</a><a href="#h23-0-109" id="h23-0-109" class="i">+// EditComment updates an issue comment.
</a><a href="#h23-0-110" id="h23-0-110" class="i">+//
</a><a href="#h23-0-111" id="h23-0-111" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/comments/#edit-a-comment
</a><a href="#h23-0-112" id="h23-0-112" class="i">+func (s *IssuesService) EditComment(owner string, repo string, id int, comment *IssueComment) (*IssueComment, *Response, error) {
</a><a href="#h23-0-113" id="h23-0-113" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/comments/%d&quot;, owner, repo, id)
</a><a href="#h23-0-114" id="h23-0-114" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, comment)
</a><a href="#h23-0-115" id="h23-0-115" class="i">+	if err != nil {
</a><a href="#h23-0-116" id="h23-0-116" class="i">+		return nil, nil, err
</a><a href="#h23-0-117" id="h23-0-117" class="i">+	}
</a><a href="#h23-0-118" id="h23-0-118" class="i">+	c := new(IssueComment)
</a><a href="#h23-0-119" id="h23-0-119" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h23-0-120" id="h23-0-120" class="i">+	if err != nil {
</a><a href="#h23-0-121" id="h23-0-121" class="i">+		return nil, resp, err
</a><a href="#h23-0-122" id="h23-0-122" class="i">+	}
</a><a href="#h23-0-123" id="h23-0-123" class="i">+
</a><a href="#h23-0-124" id="h23-0-124" class="i">+	return c, resp, err
</a><a href="#h23-0-125" id="h23-0-125" class="i">+}
</a><a href="#h23-0-126" id="h23-0-126" class="i">+
</a><a href="#h23-0-127" id="h23-0-127" class="i">+// DeleteComment deletes an issue comment.
</a><a href="#h23-0-128" id="h23-0-128" class="i">+//
</a><a href="#h23-0-129" id="h23-0-129" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/comments/#delete-a-comment
</a><a href="#h23-0-130" id="h23-0-130" class="i">+func (s *IssuesService) DeleteComment(owner string, repo string, id int) (*Response, error) {
</a><a href="#h23-0-131" id="h23-0-131" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/comments/%d&quot;, owner, repo, id)
</a><a href="#h23-0-132" id="h23-0-132" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h23-0-133" id="h23-0-133" class="i">+	if err != nil {
</a><a href="#h23-0-134" id="h23-0-134" class="i">+		return nil, err
</a><a href="#h23-0-135" id="h23-0-135" class="i">+	}
</a><a href="#h23-0-136" id="h23-0-136" class="i">+	return s.client.Do(req, nil)
</a><a href="#h23-0-137" id="h23-0-137" class="i">+}
</a><b>diff --git a/<a id="h24" href="../file/vendor/github.com/google/go-github/github/issues_events.go">vendor/github.com/google/go-github/github/issues_events.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/issues_events.go">vendor/github.com/google/go-github/github/issues_events.go</a></b>
<a href="#h24-0" id="h24-0" class="h">@@ -0,0 +1,149 @@
</a><a href="#h24-0-0" id="h24-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h24-0-1" id="h24-0-1" class="i">+//
</a><a href="#h24-0-2" id="h24-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h24-0-3" id="h24-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h24-0-4" id="h24-0-4" class="i">+
</a><a href="#h24-0-5" id="h24-0-5" class="i">+package github
</a><a href="#h24-0-6" id="h24-0-6" class="i">+
</a><a href="#h24-0-7" id="h24-0-7" class="i">+import (
</a><a href="#h24-0-8" id="h24-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h24-0-9" id="h24-0-9" class="i">+	&quot;time&quot;
</a><a href="#h24-0-10" id="h24-0-10" class="i">+)
</a><a href="#h24-0-11" id="h24-0-11" class="i">+
</a><a href="#h24-0-12" id="h24-0-12" class="i">+// IssueEvent represents an event that occurred around an Issue or Pull Request.
</a><a href="#h24-0-13" id="h24-0-13" class="i">+type IssueEvent struct {
</a><a href="#h24-0-14" id="h24-0-14" class="i">+	ID  *int    `json:&quot;id,omitempty&quot;`
</a><a href="#h24-0-15" id="h24-0-15" class="i">+	URL *string `json:&quot;url,omitempty&quot;`
</a><a href="#h24-0-16" id="h24-0-16" class="i">+
</a><a href="#h24-0-17" id="h24-0-17" class="i">+	// The User that generated this event.
</a><a href="#h24-0-18" id="h24-0-18" class="i">+	Actor *User `json:&quot;actor,omitempty&quot;`
</a><a href="#h24-0-19" id="h24-0-19" class="i">+
</a><a href="#h24-0-20" id="h24-0-20" class="i">+	// Event identifies the actual type of Event that occurred.  Possible
</a><a href="#h24-0-21" id="h24-0-21" class="i">+	// values are:
</a><a href="#h24-0-22" id="h24-0-22" class="i">+	//
</a><a href="#h24-0-23" id="h24-0-23" class="i">+	//     closed
</a><a href="#h24-0-24" id="h24-0-24" class="i">+	//       The Actor closed the issue.
</a><a href="#h24-0-25" id="h24-0-25" class="i">+	//       If the issue was closed by commit message, CommitID holds the SHA1 hash of the commit.
</a><a href="#h24-0-26" id="h24-0-26" class="i">+	//
</a><a href="#h24-0-27" id="h24-0-27" class="i">+	//     merged
</a><a href="#h24-0-28" id="h24-0-28" class="i">+	//       The Actor merged into master a branch containing a commit mentioning the issue.
</a><a href="#h24-0-29" id="h24-0-29" class="i">+	//       CommitID holds the SHA1 of the merge commit.
</a><a href="#h24-0-30" id="h24-0-30" class="i">+	//
</a><a href="#h24-0-31" id="h24-0-31" class="i">+	//     referenced
</a><a href="#h24-0-32" id="h24-0-32" class="i">+	//       The Actor committed to master a commit mentioning the issue in its commit message.
</a><a href="#h24-0-33" id="h24-0-33" class="i">+	//       CommitID holds the SHA1 of the commit.
</a><a href="#h24-0-34" id="h24-0-34" class="i">+	//
</a><a href="#h24-0-35" id="h24-0-35" class="i">+	//     reopened, locked, unlocked
</a><a href="#h24-0-36" id="h24-0-36" class="i">+	//       The Actor did that to the issue.
</a><a href="#h24-0-37" id="h24-0-37" class="i">+	//
</a><a href="#h24-0-38" id="h24-0-38" class="i">+	//     renamed
</a><a href="#h24-0-39" id="h24-0-39" class="i">+	//       The Actor changed the issue title from Rename.From to Rename.To.
</a><a href="#h24-0-40" id="h24-0-40" class="i">+	//
</a><a href="#h24-0-41" id="h24-0-41" class="i">+	//     mentioned
</a><a href="#h24-0-42" id="h24-0-42" class="i">+	//       Someone unspecified @mentioned the Actor [sic] in an issue comment body.
</a><a href="#h24-0-43" id="h24-0-43" class="i">+	//
</a><a href="#h24-0-44" id="h24-0-44" class="i">+	//     assigned, unassigned
</a><a href="#h24-0-45" id="h24-0-45" class="i">+	//       The Actor assigned the issue to or removed the assignment from the Assignee.
</a><a href="#h24-0-46" id="h24-0-46" class="i">+	//
</a><a href="#h24-0-47" id="h24-0-47" class="i">+	//     labeled, unlabeled
</a><a href="#h24-0-48" id="h24-0-48" class="i">+	//       The Actor added or removed the Label from the issue.
</a><a href="#h24-0-49" id="h24-0-49" class="i">+	//
</a><a href="#h24-0-50" id="h24-0-50" class="i">+	//     milestoned, demilestoned
</a><a href="#h24-0-51" id="h24-0-51" class="i">+	//       The Actor added or removed the issue from the Milestone.
</a><a href="#h24-0-52" id="h24-0-52" class="i">+	//
</a><a href="#h24-0-53" id="h24-0-53" class="i">+	//     subscribed, unsubscribed
</a><a href="#h24-0-54" id="h24-0-54" class="i">+	//       The Actor subscribed to or unsubscribed from notifications for an issue.
</a><a href="#h24-0-55" id="h24-0-55" class="i">+	//
</a><a href="#h24-0-56" id="h24-0-56" class="i">+	//     head_ref_deleted, head_ref_restored
</a><a href="#h24-0-57" id="h24-0-57" class="i">+	//       The pull requests branch was deleted or restored.
</a><a href="#h24-0-58" id="h24-0-58" class="i">+	//
</a><a href="#h24-0-59" id="h24-0-59" class="i">+	Event *string `json:&quot;event,omitempty&quot;`
</a><a href="#h24-0-60" id="h24-0-60" class="i">+
</a><a href="#h24-0-61" id="h24-0-61" class="i">+	CreatedAt *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h24-0-62" id="h24-0-62" class="i">+	Issue     *Issue     `json:&quot;issue,omitempty&quot;`
</a><a href="#h24-0-63" id="h24-0-63" class="i">+
</a><a href="#h24-0-64" id="h24-0-64" class="i">+	// Only present on certain events; see above.
</a><a href="#h24-0-65" id="h24-0-65" class="i">+	Assignee  *User      `json:&quot;assignee,omitempty&quot;`
</a><a href="#h24-0-66" id="h24-0-66" class="i">+	CommitID  *string    `json:&quot;commit_id,omitempty&quot;`
</a><a href="#h24-0-67" id="h24-0-67" class="i">+	Milestone *Milestone `json:&quot;milestone,omitempty&quot;`
</a><a href="#h24-0-68" id="h24-0-68" class="i">+	Label     *Label     `json:&quot;label,omitempty&quot;`
</a><a href="#h24-0-69" id="h24-0-69" class="i">+	Rename    *Rename    `json:&quot;rename,omitempty&quot;`
</a><a href="#h24-0-70" id="h24-0-70" class="i">+}
</a><a href="#h24-0-71" id="h24-0-71" class="i">+
</a><a href="#h24-0-72" id="h24-0-72" class="i">+// ListIssueEvents lists events for the specified issue.
</a><a href="#h24-0-73" id="h24-0-73" class="i">+//
</a><a href="#h24-0-74" id="h24-0-74" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/events/#list-events-for-an-issue
</a><a href="#h24-0-75" id="h24-0-75" class="i">+func (s *IssuesService) ListIssueEvents(owner, repo string, number int, opt *ListOptions) ([]IssueEvent, *Response, error) {
</a><a href="#h24-0-76" id="h24-0-76" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%v/events&quot;, owner, repo, number)
</a><a href="#h24-0-77" id="h24-0-77" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h24-0-78" id="h24-0-78" class="i">+	if err != nil {
</a><a href="#h24-0-79" id="h24-0-79" class="i">+		return nil, nil, err
</a><a href="#h24-0-80" id="h24-0-80" class="i">+	}
</a><a href="#h24-0-81" id="h24-0-81" class="i">+
</a><a href="#h24-0-82" id="h24-0-82" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h24-0-83" id="h24-0-83" class="i">+	if err != nil {
</a><a href="#h24-0-84" id="h24-0-84" class="i">+		return nil, nil, err
</a><a href="#h24-0-85" id="h24-0-85" class="i">+	}
</a><a href="#h24-0-86" id="h24-0-86" class="i">+
</a><a href="#h24-0-87" id="h24-0-87" class="i">+	var events []IssueEvent
</a><a href="#h24-0-88" id="h24-0-88" class="i">+	resp, err := s.client.Do(req, &amp;events)
</a><a href="#h24-0-89" id="h24-0-89" class="i">+	if err != nil {
</a><a href="#h24-0-90" id="h24-0-90" class="i">+		return nil, resp, err
</a><a href="#h24-0-91" id="h24-0-91" class="i">+	}
</a><a href="#h24-0-92" id="h24-0-92" class="i">+
</a><a href="#h24-0-93" id="h24-0-93" class="i">+	return events, resp, err
</a><a href="#h24-0-94" id="h24-0-94" class="i">+}
</a><a href="#h24-0-95" id="h24-0-95" class="i">+
</a><a href="#h24-0-96" id="h24-0-96" class="i">+// ListRepositoryEvents lists events for the specified repository.
</a><a href="#h24-0-97" id="h24-0-97" class="i">+//
</a><a href="#h24-0-98" id="h24-0-98" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/events/#list-events-for-a-repository
</a><a href="#h24-0-99" id="h24-0-99" class="i">+func (s *IssuesService) ListRepositoryEvents(owner, repo string, opt *ListOptions) ([]IssueEvent, *Response, error) {
</a><a href="#h24-0-100" id="h24-0-100" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/events&quot;, owner, repo)
</a><a href="#h24-0-101" id="h24-0-101" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h24-0-102" id="h24-0-102" class="i">+	if err != nil {
</a><a href="#h24-0-103" id="h24-0-103" class="i">+		return nil, nil, err
</a><a href="#h24-0-104" id="h24-0-104" class="i">+	}
</a><a href="#h24-0-105" id="h24-0-105" class="i">+
</a><a href="#h24-0-106" id="h24-0-106" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h24-0-107" id="h24-0-107" class="i">+	if err != nil {
</a><a href="#h24-0-108" id="h24-0-108" class="i">+		return nil, nil, err
</a><a href="#h24-0-109" id="h24-0-109" class="i">+	}
</a><a href="#h24-0-110" id="h24-0-110" class="i">+
</a><a href="#h24-0-111" id="h24-0-111" class="i">+	var events []IssueEvent
</a><a href="#h24-0-112" id="h24-0-112" class="i">+	resp, err := s.client.Do(req, &amp;events)
</a><a href="#h24-0-113" id="h24-0-113" class="i">+	if err != nil {
</a><a href="#h24-0-114" id="h24-0-114" class="i">+		return nil, resp, err
</a><a href="#h24-0-115" id="h24-0-115" class="i">+	}
</a><a href="#h24-0-116" id="h24-0-116" class="i">+
</a><a href="#h24-0-117" id="h24-0-117" class="i">+	return events, resp, err
</a><a href="#h24-0-118" id="h24-0-118" class="i">+}
</a><a href="#h24-0-119" id="h24-0-119" class="i">+
</a><a href="#h24-0-120" id="h24-0-120" class="i">+// GetEvent returns the specified issue event.
</a><a href="#h24-0-121" id="h24-0-121" class="i">+//
</a><a href="#h24-0-122" id="h24-0-122" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/events/#get-a-single-event
</a><a href="#h24-0-123" id="h24-0-123" class="i">+func (s *IssuesService) GetEvent(owner, repo string, id int) (*IssueEvent, *Response, error) {
</a><a href="#h24-0-124" id="h24-0-124" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/events/%v&quot;, owner, repo, id)
</a><a href="#h24-0-125" id="h24-0-125" class="i">+
</a><a href="#h24-0-126" id="h24-0-126" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h24-0-127" id="h24-0-127" class="i">+	if err != nil {
</a><a href="#h24-0-128" id="h24-0-128" class="i">+		return nil, nil, err
</a><a href="#h24-0-129" id="h24-0-129" class="i">+	}
</a><a href="#h24-0-130" id="h24-0-130" class="i">+
</a><a href="#h24-0-131" id="h24-0-131" class="i">+	event := new(IssueEvent)
</a><a href="#h24-0-132" id="h24-0-132" class="i">+	resp, err := s.client.Do(req, event)
</a><a href="#h24-0-133" id="h24-0-133" class="i">+	if err != nil {
</a><a href="#h24-0-134" id="h24-0-134" class="i">+		return nil, resp, err
</a><a href="#h24-0-135" id="h24-0-135" class="i">+	}
</a><a href="#h24-0-136" id="h24-0-136" class="i">+
</a><a href="#h24-0-137" id="h24-0-137" class="i">+	return event, resp, err
</a><a href="#h24-0-138" id="h24-0-138" class="i">+}
</a><a href="#h24-0-139" id="h24-0-139" class="i">+
</a><a href="#h24-0-140" id="h24-0-140" class="i">+// Rename contains details for &#39;renamed&#39; events.
</a><a href="#h24-0-141" id="h24-0-141" class="i">+type Rename struct {
</a><a href="#h24-0-142" id="h24-0-142" class="i">+	From *string `json:&quot;from,omitempty&quot;`
</a><a href="#h24-0-143" id="h24-0-143" class="i">+	To   *string `json:&quot;to,omitempty&quot;`
</a><a href="#h24-0-144" id="h24-0-144" class="i">+}
</a><a href="#h24-0-145" id="h24-0-145" class="i">+
</a><a href="#h24-0-146" id="h24-0-146" class="i">+func (r Rename) String() string {
</a><a href="#h24-0-147" id="h24-0-147" class="i">+	return Stringify(r)
</a><a href="#h24-0-148" id="h24-0-148" class="i">+}
</a><b>diff --git a/<a id="h25" href="../file/vendor/github.com/google/go-github/github/issues_labels.go">vendor/github.com/google/go-github/github/issues_labels.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/issues_labels.go">vendor/github.com/google/go-github/github/issues_labels.go</a></b>
<a href="#h25-0" id="h25-0" class="h">@@ -0,0 +1,222 @@
</a><a href="#h25-0-0" id="h25-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h25-0-1" id="h25-0-1" class="i">+//
</a><a href="#h25-0-2" id="h25-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h25-0-3" id="h25-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h25-0-4" id="h25-0-4" class="i">+
</a><a href="#h25-0-5" id="h25-0-5" class="i">+package github
</a><a href="#h25-0-6" id="h25-0-6" class="i">+
</a><a href="#h25-0-7" id="h25-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h25-0-8" id="h25-0-8" class="i">+
</a><a href="#h25-0-9" id="h25-0-9" class="i">+// Label represents a GitHub label on an Issue
</a><a href="#h25-0-10" id="h25-0-10" class="i">+type Label struct {
</a><a href="#h25-0-11" id="h25-0-11" class="i">+	URL   *string `json:&quot;url,omitempty&quot;`
</a><a href="#h25-0-12" id="h25-0-12" class="i">+	Name  *string `json:&quot;name,omitempty&quot;`
</a><a href="#h25-0-13" id="h25-0-13" class="i">+	Color *string `json:&quot;color,omitempty&quot;`
</a><a href="#h25-0-14" id="h25-0-14" class="i">+}
</a><a href="#h25-0-15" id="h25-0-15" class="i">+
</a><a href="#h25-0-16" id="h25-0-16" class="i">+func (l Label) String() string {
</a><a href="#h25-0-17" id="h25-0-17" class="i">+	return fmt.Sprint(*l.Name)
</a><a href="#h25-0-18" id="h25-0-18" class="i">+}
</a><a href="#h25-0-19" id="h25-0-19" class="i">+
</a><a href="#h25-0-20" id="h25-0-20" class="i">+// ListLabels lists all labels for a repository.
</a><a href="#h25-0-21" id="h25-0-21" class="i">+//
</a><a href="#h25-0-22" id="h25-0-22" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
</a><a href="#h25-0-23" id="h25-0-23" class="i">+func (s *IssuesService) ListLabels(owner string, repo string, opt *ListOptions) ([]Label, *Response, error) {
</a><a href="#h25-0-24" id="h25-0-24" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/labels&quot;, owner, repo)
</a><a href="#h25-0-25" id="h25-0-25" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h25-0-26" id="h25-0-26" class="i">+	if err != nil {
</a><a href="#h25-0-27" id="h25-0-27" class="i">+		return nil, nil, err
</a><a href="#h25-0-28" id="h25-0-28" class="i">+	}
</a><a href="#h25-0-29" id="h25-0-29" class="i">+
</a><a href="#h25-0-30" id="h25-0-30" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h25-0-31" id="h25-0-31" class="i">+	if err != nil {
</a><a href="#h25-0-32" id="h25-0-32" class="i">+		return nil, nil, err
</a><a href="#h25-0-33" id="h25-0-33" class="i">+	}
</a><a href="#h25-0-34" id="h25-0-34" class="i">+
</a><a href="#h25-0-35" id="h25-0-35" class="i">+	labels := new([]Label)
</a><a href="#h25-0-36" id="h25-0-36" class="i">+	resp, err := s.client.Do(req, labels)
</a><a href="#h25-0-37" id="h25-0-37" class="i">+	if err != nil {
</a><a href="#h25-0-38" id="h25-0-38" class="i">+		return nil, resp, err
</a><a href="#h25-0-39" id="h25-0-39" class="i">+	}
</a><a href="#h25-0-40" id="h25-0-40" class="i">+
</a><a href="#h25-0-41" id="h25-0-41" class="i">+	return *labels, resp, err
</a><a href="#h25-0-42" id="h25-0-42" class="i">+}
</a><a href="#h25-0-43" id="h25-0-43" class="i">+
</a><a href="#h25-0-44" id="h25-0-44" class="i">+// GetLabel gets a single label.
</a><a href="#h25-0-45" id="h25-0-45" class="i">+//
</a><a href="#h25-0-46" id="h25-0-46" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#get-a-single-label
</a><a href="#h25-0-47" id="h25-0-47" class="i">+func (s *IssuesService) GetLabel(owner string, repo string, name string) (*Label, *Response, error) {
</a><a href="#h25-0-48" id="h25-0-48" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/labels/%v&quot;, owner, repo, name)
</a><a href="#h25-0-49" id="h25-0-49" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h25-0-50" id="h25-0-50" class="i">+	if err != nil {
</a><a href="#h25-0-51" id="h25-0-51" class="i">+		return nil, nil, err
</a><a href="#h25-0-52" id="h25-0-52" class="i">+	}
</a><a href="#h25-0-53" id="h25-0-53" class="i">+
</a><a href="#h25-0-54" id="h25-0-54" class="i">+	label := new(Label)
</a><a href="#h25-0-55" id="h25-0-55" class="i">+	resp, err := s.client.Do(req, label)
</a><a href="#h25-0-56" id="h25-0-56" class="i">+	if err != nil {
</a><a href="#h25-0-57" id="h25-0-57" class="i">+		return nil, resp, err
</a><a href="#h25-0-58" id="h25-0-58" class="i">+	}
</a><a href="#h25-0-59" id="h25-0-59" class="i">+
</a><a href="#h25-0-60" id="h25-0-60" class="i">+	return label, resp, err
</a><a href="#h25-0-61" id="h25-0-61" class="i">+}
</a><a href="#h25-0-62" id="h25-0-62" class="i">+
</a><a href="#h25-0-63" id="h25-0-63" class="i">+// CreateLabel creates a new label on the specified repository.
</a><a href="#h25-0-64" id="h25-0-64" class="i">+//
</a><a href="#h25-0-65" id="h25-0-65" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#create-a-label
</a><a href="#h25-0-66" id="h25-0-66" class="i">+func (s *IssuesService) CreateLabel(owner string, repo string, label *Label) (*Label, *Response, error) {
</a><a href="#h25-0-67" id="h25-0-67" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/labels&quot;, owner, repo)
</a><a href="#h25-0-68" id="h25-0-68" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, label)
</a><a href="#h25-0-69" id="h25-0-69" class="i">+	if err != nil {
</a><a href="#h25-0-70" id="h25-0-70" class="i">+		return nil, nil, err
</a><a href="#h25-0-71" id="h25-0-71" class="i">+	}
</a><a href="#h25-0-72" id="h25-0-72" class="i">+
</a><a href="#h25-0-73" id="h25-0-73" class="i">+	l := new(Label)
</a><a href="#h25-0-74" id="h25-0-74" class="i">+	resp, err := s.client.Do(req, l)
</a><a href="#h25-0-75" id="h25-0-75" class="i">+	if err != nil {
</a><a href="#h25-0-76" id="h25-0-76" class="i">+		return nil, resp, err
</a><a href="#h25-0-77" id="h25-0-77" class="i">+	}
</a><a href="#h25-0-78" id="h25-0-78" class="i">+
</a><a href="#h25-0-79" id="h25-0-79" class="i">+	return l, resp, err
</a><a href="#h25-0-80" id="h25-0-80" class="i">+}
</a><a href="#h25-0-81" id="h25-0-81" class="i">+
</a><a href="#h25-0-82" id="h25-0-82" class="i">+// EditLabel edits a label.
</a><a href="#h25-0-83" id="h25-0-83" class="i">+//
</a><a href="#h25-0-84" id="h25-0-84" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#update-a-label
</a><a href="#h25-0-85" id="h25-0-85" class="i">+func (s *IssuesService) EditLabel(owner string, repo string, name string, label *Label) (*Label, *Response, error) {
</a><a href="#h25-0-86" id="h25-0-86" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/labels/%v&quot;, owner, repo, name)
</a><a href="#h25-0-87" id="h25-0-87" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, label)
</a><a href="#h25-0-88" id="h25-0-88" class="i">+	if err != nil {
</a><a href="#h25-0-89" id="h25-0-89" class="i">+		return nil, nil, err
</a><a href="#h25-0-90" id="h25-0-90" class="i">+	}
</a><a href="#h25-0-91" id="h25-0-91" class="i">+
</a><a href="#h25-0-92" id="h25-0-92" class="i">+	l := new(Label)
</a><a href="#h25-0-93" id="h25-0-93" class="i">+	resp, err := s.client.Do(req, l)
</a><a href="#h25-0-94" id="h25-0-94" class="i">+	if err != nil {
</a><a href="#h25-0-95" id="h25-0-95" class="i">+		return nil, resp, err
</a><a href="#h25-0-96" id="h25-0-96" class="i">+	}
</a><a href="#h25-0-97" id="h25-0-97" class="i">+
</a><a href="#h25-0-98" id="h25-0-98" class="i">+	return l, resp, err
</a><a href="#h25-0-99" id="h25-0-99" class="i">+}
</a><a href="#h25-0-100" id="h25-0-100" class="i">+
</a><a href="#h25-0-101" id="h25-0-101" class="i">+// DeleteLabel deletes a label.
</a><a href="#h25-0-102" id="h25-0-102" class="i">+//
</a><a href="#h25-0-103" id="h25-0-103" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#delete-a-label
</a><a href="#h25-0-104" id="h25-0-104" class="i">+func (s *IssuesService) DeleteLabel(owner string, repo string, name string) (*Response, error) {
</a><a href="#h25-0-105" id="h25-0-105" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/labels/%v&quot;, owner, repo, name)
</a><a href="#h25-0-106" id="h25-0-106" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h25-0-107" id="h25-0-107" class="i">+	if err != nil {
</a><a href="#h25-0-108" id="h25-0-108" class="i">+		return nil, err
</a><a href="#h25-0-109" id="h25-0-109" class="i">+	}
</a><a href="#h25-0-110" id="h25-0-110" class="i">+	return s.client.Do(req, nil)
</a><a href="#h25-0-111" id="h25-0-111" class="i">+}
</a><a href="#h25-0-112" id="h25-0-112" class="i">+
</a><a href="#h25-0-113" id="h25-0-113" class="i">+// ListLabelsByIssue lists all labels for an issue.
</a><a href="#h25-0-114" id="h25-0-114" class="i">+//
</a><a href="#h25-0-115" id="h25-0-115" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
</a><a href="#h25-0-116" id="h25-0-116" class="i">+func (s *IssuesService) ListLabelsByIssue(owner string, repo string, number int, opt *ListOptions) ([]Label, *Response, error) {
</a><a href="#h25-0-117" id="h25-0-117" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/labels&quot;, owner, repo, number)
</a><a href="#h25-0-118" id="h25-0-118" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h25-0-119" id="h25-0-119" class="i">+	if err != nil {
</a><a href="#h25-0-120" id="h25-0-120" class="i">+		return nil, nil, err
</a><a href="#h25-0-121" id="h25-0-121" class="i">+	}
</a><a href="#h25-0-122" id="h25-0-122" class="i">+
</a><a href="#h25-0-123" id="h25-0-123" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h25-0-124" id="h25-0-124" class="i">+	if err != nil {
</a><a href="#h25-0-125" id="h25-0-125" class="i">+		return nil, nil, err
</a><a href="#h25-0-126" id="h25-0-126" class="i">+	}
</a><a href="#h25-0-127" id="h25-0-127" class="i">+
</a><a href="#h25-0-128" id="h25-0-128" class="i">+	labels := new([]Label)
</a><a href="#h25-0-129" id="h25-0-129" class="i">+	resp, err := s.client.Do(req, labels)
</a><a href="#h25-0-130" id="h25-0-130" class="i">+	if err != nil {
</a><a href="#h25-0-131" id="h25-0-131" class="i">+		return nil, resp, err
</a><a href="#h25-0-132" id="h25-0-132" class="i">+	}
</a><a href="#h25-0-133" id="h25-0-133" class="i">+
</a><a href="#h25-0-134" id="h25-0-134" class="i">+	return *labels, resp, err
</a><a href="#h25-0-135" id="h25-0-135" class="i">+}
</a><a href="#h25-0-136" id="h25-0-136" class="i">+
</a><a href="#h25-0-137" id="h25-0-137" class="i">+// AddLabelsToIssue adds labels to an issue.
</a><a href="#h25-0-138" id="h25-0-138" class="i">+//
</a><a href="#h25-0-139" id="h25-0-139" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
</a><a href="#h25-0-140" id="h25-0-140" class="i">+func (s *IssuesService) AddLabelsToIssue(owner string, repo string, number int, labels []string) ([]Label, *Response, error) {
</a><a href="#h25-0-141" id="h25-0-141" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/labels&quot;, owner, repo, number)
</a><a href="#h25-0-142" id="h25-0-142" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, labels)
</a><a href="#h25-0-143" id="h25-0-143" class="i">+	if err != nil {
</a><a href="#h25-0-144" id="h25-0-144" class="i">+		return nil, nil, err
</a><a href="#h25-0-145" id="h25-0-145" class="i">+	}
</a><a href="#h25-0-146" id="h25-0-146" class="i">+
</a><a href="#h25-0-147" id="h25-0-147" class="i">+	l := new([]Label)
</a><a href="#h25-0-148" id="h25-0-148" class="i">+	resp, err := s.client.Do(req, l)
</a><a href="#h25-0-149" id="h25-0-149" class="i">+	if err != nil {
</a><a href="#h25-0-150" id="h25-0-150" class="i">+		return nil, resp, err
</a><a href="#h25-0-151" id="h25-0-151" class="i">+	}
</a><a href="#h25-0-152" id="h25-0-152" class="i">+
</a><a href="#h25-0-153" id="h25-0-153" class="i">+	return *l, resp, err
</a><a href="#h25-0-154" id="h25-0-154" class="i">+}
</a><a href="#h25-0-155" id="h25-0-155" class="i">+
</a><a href="#h25-0-156" id="h25-0-156" class="i">+// RemoveLabelForIssue removes a label for an issue.
</a><a href="#h25-0-157" id="h25-0-157" class="i">+//
</a><a href="#h25-0-158" id="h25-0-158" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue
</a><a href="#h25-0-159" id="h25-0-159" class="i">+func (s *IssuesService) RemoveLabelForIssue(owner string, repo string, number int, label string) (*Response, error) {
</a><a href="#h25-0-160" id="h25-0-160" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/labels/%v&quot;, owner, repo, number, label)
</a><a href="#h25-0-161" id="h25-0-161" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h25-0-162" id="h25-0-162" class="i">+	if err != nil {
</a><a href="#h25-0-163" id="h25-0-163" class="i">+		return nil, err
</a><a href="#h25-0-164" id="h25-0-164" class="i">+	}
</a><a href="#h25-0-165" id="h25-0-165" class="i">+	return s.client.Do(req, nil)
</a><a href="#h25-0-166" id="h25-0-166" class="i">+}
</a><a href="#h25-0-167" id="h25-0-167" class="i">+
</a><a href="#h25-0-168" id="h25-0-168" class="i">+// ReplaceLabelsForIssue replaces all labels for an issue.
</a><a href="#h25-0-169" id="h25-0-169" class="i">+//
</a><a href="#h25-0-170" id="h25-0-170" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue
</a><a href="#h25-0-171" id="h25-0-171" class="i">+func (s *IssuesService) ReplaceLabelsForIssue(owner string, repo string, number int, labels []string) ([]Label, *Response, error) {
</a><a href="#h25-0-172" id="h25-0-172" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/labels&quot;, owner, repo, number)
</a><a href="#h25-0-173" id="h25-0-173" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, labels)
</a><a href="#h25-0-174" id="h25-0-174" class="i">+	if err != nil {
</a><a href="#h25-0-175" id="h25-0-175" class="i">+		return nil, nil, err
</a><a href="#h25-0-176" id="h25-0-176" class="i">+	}
</a><a href="#h25-0-177" id="h25-0-177" class="i">+
</a><a href="#h25-0-178" id="h25-0-178" class="i">+	l := new([]Label)
</a><a href="#h25-0-179" id="h25-0-179" class="i">+	resp, err := s.client.Do(req, l)
</a><a href="#h25-0-180" id="h25-0-180" class="i">+	if err != nil {
</a><a href="#h25-0-181" id="h25-0-181" class="i">+		return nil, resp, err
</a><a href="#h25-0-182" id="h25-0-182" class="i">+	}
</a><a href="#h25-0-183" id="h25-0-183" class="i">+
</a><a href="#h25-0-184" id="h25-0-184" class="i">+	return *l, resp, err
</a><a href="#h25-0-185" id="h25-0-185" class="i">+}
</a><a href="#h25-0-186" id="h25-0-186" class="i">+
</a><a href="#h25-0-187" id="h25-0-187" class="i">+// RemoveLabelsForIssue removes all labels for an issue.
</a><a href="#h25-0-188" id="h25-0-188" class="i">+//
</a><a href="#h25-0-189" id="h25-0-189" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue
</a><a href="#h25-0-190" id="h25-0-190" class="i">+func (s *IssuesService) RemoveLabelsForIssue(owner string, repo string, number int) (*Response, error) {
</a><a href="#h25-0-191" id="h25-0-191" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/issues/%d/labels&quot;, owner, repo, number)
</a><a href="#h25-0-192" id="h25-0-192" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h25-0-193" id="h25-0-193" class="i">+	if err != nil {
</a><a href="#h25-0-194" id="h25-0-194" class="i">+		return nil, err
</a><a href="#h25-0-195" id="h25-0-195" class="i">+	}
</a><a href="#h25-0-196" id="h25-0-196" class="i">+	return s.client.Do(req, nil)
</a><a href="#h25-0-197" id="h25-0-197" class="i">+}
</a><a href="#h25-0-198" id="h25-0-198" class="i">+
</a><a href="#h25-0-199" id="h25-0-199" class="i">+// ListLabelsForMilestone lists labels for every issue in a milestone.
</a><a href="#h25-0-200" id="h25-0-200" class="i">+//
</a><a href="#h25-0-201" id="h25-0-201" class="i">+// GitHub API docs: http://developer.github.com/v3/issues/labels/#get-labels-for-every-issue-in-a-milestone
</a><a href="#h25-0-202" id="h25-0-202" class="i">+func (s *IssuesService) ListLabelsForMilestone(owner string, repo string, number int, opt *ListOptions) ([]Label, *Response, error) {
</a><a href="#h25-0-203" id="h25-0-203" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/milestones/%d/labels&quot;, owner, repo, number)
</a><a href="#h25-0-204" id="h25-0-204" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h25-0-205" id="h25-0-205" class="i">+	if err != nil {
</a><a href="#h25-0-206" id="h25-0-206" class="i">+		return nil, nil, err
</a><a href="#h25-0-207" id="h25-0-207" class="i">+	}
</a><a href="#h25-0-208" id="h25-0-208" class="i">+
</a><a href="#h25-0-209" id="h25-0-209" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h25-0-210" id="h25-0-210" class="i">+	if err != nil {
</a><a href="#h25-0-211" id="h25-0-211" class="i">+		return nil, nil, err
</a><a href="#h25-0-212" id="h25-0-212" class="i">+	}
</a><a href="#h25-0-213" id="h25-0-213" class="i">+
</a><a href="#h25-0-214" id="h25-0-214" class="i">+	labels := new([]Label)
</a><a href="#h25-0-215" id="h25-0-215" class="i">+	resp, err := s.client.Do(req, labels)
</a><a href="#h25-0-216" id="h25-0-216" class="i">+	if err != nil {
</a><a href="#h25-0-217" id="h25-0-217" class="i">+		return nil, resp, err
</a><a href="#h25-0-218" id="h25-0-218" class="i">+	}
</a><a href="#h25-0-219" id="h25-0-219" class="i">+
</a><a href="#h25-0-220" id="h25-0-220" class="i">+	return *labels, resp, err
</a><a href="#h25-0-221" id="h25-0-221" class="i">+}
</a><b>diff --git a/<a id="h26" href="../file/vendor/github.com/google/go-github/github/issues_milestones.go">vendor/github.com/google/go-github/github/issues_milestones.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/issues_milestones.go">vendor/github.com/google/go-github/github/issues_milestones.go</a></b>
<a href="#h26-0" id="h26-0" class="h">@@ -0,0 +1,144 @@
</a><a href="#h26-0-0" id="h26-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h26-0-1" id="h26-0-1" class="i">+//
</a><a href="#h26-0-2" id="h26-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h26-0-3" id="h26-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h26-0-4" id="h26-0-4" class="i">+
</a><a href="#h26-0-5" id="h26-0-5" class="i">+package github
</a><a href="#h26-0-6" id="h26-0-6" class="i">+
</a><a href="#h26-0-7" id="h26-0-7" class="i">+import (
</a><a href="#h26-0-8" id="h26-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h26-0-9" id="h26-0-9" class="i">+	&quot;time&quot;
</a><a href="#h26-0-10" id="h26-0-10" class="i">+)
</a><a href="#h26-0-11" id="h26-0-11" class="i">+
</a><a href="#h26-0-12" id="h26-0-12" class="i">+// Milestone represents a Github repository milestone.
</a><a href="#h26-0-13" id="h26-0-13" class="i">+type Milestone struct {
</a><a href="#h26-0-14" id="h26-0-14" class="i">+	URL          *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h26-0-15" id="h26-0-15" class="i">+	HTMLURL      *string    `json:&quot;html_url,omitempty&quot;`
</a><a href="#h26-0-16" id="h26-0-16" class="i">+	LabelsURL    *string    `json:&quot;labels_url,omitempty&quot;`
</a><a href="#h26-0-17" id="h26-0-17" class="i">+	ID           *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h26-0-18" id="h26-0-18" class="i">+	Number       *int       `json:&quot;number,omitempty&quot;`
</a><a href="#h26-0-19" id="h26-0-19" class="i">+	State        *string    `json:&quot;state,omitempty&quot;`
</a><a href="#h26-0-20" id="h26-0-20" class="i">+	Title        *string    `json:&quot;title,omitempty&quot;`
</a><a href="#h26-0-21" id="h26-0-21" class="i">+	Description  *string    `json:&quot;description,omitempty&quot;`
</a><a href="#h26-0-22" id="h26-0-22" class="i">+	Creator      *User      `json:&quot;creator,omitempty&quot;`
</a><a href="#h26-0-23" id="h26-0-23" class="i">+	OpenIssues   *int       `json:&quot;open_issues,omitempty&quot;`
</a><a href="#h26-0-24" id="h26-0-24" class="i">+	ClosedIssues *int       `json:&quot;closed_issues,omitempty&quot;`
</a><a href="#h26-0-25" id="h26-0-25" class="i">+	CreatedAt    *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h26-0-26" id="h26-0-26" class="i">+	UpdatedAt    *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h26-0-27" id="h26-0-27" class="i">+	ClosedAt     *time.Time `json:&quot;closed_at,omitempty&quot;`
</a><a href="#h26-0-28" id="h26-0-28" class="i">+	DueOn        *time.Time `json:&quot;due_on,omitempty&quot;`
</a><a href="#h26-0-29" id="h26-0-29" class="i">+}
</a><a href="#h26-0-30" id="h26-0-30" class="i">+
</a><a href="#h26-0-31" id="h26-0-31" class="i">+func (m Milestone) String() string {
</a><a href="#h26-0-32" id="h26-0-32" class="i">+	return Stringify(m)
</a><a href="#h26-0-33" id="h26-0-33" class="i">+}
</a><a href="#h26-0-34" id="h26-0-34" class="i">+
</a><a href="#h26-0-35" id="h26-0-35" class="i">+// MilestoneListOptions specifies the optional parameters to the
</a><a href="#h26-0-36" id="h26-0-36" class="i">+// IssuesService.ListMilestones method.
</a><a href="#h26-0-37" id="h26-0-37" class="i">+type MilestoneListOptions struct {
</a><a href="#h26-0-38" id="h26-0-38" class="i">+	// State filters milestones based on their state. Possible values are:
</a><a href="#h26-0-39" id="h26-0-39" class="i">+	// open, closed. Default is &quot;open&quot;.
</a><a href="#h26-0-40" id="h26-0-40" class="i">+	State string `url:&quot;state,omitempty&quot;`
</a><a href="#h26-0-41" id="h26-0-41" class="i">+
</a><a href="#h26-0-42" id="h26-0-42" class="i">+	// Sort specifies how to sort milestones. Possible values are: due_date, completeness.
</a><a href="#h26-0-43" id="h26-0-43" class="i">+	// Default value is &quot;due_date&quot;.
</a><a href="#h26-0-44" id="h26-0-44" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h26-0-45" id="h26-0-45" class="i">+
</a><a href="#h26-0-46" id="h26-0-46" class="i">+	// Direction in which to sort milestones. Possible values are: asc, desc.
</a><a href="#h26-0-47" id="h26-0-47" class="i">+	// Default is &quot;asc&quot;.
</a><a href="#h26-0-48" id="h26-0-48" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h26-0-49" id="h26-0-49" class="i">+}
</a><a href="#h26-0-50" id="h26-0-50" class="i">+
</a><a href="#h26-0-51" id="h26-0-51" class="i">+// ListMilestones lists all milestones for a repository.
</a><a href="#h26-0-52" id="h26-0-52" class="i">+//
</a><a href="#h26-0-53" id="h26-0-53" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/milestones/#list-milestones-for-a-repository
</a><a href="#h26-0-54" id="h26-0-54" class="i">+func (s *IssuesService) ListMilestones(owner string, repo string, opt *MilestoneListOptions) ([]Milestone, *Response, error) {
</a><a href="#h26-0-55" id="h26-0-55" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/milestones&quot;, owner, repo)
</a><a href="#h26-0-56" id="h26-0-56" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h26-0-57" id="h26-0-57" class="i">+	if err != nil {
</a><a href="#h26-0-58" id="h26-0-58" class="i">+		return nil, nil, err
</a><a href="#h26-0-59" id="h26-0-59" class="i">+	}
</a><a href="#h26-0-60" id="h26-0-60" class="i">+
</a><a href="#h26-0-61" id="h26-0-61" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h26-0-62" id="h26-0-62" class="i">+	if err != nil {
</a><a href="#h26-0-63" id="h26-0-63" class="i">+		return nil, nil, err
</a><a href="#h26-0-64" id="h26-0-64" class="i">+	}
</a><a href="#h26-0-65" id="h26-0-65" class="i">+
</a><a href="#h26-0-66" id="h26-0-66" class="i">+	milestones := new([]Milestone)
</a><a href="#h26-0-67" id="h26-0-67" class="i">+	resp, err := s.client.Do(req, milestones)
</a><a href="#h26-0-68" id="h26-0-68" class="i">+	if err != nil {
</a><a href="#h26-0-69" id="h26-0-69" class="i">+		return nil, resp, err
</a><a href="#h26-0-70" id="h26-0-70" class="i">+	}
</a><a href="#h26-0-71" id="h26-0-71" class="i">+
</a><a href="#h26-0-72" id="h26-0-72" class="i">+	return *milestones, resp, err
</a><a href="#h26-0-73" id="h26-0-73" class="i">+}
</a><a href="#h26-0-74" id="h26-0-74" class="i">+
</a><a href="#h26-0-75" id="h26-0-75" class="i">+// GetMilestone gets a single milestone.
</a><a href="#h26-0-76" id="h26-0-76" class="i">+//
</a><a href="#h26-0-77" id="h26-0-77" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/milestones/#get-a-single-milestone
</a><a href="#h26-0-78" id="h26-0-78" class="i">+func (s *IssuesService) GetMilestone(owner string, repo string, number int) (*Milestone, *Response, error) {
</a><a href="#h26-0-79" id="h26-0-79" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/milestones/%d&quot;, owner, repo, number)
</a><a href="#h26-0-80" id="h26-0-80" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h26-0-81" id="h26-0-81" class="i">+	if err != nil {
</a><a href="#h26-0-82" id="h26-0-82" class="i">+		return nil, nil, err
</a><a href="#h26-0-83" id="h26-0-83" class="i">+	}
</a><a href="#h26-0-84" id="h26-0-84" class="i">+
</a><a href="#h26-0-85" id="h26-0-85" class="i">+	milestone := new(Milestone)
</a><a href="#h26-0-86" id="h26-0-86" class="i">+	resp, err := s.client.Do(req, milestone)
</a><a href="#h26-0-87" id="h26-0-87" class="i">+	if err != nil {
</a><a href="#h26-0-88" id="h26-0-88" class="i">+		return nil, resp, err
</a><a href="#h26-0-89" id="h26-0-89" class="i">+	}
</a><a href="#h26-0-90" id="h26-0-90" class="i">+
</a><a href="#h26-0-91" id="h26-0-91" class="i">+	return milestone, resp, err
</a><a href="#h26-0-92" id="h26-0-92" class="i">+}
</a><a href="#h26-0-93" id="h26-0-93" class="i">+
</a><a href="#h26-0-94" id="h26-0-94" class="i">+// CreateMilestone creates a new milestone on the specified repository.
</a><a href="#h26-0-95" id="h26-0-95" class="i">+//
</a><a href="#h26-0-96" id="h26-0-96" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/milestones/#create-a-milestone
</a><a href="#h26-0-97" id="h26-0-97" class="i">+func (s *IssuesService) CreateMilestone(owner string, repo string, milestone *Milestone) (*Milestone, *Response, error) {
</a><a href="#h26-0-98" id="h26-0-98" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/milestones&quot;, owner, repo)
</a><a href="#h26-0-99" id="h26-0-99" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, milestone)
</a><a href="#h26-0-100" id="h26-0-100" class="i">+	if err != nil {
</a><a href="#h26-0-101" id="h26-0-101" class="i">+		return nil, nil, err
</a><a href="#h26-0-102" id="h26-0-102" class="i">+	}
</a><a href="#h26-0-103" id="h26-0-103" class="i">+
</a><a href="#h26-0-104" id="h26-0-104" class="i">+	m := new(Milestone)
</a><a href="#h26-0-105" id="h26-0-105" class="i">+	resp, err := s.client.Do(req, m)
</a><a href="#h26-0-106" id="h26-0-106" class="i">+	if err != nil {
</a><a href="#h26-0-107" id="h26-0-107" class="i">+		return nil, resp, err
</a><a href="#h26-0-108" id="h26-0-108" class="i">+	}
</a><a href="#h26-0-109" id="h26-0-109" class="i">+
</a><a href="#h26-0-110" id="h26-0-110" class="i">+	return m, resp, err
</a><a href="#h26-0-111" id="h26-0-111" class="i">+}
</a><a href="#h26-0-112" id="h26-0-112" class="i">+
</a><a href="#h26-0-113" id="h26-0-113" class="i">+// EditMilestone edits a milestone.
</a><a href="#h26-0-114" id="h26-0-114" class="i">+//
</a><a href="#h26-0-115" id="h26-0-115" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/milestones/#update-a-milestone
</a><a href="#h26-0-116" id="h26-0-116" class="i">+func (s *IssuesService) EditMilestone(owner string, repo string, number int, milestone *Milestone) (*Milestone, *Response, error) {
</a><a href="#h26-0-117" id="h26-0-117" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/milestones/%d&quot;, owner, repo, number)
</a><a href="#h26-0-118" id="h26-0-118" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, milestone)
</a><a href="#h26-0-119" id="h26-0-119" class="i">+	if err != nil {
</a><a href="#h26-0-120" id="h26-0-120" class="i">+		return nil, nil, err
</a><a href="#h26-0-121" id="h26-0-121" class="i">+	}
</a><a href="#h26-0-122" id="h26-0-122" class="i">+
</a><a href="#h26-0-123" id="h26-0-123" class="i">+	m := new(Milestone)
</a><a href="#h26-0-124" id="h26-0-124" class="i">+	resp, err := s.client.Do(req, m)
</a><a href="#h26-0-125" id="h26-0-125" class="i">+	if err != nil {
</a><a href="#h26-0-126" id="h26-0-126" class="i">+		return nil, resp, err
</a><a href="#h26-0-127" id="h26-0-127" class="i">+	}
</a><a href="#h26-0-128" id="h26-0-128" class="i">+
</a><a href="#h26-0-129" id="h26-0-129" class="i">+	return m, resp, err
</a><a href="#h26-0-130" id="h26-0-130" class="i">+}
</a><a href="#h26-0-131" id="h26-0-131" class="i">+
</a><a href="#h26-0-132" id="h26-0-132" class="i">+// DeleteMilestone deletes a milestone.
</a><a href="#h26-0-133" id="h26-0-133" class="i">+//
</a><a href="#h26-0-134" id="h26-0-134" class="i">+// GitHub API docs: https://developer.github.com/v3/issues/milestones/#delete-a-milestone
</a><a href="#h26-0-135" id="h26-0-135" class="i">+func (s *IssuesService) DeleteMilestone(owner string, repo string, number int) (*Response, error) {
</a><a href="#h26-0-136" id="h26-0-136" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/milestones/%d&quot;, owner, repo, number)
</a><a href="#h26-0-137" id="h26-0-137" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h26-0-138" id="h26-0-138" class="i">+	if err != nil {
</a><a href="#h26-0-139" id="h26-0-139" class="i">+		return nil, err
</a><a href="#h26-0-140" id="h26-0-140" class="i">+	}
</a><a href="#h26-0-141" id="h26-0-141" class="i">+
</a><a href="#h26-0-142" id="h26-0-142" class="i">+	return s.client.Do(req, nil)
</a><a href="#h26-0-143" id="h26-0-143" class="i">+}
</a><b>diff --git a/<a id="h27" href="../file/vendor/github.com/google/go-github/github/licenses.go">vendor/github.com/google/go-github/github/licenses.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/licenses.go">vendor/github.com/google/go-github/github/licenses.go</a></b>
<a href="#h27-0" id="h27-0" class="h">@@ -0,0 +1,81 @@
</a><a href="#h27-0-0" id="h27-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h27-0-1" id="h27-0-1" class="i">+//
</a><a href="#h27-0-2" id="h27-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h27-0-3" id="h27-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h27-0-4" id="h27-0-4" class="i">+
</a><a href="#h27-0-5" id="h27-0-5" class="i">+package github
</a><a href="#h27-0-6" id="h27-0-6" class="i">+
</a><a href="#h27-0-7" id="h27-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h27-0-8" id="h27-0-8" class="i">+
</a><a href="#h27-0-9" id="h27-0-9" class="i">+// LicensesService handles communication with the license related
</a><a href="#h27-0-10" id="h27-0-10" class="i">+// methods of the GitHub API.
</a><a href="#h27-0-11" id="h27-0-11" class="i">+//
</a><a href="#h27-0-12" id="h27-0-12" class="i">+// GitHub API docs: http://developer.github.com/v3/pulls/
</a><a href="#h27-0-13" id="h27-0-13" class="i">+type LicensesService struct {
</a><a href="#h27-0-14" id="h27-0-14" class="i">+	client *Client
</a><a href="#h27-0-15" id="h27-0-15" class="i">+}
</a><a href="#h27-0-16" id="h27-0-16" class="i">+
</a><a href="#h27-0-17" id="h27-0-17" class="i">+// License represents an open source license.
</a><a href="#h27-0-18" id="h27-0-18" class="i">+type License struct {
</a><a href="#h27-0-19" id="h27-0-19" class="i">+	Key  *string `json:&quot;key,omitempty&quot;`
</a><a href="#h27-0-20" id="h27-0-20" class="i">+	Name *string `json:&quot;name,omitempty&quot;`
</a><a href="#h27-0-21" id="h27-0-21" class="i">+	URL  *string `json:&quot;url,omitempty&quot;`
</a><a href="#h27-0-22" id="h27-0-22" class="i">+
</a><a href="#h27-0-23" id="h27-0-23" class="i">+	HTMLURL        *string   `json:&quot;html_url,omitempty&quot;`
</a><a href="#h27-0-24" id="h27-0-24" class="i">+	Featured       *bool     `json:&quot;featured,omitempty&quot;`
</a><a href="#h27-0-25" id="h27-0-25" class="i">+	Description    *string   `json:&quot;description,omitempty&quot;`
</a><a href="#h27-0-26" id="h27-0-26" class="i">+	Category       *string   `json:&quot;category,omitempty&quot;`
</a><a href="#h27-0-27" id="h27-0-27" class="i">+	Implementation *string   `json:&quot;implementation,omitempty&quot;`
</a><a href="#h27-0-28" id="h27-0-28" class="i">+	Required       *[]string `json:&quot;required,omitempty&quot;`
</a><a href="#h27-0-29" id="h27-0-29" class="i">+	Permitted      *[]string `json:&quot;permitted,omitempty&quot;`
</a><a href="#h27-0-30" id="h27-0-30" class="i">+	Forbidden      *[]string `json:&quot;forbidden,omitempty&quot;`
</a><a href="#h27-0-31" id="h27-0-31" class="i">+	Body           *string   `json:&quot;body,omitempty&quot;`
</a><a href="#h27-0-32" id="h27-0-32" class="i">+}
</a><a href="#h27-0-33" id="h27-0-33" class="i">+
</a><a href="#h27-0-34" id="h27-0-34" class="i">+func (l License) String() string {
</a><a href="#h27-0-35" id="h27-0-35" class="i">+	return Stringify(l)
</a><a href="#h27-0-36" id="h27-0-36" class="i">+}
</a><a href="#h27-0-37" id="h27-0-37" class="i">+
</a><a href="#h27-0-38" id="h27-0-38" class="i">+// List popular open source licenses.
</a><a href="#h27-0-39" id="h27-0-39" class="i">+//
</a><a href="#h27-0-40" id="h27-0-40" class="i">+// GitHub API docs: https://developer.github.com/v3/licenses/#list-all-licenses
</a><a href="#h27-0-41" id="h27-0-41" class="i">+func (s *LicensesService) List() ([]License, *Response, error) {
</a><a href="#h27-0-42" id="h27-0-42" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, &quot;licenses&quot;, nil)
</a><a href="#h27-0-43" id="h27-0-43" class="i">+	if err != nil {
</a><a href="#h27-0-44" id="h27-0-44" class="i">+		return nil, nil, err
</a><a href="#h27-0-45" id="h27-0-45" class="i">+	}
</a><a href="#h27-0-46" id="h27-0-46" class="i">+
</a><a href="#h27-0-47" id="h27-0-47" class="i">+	// TODO: remove custom Accept header when this API fully launches
</a><a href="#h27-0-48" id="h27-0-48" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeLicensesPreview)
</a><a href="#h27-0-49" id="h27-0-49" class="i">+
</a><a href="#h27-0-50" id="h27-0-50" class="i">+	licenses := new([]License)
</a><a href="#h27-0-51" id="h27-0-51" class="i">+	resp, err := s.client.Do(req, licenses)
</a><a href="#h27-0-52" id="h27-0-52" class="i">+	if err != nil {
</a><a href="#h27-0-53" id="h27-0-53" class="i">+		return nil, resp, err
</a><a href="#h27-0-54" id="h27-0-54" class="i">+	}
</a><a href="#h27-0-55" id="h27-0-55" class="i">+
</a><a href="#h27-0-56" id="h27-0-56" class="i">+	return *licenses, resp, err
</a><a href="#h27-0-57" id="h27-0-57" class="i">+}
</a><a href="#h27-0-58" id="h27-0-58" class="i">+
</a><a href="#h27-0-59" id="h27-0-59" class="i">+// Get extended metadata for one license.
</a><a href="#h27-0-60" id="h27-0-60" class="i">+//
</a><a href="#h27-0-61" id="h27-0-61" class="i">+// GitHub API docs: https://developer.github.com/v3/licenses/#get-an-individual-license
</a><a href="#h27-0-62" id="h27-0-62" class="i">+func (s *LicensesService) Get(licenseName string) (*License, *Response, error) {
</a><a href="#h27-0-63" id="h27-0-63" class="i">+	u := fmt.Sprintf(&quot;licenses/%s&quot;, licenseName)
</a><a href="#h27-0-64" id="h27-0-64" class="i">+
</a><a href="#h27-0-65" id="h27-0-65" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h27-0-66" id="h27-0-66" class="i">+	if err != nil {
</a><a href="#h27-0-67" id="h27-0-67" class="i">+		return nil, nil, err
</a><a href="#h27-0-68" id="h27-0-68" class="i">+	}
</a><a href="#h27-0-69" id="h27-0-69" class="i">+
</a><a href="#h27-0-70" id="h27-0-70" class="i">+	// TODO: remove custom Accept header when this API fully launches
</a><a href="#h27-0-71" id="h27-0-71" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeLicensesPreview)
</a><a href="#h27-0-72" id="h27-0-72" class="i">+
</a><a href="#h27-0-73" id="h27-0-73" class="i">+	license := new(License)
</a><a href="#h27-0-74" id="h27-0-74" class="i">+	resp, err := s.client.Do(req, license)
</a><a href="#h27-0-75" id="h27-0-75" class="i">+	if err != nil {
</a><a href="#h27-0-76" id="h27-0-76" class="i">+		return nil, resp, err
</a><a href="#h27-0-77" id="h27-0-77" class="i">+	}
</a><a href="#h27-0-78" id="h27-0-78" class="i">+
</a><a href="#h27-0-79" id="h27-0-79" class="i">+	return license, resp, err
</a><a href="#h27-0-80" id="h27-0-80" class="i">+}
</a><b>diff --git a/<a id="h28" href="../file/vendor/github.com/google/go-github/github/migrations.go">vendor/github.com/google/go-github/github/migrations.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/migrations.go">vendor/github.com/google/go-github/github/migrations.go</a></b>
<a href="#h28-0" id="h28-0" class="h">@@ -0,0 +1,225 @@
</a><a href="#h28-0-0" id="h28-0-0" class="i">+// Copyright 2016 The go-github AUTHORS. All rights reserved.
</a><a href="#h28-0-1" id="h28-0-1" class="i">+//
</a><a href="#h28-0-2" id="h28-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h28-0-3" id="h28-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h28-0-4" id="h28-0-4" class="i">+
</a><a href="#h28-0-5" id="h28-0-5" class="i">+package github
</a><a href="#h28-0-6" id="h28-0-6" class="i">+
</a><a href="#h28-0-7" id="h28-0-7" class="i">+import (
</a><a href="#h28-0-8" id="h28-0-8" class="i">+	&quot;errors&quot;
</a><a href="#h28-0-9" id="h28-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h28-0-10" id="h28-0-10" class="i">+	&quot;net/http&quot;
</a><a href="#h28-0-11" id="h28-0-11" class="i">+	&quot;strings&quot;
</a><a href="#h28-0-12" id="h28-0-12" class="i">+)
</a><a href="#h28-0-13" id="h28-0-13" class="i">+
</a><a href="#h28-0-14" id="h28-0-14" class="i">+// MigrationService provides access to the migration related functions
</a><a href="#h28-0-15" id="h28-0-15" class="i">+// in the GitHub API.
</a><a href="#h28-0-16" id="h28-0-16" class="i">+//
</a><a href="#h28-0-17" id="h28-0-17" class="i">+// GitHub API docs: https://developer.github.com/v3/migration/
</a><a href="#h28-0-18" id="h28-0-18" class="i">+type MigrationService struct {
</a><a href="#h28-0-19" id="h28-0-19" class="i">+	client *Client
</a><a href="#h28-0-20" id="h28-0-20" class="i">+}
</a><a href="#h28-0-21" id="h28-0-21" class="i">+
</a><a href="#h28-0-22" id="h28-0-22" class="i">+// Migration represents a GitHub migration (archival).
</a><a href="#h28-0-23" id="h28-0-23" class="i">+type Migration struct {
</a><a href="#h28-0-24" id="h28-0-24" class="i">+	ID   *int    `json:&quot;id,omitempty&quot;`
</a><a href="#h28-0-25" id="h28-0-25" class="i">+	GUID *string `json:&quot;guid,omitempty&quot;`
</a><a href="#h28-0-26" id="h28-0-26" class="i">+	// State is the current state of a migration.
</a><a href="#h28-0-27" id="h28-0-27" class="i">+	// Possible values are:
</a><a href="#h28-0-28" id="h28-0-28" class="i">+	//     &quot;pending&quot; which means the migration hasn&#39;t started yet,
</a><a href="#h28-0-29" id="h28-0-29" class="i">+	//     &quot;exporting&quot; which means the migration is in progress,
</a><a href="#h28-0-30" id="h28-0-30" class="i">+	//     &quot;exported&quot; which means the migration finished successfully, or
</a><a href="#h28-0-31" id="h28-0-31" class="i">+	//     &quot;failed&quot; which means the migration failed.
</a><a href="#h28-0-32" id="h28-0-32" class="i">+	State *string `json:&quot;state,omitempty&quot;`
</a><a href="#h28-0-33" id="h28-0-33" class="i">+	// LockRepositories indicates whether repositories are locked (to prevent
</a><a href="#h28-0-34" id="h28-0-34" class="i">+	// manipulation) while migrating data.
</a><a href="#h28-0-35" id="h28-0-35" class="i">+	LockRepositories *bool `json:&quot;lock_repositories,omitempty&quot;`
</a><a href="#h28-0-36" id="h28-0-36" class="i">+	// ExcludeAttachments indicates whether attachments should be excluded from
</a><a href="#h28-0-37" id="h28-0-37" class="i">+	// the migration (to reduce migration archive file size).
</a><a href="#h28-0-38" id="h28-0-38" class="i">+	ExcludeAttachments *bool         `json:&quot;exclude_attachments,omitempty&quot;`
</a><a href="#h28-0-39" id="h28-0-39" class="i">+	URL                *string       `json:&quot;url,omitempty&quot;`
</a><a href="#h28-0-40" id="h28-0-40" class="i">+	CreatedAt          *string       `json:&quot;created_at,omitempty&quot;`
</a><a href="#h28-0-41" id="h28-0-41" class="i">+	UpdatedAt          *string       `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h28-0-42" id="h28-0-42" class="i">+	Repositories       []*Repository `json:&quot;repositories,omitempty&quot;`
</a><a href="#h28-0-43" id="h28-0-43" class="i">+}
</a><a href="#h28-0-44" id="h28-0-44" class="i">+
</a><a href="#h28-0-45" id="h28-0-45" class="i">+func (m Migration) String() string {
</a><a href="#h28-0-46" id="h28-0-46" class="i">+	return Stringify(m)
</a><a href="#h28-0-47" id="h28-0-47" class="i">+}
</a><a href="#h28-0-48" id="h28-0-48" class="i">+
</a><a href="#h28-0-49" id="h28-0-49" class="i">+// MigrationOptions specifies the optional parameters to Migration methods.
</a><a href="#h28-0-50" id="h28-0-50" class="i">+type MigrationOptions struct {
</a><a href="#h28-0-51" id="h28-0-51" class="i">+	// LockRepositories indicates whether repositories should be locked (to prevent
</a><a href="#h28-0-52" id="h28-0-52" class="i">+	// manipulation) while migrating data.
</a><a href="#h28-0-53" id="h28-0-53" class="i">+	LockRepositories bool
</a><a href="#h28-0-54" id="h28-0-54" class="i">+
</a><a href="#h28-0-55" id="h28-0-55" class="i">+	// ExcludeAttachments indicates whether attachments should be excluded from
</a><a href="#h28-0-56" id="h28-0-56" class="i">+	// the migration (to reduce migration archive file size).
</a><a href="#h28-0-57" id="h28-0-57" class="i">+	ExcludeAttachments bool
</a><a href="#h28-0-58" id="h28-0-58" class="i">+}
</a><a href="#h28-0-59" id="h28-0-59" class="i">+
</a><a href="#h28-0-60" id="h28-0-60" class="i">+// startMigration represents the body of a StartMigration request.
</a><a href="#h28-0-61" id="h28-0-61" class="i">+type startMigration struct {
</a><a href="#h28-0-62" id="h28-0-62" class="i">+	// Repositories is a slice of repository names to migrate.
</a><a href="#h28-0-63" id="h28-0-63" class="i">+	Repositories []string `json:&quot;repositories,omitempty&quot;`
</a><a href="#h28-0-64" id="h28-0-64" class="i">+
</a><a href="#h28-0-65" id="h28-0-65" class="i">+	// LockRepositories indicates whether repositories should be locked (to prevent
</a><a href="#h28-0-66" id="h28-0-66" class="i">+	// manipulation) while migrating data.
</a><a href="#h28-0-67" id="h28-0-67" class="i">+	LockRepositories *bool `json:&quot;lock_repositories,omitempty&quot;`
</a><a href="#h28-0-68" id="h28-0-68" class="i">+
</a><a href="#h28-0-69" id="h28-0-69" class="i">+	// ExcludeAttachments indicates whether attachments should be excluded from
</a><a href="#h28-0-70" id="h28-0-70" class="i">+	// the migration (to reduce migration archive file size).
</a><a href="#h28-0-71" id="h28-0-71" class="i">+	ExcludeAttachments *bool `json:&quot;exclude_attachments,omitempty&quot;`
</a><a href="#h28-0-72" id="h28-0-72" class="i">+}
</a><a href="#h28-0-73" id="h28-0-73" class="i">+
</a><a href="#h28-0-74" id="h28-0-74" class="i">+// StartMigration starts the generation of a migration archive.
</a><a href="#h28-0-75" id="h28-0-75" class="i">+// repos is a slice of repository names to migrate.
</a><a href="#h28-0-76" id="h28-0-76" class="i">+//
</a><a href="#h28-0-77" id="h28-0-77" class="i">+// GitHub API docs: https://developer.github.com/v3/migration/migrations/#start-a-migration
</a><a href="#h28-0-78" id="h28-0-78" class="i">+func (s *MigrationService) StartMigration(org string, repos []string, opt *MigrationOptions) (*Migration, *Response, error) {
</a><a href="#h28-0-79" id="h28-0-79" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/migrations&quot;, org)
</a><a href="#h28-0-80" id="h28-0-80" class="i">+
</a><a href="#h28-0-81" id="h28-0-81" class="i">+	body := &amp;startMigration{Repositories: repos}
</a><a href="#h28-0-82" id="h28-0-82" class="i">+	if opt != nil {
</a><a href="#h28-0-83" id="h28-0-83" class="i">+		body.LockRepositories = Bool(opt.LockRepositories)
</a><a href="#h28-0-84" id="h28-0-84" class="i">+		body.ExcludeAttachments = Bool(opt.ExcludeAttachments)
</a><a href="#h28-0-85" id="h28-0-85" class="i">+	}
</a><a href="#h28-0-86" id="h28-0-86" class="i">+
</a><a href="#h28-0-87" id="h28-0-87" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, body)
</a><a href="#h28-0-88" id="h28-0-88" class="i">+	if err != nil {
</a><a href="#h28-0-89" id="h28-0-89" class="i">+		return nil, nil, err
</a><a href="#h28-0-90" id="h28-0-90" class="i">+	}
</a><a href="#h28-0-91" id="h28-0-91" class="i">+
</a><a href="#h28-0-92" id="h28-0-92" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h28-0-93" id="h28-0-93" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeMigrationsPreview)
</a><a href="#h28-0-94" id="h28-0-94" class="i">+
</a><a href="#h28-0-95" id="h28-0-95" class="i">+	m := &amp;Migration{}
</a><a href="#h28-0-96" id="h28-0-96" class="i">+	resp, err := s.client.Do(req, m)
</a><a href="#h28-0-97" id="h28-0-97" class="i">+	if err != nil {
</a><a href="#h28-0-98" id="h28-0-98" class="i">+		return nil, resp, err
</a><a href="#h28-0-99" id="h28-0-99" class="i">+	}
</a><a href="#h28-0-100" id="h28-0-100" class="i">+
</a><a href="#h28-0-101" id="h28-0-101" class="i">+	return m, resp, nil
</a><a href="#h28-0-102" id="h28-0-102" class="i">+}
</a><a href="#h28-0-103" id="h28-0-103" class="i">+
</a><a href="#h28-0-104" id="h28-0-104" class="i">+// ListMigrations lists the most recent migrations.
</a><a href="#h28-0-105" id="h28-0-105" class="i">+//
</a><a href="#h28-0-106" id="h28-0-106" class="i">+// GitHub API docs: https://developer.github.com/v3/migration/migrations/#get-a-list-of-migrations
</a><a href="#h28-0-107" id="h28-0-107" class="i">+func (s *MigrationService) ListMigrations(org string) ([]*Migration, *Response, error) {
</a><a href="#h28-0-108" id="h28-0-108" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/migrations&quot;, org)
</a><a href="#h28-0-109" id="h28-0-109" class="i">+
</a><a href="#h28-0-110" id="h28-0-110" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h28-0-111" id="h28-0-111" class="i">+	if err != nil {
</a><a href="#h28-0-112" id="h28-0-112" class="i">+		return nil, nil, err
</a><a href="#h28-0-113" id="h28-0-113" class="i">+	}
</a><a href="#h28-0-114" id="h28-0-114" class="i">+
</a><a href="#h28-0-115" id="h28-0-115" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h28-0-116" id="h28-0-116" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeMigrationsPreview)
</a><a href="#h28-0-117" id="h28-0-117" class="i">+
</a><a href="#h28-0-118" id="h28-0-118" class="i">+	var m []*Migration
</a><a href="#h28-0-119" id="h28-0-119" class="i">+	resp, err := s.client.Do(req, &amp;m)
</a><a href="#h28-0-120" id="h28-0-120" class="i">+	if err != nil {
</a><a href="#h28-0-121" id="h28-0-121" class="i">+		return nil, resp, err
</a><a href="#h28-0-122" id="h28-0-122" class="i">+	}
</a><a href="#h28-0-123" id="h28-0-123" class="i">+
</a><a href="#h28-0-124" id="h28-0-124" class="i">+	return m, resp, nil
</a><a href="#h28-0-125" id="h28-0-125" class="i">+}
</a><a href="#h28-0-126" id="h28-0-126" class="i">+
</a><a href="#h28-0-127" id="h28-0-127" class="i">+// MigrationStatus gets the status of a specific migration archive.
</a><a href="#h28-0-128" id="h28-0-128" class="i">+// id is the migration ID.
</a><a href="#h28-0-129" id="h28-0-129" class="i">+//
</a><a href="#h28-0-130" id="h28-0-130" class="i">+// GitHub API docs: https://developer.github.com/v3/migration/migrations/#get-the-status-of-a-migration
</a><a href="#h28-0-131" id="h28-0-131" class="i">+func (s *MigrationService) MigrationStatus(org string, id int) (*Migration, *Response, error) {
</a><a href="#h28-0-132" id="h28-0-132" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/migrations/%v&quot;, org, id)
</a><a href="#h28-0-133" id="h28-0-133" class="i">+
</a><a href="#h28-0-134" id="h28-0-134" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h28-0-135" id="h28-0-135" class="i">+	if err != nil {
</a><a href="#h28-0-136" id="h28-0-136" class="i">+		return nil, nil, err
</a><a href="#h28-0-137" id="h28-0-137" class="i">+	}
</a><a href="#h28-0-138" id="h28-0-138" class="i">+
</a><a href="#h28-0-139" id="h28-0-139" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h28-0-140" id="h28-0-140" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeMigrationsPreview)
</a><a href="#h28-0-141" id="h28-0-141" class="i">+
</a><a href="#h28-0-142" id="h28-0-142" class="i">+	m := &amp;Migration{}
</a><a href="#h28-0-143" id="h28-0-143" class="i">+	resp, err := s.client.Do(req, m)
</a><a href="#h28-0-144" id="h28-0-144" class="i">+	if err != nil {
</a><a href="#h28-0-145" id="h28-0-145" class="i">+		return nil, resp, err
</a><a href="#h28-0-146" id="h28-0-146" class="i">+	}
</a><a href="#h28-0-147" id="h28-0-147" class="i">+
</a><a href="#h28-0-148" id="h28-0-148" class="i">+	return m, resp, nil
</a><a href="#h28-0-149" id="h28-0-149" class="i">+}
</a><a href="#h28-0-150" id="h28-0-150" class="i">+
</a><a href="#h28-0-151" id="h28-0-151" class="i">+// MigrationArchiveURL fetches a migration archive URL.
</a><a href="#h28-0-152" id="h28-0-152" class="i">+// id is the migration ID.
</a><a href="#h28-0-153" id="h28-0-153" class="i">+//
</a><a href="#h28-0-154" id="h28-0-154" class="i">+// GitHub API docs: https://developer.github.com/v3/migration/migrations/#download-a-migration-archive
</a><a href="#h28-0-155" id="h28-0-155" class="i">+func (s *MigrationService) MigrationArchiveURL(org string, id int) (url string, err error) {
</a><a href="#h28-0-156" id="h28-0-156" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/migrations/%v/archive&quot;, org, id)
</a><a href="#h28-0-157" id="h28-0-157" class="i">+
</a><a href="#h28-0-158" id="h28-0-158" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h28-0-159" id="h28-0-159" class="i">+	if err != nil {
</a><a href="#h28-0-160" id="h28-0-160" class="i">+		return &quot;&quot;, err
</a><a href="#h28-0-161" id="h28-0-161" class="i">+	}
</a><a href="#h28-0-162" id="h28-0-162" class="i">+
</a><a href="#h28-0-163" id="h28-0-163" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h28-0-164" id="h28-0-164" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeMigrationsPreview)
</a><a href="#h28-0-165" id="h28-0-165" class="i">+
</a><a href="#h28-0-166" id="h28-0-166" class="i">+	s.client.clientMu.Lock()
</a><a href="#h28-0-167" id="h28-0-167" class="i">+	defer s.client.clientMu.Unlock()
</a><a href="#h28-0-168" id="h28-0-168" class="i">+
</a><a href="#h28-0-169" id="h28-0-169" class="i">+	// Disable the redirect mechanism because AWS fails if the GitHub auth token is provided.
</a><a href="#h28-0-170" id="h28-0-170" class="i">+	var loc string
</a><a href="#h28-0-171" id="h28-0-171" class="i">+	saveRedirect := s.client.client.CheckRedirect
</a><a href="#h28-0-172" id="h28-0-172" class="i">+	s.client.client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
</a><a href="#h28-0-173" id="h28-0-173" class="i">+		loc = req.URL.String()
</a><a href="#h28-0-174" id="h28-0-174" class="i">+		return errors.New(&quot;disable redirect&quot;)
</a><a href="#h28-0-175" id="h28-0-175" class="i">+	}
</a><a href="#h28-0-176" id="h28-0-176" class="i">+	defer func() { s.client.client.CheckRedirect = saveRedirect }()
</a><a href="#h28-0-177" id="h28-0-177" class="i">+
</a><a href="#h28-0-178" id="h28-0-178" class="i">+	_, err = s.client.Do(req, nil) // expect error from disable redirect
</a><a href="#h28-0-179" id="h28-0-179" class="i">+	if err == nil {
</a><a href="#h28-0-180" id="h28-0-180" class="i">+		return &quot;&quot;, errors.New(&quot;expected redirect, none provided&quot;)
</a><a href="#h28-0-181" id="h28-0-181" class="i">+	}
</a><a href="#h28-0-182" id="h28-0-182" class="i">+	if !strings.Contains(err.Error(), &quot;disable redirect&quot;) {
</a><a href="#h28-0-183" id="h28-0-183" class="i">+		return &quot;&quot;, err
</a><a href="#h28-0-184" id="h28-0-184" class="i">+	}
</a><a href="#h28-0-185" id="h28-0-185" class="i">+	return loc, nil
</a><a href="#h28-0-186" id="h28-0-186" class="i">+}
</a><a href="#h28-0-187" id="h28-0-187" class="i">+
</a><a href="#h28-0-188" id="h28-0-188" class="i">+// DeleteMigration deletes a previous migration archive.
</a><a href="#h28-0-189" id="h28-0-189" class="i">+// id is the migration ID.
</a><a href="#h28-0-190" id="h28-0-190" class="i">+//
</a><a href="#h28-0-191" id="h28-0-191" class="i">+// GitHub API docs: https://developer.github.com/v3/migration/migrations/#delete-a-migration-archive
</a><a href="#h28-0-192" id="h28-0-192" class="i">+func (s *MigrationService) DeleteMigration(org string, id int) (*Response, error) {
</a><a href="#h28-0-193" id="h28-0-193" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/migrations/%v/archive&quot;, org, id)
</a><a href="#h28-0-194" id="h28-0-194" class="i">+
</a><a href="#h28-0-195" id="h28-0-195" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h28-0-196" id="h28-0-196" class="i">+	if err != nil {
</a><a href="#h28-0-197" id="h28-0-197" class="i">+		return nil, err
</a><a href="#h28-0-198" id="h28-0-198" class="i">+	}
</a><a href="#h28-0-199" id="h28-0-199" class="i">+
</a><a href="#h28-0-200" id="h28-0-200" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h28-0-201" id="h28-0-201" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeMigrationsPreview)
</a><a href="#h28-0-202" id="h28-0-202" class="i">+
</a><a href="#h28-0-203" id="h28-0-203" class="i">+	return s.client.Do(req, nil)
</a><a href="#h28-0-204" id="h28-0-204" class="i">+}
</a><a href="#h28-0-205" id="h28-0-205" class="i">+
</a><a href="#h28-0-206" id="h28-0-206" class="i">+// UnlockRepo unlocks a repository that was locked for migration.
</a><a href="#h28-0-207" id="h28-0-207" class="i">+// id is the migration ID.
</a><a href="#h28-0-208" id="h28-0-208" class="i">+// You should unlock each migrated repository and delete them when the migration
</a><a href="#h28-0-209" id="h28-0-209" class="i">+// is complete and you no longer need the source data.
</a><a href="#h28-0-210" id="h28-0-210" class="i">+//
</a><a href="#h28-0-211" id="h28-0-211" class="i">+// GitHub API docs: https://developer.github.com/v3/migration/migrations/#unlock-a-repository
</a><a href="#h28-0-212" id="h28-0-212" class="i">+func (s *MigrationService) UnlockRepo(org string, id int, repo string) (*Response, error) {
</a><a href="#h28-0-213" id="h28-0-213" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/migrations/%v/repos/%v/lock&quot;, org, id, repo)
</a><a href="#h28-0-214" id="h28-0-214" class="i">+
</a><a href="#h28-0-215" id="h28-0-215" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h28-0-216" id="h28-0-216" class="i">+	if err != nil {
</a><a href="#h28-0-217" id="h28-0-217" class="i">+		return nil, err
</a><a href="#h28-0-218" id="h28-0-218" class="i">+	}
</a><a href="#h28-0-219" id="h28-0-219" class="i">+
</a><a href="#h28-0-220" id="h28-0-220" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h28-0-221" id="h28-0-221" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeMigrationsPreview)
</a><a href="#h28-0-222" id="h28-0-222" class="i">+
</a><a href="#h28-0-223" id="h28-0-223" class="i">+	return s.client.Do(req, nil)
</a><a href="#h28-0-224" id="h28-0-224" class="i">+}
</a><b>diff --git a/<a id="h29" href="../file/vendor/github.com/google/go-github/github/misc.go">vendor/github.com/google/go-github/github/misc.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/misc.go">vendor/github.com/google/go-github/github/misc.go</a></b>
<a href="#h29-0" id="h29-0" class="h">@@ -0,0 +1,197 @@
</a><a href="#h29-0-0" id="h29-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h29-0-1" id="h29-0-1" class="i">+//
</a><a href="#h29-0-2" id="h29-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h29-0-3" id="h29-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h29-0-4" id="h29-0-4" class="i">+
</a><a href="#h29-0-5" id="h29-0-5" class="i">+package github
</a><a href="#h29-0-6" id="h29-0-6" class="i">+
</a><a href="#h29-0-7" id="h29-0-7" class="i">+import (
</a><a href="#h29-0-8" id="h29-0-8" class="i">+	&quot;bytes&quot;
</a><a href="#h29-0-9" id="h29-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h29-0-10" id="h29-0-10" class="i">+	&quot;net/url&quot;
</a><a href="#h29-0-11" id="h29-0-11" class="i">+)
</a><a href="#h29-0-12" id="h29-0-12" class="i">+
</a><a href="#h29-0-13" id="h29-0-13" class="i">+// MarkdownOptions specifies optional parameters to the Markdown method.
</a><a href="#h29-0-14" id="h29-0-14" class="i">+type MarkdownOptions struct {
</a><a href="#h29-0-15" id="h29-0-15" class="i">+	// Mode identifies the rendering mode.  Possible values are:
</a><a href="#h29-0-16" id="h29-0-16" class="i">+	//   markdown - render a document as plain Markdown, just like
</a><a href="#h29-0-17" id="h29-0-17" class="i">+	//   README files are rendered.
</a><a href="#h29-0-18" id="h29-0-18" class="i">+	//
</a><a href="#h29-0-19" id="h29-0-19" class="i">+	//   gfm - to render a document as user-content, e.g. like user
</a><a href="#h29-0-20" id="h29-0-20" class="i">+	//   comments or issues are rendered. In GFM mode, hard line breaks are
</a><a href="#h29-0-21" id="h29-0-21" class="i">+	//   always taken into account, and issue and user mentions are linked
</a><a href="#h29-0-22" id="h29-0-22" class="i">+	//   accordingly.
</a><a href="#h29-0-23" id="h29-0-23" class="i">+	//
</a><a href="#h29-0-24" id="h29-0-24" class="i">+	// Default is &quot;markdown&quot;.
</a><a href="#h29-0-25" id="h29-0-25" class="i">+	Mode string
</a><a href="#h29-0-26" id="h29-0-26" class="i">+
</a><a href="#h29-0-27" id="h29-0-27" class="i">+	// Context identifies the repository context.  Only taken into account
</a><a href="#h29-0-28" id="h29-0-28" class="i">+	// when rendering as &quot;gfm&quot;.
</a><a href="#h29-0-29" id="h29-0-29" class="i">+	Context string
</a><a href="#h29-0-30" id="h29-0-30" class="i">+}
</a><a href="#h29-0-31" id="h29-0-31" class="i">+
</a><a href="#h29-0-32" id="h29-0-32" class="i">+type markdownRequest struct {
</a><a href="#h29-0-33" id="h29-0-33" class="i">+	Text    *string `json:&quot;text,omitempty&quot;`
</a><a href="#h29-0-34" id="h29-0-34" class="i">+	Mode    *string `json:&quot;mode,omitempty&quot;`
</a><a href="#h29-0-35" id="h29-0-35" class="i">+	Context *string `json:&quot;context,omitempty&quot;`
</a><a href="#h29-0-36" id="h29-0-36" class="i">+}
</a><a href="#h29-0-37" id="h29-0-37" class="i">+
</a><a href="#h29-0-38" id="h29-0-38" class="i">+// Markdown renders an arbitrary Markdown document.
</a><a href="#h29-0-39" id="h29-0-39" class="i">+//
</a><a href="#h29-0-40" id="h29-0-40" class="i">+// GitHub API docs: https://developer.github.com/v3/markdown/
</a><a href="#h29-0-41" id="h29-0-41" class="i">+func (c *Client) Markdown(text string, opt *MarkdownOptions) (string, *Response, error) {
</a><a href="#h29-0-42" id="h29-0-42" class="i">+	request := &amp;markdownRequest{Text: String(text)}
</a><a href="#h29-0-43" id="h29-0-43" class="i">+	if opt != nil {
</a><a href="#h29-0-44" id="h29-0-44" class="i">+		if opt.Mode != &quot;&quot; {
</a><a href="#h29-0-45" id="h29-0-45" class="i">+			request.Mode = String(opt.Mode)
</a><a href="#h29-0-46" id="h29-0-46" class="i">+		}
</a><a href="#h29-0-47" id="h29-0-47" class="i">+		if opt.Context != &quot;&quot; {
</a><a href="#h29-0-48" id="h29-0-48" class="i">+			request.Context = String(opt.Context)
</a><a href="#h29-0-49" id="h29-0-49" class="i">+		}
</a><a href="#h29-0-50" id="h29-0-50" class="i">+	}
</a><a href="#h29-0-51" id="h29-0-51" class="i">+
</a><a href="#h29-0-52" id="h29-0-52" class="i">+	req, err := c.NewRequest(&quot;POST&quot;, &quot;markdown&quot;, request)
</a><a href="#h29-0-53" id="h29-0-53" class="i">+	if err != nil {
</a><a href="#h29-0-54" id="h29-0-54" class="i">+		return &quot;&quot;, nil, err
</a><a href="#h29-0-55" id="h29-0-55" class="i">+	}
</a><a href="#h29-0-56" id="h29-0-56" class="i">+
</a><a href="#h29-0-57" id="h29-0-57" class="i">+	buf := new(bytes.Buffer)
</a><a href="#h29-0-58" id="h29-0-58" class="i">+	resp, err := c.Do(req, buf)
</a><a href="#h29-0-59" id="h29-0-59" class="i">+	if err != nil {
</a><a href="#h29-0-60" id="h29-0-60" class="i">+		return &quot;&quot;, resp, err
</a><a href="#h29-0-61" id="h29-0-61" class="i">+	}
</a><a href="#h29-0-62" id="h29-0-62" class="i">+
</a><a href="#h29-0-63" id="h29-0-63" class="i">+	return buf.String(), resp, nil
</a><a href="#h29-0-64" id="h29-0-64" class="i">+}
</a><a href="#h29-0-65" id="h29-0-65" class="i">+
</a><a href="#h29-0-66" id="h29-0-66" class="i">+// ListEmojis returns the emojis available to use on GitHub.
</a><a href="#h29-0-67" id="h29-0-67" class="i">+//
</a><a href="#h29-0-68" id="h29-0-68" class="i">+// GitHub API docs: https://developer.github.com/v3/emojis/
</a><a href="#h29-0-69" id="h29-0-69" class="i">+func (c *Client) ListEmojis() (map[string]string, *Response, error) {
</a><a href="#h29-0-70" id="h29-0-70" class="i">+	req, err := c.NewRequest(&quot;GET&quot;, &quot;emojis&quot;, nil)
</a><a href="#h29-0-71" id="h29-0-71" class="i">+	if err != nil {
</a><a href="#h29-0-72" id="h29-0-72" class="i">+		return nil, nil, err
</a><a href="#h29-0-73" id="h29-0-73" class="i">+	}
</a><a href="#h29-0-74" id="h29-0-74" class="i">+
</a><a href="#h29-0-75" id="h29-0-75" class="i">+	var emoji map[string]string
</a><a href="#h29-0-76" id="h29-0-76" class="i">+	resp, err := c.Do(req, &amp;emoji)
</a><a href="#h29-0-77" id="h29-0-77" class="i">+	if err != nil {
</a><a href="#h29-0-78" id="h29-0-78" class="i">+		return nil, resp, err
</a><a href="#h29-0-79" id="h29-0-79" class="i">+	}
</a><a href="#h29-0-80" id="h29-0-80" class="i">+
</a><a href="#h29-0-81" id="h29-0-81" class="i">+	return emoji, resp, nil
</a><a href="#h29-0-82" id="h29-0-82" class="i">+}
</a><a href="#h29-0-83" id="h29-0-83" class="i">+
</a><a href="#h29-0-84" id="h29-0-84" class="i">+// APIMeta represents metadata about the GitHub API.
</a><a href="#h29-0-85" id="h29-0-85" class="i">+type APIMeta struct {
</a><a href="#h29-0-86" id="h29-0-86" class="i">+	// An Array of IP addresses in CIDR format specifying the addresses
</a><a href="#h29-0-87" id="h29-0-87" class="i">+	// that incoming service hooks will originate from on GitHub.com.
</a><a href="#h29-0-88" id="h29-0-88" class="i">+	Hooks []string `json:&quot;hooks,omitempty&quot;`
</a><a href="#h29-0-89" id="h29-0-89" class="i">+
</a><a href="#h29-0-90" id="h29-0-90" class="i">+	// An Array of IP addresses in CIDR format specifying the Git servers
</a><a href="#h29-0-91" id="h29-0-91" class="i">+	// for GitHub.com.
</a><a href="#h29-0-92" id="h29-0-92" class="i">+	Git []string `json:&quot;git,omitempty&quot;`
</a><a href="#h29-0-93" id="h29-0-93" class="i">+
</a><a href="#h29-0-94" id="h29-0-94" class="i">+	// Whether authentication with username and password is supported.
</a><a href="#h29-0-95" id="h29-0-95" class="i">+	// (GitHub Enterprise instances using CAS or OAuth for authentication
</a><a href="#h29-0-96" id="h29-0-96" class="i">+	// will return false. Features like Basic Authentication with a
</a><a href="#h29-0-97" id="h29-0-97" class="i">+	// username and password, sudo mode, and two-factor authentication are
</a><a href="#h29-0-98" id="h29-0-98" class="i">+	// not supported on these servers.)
</a><a href="#h29-0-99" id="h29-0-99" class="i">+	VerifiablePasswordAuthentication *bool `json:&quot;verifiable_password_authentication,omitempty&quot;`
</a><a href="#h29-0-100" id="h29-0-100" class="i">+
</a><a href="#h29-0-101" id="h29-0-101" class="i">+	// An array of IP addresses in CIDR format specifying the addresses
</a><a href="#h29-0-102" id="h29-0-102" class="i">+	// which serve GitHub Pages websites.
</a><a href="#h29-0-103" id="h29-0-103" class="i">+	Pages []string `json:&quot;pages,omitempty&quot;`
</a><a href="#h29-0-104" id="h29-0-104" class="i">+}
</a><a href="#h29-0-105" id="h29-0-105" class="i">+
</a><a href="#h29-0-106" id="h29-0-106" class="i">+// APIMeta returns information about GitHub.com, the service. Or, if you access
</a><a href="#h29-0-107" id="h29-0-107" class="i">+// this endpoint on your organizations GitHub Enterprise installation, this
</a><a href="#h29-0-108" id="h29-0-108" class="i">+// endpoint provides information about that installation.
</a><a href="#h29-0-109" id="h29-0-109" class="i">+//
</a><a href="#h29-0-110" id="h29-0-110" class="i">+// GitHub API docs: https://developer.github.com/v3/meta/
</a><a href="#h29-0-111" id="h29-0-111" class="i">+func (c *Client) APIMeta() (*APIMeta, *Response, error) {
</a><a href="#h29-0-112" id="h29-0-112" class="i">+	req, err := c.NewRequest(&quot;GET&quot;, &quot;meta&quot;, nil)
</a><a href="#h29-0-113" id="h29-0-113" class="i">+	if err != nil {
</a><a href="#h29-0-114" id="h29-0-114" class="i">+		return nil, nil, err
</a><a href="#h29-0-115" id="h29-0-115" class="i">+	}
</a><a href="#h29-0-116" id="h29-0-116" class="i">+
</a><a href="#h29-0-117" id="h29-0-117" class="i">+	meta := new(APIMeta)
</a><a href="#h29-0-118" id="h29-0-118" class="i">+	resp, err := c.Do(req, meta)
</a><a href="#h29-0-119" id="h29-0-119" class="i">+	if err != nil {
</a><a href="#h29-0-120" id="h29-0-120" class="i">+		return nil, resp, err
</a><a href="#h29-0-121" id="h29-0-121" class="i">+	}
</a><a href="#h29-0-122" id="h29-0-122" class="i">+
</a><a href="#h29-0-123" id="h29-0-123" class="i">+	return meta, resp, nil
</a><a href="#h29-0-124" id="h29-0-124" class="i">+}
</a><a href="#h29-0-125" id="h29-0-125" class="i">+
</a><a href="#h29-0-126" id="h29-0-126" class="i">+// Octocat returns an ASCII art octocat with the specified message in a speech
</a><a href="#h29-0-127" id="h29-0-127" class="i">+// bubble.  If message is empty, a random zen phrase is used.
</a><a href="#h29-0-128" id="h29-0-128" class="i">+func (c *Client) Octocat(message string) (string, *Response, error) {
</a><a href="#h29-0-129" id="h29-0-129" class="i">+	u := &quot;octocat&quot;
</a><a href="#h29-0-130" id="h29-0-130" class="i">+	if message != &quot;&quot; {
</a><a href="#h29-0-131" id="h29-0-131" class="i">+		u = fmt.Sprintf(&quot;%s?s=%s&quot;, u, url.QueryEscape(message))
</a><a href="#h29-0-132" id="h29-0-132" class="i">+	}
</a><a href="#h29-0-133" id="h29-0-133" class="i">+
</a><a href="#h29-0-134" id="h29-0-134" class="i">+	req, err := c.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h29-0-135" id="h29-0-135" class="i">+	if err != nil {
</a><a href="#h29-0-136" id="h29-0-136" class="i">+		return &quot;&quot;, nil, err
</a><a href="#h29-0-137" id="h29-0-137" class="i">+	}
</a><a href="#h29-0-138" id="h29-0-138" class="i">+
</a><a href="#h29-0-139" id="h29-0-139" class="i">+	buf := new(bytes.Buffer)
</a><a href="#h29-0-140" id="h29-0-140" class="i">+	resp, err := c.Do(req, buf)
</a><a href="#h29-0-141" id="h29-0-141" class="i">+	if err != nil {
</a><a href="#h29-0-142" id="h29-0-142" class="i">+		return &quot;&quot;, resp, err
</a><a href="#h29-0-143" id="h29-0-143" class="i">+	}
</a><a href="#h29-0-144" id="h29-0-144" class="i">+
</a><a href="#h29-0-145" id="h29-0-145" class="i">+	return buf.String(), resp, nil
</a><a href="#h29-0-146" id="h29-0-146" class="i">+}
</a><a href="#h29-0-147" id="h29-0-147" class="i">+
</a><a href="#h29-0-148" id="h29-0-148" class="i">+// Zen returns a random line from The Zen of GitHub.
</a><a href="#h29-0-149" id="h29-0-149" class="i">+//
</a><a href="#h29-0-150" id="h29-0-150" class="i">+// see also: http://warpspire.com/posts/taste/
</a><a href="#h29-0-151" id="h29-0-151" class="i">+func (c *Client) Zen() (string, *Response, error) {
</a><a href="#h29-0-152" id="h29-0-152" class="i">+	req, err := c.NewRequest(&quot;GET&quot;, &quot;zen&quot;, nil)
</a><a href="#h29-0-153" id="h29-0-153" class="i">+	if err != nil {
</a><a href="#h29-0-154" id="h29-0-154" class="i">+		return &quot;&quot;, nil, err
</a><a href="#h29-0-155" id="h29-0-155" class="i">+	}
</a><a href="#h29-0-156" id="h29-0-156" class="i">+
</a><a href="#h29-0-157" id="h29-0-157" class="i">+	buf := new(bytes.Buffer)
</a><a href="#h29-0-158" id="h29-0-158" class="i">+	resp, err := c.Do(req, buf)
</a><a href="#h29-0-159" id="h29-0-159" class="i">+	if err != nil {
</a><a href="#h29-0-160" id="h29-0-160" class="i">+		return &quot;&quot;, resp, err
</a><a href="#h29-0-161" id="h29-0-161" class="i">+	}
</a><a href="#h29-0-162" id="h29-0-162" class="i">+
</a><a href="#h29-0-163" id="h29-0-163" class="i">+	return buf.String(), resp, nil
</a><a href="#h29-0-164" id="h29-0-164" class="i">+}
</a><a href="#h29-0-165" id="h29-0-165" class="i">+
</a><a href="#h29-0-166" id="h29-0-166" class="i">+// ServiceHook represents a hook that has configuration settings, a list of
</a><a href="#h29-0-167" id="h29-0-167" class="i">+// available events, and default events.
</a><a href="#h29-0-168" id="h29-0-168" class="i">+type ServiceHook struct {
</a><a href="#h29-0-169" id="h29-0-169" class="i">+	Name            *string    `json:&quot;name,omitempty&quot;`
</a><a href="#h29-0-170" id="h29-0-170" class="i">+	Events          []string   `json:&quot;events,omitempty&quot;`
</a><a href="#h29-0-171" id="h29-0-171" class="i">+	SupportedEvents []string   `json:&quot;supported_events,omitempty&quot;`
</a><a href="#h29-0-172" id="h29-0-172" class="i">+	Schema          [][]string `json:&quot;schema,omitempty&quot;`
</a><a href="#h29-0-173" id="h29-0-173" class="i">+}
</a><a href="#h29-0-174" id="h29-0-174" class="i">+
</a><a href="#h29-0-175" id="h29-0-175" class="i">+func (s *ServiceHook) String() string {
</a><a href="#h29-0-176" id="h29-0-176" class="i">+	return Stringify(s)
</a><a href="#h29-0-177" id="h29-0-177" class="i">+}
</a><a href="#h29-0-178" id="h29-0-178" class="i">+
</a><a href="#h29-0-179" id="h29-0-179" class="i">+// ListServiceHooks lists all of the available service hooks.
</a><a href="#h29-0-180" id="h29-0-180" class="i">+//
</a><a href="#h29-0-181" id="h29-0-181" class="i">+// GitHub API docs: https://developer.github.com/webhooks/#services
</a><a href="#h29-0-182" id="h29-0-182" class="i">+func (c *Client) ListServiceHooks() ([]ServiceHook, *Response, error) {
</a><a href="#h29-0-183" id="h29-0-183" class="i">+	u := &quot;hooks&quot;
</a><a href="#h29-0-184" id="h29-0-184" class="i">+	req, err := c.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h29-0-185" id="h29-0-185" class="i">+	if err != nil {
</a><a href="#h29-0-186" id="h29-0-186" class="i">+		return nil, nil, err
</a><a href="#h29-0-187" id="h29-0-187" class="i">+	}
</a><a href="#h29-0-188" id="h29-0-188" class="i">+
</a><a href="#h29-0-189" id="h29-0-189" class="i">+	hooks := new([]ServiceHook)
</a><a href="#h29-0-190" id="h29-0-190" class="i">+	resp, err := c.Do(req, hooks)
</a><a href="#h29-0-191" id="h29-0-191" class="i">+	if err != nil {
</a><a href="#h29-0-192" id="h29-0-192" class="i">+		return nil, resp, err
</a><a href="#h29-0-193" id="h29-0-193" class="i">+	}
</a><a href="#h29-0-194" id="h29-0-194" class="i">+
</a><a href="#h29-0-195" id="h29-0-195" class="i">+	return *hooks, resp, err
</a><a href="#h29-0-196" id="h29-0-196" class="i">+}
</a><b>diff --git a/<a id="h30" href="../file/vendor/github.com/google/go-github/github/orgs.go">vendor/github.com/google/go-github/github/orgs.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/orgs.go">vendor/github.com/google/go-github/github/orgs.go</a></b>
<a href="#h30-0" id="h30-0" class="h">@@ -0,0 +1,170 @@
</a><a href="#h30-0-0" id="h30-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h30-0-1" id="h30-0-1" class="i">+//
</a><a href="#h30-0-2" id="h30-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h30-0-3" id="h30-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h30-0-4" id="h30-0-4" class="i">+
</a><a href="#h30-0-5" id="h30-0-5" class="i">+package github
</a><a href="#h30-0-6" id="h30-0-6" class="i">+
</a><a href="#h30-0-7" id="h30-0-7" class="i">+import (
</a><a href="#h30-0-8" id="h30-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h30-0-9" id="h30-0-9" class="i">+	&quot;time&quot;
</a><a href="#h30-0-10" id="h30-0-10" class="i">+)
</a><a href="#h30-0-11" id="h30-0-11" class="i">+
</a><a href="#h30-0-12" id="h30-0-12" class="i">+// OrganizationsService provides access to the organization related functions
</a><a href="#h30-0-13" id="h30-0-13" class="i">+// in the GitHub API.
</a><a href="#h30-0-14" id="h30-0-14" class="i">+//
</a><a href="#h30-0-15" id="h30-0-15" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/
</a><a href="#h30-0-16" id="h30-0-16" class="i">+type OrganizationsService struct {
</a><a href="#h30-0-17" id="h30-0-17" class="i">+	client *Client
</a><a href="#h30-0-18" id="h30-0-18" class="i">+}
</a><a href="#h30-0-19" id="h30-0-19" class="i">+
</a><a href="#h30-0-20" id="h30-0-20" class="i">+// Organization represents a GitHub organization account.
</a><a href="#h30-0-21" id="h30-0-21" class="i">+type Organization struct {
</a><a href="#h30-0-22" id="h30-0-22" class="i">+	Login             *string    `json:&quot;login,omitempty&quot;`
</a><a href="#h30-0-23" id="h30-0-23" class="i">+	ID                *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h30-0-24" id="h30-0-24" class="i">+	AvatarURL         *string    `json:&quot;avatar_url,omitempty&quot;`
</a><a href="#h30-0-25" id="h30-0-25" class="i">+	HTMLURL           *string    `json:&quot;html_url,omitempty&quot;`
</a><a href="#h30-0-26" id="h30-0-26" class="i">+	Name              *string    `json:&quot;name,omitempty&quot;`
</a><a href="#h30-0-27" id="h30-0-27" class="i">+	Company           *string    `json:&quot;company,omitempty&quot;`
</a><a href="#h30-0-28" id="h30-0-28" class="i">+	Blog              *string    `json:&quot;blog,omitempty&quot;`
</a><a href="#h30-0-29" id="h30-0-29" class="i">+	Location          *string    `json:&quot;location,omitempty&quot;`
</a><a href="#h30-0-30" id="h30-0-30" class="i">+	Email             *string    `json:&quot;email,omitempty&quot;`
</a><a href="#h30-0-31" id="h30-0-31" class="i">+	PublicRepos       *int       `json:&quot;public_repos,omitempty&quot;`
</a><a href="#h30-0-32" id="h30-0-32" class="i">+	PublicGists       *int       `json:&quot;public_gists,omitempty&quot;`
</a><a href="#h30-0-33" id="h30-0-33" class="i">+	Followers         *int       `json:&quot;followers,omitempty&quot;`
</a><a href="#h30-0-34" id="h30-0-34" class="i">+	Following         *int       `json:&quot;following,omitempty&quot;`
</a><a href="#h30-0-35" id="h30-0-35" class="i">+	CreatedAt         *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h30-0-36" id="h30-0-36" class="i">+	UpdatedAt         *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h30-0-37" id="h30-0-37" class="i">+	TotalPrivateRepos *int       `json:&quot;total_private_repos,omitempty&quot;`
</a><a href="#h30-0-38" id="h30-0-38" class="i">+	OwnedPrivateRepos *int       `json:&quot;owned_private_repos,omitempty&quot;`
</a><a href="#h30-0-39" id="h30-0-39" class="i">+	PrivateGists      *int       `json:&quot;private_gists,omitempty&quot;`
</a><a href="#h30-0-40" id="h30-0-40" class="i">+	DiskUsage         *int       `json:&quot;disk_usage,omitempty&quot;`
</a><a href="#h30-0-41" id="h30-0-41" class="i">+	Collaborators     *int       `json:&quot;collaborators,omitempty&quot;`
</a><a href="#h30-0-42" id="h30-0-42" class="i">+	BillingEmail      *string    `json:&quot;billing_email,omitempty&quot;`
</a><a href="#h30-0-43" id="h30-0-43" class="i">+	Type              *string    `json:&quot;type,omitempty&quot;`
</a><a href="#h30-0-44" id="h30-0-44" class="i">+	Plan              *Plan      `json:&quot;plan,omitempty&quot;`
</a><a href="#h30-0-45" id="h30-0-45" class="i">+
</a><a href="#h30-0-46" id="h30-0-46" class="i">+	// API URLs
</a><a href="#h30-0-47" id="h30-0-47" class="i">+	URL              *string `json:&quot;url,omitempty&quot;`
</a><a href="#h30-0-48" id="h30-0-48" class="i">+	EventsURL        *string `json:&quot;events_url,omitempty&quot;`
</a><a href="#h30-0-49" id="h30-0-49" class="i">+	MembersURL       *string `json:&quot;members_url,omitempty&quot;`
</a><a href="#h30-0-50" id="h30-0-50" class="i">+	PublicMembersURL *string `json:&quot;public_members_url,omitempty&quot;`
</a><a href="#h30-0-51" id="h30-0-51" class="i">+	ReposURL         *string `json:&quot;repos_url,omitempty&quot;`
</a><a href="#h30-0-52" id="h30-0-52" class="i">+}
</a><a href="#h30-0-53" id="h30-0-53" class="i">+
</a><a href="#h30-0-54" id="h30-0-54" class="i">+func (o Organization) String() string {
</a><a href="#h30-0-55" id="h30-0-55" class="i">+	return Stringify(o)
</a><a href="#h30-0-56" id="h30-0-56" class="i">+}
</a><a href="#h30-0-57" id="h30-0-57" class="i">+
</a><a href="#h30-0-58" id="h30-0-58" class="i">+// Plan represents the payment plan for an account.  See plans at https://github.com/plans.
</a><a href="#h30-0-59" id="h30-0-59" class="i">+type Plan struct {
</a><a href="#h30-0-60" id="h30-0-60" class="i">+	Name          *string `json:&quot;name,omitempty&quot;`
</a><a href="#h30-0-61" id="h30-0-61" class="i">+	Space         *int    `json:&quot;space,omitempty&quot;`
</a><a href="#h30-0-62" id="h30-0-62" class="i">+	Collaborators *int    `json:&quot;collaborators,omitempty&quot;`
</a><a href="#h30-0-63" id="h30-0-63" class="i">+	PrivateRepos  *int    `json:&quot;private_repos,omitempty&quot;`
</a><a href="#h30-0-64" id="h30-0-64" class="i">+}
</a><a href="#h30-0-65" id="h30-0-65" class="i">+
</a><a href="#h30-0-66" id="h30-0-66" class="i">+func (p Plan) String() string {
</a><a href="#h30-0-67" id="h30-0-67" class="i">+	return Stringify(p)
</a><a href="#h30-0-68" id="h30-0-68" class="i">+}
</a><a href="#h30-0-69" id="h30-0-69" class="i">+
</a><a href="#h30-0-70" id="h30-0-70" class="i">+// OrganizationsListOptions specifies the optional parameters to the
</a><a href="#h30-0-71" id="h30-0-71" class="i">+// OrganizationsService.ListAll method.
</a><a href="#h30-0-72" id="h30-0-72" class="i">+type OrganizationsListOptions struct {
</a><a href="#h30-0-73" id="h30-0-73" class="i">+	// Since filters Organizations by ID.
</a><a href="#h30-0-74" id="h30-0-74" class="i">+	Since int `url:&quot;since,omitempty&quot;`
</a><a href="#h30-0-75" id="h30-0-75" class="i">+}
</a><a href="#h30-0-76" id="h30-0-76" class="i">+
</a><a href="#h30-0-77" id="h30-0-77" class="i">+// ListAll lists all organizations, in the order that they were created on GitHub.
</a><a href="#h30-0-78" id="h30-0-78" class="i">+//
</a><a href="#h30-0-79" id="h30-0-79" class="i">+// Note: Pagination is powered exclusively by the since parameter. To continue
</a><a href="#h30-0-80" id="h30-0-80" class="i">+// listing the next set of organizations, use the ID of the last-returned organization
</a><a href="#h30-0-81" id="h30-0-81" class="i">+// as the opts.Since parameter for the next call.
</a><a href="#h30-0-82" id="h30-0-82" class="i">+//
</a><a href="#h30-0-83" id="h30-0-83" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/#list-all-organizations
</a><a href="#h30-0-84" id="h30-0-84" class="i">+func (s *OrganizationsService) ListAll(opt *OrganizationsListOptions) ([]Organization, *Response, error) {
</a><a href="#h30-0-85" id="h30-0-85" class="i">+	u, err := addOptions(&quot;organizations&quot;, opt)
</a><a href="#h30-0-86" id="h30-0-86" class="i">+	if err != nil {
</a><a href="#h30-0-87" id="h30-0-87" class="i">+		return nil, nil, err
</a><a href="#h30-0-88" id="h30-0-88" class="i">+	}
</a><a href="#h30-0-89" id="h30-0-89" class="i">+
</a><a href="#h30-0-90" id="h30-0-90" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h30-0-91" id="h30-0-91" class="i">+	if err != nil {
</a><a href="#h30-0-92" id="h30-0-92" class="i">+		return nil, nil, err
</a><a href="#h30-0-93" id="h30-0-93" class="i">+	}
</a><a href="#h30-0-94" id="h30-0-94" class="i">+
</a><a href="#h30-0-95" id="h30-0-95" class="i">+	orgs := []Organization{}
</a><a href="#h30-0-96" id="h30-0-96" class="i">+	resp, err := s.client.Do(req, &amp;orgs)
</a><a href="#h30-0-97" id="h30-0-97" class="i">+	if err != nil {
</a><a href="#h30-0-98" id="h30-0-98" class="i">+		return nil, resp, err
</a><a href="#h30-0-99" id="h30-0-99" class="i">+	}
</a><a href="#h30-0-100" id="h30-0-100" class="i">+	return orgs, resp, err
</a><a href="#h30-0-101" id="h30-0-101" class="i">+}
</a><a href="#h30-0-102" id="h30-0-102" class="i">+
</a><a href="#h30-0-103" id="h30-0-103" class="i">+// List the organizations for a user.  Passing the empty string will list
</a><a href="#h30-0-104" id="h30-0-104" class="i">+// organizations for the authenticated user.
</a><a href="#h30-0-105" id="h30-0-105" class="i">+//
</a><a href="#h30-0-106" id="h30-0-106" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/#list-user-organizations
</a><a href="#h30-0-107" id="h30-0-107" class="i">+func (s *OrganizationsService) List(user string, opt *ListOptions) ([]Organization, *Response, error) {
</a><a href="#h30-0-108" id="h30-0-108" class="i">+	var u string
</a><a href="#h30-0-109" id="h30-0-109" class="i">+	if user != &quot;&quot; {
</a><a href="#h30-0-110" id="h30-0-110" class="i">+		u = fmt.Sprintf(&quot;users/%v/orgs&quot;, user)
</a><a href="#h30-0-111" id="h30-0-111" class="i">+	} else {
</a><a href="#h30-0-112" id="h30-0-112" class="i">+		u = &quot;user/orgs&quot;
</a><a href="#h30-0-113" id="h30-0-113" class="i">+	}
</a><a href="#h30-0-114" id="h30-0-114" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h30-0-115" id="h30-0-115" class="i">+	if err != nil {
</a><a href="#h30-0-116" id="h30-0-116" class="i">+		return nil, nil, err
</a><a href="#h30-0-117" id="h30-0-117" class="i">+	}
</a><a href="#h30-0-118" id="h30-0-118" class="i">+
</a><a href="#h30-0-119" id="h30-0-119" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h30-0-120" id="h30-0-120" class="i">+	if err != nil {
</a><a href="#h30-0-121" id="h30-0-121" class="i">+		return nil, nil, err
</a><a href="#h30-0-122" id="h30-0-122" class="i">+	}
</a><a href="#h30-0-123" id="h30-0-123" class="i">+
</a><a href="#h30-0-124" id="h30-0-124" class="i">+	orgs := new([]Organization)
</a><a href="#h30-0-125" id="h30-0-125" class="i">+	resp, err := s.client.Do(req, orgs)
</a><a href="#h30-0-126" id="h30-0-126" class="i">+	if err != nil {
</a><a href="#h30-0-127" id="h30-0-127" class="i">+		return nil, resp, err
</a><a href="#h30-0-128" id="h30-0-128" class="i">+	}
</a><a href="#h30-0-129" id="h30-0-129" class="i">+
</a><a href="#h30-0-130" id="h30-0-130" class="i">+	return *orgs, resp, err
</a><a href="#h30-0-131" id="h30-0-131" class="i">+}
</a><a href="#h30-0-132" id="h30-0-132" class="i">+
</a><a href="#h30-0-133" id="h30-0-133" class="i">+// Get fetches an organization by name.
</a><a href="#h30-0-134" id="h30-0-134" class="i">+//
</a><a href="#h30-0-135" id="h30-0-135" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/#get-an-organization
</a><a href="#h30-0-136" id="h30-0-136" class="i">+func (s *OrganizationsService) Get(org string) (*Organization, *Response, error) {
</a><a href="#h30-0-137" id="h30-0-137" class="i">+	u := fmt.Sprintf(&quot;orgs/%v&quot;, org)
</a><a href="#h30-0-138" id="h30-0-138" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h30-0-139" id="h30-0-139" class="i">+	if err != nil {
</a><a href="#h30-0-140" id="h30-0-140" class="i">+		return nil, nil, err
</a><a href="#h30-0-141" id="h30-0-141" class="i">+	}
</a><a href="#h30-0-142" id="h30-0-142" class="i">+
</a><a href="#h30-0-143" id="h30-0-143" class="i">+	organization := new(Organization)
</a><a href="#h30-0-144" id="h30-0-144" class="i">+	resp, err := s.client.Do(req, organization)
</a><a href="#h30-0-145" id="h30-0-145" class="i">+	if err != nil {
</a><a href="#h30-0-146" id="h30-0-146" class="i">+		return nil, resp, err
</a><a href="#h30-0-147" id="h30-0-147" class="i">+	}
</a><a href="#h30-0-148" id="h30-0-148" class="i">+
</a><a href="#h30-0-149" id="h30-0-149" class="i">+	return organization, resp, err
</a><a href="#h30-0-150" id="h30-0-150" class="i">+}
</a><a href="#h30-0-151" id="h30-0-151" class="i">+
</a><a href="#h30-0-152" id="h30-0-152" class="i">+// Edit an organization.
</a><a href="#h30-0-153" id="h30-0-153" class="i">+//
</a><a href="#h30-0-154" id="h30-0-154" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/#edit-an-organization
</a><a href="#h30-0-155" id="h30-0-155" class="i">+func (s *OrganizationsService) Edit(name string, org *Organization) (*Organization, *Response, error) {
</a><a href="#h30-0-156" id="h30-0-156" class="i">+	u := fmt.Sprintf(&quot;orgs/%v&quot;, name)
</a><a href="#h30-0-157" id="h30-0-157" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, org)
</a><a href="#h30-0-158" id="h30-0-158" class="i">+	if err != nil {
</a><a href="#h30-0-159" id="h30-0-159" class="i">+		return nil, nil, err
</a><a href="#h30-0-160" id="h30-0-160" class="i">+	}
</a><a href="#h30-0-161" id="h30-0-161" class="i">+
</a><a href="#h30-0-162" id="h30-0-162" class="i">+	o := new(Organization)
</a><a href="#h30-0-163" id="h30-0-163" class="i">+	resp, err := s.client.Do(req, o)
</a><a href="#h30-0-164" id="h30-0-164" class="i">+	if err != nil {
</a><a href="#h30-0-165" id="h30-0-165" class="i">+		return nil, resp, err
</a><a href="#h30-0-166" id="h30-0-166" class="i">+	}
</a><a href="#h30-0-167" id="h30-0-167" class="i">+
</a><a href="#h30-0-168" id="h30-0-168" class="i">+	return o, resp, err
</a><a href="#h30-0-169" id="h30-0-169" class="i">+}
</a><b>diff --git a/<a id="h31" href="../file/vendor/github.com/google/go-github/github/orgs_hooks.go">vendor/github.com/google/go-github/github/orgs_hooks.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/orgs_hooks.go">vendor/github.com/google/go-github/github/orgs_hooks.go</a></b>
<a href="#h31-0" id="h31-0" class="h">@@ -0,0 +1,104 @@
</a><a href="#h31-0-0" id="h31-0-0" class="i">+// Copyright 2015 The go-github AUTHORS. All rights reserved.
</a><a href="#h31-0-1" id="h31-0-1" class="i">+//
</a><a href="#h31-0-2" id="h31-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h31-0-3" id="h31-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h31-0-4" id="h31-0-4" class="i">+
</a><a href="#h31-0-5" id="h31-0-5" class="i">+package github
</a><a href="#h31-0-6" id="h31-0-6" class="i">+
</a><a href="#h31-0-7" id="h31-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h31-0-8" id="h31-0-8" class="i">+
</a><a href="#h31-0-9" id="h31-0-9" class="i">+// ListHooks lists all Hooks for the specified organization.
</a><a href="#h31-0-10" id="h31-0-10" class="i">+//
</a><a href="#h31-0-11" id="h31-0-11" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/hooks/#list-hooks
</a><a href="#h31-0-12" id="h31-0-12" class="i">+func (s *OrganizationsService) ListHooks(org string, opt *ListOptions) ([]Hook, *Response, error) {
</a><a href="#h31-0-13" id="h31-0-13" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/hooks&quot;, org)
</a><a href="#h31-0-14" id="h31-0-14" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h31-0-15" id="h31-0-15" class="i">+	if err != nil {
</a><a href="#h31-0-16" id="h31-0-16" class="i">+		return nil, nil, err
</a><a href="#h31-0-17" id="h31-0-17" class="i">+	}
</a><a href="#h31-0-18" id="h31-0-18" class="i">+
</a><a href="#h31-0-19" id="h31-0-19" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h31-0-20" id="h31-0-20" class="i">+	if err != nil {
</a><a href="#h31-0-21" id="h31-0-21" class="i">+		return nil, nil, err
</a><a href="#h31-0-22" id="h31-0-22" class="i">+	}
</a><a href="#h31-0-23" id="h31-0-23" class="i">+
</a><a href="#h31-0-24" id="h31-0-24" class="i">+	hooks := new([]Hook)
</a><a href="#h31-0-25" id="h31-0-25" class="i">+	resp, err := s.client.Do(req, hooks)
</a><a href="#h31-0-26" id="h31-0-26" class="i">+	if err != nil {
</a><a href="#h31-0-27" id="h31-0-27" class="i">+		return nil, resp, err
</a><a href="#h31-0-28" id="h31-0-28" class="i">+	}
</a><a href="#h31-0-29" id="h31-0-29" class="i">+
</a><a href="#h31-0-30" id="h31-0-30" class="i">+	return *hooks, resp, err
</a><a href="#h31-0-31" id="h31-0-31" class="i">+}
</a><a href="#h31-0-32" id="h31-0-32" class="i">+
</a><a href="#h31-0-33" id="h31-0-33" class="i">+// GetHook returns a single specified Hook.
</a><a href="#h31-0-34" id="h31-0-34" class="i">+//
</a><a href="#h31-0-35" id="h31-0-35" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/hooks/#get-single-hook
</a><a href="#h31-0-36" id="h31-0-36" class="i">+func (s *OrganizationsService) GetHook(org string, id int) (*Hook, *Response, error) {
</a><a href="#h31-0-37" id="h31-0-37" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/hooks/%d&quot;, org, id)
</a><a href="#h31-0-38" id="h31-0-38" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h31-0-39" id="h31-0-39" class="i">+	if err != nil {
</a><a href="#h31-0-40" id="h31-0-40" class="i">+		return nil, nil, err
</a><a href="#h31-0-41" id="h31-0-41" class="i">+	}
</a><a href="#h31-0-42" id="h31-0-42" class="i">+	hook := new(Hook)
</a><a href="#h31-0-43" id="h31-0-43" class="i">+	resp, err := s.client.Do(req, hook)
</a><a href="#h31-0-44" id="h31-0-44" class="i">+	return hook, resp, err
</a><a href="#h31-0-45" id="h31-0-45" class="i">+}
</a><a href="#h31-0-46" id="h31-0-46" class="i">+
</a><a href="#h31-0-47" id="h31-0-47" class="i">+// CreateHook creates a Hook for the specified org.
</a><a href="#h31-0-48" id="h31-0-48" class="i">+// Name and Config are required fields.
</a><a href="#h31-0-49" id="h31-0-49" class="i">+//
</a><a href="#h31-0-50" id="h31-0-50" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/hooks/#create-a-hook
</a><a href="#h31-0-51" id="h31-0-51" class="i">+func (s *OrganizationsService) CreateHook(org string, hook *Hook) (*Hook, *Response, error) {
</a><a href="#h31-0-52" id="h31-0-52" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/hooks&quot;, org)
</a><a href="#h31-0-53" id="h31-0-53" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, hook)
</a><a href="#h31-0-54" id="h31-0-54" class="i">+	if err != nil {
</a><a href="#h31-0-55" id="h31-0-55" class="i">+		return nil, nil, err
</a><a href="#h31-0-56" id="h31-0-56" class="i">+	}
</a><a href="#h31-0-57" id="h31-0-57" class="i">+
</a><a href="#h31-0-58" id="h31-0-58" class="i">+	h := new(Hook)
</a><a href="#h31-0-59" id="h31-0-59" class="i">+	resp, err := s.client.Do(req, h)
</a><a href="#h31-0-60" id="h31-0-60" class="i">+	if err != nil {
</a><a href="#h31-0-61" id="h31-0-61" class="i">+		return nil, resp, err
</a><a href="#h31-0-62" id="h31-0-62" class="i">+	}
</a><a href="#h31-0-63" id="h31-0-63" class="i">+
</a><a href="#h31-0-64" id="h31-0-64" class="i">+	return h, resp, err
</a><a href="#h31-0-65" id="h31-0-65" class="i">+}
</a><a href="#h31-0-66" id="h31-0-66" class="i">+
</a><a href="#h31-0-67" id="h31-0-67" class="i">+// EditHook updates a specified Hook.
</a><a href="#h31-0-68" id="h31-0-68" class="i">+//
</a><a href="#h31-0-69" id="h31-0-69" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/hooks/#edit-a-hook
</a><a href="#h31-0-70" id="h31-0-70" class="i">+func (s *OrganizationsService) EditHook(org string, id int, hook *Hook) (*Hook, *Response, error) {
</a><a href="#h31-0-71" id="h31-0-71" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/hooks/%d&quot;, org, id)
</a><a href="#h31-0-72" id="h31-0-72" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, hook)
</a><a href="#h31-0-73" id="h31-0-73" class="i">+	if err != nil {
</a><a href="#h31-0-74" id="h31-0-74" class="i">+		return nil, nil, err
</a><a href="#h31-0-75" id="h31-0-75" class="i">+	}
</a><a href="#h31-0-76" id="h31-0-76" class="i">+	h := new(Hook)
</a><a href="#h31-0-77" id="h31-0-77" class="i">+	resp, err := s.client.Do(req, h)
</a><a href="#h31-0-78" id="h31-0-78" class="i">+	return h, resp, err
</a><a href="#h31-0-79" id="h31-0-79" class="i">+}
</a><a href="#h31-0-80" id="h31-0-80" class="i">+
</a><a href="#h31-0-81" id="h31-0-81" class="i">+// PingHook triggers a &#39;ping&#39; event to be sent to the Hook.
</a><a href="#h31-0-82" id="h31-0-82" class="i">+//
</a><a href="#h31-0-83" id="h31-0-83" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/hooks/#ping-a-hook
</a><a href="#h31-0-84" id="h31-0-84" class="i">+func (s *OrganizationsService) PingHook(org string, id int) (*Response, error) {
</a><a href="#h31-0-85" id="h31-0-85" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/hooks/%d/pings&quot;, org, id)
</a><a href="#h31-0-86" id="h31-0-86" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, nil)
</a><a href="#h31-0-87" id="h31-0-87" class="i">+	if err != nil {
</a><a href="#h31-0-88" id="h31-0-88" class="i">+		return nil, err
</a><a href="#h31-0-89" id="h31-0-89" class="i">+	}
</a><a href="#h31-0-90" id="h31-0-90" class="i">+	return s.client.Do(req, nil)
</a><a href="#h31-0-91" id="h31-0-91" class="i">+}
</a><a href="#h31-0-92" id="h31-0-92" class="i">+
</a><a href="#h31-0-93" id="h31-0-93" class="i">+// DeleteHook deletes a specified Hook.
</a><a href="#h31-0-94" id="h31-0-94" class="i">+//
</a><a href="#h31-0-95" id="h31-0-95" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/hooks/#delete-a-hook
</a><a href="#h31-0-96" id="h31-0-96" class="i">+func (s *OrganizationsService) DeleteHook(org string, id int) (*Response, error) {
</a><a href="#h31-0-97" id="h31-0-97" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/hooks/%d&quot;, org, id)
</a><a href="#h31-0-98" id="h31-0-98" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h31-0-99" id="h31-0-99" class="i">+	if err != nil {
</a><a href="#h31-0-100" id="h31-0-100" class="i">+		return nil, err
</a><a href="#h31-0-101" id="h31-0-101" class="i">+	}
</a><a href="#h31-0-102" id="h31-0-102" class="i">+	return s.client.Do(req, nil)
</a><a href="#h31-0-103" id="h31-0-103" class="i">+}
</a><b>diff --git a/<a id="h32" href="../file/vendor/github.com/google/go-github/github/orgs_members.go">vendor/github.com/google/go-github/github/orgs_members.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/orgs_members.go">vendor/github.com/google/go-github/github/orgs_members.go</a></b>
<a href="#h32-0" id="h32-0" class="h">@@ -0,0 +1,276 @@
</a><a href="#h32-0-0" id="h32-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h32-0-1" id="h32-0-1" class="i">+//
</a><a href="#h32-0-2" id="h32-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h32-0-3" id="h32-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h32-0-4" id="h32-0-4" class="i">+
</a><a href="#h32-0-5" id="h32-0-5" class="i">+package github
</a><a href="#h32-0-6" id="h32-0-6" class="i">+
</a><a href="#h32-0-7" id="h32-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h32-0-8" id="h32-0-8" class="i">+
</a><a href="#h32-0-9" id="h32-0-9" class="i">+// Membership represents the status of a user&#39;s membership in an organization or team.
</a><a href="#h32-0-10" id="h32-0-10" class="i">+type Membership struct {
</a><a href="#h32-0-11" id="h32-0-11" class="i">+	URL *string `json:&quot;url,omitempty&quot;`
</a><a href="#h32-0-12" id="h32-0-12" class="i">+
</a><a href="#h32-0-13" id="h32-0-13" class="i">+	// State is the user&#39;s status within the organization or team.
</a><a href="#h32-0-14" id="h32-0-14" class="i">+	// Possible values are: &quot;active&quot;, &quot;pending&quot;
</a><a href="#h32-0-15" id="h32-0-15" class="i">+	State *string `json:&quot;state,omitempty&quot;`
</a><a href="#h32-0-16" id="h32-0-16" class="i">+
</a><a href="#h32-0-17" id="h32-0-17" class="i">+	// Role identifies the user&#39;s role within the organization or team.
</a><a href="#h32-0-18" id="h32-0-18" class="i">+	// Possible values for organization membership:
</a><a href="#h32-0-19" id="h32-0-19" class="i">+	//     member - non-owner organization member
</a><a href="#h32-0-20" id="h32-0-20" class="i">+	//     admin - organization owner
</a><a href="#h32-0-21" id="h32-0-21" class="i">+	//
</a><a href="#h32-0-22" id="h32-0-22" class="i">+	// Possible values for team membership are:
</a><a href="#h32-0-23" id="h32-0-23" class="i">+	//     member - a normal member of the team
</a><a href="#h32-0-24" id="h32-0-24" class="i">+	//     maintainer - a team maintainer. Able to add/remove other team
</a><a href="#h32-0-25" id="h32-0-25" class="i">+	//                  members, promote other team members to team
</a><a href="#h32-0-26" id="h32-0-26" class="i">+	//                  maintainer, and edit the teams name and description
</a><a href="#h32-0-27" id="h32-0-27" class="i">+	Role *string `json:&quot;role,omitempty&quot;`
</a><a href="#h32-0-28" id="h32-0-28" class="i">+
</a><a href="#h32-0-29" id="h32-0-29" class="i">+	// For organization membership, the API URL of the organization.
</a><a href="#h32-0-30" id="h32-0-30" class="i">+	OrganizationURL *string `json:&quot;organization_url,omitempty&quot;`
</a><a href="#h32-0-31" id="h32-0-31" class="i">+
</a><a href="#h32-0-32" id="h32-0-32" class="i">+	// For organization membership, the organization the membership is for.
</a><a href="#h32-0-33" id="h32-0-33" class="i">+	Organization *Organization `json:&quot;organization,omitempty&quot;`
</a><a href="#h32-0-34" id="h32-0-34" class="i">+
</a><a href="#h32-0-35" id="h32-0-35" class="i">+	// For organization membership, the user the membership is for.
</a><a href="#h32-0-36" id="h32-0-36" class="i">+	User *User `json:&quot;user,omitempty&quot;`
</a><a href="#h32-0-37" id="h32-0-37" class="i">+}
</a><a href="#h32-0-38" id="h32-0-38" class="i">+
</a><a href="#h32-0-39" id="h32-0-39" class="i">+func (m Membership) String() string {
</a><a href="#h32-0-40" id="h32-0-40" class="i">+	return Stringify(m)
</a><a href="#h32-0-41" id="h32-0-41" class="i">+}
</a><a href="#h32-0-42" id="h32-0-42" class="i">+
</a><a href="#h32-0-43" id="h32-0-43" class="i">+// ListMembersOptions specifies optional parameters to the
</a><a href="#h32-0-44" id="h32-0-44" class="i">+// OrganizationsService.ListMembers method.
</a><a href="#h32-0-45" id="h32-0-45" class="i">+type ListMembersOptions struct {
</a><a href="#h32-0-46" id="h32-0-46" class="i">+	// If true (or if the authenticated user is not an owner of the
</a><a href="#h32-0-47" id="h32-0-47" class="i">+	// organization), list only publicly visible members.
</a><a href="#h32-0-48" id="h32-0-48" class="i">+	PublicOnly bool `url:&quot;-&quot;`
</a><a href="#h32-0-49" id="h32-0-49" class="i">+
</a><a href="#h32-0-50" id="h32-0-50" class="i">+	// Filter members returned in the list.  Possible values are:
</a><a href="#h32-0-51" id="h32-0-51" class="i">+	// 2fa_disabled, all.  Default is &quot;all&quot;.
</a><a href="#h32-0-52" id="h32-0-52" class="i">+	Filter string `url:&quot;filter,omitempty&quot;`
</a><a href="#h32-0-53" id="h32-0-53" class="i">+
</a><a href="#h32-0-54" id="h32-0-54" class="i">+	// Role filters members returned by their role in the organization.
</a><a href="#h32-0-55" id="h32-0-55" class="i">+	// Possible values are:
</a><a href="#h32-0-56" id="h32-0-56" class="i">+	//     all - all members of the organization, regardless of role
</a><a href="#h32-0-57" id="h32-0-57" class="i">+	//     admin - organization owners
</a><a href="#h32-0-58" id="h32-0-58" class="i">+	//     member - non-organization members
</a><a href="#h32-0-59" id="h32-0-59" class="i">+	//
</a><a href="#h32-0-60" id="h32-0-60" class="i">+	// Default is &quot;all&quot;.
</a><a href="#h32-0-61" id="h32-0-61" class="i">+	Role string `url:&quot;role,omitempty&quot;`
</a><a href="#h32-0-62" id="h32-0-62" class="i">+
</a><a href="#h32-0-63" id="h32-0-63" class="i">+	ListOptions
</a><a href="#h32-0-64" id="h32-0-64" class="i">+}
</a><a href="#h32-0-65" id="h32-0-65" class="i">+
</a><a href="#h32-0-66" id="h32-0-66" class="i">+// ListMembers lists the members for an organization.  If the authenticated
</a><a href="#h32-0-67" id="h32-0-67" class="i">+// user is an owner of the organization, this will return both concealed and
</a><a href="#h32-0-68" id="h32-0-68" class="i">+// public members, otherwise it will only return public members.
</a><a href="#h32-0-69" id="h32-0-69" class="i">+//
</a><a href="#h32-0-70" id="h32-0-70" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/members/#members-list
</a><a href="#h32-0-71" id="h32-0-71" class="i">+func (s *OrganizationsService) ListMembers(org string, opt *ListMembersOptions) ([]User, *Response, error) {
</a><a href="#h32-0-72" id="h32-0-72" class="i">+	var u string
</a><a href="#h32-0-73" id="h32-0-73" class="i">+	if opt != nil &amp;&amp; opt.PublicOnly {
</a><a href="#h32-0-74" id="h32-0-74" class="i">+		u = fmt.Sprintf(&quot;orgs/%v/public_members&quot;, org)
</a><a href="#h32-0-75" id="h32-0-75" class="i">+	} else {
</a><a href="#h32-0-76" id="h32-0-76" class="i">+		u = fmt.Sprintf(&quot;orgs/%v/members&quot;, org)
</a><a href="#h32-0-77" id="h32-0-77" class="i">+	}
</a><a href="#h32-0-78" id="h32-0-78" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h32-0-79" id="h32-0-79" class="i">+	if err != nil {
</a><a href="#h32-0-80" id="h32-0-80" class="i">+		return nil, nil, err
</a><a href="#h32-0-81" id="h32-0-81" class="i">+	}
</a><a href="#h32-0-82" id="h32-0-82" class="i">+
</a><a href="#h32-0-83" id="h32-0-83" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h32-0-84" id="h32-0-84" class="i">+	if err != nil {
</a><a href="#h32-0-85" id="h32-0-85" class="i">+		return nil, nil, err
</a><a href="#h32-0-86" id="h32-0-86" class="i">+	}
</a><a href="#h32-0-87" id="h32-0-87" class="i">+
</a><a href="#h32-0-88" id="h32-0-88" class="i">+	if opt != nil &amp;&amp; opt.Role != &quot;&quot; {
</a><a href="#h32-0-89" id="h32-0-89" class="i">+		req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h32-0-90" id="h32-0-90" class="i">+	}
</a><a href="#h32-0-91" id="h32-0-91" class="i">+
</a><a href="#h32-0-92" id="h32-0-92" class="i">+	members := new([]User)
</a><a href="#h32-0-93" id="h32-0-93" class="i">+	resp, err := s.client.Do(req, members)
</a><a href="#h32-0-94" id="h32-0-94" class="i">+	if err != nil {
</a><a href="#h32-0-95" id="h32-0-95" class="i">+		return nil, resp, err
</a><a href="#h32-0-96" id="h32-0-96" class="i">+	}
</a><a href="#h32-0-97" id="h32-0-97" class="i">+
</a><a href="#h32-0-98" id="h32-0-98" class="i">+	return *members, resp, err
</a><a href="#h32-0-99" id="h32-0-99" class="i">+}
</a><a href="#h32-0-100" id="h32-0-100" class="i">+
</a><a href="#h32-0-101" id="h32-0-101" class="i">+// IsMember checks if a user is a member of an organization.
</a><a href="#h32-0-102" id="h32-0-102" class="i">+//
</a><a href="#h32-0-103" id="h32-0-103" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/members/#check-membership
</a><a href="#h32-0-104" id="h32-0-104" class="i">+func (s *OrganizationsService) IsMember(org, user string) (bool, *Response, error) {
</a><a href="#h32-0-105" id="h32-0-105" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/members/%v&quot;, org, user)
</a><a href="#h32-0-106" id="h32-0-106" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h32-0-107" id="h32-0-107" class="i">+	if err != nil {
</a><a href="#h32-0-108" id="h32-0-108" class="i">+		return false, nil, err
</a><a href="#h32-0-109" id="h32-0-109" class="i">+	}
</a><a href="#h32-0-110" id="h32-0-110" class="i">+
</a><a href="#h32-0-111" id="h32-0-111" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h32-0-112" id="h32-0-112" class="i">+	member, err := parseBoolResponse(err)
</a><a href="#h32-0-113" id="h32-0-113" class="i">+	return member, resp, err
</a><a href="#h32-0-114" id="h32-0-114" class="i">+}
</a><a href="#h32-0-115" id="h32-0-115" class="i">+
</a><a href="#h32-0-116" id="h32-0-116" class="i">+// IsPublicMember checks if a user is a public member of an organization.
</a><a href="#h32-0-117" id="h32-0-117" class="i">+//
</a><a href="#h32-0-118" id="h32-0-118" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/members/#check-public-membership
</a><a href="#h32-0-119" id="h32-0-119" class="i">+func (s *OrganizationsService) IsPublicMember(org, user string) (bool, *Response, error) {
</a><a href="#h32-0-120" id="h32-0-120" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/public_members/%v&quot;, org, user)
</a><a href="#h32-0-121" id="h32-0-121" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h32-0-122" id="h32-0-122" class="i">+	if err != nil {
</a><a href="#h32-0-123" id="h32-0-123" class="i">+		return false, nil, err
</a><a href="#h32-0-124" id="h32-0-124" class="i">+	}
</a><a href="#h32-0-125" id="h32-0-125" class="i">+
</a><a href="#h32-0-126" id="h32-0-126" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h32-0-127" id="h32-0-127" class="i">+	member, err := parseBoolResponse(err)
</a><a href="#h32-0-128" id="h32-0-128" class="i">+	return member, resp, err
</a><a href="#h32-0-129" id="h32-0-129" class="i">+}
</a><a href="#h32-0-130" id="h32-0-130" class="i">+
</a><a href="#h32-0-131" id="h32-0-131" class="i">+// RemoveMember removes a user from all teams of an organization.
</a><a href="#h32-0-132" id="h32-0-132" class="i">+//
</a><a href="#h32-0-133" id="h32-0-133" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/members/#remove-a-member
</a><a href="#h32-0-134" id="h32-0-134" class="i">+func (s *OrganizationsService) RemoveMember(org, user string) (*Response, error) {
</a><a href="#h32-0-135" id="h32-0-135" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/members/%v&quot;, org, user)
</a><a href="#h32-0-136" id="h32-0-136" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h32-0-137" id="h32-0-137" class="i">+	if err != nil {
</a><a href="#h32-0-138" id="h32-0-138" class="i">+		return nil, err
</a><a href="#h32-0-139" id="h32-0-139" class="i">+	}
</a><a href="#h32-0-140" id="h32-0-140" class="i">+
</a><a href="#h32-0-141" id="h32-0-141" class="i">+	return s.client.Do(req, nil)
</a><a href="#h32-0-142" id="h32-0-142" class="i">+}
</a><a href="#h32-0-143" id="h32-0-143" class="i">+
</a><a href="#h32-0-144" id="h32-0-144" class="i">+// PublicizeMembership publicizes a user&#39;s membership in an organization. (A
</a><a href="#h32-0-145" id="h32-0-145" class="i">+// user cannot publicize the membership for another user.)
</a><a href="#h32-0-146" id="h32-0-146" class="i">+//
</a><a href="#h32-0-147" id="h32-0-147" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/members/#publicize-a-users-membership
</a><a href="#h32-0-148" id="h32-0-148" class="i">+func (s *OrganizationsService) PublicizeMembership(org, user string) (*Response, error) {
</a><a href="#h32-0-149" id="h32-0-149" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/public_members/%v&quot;, org, user)
</a><a href="#h32-0-150" id="h32-0-150" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h32-0-151" id="h32-0-151" class="i">+	if err != nil {
</a><a href="#h32-0-152" id="h32-0-152" class="i">+		return nil, err
</a><a href="#h32-0-153" id="h32-0-153" class="i">+	}
</a><a href="#h32-0-154" id="h32-0-154" class="i">+
</a><a href="#h32-0-155" id="h32-0-155" class="i">+	return s.client.Do(req, nil)
</a><a href="#h32-0-156" id="h32-0-156" class="i">+}
</a><a href="#h32-0-157" id="h32-0-157" class="i">+
</a><a href="#h32-0-158" id="h32-0-158" class="i">+// ConcealMembership conceals a user&#39;s membership in an organization.
</a><a href="#h32-0-159" id="h32-0-159" class="i">+//
</a><a href="#h32-0-160" id="h32-0-160" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/members/#conceal-a-users-membership
</a><a href="#h32-0-161" id="h32-0-161" class="i">+func (s *OrganizationsService) ConcealMembership(org, user string) (*Response, error) {
</a><a href="#h32-0-162" id="h32-0-162" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/public_members/%v&quot;, org, user)
</a><a href="#h32-0-163" id="h32-0-163" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h32-0-164" id="h32-0-164" class="i">+	if err != nil {
</a><a href="#h32-0-165" id="h32-0-165" class="i">+		return nil, err
</a><a href="#h32-0-166" id="h32-0-166" class="i">+	}
</a><a href="#h32-0-167" id="h32-0-167" class="i">+
</a><a href="#h32-0-168" id="h32-0-168" class="i">+	return s.client.Do(req, nil)
</a><a href="#h32-0-169" id="h32-0-169" class="i">+}
</a><a href="#h32-0-170" id="h32-0-170" class="i">+
</a><a href="#h32-0-171" id="h32-0-171" class="i">+// ListOrgMembershipsOptions specifies optional parameters to the
</a><a href="#h32-0-172" id="h32-0-172" class="i">+// OrganizationsService.ListOrgMemberships method.
</a><a href="#h32-0-173" id="h32-0-173" class="i">+type ListOrgMembershipsOptions struct {
</a><a href="#h32-0-174" id="h32-0-174" class="i">+	// Filter memberships to include only those with the specified state.
</a><a href="#h32-0-175" id="h32-0-175" class="i">+	// Possible values are: &quot;active&quot;, &quot;pending&quot;.
</a><a href="#h32-0-176" id="h32-0-176" class="i">+	State string `url:&quot;state,omitempty&quot;`
</a><a href="#h32-0-177" id="h32-0-177" class="i">+
</a><a href="#h32-0-178" id="h32-0-178" class="i">+	ListOptions
</a><a href="#h32-0-179" id="h32-0-179" class="i">+}
</a><a href="#h32-0-180" id="h32-0-180" class="i">+
</a><a href="#h32-0-181" id="h32-0-181" class="i">+// ListOrgMemberships lists the organization memberships for the authenticated user.
</a><a href="#h32-0-182" id="h32-0-182" class="i">+//
</a><a href="#h32-0-183" id="h32-0-183" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/members/#list-your-organization-memberships
</a><a href="#h32-0-184" id="h32-0-184" class="i">+func (s *OrganizationsService) ListOrgMemberships(opt *ListOrgMembershipsOptions) ([]Membership, *Response, error) {
</a><a href="#h32-0-185" id="h32-0-185" class="i">+	u := &quot;user/memberships/orgs&quot;
</a><a href="#h32-0-186" id="h32-0-186" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h32-0-187" id="h32-0-187" class="i">+	if err != nil {
</a><a href="#h32-0-188" id="h32-0-188" class="i">+		return nil, nil, err
</a><a href="#h32-0-189" id="h32-0-189" class="i">+	}
</a><a href="#h32-0-190" id="h32-0-190" class="i">+
</a><a href="#h32-0-191" id="h32-0-191" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h32-0-192" id="h32-0-192" class="i">+	if err != nil {
</a><a href="#h32-0-193" id="h32-0-193" class="i">+		return nil, nil, err
</a><a href="#h32-0-194" id="h32-0-194" class="i">+	}
</a><a href="#h32-0-195" id="h32-0-195" class="i">+
</a><a href="#h32-0-196" id="h32-0-196" class="i">+	var memberships []Membership
</a><a href="#h32-0-197" id="h32-0-197" class="i">+	resp, err := s.client.Do(req, &amp;memberships)
</a><a href="#h32-0-198" id="h32-0-198" class="i">+	if err != nil {
</a><a href="#h32-0-199" id="h32-0-199" class="i">+		return nil, resp, err
</a><a href="#h32-0-200" id="h32-0-200" class="i">+	}
</a><a href="#h32-0-201" id="h32-0-201" class="i">+
</a><a href="#h32-0-202" id="h32-0-202" class="i">+	return memberships, resp, err
</a><a href="#h32-0-203" id="h32-0-203" class="i">+}
</a><a href="#h32-0-204" id="h32-0-204" class="i">+
</a><a href="#h32-0-205" id="h32-0-205" class="i">+// GetOrgMembership gets the membership for a user in a specified organization.
</a><a href="#h32-0-206" id="h32-0-206" class="i">+// Passing an empty string for user will get the membership for the
</a><a href="#h32-0-207" id="h32-0-207" class="i">+// authenticated user.
</a><a href="#h32-0-208" id="h32-0-208" class="i">+//
</a><a href="#h32-0-209" id="h32-0-209" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/members/#get-organization-membership
</a><a href="#h32-0-210" id="h32-0-210" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/members/#get-your-organization-membership
</a><a href="#h32-0-211" id="h32-0-211" class="i">+func (s *OrganizationsService) GetOrgMembership(user, org string) (*Membership, *Response, error) {
</a><a href="#h32-0-212" id="h32-0-212" class="i">+	var u string
</a><a href="#h32-0-213" id="h32-0-213" class="i">+	if user != &quot;&quot; {
</a><a href="#h32-0-214" id="h32-0-214" class="i">+		u = fmt.Sprintf(&quot;orgs/%v/memberships/%v&quot;, org, user)
</a><a href="#h32-0-215" id="h32-0-215" class="i">+	} else {
</a><a href="#h32-0-216" id="h32-0-216" class="i">+		u = fmt.Sprintf(&quot;user/memberships/orgs/%v&quot;, org)
</a><a href="#h32-0-217" id="h32-0-217" class="i">+	}
</a><a href="#h32-0-218" id="h32-0-218" class="i">+
</a><a href="#h32-0-219" id="h32-0-219" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h32-0-220" id="h32-0-220" class="i">+	if err != nil {
</a><a href="#h32-0-221" id="h32-0-221" class="i">+		return nil, nil, err
</a><a href="#h32-0-222" id="h32-0-222" class="i">+	}
</a><a href="#h32-0-223" id="h32-0-223" class="i">+
</a><a href="#h32-0-224" id="h32-0-224" class="i">+	membership := new(Membership)
</a><a href="#h32-0-225" id="h32-0-225" class="i">+	resp, err := s.client.Do(req, membership)
</a><a href="#h32-0-226" id="h32-0-226" class="i">+	if err != nil {
</a><a href="#h32-0-227" id="h32-0-227" class="i">+		return nil, resp, err
</a><a href="#h32-0-228" id="h32-0-228" class="i">+	}
</a><a href="#h32-0-229" id="h32-0-229" class="i">+
</a><a href="#h32-0-230" id="h32-0-230" class="i">+	return membership, resp, err
</a><a href="#h32-0-231" id="h32-0-231" class="i">+}
</a><a href="#h32-0-232" id="h32-0-232" class="i">+
</a><a href="#h32-0-233" id="h32-0-233" class="i">+// EditOrgMembership edits the membership for user in specified organization.
</a><a href="#h32-0-234" id="h32-0-234" class="i">+// Passing an empty string for user will edit the membership for the
</a><a href="#h32-0-235" id="h32-0-235" class="i">+// authenticated user.
</a><a href="#h32-0-236" id="h32-0-236" class="i">+//
</a><a href="#h32-0-237" id="h32-0-237" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership
</a><a href="#h32-0-238" id="h32-0-238" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/members/#edit-your-organization-membership
</a><a href="#h32-0-239" id="h32-0-239" class="i">+func (s *OrganizationsService) EditOrgMembership(user, org string, membership *Membership) (*Membership, *Response, error) {
</a><a href="#h32-0-240" id="h32-0-240" class="i">+	var u, method string
</a><a href="#h32-0-241" id="h32-0-241" class="i">+	if user != &quot;&quot; {
</a><a href="#h32-0-242" id="h32-0-242" class="i">+		u = fmt.Sprintf(&quot;orgs/%v/memberships/%v&quot;, org, user)
</a><a href="#h32-0-243" id="h32-0-243" class="i">+		method = &quot;PUT&quot;
</a><a href="#h32-0-244" id="h32-0-244" class="i">+	} else {
</a><a href="#h32-0-245" id="h32-0-245" class="i">+		u = fmt.Sprintf(&quot;user/memberships/orgs/%v&quot;, org)
</a><a href="#h32-0-246" id="h32-0-246" class="i">+		method = &quot;PATCH&quot;
</a><a href="#h32-0-247" id="h32-0-247" class="i">+	}
</a><a href="#h32-0-248" id="h32-0-248" class="i">+
</a><a href="#h32-0-249" id="h32-0-249" class="i">+	req, err := s.client.NewRequest(method, u, membership)
</a><a href="#h32-0-250" id="h32-0-250" class="i">+	if err != nil {
</a><a href="#h32-0-251" id="h32-0-251" class="i">+		return nil, nil, err
</a><a href="#h32-0-252" id="h32-0-252" class="i">+	}
</a><a href="#h32-0-253" id="h32-0-253" class="i">+
</a><a href="#h32-0-254" id="h32-0-254" class="i">+	m := new(Membership)
</a><a href="#h32-0-255" id="h32-0-255" class="i">+	resp, err := s.client.Do(req, m)
</a><a href="#h32-0-256" id="h32-0-256" class="i">+	if err != nil {
</a><a href="#h32-0-257" id="h32-0-257" class="i">+		return nil, resp, err
</a><a href="#h32-0-258" id="h32-0-258" class="i">+	}
</a><a href="#h32-0-259" id="h32-0-259" class="i">+
</a><a href="#h32-0-260" id="h32-0-260" class="i">+	return m, resp, err
</a><a href="#h32-0-261" id="h32-0-261" class="i">+}
</a><a href="#h32-0-262" id="h32-0-262" class="i">+
</a><a href="#h32-0-263" id="h32-0-263" class="i">+// RemoveOrgMembership removes user from the specified organization.  If the
</a><a href="#h32-0-264" id="h32-0-264" class="i">+// user has been invited to the organization, this will cancel their invitation.
</a><a href="#h32-0-265" id="h32-0-265" class="i">+//
</a><a href="#h32-0-266" id="h32-0-266" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/members/#remove-organization-membership
</a><a href="#h32-0-267" id="h32-0-267" class="i">+func (s *OrganizationsService) RemoveOrgMembership(user, org string) (*Response, error) {
</a><a href="#h32-0-268" id="h32-0-268" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/memberships/%v&quot;, org, user)
</a><a href="#h32-0-269" id="h32-0-269" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h32-0-270" id="h32-0-270" class="i">+	if err != nil {
</a><a href="#h32-0-271" id="h32-0-271" class="i">+		return nil, err
</a><a href="#h32-0-272" id="h32-0-272" class="i">+	}
</a><a href="#h32-0-273" id="h32-0-273" class="i">+
</a><a href="#h32-0-274" id="h32-0-274" class="i">+	return s.client.Do(req, nil)
</a><a href="#h32-0-275" id="h32-0-275" class="i">+}
</a><b>diff --git a/<a id="h33" href="../file/vendor/github.com/google/go-github/github/orgs_teams.go">vendor/github.com/google/go-github/github/orgs_teams.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/orgs_teams.go">vendor/github.com/google/go-github/github/orgs_teams.go</a></b>
<a href="#h33-0" id="h33-0" class="h">@@ -0,0 +1,399 @@
</a><a href="#h33-0-0" id="h33-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h33-0-1" id="h33-0-1" class="i">+//
</a><a href="#h33-0-2" id="h33-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h33-0-3" id="h33-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h33-0-4" id="h33-0-4" class="i">+
</a><a href="#h33-0-5" id="h33-0-5" class="i">+package github
</a><a href="#h33-0-6" id="h33-0-6" class="i">+
</a><a href="#h33-0-7" id="h33-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h33-0-8" id="h33-0-8" class="i">+
</a><a href="#h33-0-9" id="h33-0-9" class="i">+// Team represents a team within a GitHub organization.  Teams are used to
</a><a href="#h33-0-10" id="h33-0-10" class="i">+// manage access to an organization&#39;s repositories.
</a><a href="#h33-0-11" id="h33-0-11" class="i">+type Team struct {
</a><a href="#h33-0-12" id="h33-0-12" class="i">+	ID          *int    `json:&quot;id,omitempty&quot;`
</a><a href="#h33-0-13" id="h33-0-13" class="i">+	Name        *string `json:&quot;name,omitempty&quot;`
</a><a href="#h33-0-14" id="h33-0-14" class="i">+	Description *string `json:&quot;description,omitempty&quot;`
</a><a href="#h33-0-15" id="h33-0-15" class="i">+	URL         *string `json:&quot;url,omitempty&quot;`
</a><a href="#h33-0-16" id="h33-0-16" class="i">+	Slug        *string `json:&quot;slug,omitempty&quot;`
</a><a href="#h33-0-17" id="h33-0-17" class="i">+
</a><a href="#h33-0-18" id="h33-0-18" class="i">+	// Permission is deprecated when creating or editing a team in an org
</a><a href="#h33-0-19" id="h33-0-19" class="i">+	// using the new GitHub permission model.  It no longer identifies the
</a><a href="#h33-0-20" id="h33-0-20" class="i">+	// permission a team has on its repos, but only specifies the default
</a><a href="#h33-0-21" id="h33-0-21" class="i">+	// permission a repo is initially added with.  Avoid confusion by
</a><a href="#h33-0-22" id="h33-0-22" class="i">+	// specifying a permission value when calling AddTeamRepo.
</a><a href="#h33-0-23" id="h33-0-23" class="i">+	Permission *string `json:&quot;permission,omitempty&quot;`
</a><a href="#h33-0-24" id="h33-0-24" class="i">+
</a><a href="#h33-0-25" id="h33-0-25" class="i">+	// Privacy identifies the level of privacy this team should have.
</a><a href="#h33-0-26" id="h33-0-26" class="i">+	// Possible values are:
</a><a href="#h33-0-27" id="h33-0-27" class="i">+	//     secret - only visible to organization owners and members of this team
</a><a href="#h33-0-28" id="h33-0-28" class="i">+	//     closed - visible to all members of this organization
</a><a href="#h33-0-29" id="h33-0-29" class="i">+	// Default is &quot;secret&quot;.
</a><a href="#h33-0-30" id="h33-0-30" class="i">+	Privacy *string `json:&quot;privacy,omitempty&quot;`
</a><a href="#h33-0-31" id="h33-0-31" class="i">+
</a><a href="#h33-0-32" id="h33-0-32" class="i">+	MembersCount    *int          `json:&quot;members_count,omitempty&quot;`
</a><a href="#h33-0-33" id="h33-0-33" class="i">+	ReposCount      *int          `json:&quot;repos_count,omitempty&quot;`
</a><a href="#h33-0-34" id="h33-0-34" class="i">+	Organization    *Organization `json:&quot;organization,omitempty&quot;`
</a><a href="#h33-0-35" id="h33-0-35" class="i">+	MembersURL      *string       `json:&quot;members_url,omitempty&quot;`
</a><a href="#h33-0-36" id="h33-0-36" class="i">+	RepositoriesURL *string       `json:&quot;repositories_url,omitempty&quot;`
</a><a href="#h33-0-37" id="h33-0-37" class="i">+}
</a><a href="#h33-0-38" id="h33-0-38" class="i">+
</a><a href="#h33-0-39" id="h33-0-39" class="i">+func (t Team) String() string {
</a><a href="#h33-0-40" id="h33-0-40" class="i">+	return Stringify(t)
</a><a href="#h33-0-41" id="h33-0-41" class="i">+}
</a><a href="#h33-0-42" id="h33-0-42" class="i">+
</a><a href="#h33-0-43" id="h33-0-43" class="i">+// ListTeams lists all of the teams for an organization.
</a><a href="#h33-0-44" id="h33-0-44" class="i">+//
</a><a href="#h33-0-45" id="h33-0-45" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#list-teams
</a><a href="#h33-0-46" id="h33-0-46" class="i">+func (s *OrganizationsService) ListTeams(org string, opt *ListOptions) ([]Team, *Response, error) {
</a><a href="#h33-0-47" id="h33-0-47" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/teams&quot;, org)
</a><a href="#h33-0-48" id="h33-0-48" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h33-0-49" id="h33-0-49" class="i">+	if err != nil {
</a><a href="#h33-0-50" id="h33-0-50" class="i">+		return nil, nil, err
</a><a href="#h33-0-51" id="h33-0-51" class="i">+	}
</a><a href="#h33-0-52" id="h33-0-52" class="i">+
</a><a href="#h33-0-53" id="h33-0-53" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-54" id="h33-0-54" class="i">+	if err != nil {
</a><a href="#h33-0-55" id="h33-0-55" class="i">+		return nil, nil, err
</a><a href="#h33-0-56" id="h33-0-56" class="i">+	}
</a><a href="#h33-0-57" id="h33-0-57" class="i">+
</a><a href="#h33-0-58" id="h33-0-58" class="i">+	teams := new([]Team)
</a><a href="#h33-0-59" id="h33-0-59" class="i">+	resp, err := s.client.Do(req, teams)
</a><a href="#h33-0-60" id="h33-0-60" class="i">+	if err != nil {
</a><a href="#h33-0-61" id="h33-0-61" class="i">+		return nil, resp, err
</a><a href="#h33-0-62" id="h33-0-62" class="i">+	}
</a><a href="#h33-0-63" id="h33-0-63" class="i">+
</a><a href="#h33-0-64" id="h33-0-64" class="i">+	return *teams, resp, err
</a><a href="#h33-0-65" id="h33-0-65" class="i">+}
</a><a href="#h33-0-66" id="h33-0-66" class="i">+
</a><a href="#h33-0-67" id="h33-0-67" class="i">+// GetTeam fetches a team by ID.
</a><a href="#h33-0-68" id="h33-0-68" class="i">+//
</a><a href="#h33-0-69" id="h33-0-69" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#get-team
</a><a href="#h33-0-70" id="h33-0-70" class="i">+func (s *OrganizationsService) GetTeam(team int) (*Team, *Response, error) {
</a><a href="#h33-0-71" id="h33-0-71" class="i">+	u := fmt.Sprintf(&quot;teams/%v&quot;, team)
</a><a href="#h33-0-72" id="h33-0-72" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-73" id="h33-0-73" class="i">+	if err != nil {
</a><a href="#h33-0-74" id="h33-0-74" class="i">+		return nil, nil, err
</a><a href="#h33-0-75" id="h33-0-75" class="i">+	}
</a><a href="#h33-0-76" id="h33-0-76" class="i">+
</a><a href="#h33-0-77" id="h33-0-77" class="i">+	t := new(Team)
</a><a href="#h33-0-78" id="h33-0-78" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h33-0-79" id="h33-0-79" class="i">+	if err != nil {
</a><a href="#h33-0-80" id="h33-0-80" class="i">+		return nil, resp, err
</a><a href="#h33-0-81" id="h33-0-81" class="i">+	}
</a><a href="#h33-0-82" id="h33-0-82" class="i">+
</a><a href="#h33-0-83" id="h33-0-83" class="i">+	return t, resp, err
</a><a href="#h33-0-84" id="h33-0-84" class="i">+}
</a><a href="#h33-0-85" id="h33-0-85" class="i">+
</a><a href="#h33-0-86" id="h33-0-86" class="i">+// CreateTeam creates a new team within an organization.
</a><a href="#h33-0-87" id="h33-0-87" class="i">+//
</a><a href="#h33-0-88" id="h33-0-88" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#create-team
</a><a href="#h33-0-89" id="h33-0-89" class="i">+func (s *OrganizationsService) CreateTeam(org string, team *Team) (*Team, *Response, error) {
</a><a href="#h33-0-90" id="h33-0-90" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/teams&quot;, org)
</a><a href="#h33-0-91" id="h33-0-91" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, team)
</a><a href="#h33-0-92" id="h33-0-92" class="i">+	if err != nil {
</a><a href="#h33-0-93" id="h33-0-93" class="i">+		return nil, nil, err
</a><a href="#h33-0-94" id="h33-0-94" class="i">+	}
</a><a href="#h33-0-95" id="h33-0-95" class="i">+
</a><a href="#h33-0-96" id="h33-0-96" class="i">+	if team.Privacy != nil {
</a><a href="#h33-0-97" id="h33-0-97" class="i">+		req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h33-0-98" id="h33-0-98" class="i">+	}
</a><a href="#h33-0-99" id="h33-0-99" class="i">+
</a><a href="#h33-0-100" id="h33-0-100" class="i">+	t := new(Team)
</a><a href="#h33-0-101" id="h33-0-101" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h33-0-102" id="h33-0-102" class="i">+	if err != nil {
</a><a href="#h33-0-103" id="h33-0-103" class="i">+		return nil, resp, err
</a><a href="#h33-0-104" id="h33-0-104" class="i">+	}
</a><a href="#h33-0-105" id="h33-0-105" class="i">+
</a><a href="#h33-0-106" id="h33-0-106" class="i">+	return t, resp, err
</a><a href="#h33-0-107" id="h33-0-107" class="i">+}
</a><a href="#h33-0-108" id="h33-0-108" class="i">+
</a><a href="#h33-0-109" id="h33-0-109" class="i">+// EditTeam edits a team.
</a><a href="#h33-0-110" id="h33-0-110" class="i">+//
</a><a href="#h33-0-111" id="h33-0-111" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#edit-team
</a><a href="#h33-0-112" id="h33-0-112" class="i">+func (s *OrganizationsService) EditTeam(id int, team *Team) (*Team, *Response, error) {
</a><a href="#h33-0-113" id="h33-0-113" class="i">+	u := fmt.Sprintf(&quot;teams/%v&quot;, id)
</a><a href="#h33-0-114" id="h33-0-114" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, team)
</a><a href="#h33-0-115" id="h33-0-115" class="i">+	if err != nil {
</a><a href="#h33-0-116" id="h33-0-116" class="i">+		return nil, nil, err
</a><a href="#h33-0-117" id="h33-0-117" class="i">+	}
</a><a href="#h33-0-118" id="h33-0-118" class="i">+
</a><a href="#h33-0-119" id="h33-0-119" class="i">+	if team.Privacy != nil {
</a><a href="#h33-0-120" id="h33-0-120" class="i">+		req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h33-0-121" id="h33-0-121" class="i">+	}
</a><a href="#h33-0-122" id="h33-0-122" class="i">+
</a><a href="#h33-0-123" id="h33-0-123" class="i">+	t := new(Team)
</a><a href="#h33-0-124" id="h33-0-124" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h33-0-125" id="h33-0-125" class="i">+	if err != nil {
</a><a href="#h33-0-126" id="h33-0-126" class="i">+		return nil, resp, err
</a><a href="#h33-0-127" id="h33-0-127" class="i">+	}
</a><a href="#h33-0-128" id="h33-0-128" class="i">+
</a><a href="#h33-0-129" id="h33-0-129" class="i">+	return t, resp, err
</a><a href="#h33-0-130" id="h33-0-130" class="i">+}
</a><a href="#h33-0-131" id="h33-0-131" class="i">+
</a><a href="#h33-0-132" id="h33-0-132" class="i">+// DeleteTeam deletes a team.
</a><a href="#h33-0-133" id="h33-0-133" class="i">+//
</a><a href="#h33-0-134" id="h33-0-134" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#delete-team
</a><a href="#h33-0-135" id="h33-0-135" class="i">+func (s *OrganizationsService) DeleteTeam(team int) (*Response, error) {
</a><a href="#h33-0-136" id="h33-0-136" class="i">+	u := fmt.Sprintf(&quot;teams/%v&quot;, team)
</a><a href="#h33-0-137" id="h33-0-137" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h33-0-138" id="h33-0-138" class="i">+	if err != nil {
</a><a href="#h33-0-139" id="h33-0-139" class="i">+		return nil, err
</a><a href="#h33-0-140" id="h33-0-140" class="i">+	}
</a><a href="#h33-0-141" id="h33-0-141" class="i">+
</a><a href="#h33-0-142" id="h33-0-142" class="i">+	return s.client.Do(req, nil)
</a><a href="#h33-0-143" id="h33-0-143" class="i">+}
</a><a href="#h33-0-144" id="h33-0-144" class="i">+
</a><a href="#h33-0-145" id="h33-0-145" class="i">+// OrganizationListTeamMembersOptions specifies the optional parameters to the
</a><a href="#h33-0-146" id="h33-0-146" class="i">+// OrganizationsService.ListTeamMembers method.
</a><a href="#h33-0-147" id="h33-0-147" class="i">+type OrganizationListTeamMembersOptions struct {
</a><a href="#h33-0-148" id="h33-0-148" class="i">+	// Role filters members returned by their role in the team.  Possible
</a><a href="#h33-0-149" id="h33-0-149" class="i">+	// values are &quot;all&quot;, &quot;member&quot;, &quot;maintainer&quot;.  Default is &quot;all&quot;.
</a><a href="#h33-0-150" id="h33-0-150" class="i">+	Role string `url:&quot;role,omitempty&quot;`
</a><a href="#h33-0-151" id="h33-0-151" class="i">+
</a><a href="#h33-0-152" id="h33-0-152" class="i">+	ListOptions
</a><a href="#h33-0-153" id="h33-0-153" class="i">+}
</a><a href="#h33-0-154" id="h33-0-154" class="i">+
</a><a href="#h33-0-155" id="h33-0-155" class="i">+// ListTeamMembers lists all of the users who are members of the specified
</a><a href="#h33-0-156" id="h33-0-156" class="i">+// team.
</a><a href="#h33-0-157" id="h33-0-157" class="i">+//
</a><a href="#h33-0-158" id="h33-0-158" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#list-team-members
</a><a href="#h33-0-159" id="h33-0-159" class="i">+func (s *OrganizationsService) ListTeamMembers(team int, opt *OrganizationListTeamMembersOptions) ([]User, *Response, error) {
</a><a href="#h33-0-160" id="h33-0-160" class="i">+	u := fmt.Sprintf(&quot;teams/%v/members&quot;, team)
</a><a href="#h33-0-161" id="h33-0-161" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h33-0-162" id="h33-0-162" class="i">+	if err != nil {
</a><a href="#h33-0-163" id="h33-0-163" class="i">+		return nil, nil, err
</a><a href="#h33-0-164" id="h33-0-164" class="i">+	}
</a><a href="#h33-0-165" id="h33-0-165" class="i">+
</a><a href="#h33-0-166" id="h33-0-166" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-167" id="h33-0-167" class="i">+	if err != nil {
</a><a href="#h33-0-168" id="h33-0-168" class="i">+		return nil, nil, err
</a><a href="#h33-0-169" id="h33-0-169" class="i">+	}
</a><a href="#h33-0-170" id="h33-0-170" class="i">+
</a><a href="#h33-0-171" id="h33-0-171" class="i">+	if opt != nil &amp;&amp; opt.Role != &quot;&quot; {
</a><a href="#h33-0-172" id="h33-0-172" class="i">+		req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h33-0-173" id="h33-0-173" class="i">+	}
</a><a href="#h33-0-174" id="h33-0-174" class="i">+
</a><a href="#h33-0-175" id="h33-0-175" class="i">+	members := new([]User)
</a><a href="#h33-0-176" id="h33-0-176" class="i">+	resp, err := s.client.Do(req, members)
</a><a href="#h33-0-177" id="h33-0-177" class="i">+	if err != nil {
</a><a href="#h33-0-178" id="h33-0-178" class="i">+		return nil, resp, err
</a><a href="#h33-0-179" id="h33-0-179" class="i">+	}
</a><a href="#h33-0-180" id="h33-0-180" class="i">+
</a><a href="#h33-0-181" id="h33-0-181" class="i">+	return *members, resp, err
</a><a href="#h33-0-182" id="h33-0-182" class="i">+}
</a><a href="#h33-0-183" id="h33-0-183" class="i">+
</a><a href="#h33-0-184" id="h33-0-184" class="i">+// IsTeamMember checks if a user is a member of the specified team.
</a><a href="#h33-0-185" id="h33-0-185" class="i">+//
</a><a href="#h33-0-186" id="h33-0-186" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#get-team-member
</a><a href="#h33-0-187" id="h33-0-187" class="i">+func (s *OrganizationsService) IsTeamMember(team int, user string) (bool, *Response, error) {
</a><a href="#h33-0-188" id="h33-0-188" class="i">+	u := fmt.Sprintf(&quot;teams/%v/members/%v&quot;, team, user)
</a><a href="#h33-0-189" id="h33-0-189" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-190" id="h33-0-190" class="i">+	if err != nil {
</a><a href="#h33-0-191" id="h33-0-191" class="i">+		return false, nil, err
</a><a href="#h33-0-192" id="h33-0-192" class="i">+	}
</a><a href="#h33-0-193" id="h33-0-193" class="i">+
</a><a href="#h33-0-194" id="h33-0-194" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h33-0-195" id="h33-0-195" class="i">+	member, err := parseBoolResponse(err)
</a><a href="#h33-0-196" id="h33-0-196" class="i">+	return member, resp, err
</a><a href="#h33-0-197" id="h33-0-197" class="i">+}
</a><a href="#h33-0-198" id="h33-0-198" class="i">+
</a><a href="#h33-0-199" id="h33-0-199" class="i">+// ListTeamRepos lists the repositories that the specified team has access to.
</a><a href="#h33-0-200" id="h33-0-200" class="i">+//
</a><a href="#h33-0-201" id="h33-0-201" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#list-team-repos
</a><a href="#h33-0-202" id="h33-0-202" class="i">+func (s *OrganizationsService) ListTeamRepos(team int, opt *ListOptions) ([]Repository, *Response, error) {
</a><a href="#h33-0-203" id="h33-0-203" class="i">+	u := fmt.Sprintf(&quot;teams/%v/repos&quot;, team)
</a><a href="#h33-0-204" id="h33-0-204" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h33-0-205" id="h33-0-205" class="i">+	if err != nil {
</a><a href="#h33-0-206" id="h33-0-206" class="i">+		return nil, nil, err
</a><a href="#h33-0-207" id="h33-0-207" class="i">+	}
</a><a href="#h33-0-208" id="h33-0-208" class="i">+
</a><a href="#h33-0-209" id="h33-0-209" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-210" id="h33-0-210" class="i">+	if err != nil {
</a><a href="#h33-0-211" id="h33-0-211" class="i">+		return nil, nil, err
</a><a href="#h33-0-212" id="h33-0-212" class="i">+	}
</a><a href="#h33-0-213" id="h33-0-213" class="i">+
</a><a href="#h33-0-214" id="h33-0-214" class="i">+	repos := new([]Repository)
</a><a href="#h33-0-215" id="h33-0-215" class="i">+	resp, err := s.client.Do(req, repos)
</a><a href="#h33-0-216" id="h33-0-216" class="i">+	if err != nil {
</a><a href="#h33-0-217" id="h33-0-217" class="i">+		return nil, resp, err
</a><a href="#h33-0-218" id="h33-0-218" class="i">+	}
</a><a href="#h33-0-219" id="h33-0-219" class="i">+
</a><a href="#h33-0-220" id="h33-0-220" class="i">+	return *repos, resp, err
</a><a href="#h33-0-221" id="h33-0-221" class="i">+}
</a><a href="#h33-0-222" id="h33-0-222" class="i">+
</a><a href="#h33-0-223" id="h33-0-223" class="i">+// IsTeamRepo checks if a team manages the specified repository.  If the
</a><a href="#h33-0-224" id="h33-0-224" class="i">+// repository is managed by team, a Repository is returned which includes the
</a><a href="#h33-0-225" id="h33-0-225" class="i">+// permissions team has for that repo.
</a><a href="#h33-0-226" id="h33-0-226" class="i">+//
</a><a href="#h33-0-227" id="h33-0-227" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#get-team-repo
</a><a href="#h33-0-228" id="h33-0-228" class="i">+func (s *OrganizationsService) IsTeamRepo(team int, owner string, repo string) (*Repository, *Response, error) {
</a><a href="#h33-0-229" id="h33-0-229" class="i">+	u := fmt.Sprintf(&quot;teams/%v/repos/%v/%v&quot;, team, owner, repo)
</a><a href="#h33-0-230" id="h33-0-230" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-231" id="h33-0-231" class="i">+	if err != nil {
</a><a href="#h33-0-232" id="h33-0-232" class="i">+		return nil, nil, err
</a><a href="#h33-0-233" id="h33-0-233" class="i">+	}
</a><a href="#h33-0-234" id="h33-0-234" class="i">+
</a><a href="#h33-0-235" id="h33-0-235" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionRepoPreview)
</a><a href="#h33-0-236" id="h33-0-236" class="i">+
</a><a href="#h33-0-237" id="h33-0-237" class="i">+	repository := new(Repository)
</a><a href="#h33-0-238" id="h33-0-238" class="i">+	resp, err := s.client.Do(req, repository)
</a><a href="#h33-0-239" id="h33-0-239" class="i">+	if err != nil {
</a><a href="#h33-0-240" id="h33-0-240" class="i">+		return nil, resp, err
</a><a href="#h33-0-241" id="h33-0-241" class="i">+	}
</a><a href="#h33-0-242" id="h33-0-242" class="i">+
</a><a href="#h33-0-243" id="h33-0-243" class="i">+	return repository, resp, err
</a><a href="#h33-0-244" id="h33-0-244" class="i">+}
</a><a href="#h33-0-245" id="h33-0-245" class="i">+
</a><a href="#h33-0-246" id="h33-0-246" class="i">+// OrganizationAddTeamRepoOptions specifies the optional parameters to the
</a><a href="#h33-0-247" id="h33-0-247" class="i">+// OrganizationsService.AddTeamRepo method.
</a><a href="#h33-0-248" id="h33-0-248" class="i">+type OrganizationAddTeamRepoOptions struct {
</a><a href="#h33-0-249" id="h33-0-249" class="i">+	// Permission specifies the permission to grant the team on this repository.
</a><a href="#h33-0-250" id="h33-0-250" class="i">+	// Possible values are:
</a><a href="#h33-0-251" id="h33-0-251" class="i">+	//     pull - team members can pull, but not push to or administer this repository
</a><a href="#h33-0-252" id="h33-0-252" class="i">+	//     push - team members can pull and push, but not administer this repository
</a><a href="#h33-0-253" id="h33-0-253" class="i">+	//     admin - team members can pull, push and administer this repository
</a><a href="#h33-0-254" id="h33-0-254" class="i">+	//
</a><a href="#h33-0-255" id="h33-0-255" class="i">+	// If not specified, the team&#39;s permission attribute will be used.
</a><a href="#h33-0-256" id="h33-0-256" class="i">+	Permission string `json:&quot;permission,omitempty&quot;`
</a><a href="#h33-0-257" id="h33-0-257" class="i">+}
</a><a href="#h33-0-258" id="h33-0-258" class="i">+
</a><a href="#h33-0-259" id="h33-0-259" class="i">+// AddTeamRepo adds a repository to be managed by the specified team.  The
</a><a href="#h33-0-260" id="h33-0-260" class="i">+// specified repository must be owned by the organization to which the team
</a><a href="#h33-0-261" id="h33-0-261" class="i">+// belongs, or a direct fork of a repository owned by the organization.
</a><a href="#h33-0-262" id="h33-0-262" class="i">+//
</a><a href="#h33-0-263" id="h33-0-263" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#add-team-repo
</a><a href="#h33-0-264" id="h33-0-264" class="i">+func (s *OrganizationsService) AddTeamRepo(team int, owner string, repo string, opt *OrganizationAddTeamRepoOptions) (*Response, error) {
</a><a href="#h33-0-265" id="h33-0-265" class="i">+	u := fmt.Sprintf(&quot;teams/%v/repos/%v/%v&quot;, team, owner, repo)
</a><a href="#h33-0-266" id="h33-0-266" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, opt)
</a><a href="#h33-0-267" id="h33-0-267" class="i">+	if err != nil {
</a><a href="#h33-0-268" id="h33-0-268" class="i">+		return nil, err
</a><a href="#h33-0-269" id="h33-0-269" class="i">+	}
</a><a href="#h33-0-270" id="h33-0-270" class="i">+
</a><a href="#h33-0-271" id="h33-0-271" class="i">+	if opt != nil {
</a><a href="#h33-0-272" id="h33-0-272" class="i">+		req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h33-0-273" id="h33-0-273" class="i">+	}
</a><a href="#h33-0-274" id="h33-0-274" class="i">+
</a><a href="#h33-0-275" id="h33-0-275" class="i">+	return s.client.Do(req, nil)
</a><a href="#h33-0-276" id="h33-0-276" class="i">+}
</a><a href="#h33-0-277" id="h33-0-277" class="i">+
</a><a href="#h33-0-278" id="h33-0-278" class="i">+// RemoveTeamRepo removes a repository from being managed by the specified
</a><a href="#h33-0-279" id="h33-0-279" class="i">+// team.  Note that this does not delete the repository, it just removes it
</a><a href="#h33-0-280" id="h33-0-280" class="i">+// from the team.
</a><a href="#h33-0-281" id="h33-0-281" class="i">+//
</a><a href="#h33-0-282" id="h33-0-282" class="i">+// GitHub API docs: http://developer.github.com/v3/orgs/teams/#remove-team-repo
</a><a href="#h33-0-283" id="h33-0-283" class="i">+func (s *OrganizationsService) RemoveTeamRepo(team int, owner string, repo string) (*Response, error) {
</a><a href="#h33-0-284" id="h33-0-284" class="i">+	u := fmt.Sprintf(&quot;teams/%v/repos/%v/%v&quot;, team, owner, repo)
</a><a href="#h33-0-285" id="h33-0-285" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h33-0-286" id="h33-0-286" class="i">+	if err != nil {
</a><a href="#h33-0-287" id="h33-0-287" class="i">+		return nil, err
</a><a href="#h33-0-288" id="h33-0-288" class="i">+	}
</a><a href="#h33-0-289" id="h33-0-289" class="i">+
</a><a href="#h33-0-290" id="h33-0-290" class="i">+	return s.client.Do(req, nil)
</a><a href="#h33-0-291" id="h33-0-291" class="i">+}
</a><a href="#h33-0-292" id="h33-0-292" class="i">+
</a><a href="#h33-0-293" id="h33-0-293" class="i">+// ListUserTeams lists a user&#39;s teams
</a><a href="#h33-0-294" id="h33-0-294" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/teams/#list-user-teams
</a><a href="#h33-0-295" id="h33-0-295" class="i">+func (s *OrganizationsService) ListUserTeams(opt *ListOptions) ([]Team, *Response, error) {
</a><a href="#h33-0-296" id="h33-0-296" class="i">+	u := &quot;user/teams&quot;
</a><a href="#h33-0-297" id="h33-0-297" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h33-0-298" id="h33-0-298" class="i">+	if err != nil {
</a><a href="#h33-0-299" id="h33-0-299" class="i">+		return nil, nil, err
</a><a href="#h33-0-300" id="h33-0-300" class="i">+	}
</a><a href="#h33-0-301" id="h33-0-301" class="i">+
</a><a href="#h33-0-302" id="h33-0-302" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-303" id="h33-0-303" class="i">+	if err != nil {
</a><a href="#h33-0-304" id="h33-0-304" class="i">+		return nil, nil, err
</a><a href="#h33-0-305" id="h33-0-305" class="i">+	}
</a><a href="#h33-0-306" id="h33-0-306" class="i">+
</a><a href="#h33-0-307" id="h33-0-307" class="i">+	teams := new([]Team)
</a><a href="#h33-0-308" id="h33-0-308" class="i">+	resp, err := s.client.Do(req, teams)
</a><a href="#h33-0-309" id="h33-0-309" class="i">+	if err != nil {
</a><a href="#h33-0-310" id="h33-0-310" class="i">+		return nil, resp, err
</a><a href="#h33-0-311" id="h33-0-311" class="i">+	}
</a><a href="#h33-0-312" id="h33-0-312" class="i">+
</a><a href="#h33-0-313" id="h33-0-313" class="i">+	return *teams, resp, err
</a><a href="#h33-0-314" id="h33-0-314" class="i">+}
</a><a href="#h33-0-315" id="h33-0-315" class="i">+
</a><a href="#h33-0-316" id="h33-0-316" class="i">+// GetTeamMembership returns the membership status for a user in a team.
</a><a href="#h33-0-317" id="h33-0-317" class="i">+//
</a><a href="#h33-0-318" id="h33-0-318" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/teams/#get-team-membership
</a><a href="#h33-0-319" id="h33-0-319" class="i">+func (s *OrganizationsService) GetTeamMembership(team int, user string) (*Membership, *Response, error) {
</a><a href="#h33-0-320" id="h33-0-320" class="i">+	u := fmt.Sprintf(&quot;teams/%v/memberships/%v&quot;, team, user)
</a><a href="#h33-0-321" id="h33-0-321" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h33-0-322" id="h33-0-322" class="i">+	if err != nil {
</a><a href="#h33-0-323" id="h33-0-323" class="i">+		return nil, nil, err
</a><a href="#h33-0-324" id="h33-0-324" class="i">+	}
</a><a href="#h33-0-325" id="h33-0-325" class="i">+
</a><a href="#h33-0-326" id="h33-0-326" class="i">+	t := new(Membership)
</a><a href="#h33-0-327" id="h33-0-327" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h33-0-328" id="h33-0-328" class="i">+	if err != nil {
</a><a href="#h33-0-329" id="h33-0-329" class="i">+		return nil, resp, err
</a><a href="#h33-0-330" id="h33-0-330" class="i">+	}
</a><a href="#h33-0-331" id="h33-0-331" class="i">+
</a><a href="#h33-0-332" id="h33-0-332" class="i">+	return t, resp, err
</a><a href="#h33-0-333" id="h33-0-333" class="i">+}
</a><a href="#h33-0-334" id="h33-0-334" class="i">+
</a><a href="#h33-0-335" id="h33-0-335" class="i">+// OrganizationAddTeamMembershipOptions does stuff specifies the optional
</a><a href="#h33-0-336" id="h33-0-336" class="i">+// parameters to the OrganizationsService.AddTeamMembership method.
</a><a href="#h33-0-337" id="h33-0-337" class="i">+type OrganizationAddTeamMembershipOptions struct {
</a><a href="#h33-0-338" id="h33-0-338" class="i">+	// Role specifies the role the user should have in the team.  Possible
</a><a href="#h33-0-339" id="h33-0-339" class="i">+	// values are:
</a><a href="#h33-0-340" id="h33-0-340" class="i">+	//     member - a normal member of the team
</a><a href="#h33-0-341" id="h33-0-341" class="i">+	//     maintainer - a team maintainer. Able to add/remove other team
</a><a href="#h33-0-342" id="h33-0-342" class="i">+	//                  members, promote other team members to team
</a><a href="#h33-0-343" id="h33-0-343" class="i">+	//                  maintainer, and edit the teams name and description
</a><a href="#h33-0-344" id="h33-0-344" class="i">+	//
</a><a href="#h33-0-345" id="h33-0-345" class="i">+	// Default value is &quot;member&quot;.
</a><a href="#h33-0-346" id="h33-0-346" class="i">+	Role string `json:&quot;role,omitempty&quot;`
</a><a href="#h33-0-347" id="h33-0-347" class="i">+}
</a><a href="#h33-0-348" id="h33-0-348" class="i">+
</a><a href="#h33-0-349" id="h33-0-349" class="i">+// AddTeamMembership adds or invites a user to a team.
</a><a href="#h33-0-350" id="h33-0-350" class="i">+//
</a><a href="#h33-0-351" id="h33-0-351" class="i">+// In order to add a membership between a user and a team, the authenticated
</a><a href="#h33-0-352" id="h33-0-352" class="i">+// user must have &#39;admin&#39; permissions to the team or be an owner of the
</a><a href="#h33-0-353" id="h33-0-353" class="i">+// organization that the team is associated with.
</a><a href="#h33-0-354" id="h33-0-354" class="i">+//
</a><a href="#h33-0-355" id="h33-0-355" class="i">+// If the user is already a part of the team&#39;s organization (meaning they&#39;re on
</a><a href="#h33-0-356" id="h33-0-356" class="i">+// at least one other team in the organization), this endpoint will add the
</a><a href="#h33-0-357" id="h33-0-357" class="i">+// user to the team.
</a><a href="#h33-0-358" id="h33-0-358" class="i">+//
</a><a href="#h33-0-359" id="h33-0-359" class="i">+// If the user is completely unaffiliated with the team&#39;s organization (meaning
</a><a href="#h33-0-360" id="h33-0-360" class="i">+// they&#39;re on none of the organization&#39;s teams), this endpoint will send an
</a><a href="#h33-0-361" id="h33-0-361" class="i">+// invitation to the user via email. This newly-created membership will be in
</a><a href="#h33-0-362" id="h33-0-362" class="i">+// the &quot;pending&quot; state until the user accepts the invitation, at which point
</a><a href="#h33-0-363" id="h33-0-363" class="i">+// the membership will transition to the &quot;active&quot; state and the user will be
</a><a href="#h33-0-364" id="h33-0-364" class="i">+// added as a member of the team.
</a><a href="#h33-0-365" id="h33-0-365" class="i">+//
</a><a href="#h33-0-366" id="h33-0-366" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/teams/#add-team-membership
</a><a href="#h33-0-367" id="h33-0-367" class="i">+func (s *OrganizationsService) AddTeamMembership(team int, user string, opt *OrganizationAddTeamMembershipOptions) (*Membership, *Response, error) {
</a><a href="#h33-0-368" id="h33-0-368" class="i">+	u := fmt.Sprintf(&quot;teams/%v/memberships/%v&quot;, team, user)
</a><a href="#h33-0-369" id="h33-0-369" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, opt)
</a><a href="#h33-0-370" id="h33-0-370" class="i">+	if err != nil {
</a><a href="#h33-0-371" id="h33-0-371" class="i">+		return nil, nil, err
</a><a href="#h33-0-372" id="h33-0-372" class="i">+	}
</a><a href="#h33-0-373" id="h33-0-373" class="i">+
</a><a href="#h33-0-374" id="h33-0-374" class="i">+	if opt != nil {
</a><a href="#h33-0-375" id="h33-0-375" class="i">+		req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h33-0-376" id="h33-0-376" class="i">+	}
</a><a href="#h33-0-377" id="h33-0-377" class="i">+
</a><a href="#h33-0-378" id="h33-0-378" class="i">+	t := new(Membership)
</a><a href="#h33-0-379" id="h33-0-379" class="i">+	resp, err := s.client.Do(req, t)
</a><a href="#h33-0-380" id="h33-0-380" class="i">+	if err != nil {
</a><a href="#h33-0-381" id="h33-0-381" class="i">+		return nil, resp, err
</a><a href="#h33-0-382" id="h33-0-382" class="i">+	}
</a><a href="#h33-0-383" id="h33-0-383" class="i">+
</a><a href="#h33-0-384" id="h33-0-384" class="i">+	return t, resp, err
</a><a href="#h33-0-385" id="h33-0-385" class="i">+}
</a><a href="#h33-0-386" id="h33-0-386" class="i">+
</a><a href="#h33-0-387" id="h33-0-387" class="i">+// RemoveTeamMembership removes a user from a team.
</a><a href="#h33-0-388" id="h33-0-388" class="i">+//
</a><a href="#h33-0-389" id="h33-0-389" class="i">+// GitHub API docs: https://developer.github.com/v3/orgs/teams/#remove-team-membership
</a><a href="#h33-0-390" id="h33-0-390" class="i">+func (s *OrganizationsService) RemoveTeamMembership(team int, user string) (*Response, error) {
</a><a href="#h33-0-391" id="h33-0-391" class="i">+	u := fmt.Sprintf(&quot;teams/%v/memberships/%v&quot;, team, user)
</a><a href="#h33-0-392" id="h33-0-392" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h33-0-393" id="h33-0-393" class="i">+	if err != nil {
</a><a href="#h33-0-394" id="h33-0-394" class="i">+		return nil, err
</a><a href="#h33-0-395" id="h33-0-395" class="i">+	}
</a><a href="#h33-0-396" id="h33-0-396" class="i">+
</a><a href="#h33-0-397" id="h33-0-397" class="i">+	return s.client.Do(req, nil)
</a><a href="#h33-0-398" id="h33-0-398" class="i">+}
</a><b>diff --git a/<a id="h34" href="../file/vendor/github.com/google/go-github/github/pulls.go">vendor/github.com/google/go-github/github/pulls.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/pulls.go">vendor/github.com/google/go-github/github/pulls.go</a></b>
<a href="#h34-0" id="h34-0" class="h">@@ -0,0 +1,275 @@
</a><a href="#h34-0-0" id="h34-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h34-0-1" id="h34-0-1" class="i">+//
</a><a href="#h34-0-2" id="h34-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h34-0-3" id="h34-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h34-0-4" id="h34-0-4" class="i">+
</a><a href="#h34-0-5" id="h34-0-5" class="i">+package github
</a><a href="#h34-0-6" id="h34-0-6" class="i">+
</a><a href="#h34-0-7" id="h34-0-7" class="i">+import (
</a><a href="#h34-0-8" id="h34-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h34-0-9" id="h34-0-9" class="i">+	&quot;time&quot;
</a><a href="#h34-0-10" id="h34-0-10" class="i">+)
</a><a href="#h34-0-11" id="h34-0-11" class="i">+
</a><a href="#h34-0-12" id="h34-0-12" class="i">+// PullRequestsService handles communication with the pull request related
</a><a href="#h34-0-13" id="h34-0-13" class="i">+// methods of the GitHub API.
</a><a href="#h34-0-14" id="h34-0-14" class="i">+//
</a><a href="#h34-0-15" id="h34-0-15" class="i">+// GitHub API docs: http://developer.github.com/v3/pulls/
</a><a href="#h34-0-16" id="h34-0-16" class="i">+type PullRequestsService struct {
</a><a href="#h34-0-17" id="h34-0-17" class="i">+	client *Client
</a><a href="#h34-0-18" id="h34-0-18" class="i">+}
</a><a href="#h34-0-19" id="h34-0-19" class="i">+
</a><a href="#h34-0-20" id="h34-0-20" class="i">+// PullRequest represents a GitHub pull request on a repository.
</a><a href="#h34-0-21" id="h34-0-21" class="i">+type PullRequest struct {
</a><a href="#h34-0-22" id="h34-0-22" class="i">+	Number       *int       `json:&quot;number,omitempty&quot;`
</a><a href="#h34-0-23" id="h34-0-23" class="i">+	State        *string    `json:&quot;state,omitempty&quot;`
</a><a href="#h34-0-24" id="h34-0-24" class="i">+	Title        *string    `json:&quot;title,omitempty&quot;`
</a><a href="#h34-0-25" id="h34-0-25" class="i">+	Body         *string    `json:&quot;body,omitempty&quot;`
</a><a href="#h34-0-26" id="h34-0-26" class="i">+	CreatedAt    *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h34-0-27" id="h34-0-27" class="i">+	UpdatedAt    *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h34-0-28" id="h34-0-28" class="i">+	ClosedAt     *time.Time `json:&quot;closed_at,omitempty&quot;`
</a><a href="#h34-0-29" id="h34-0-29" class="i">+	MergedAt     *time.Time `json:&quot;merged_at,omitempty&quot;`
</a><a href="#h34-0-30" id="h34-0-30" class="i">+	User         *User      `json:&quot;user,omitempty&quot;`
</a><a href="#h34-0-31" id="h34-0-31" class="i">+	Merged       *bool      `json:&quot;merged,omitempty&quot;`
</a><a href="#h34-0-32" id="h34-0-32" class="i">+	Mergeable    *bool      `json:&quot;mergeable,omitempty&quot;`
</a><a href="#h34-0-33" id="h34-0-33" class="i">+	MergedBy     *User      `json:&quot;merged_by,omitempty&quot;`
</a><a href="#h34-0-34" id="h34-0-34" class="i">+	Comments     *int       `json:&quot;comments,omitempty&quot;`
</a><a href="#h34-0-35" id="h34-0-35" class="i">+	Commits      *int       `json:&quot;commits,omitempty&quot;`
</a><a href="#h34-0-36" id="h34-0-36" class="i">+	Additions    *int       `json:&quot;additions,omitempty&quot;`
</a><a href="#h34-0-37" id="h34-0-37" class="i">+	Deletions    *int       `json:&quot;deletions,omitempty&quot;`
</a><a href="#h34-0-38" id="h34-0-38" class="i">+	ChangedFiles *int       `json:&quot;changed_files,omitempty&quot;`
</a><a href="#h34-0-39" id="h34-0-39" class="i">+	URL          *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h34-0-40" id="h34-0-40" class="i">+	HTMLURL      *string    `json:&quot;html_url,omitempty&quot;`
</a><a href="#h34-0-41" id="h34-0-41" class="i">+	IssueURL     *string    `json:&quot;issue_url,omitempty&quot;`
</a><a href="#h34-0-42" id="h34-0-42" class="i">+	StatusesURL  *string    `json:&quot;statuses_url,omitempty&quot;`
</a><a href="#h34-0-43" id="h34-0-43" class="i">+	DiffURL      *string    `json:&quot;diff_url,omitempty&quot;`
</a><a href="#h34-0-44" id="h34-0-44" class="i">+	PatchURL     *string    `json:&quot;patch_url,omitempty&quot;`
</a><a href="#h34-0-45" id="h34-0-45" class="i">+
</a><a href="#h34-0-46" id="h34-0-46" class="i">+	Head *PullRequestBranch `json:&quot;head,omitempty&quot;`
</a><a href="#h34-0-47" id="h34-0-47" class="i">+	Base *PullRequestBranch `json:&quot;base,omitempty&quot;`
</a><a href="#h34-0-48" id="h34-0-48" class="i">+}
</a><a href="#h34-0-49" id="h34-0-49" class="i">+
</a><a href="#h34-0-50" id="h34-0-50" class="i">+func (p PullRequest) String() string {
</a><a href="#h34-0-51" id="h34-0-51" class="i">+	return Stringify(p)
</a><a href="#h34-0-52" id="h34-0-52" class="i">+}
</a><a href="#h34-0-53" id="h34-0-53" class="i">+
</a><a href="#h34-0-54" id="h34-0-54" class="i">+// PullRequestBranch represents a base or head branch in a GitHub pull request.
</a><a href="#h34-0-55" id="h34-0-55" class="i">+type PullRequestBranch struct {
</a><a href="#h34-0-56" id="h34-0-56" class="i">+	Label *string     `json:&quot;label,omitempty&quot;`
</a><a href="#h34-0-57" id="h34-0-57" class="i">+	Ref   *string     `json:&quot;ref,omitempty&quot;`
</a><a href="#h34-0-58" id="h34-0-58" class="i">+	SHA   *string     `json:&quot;sha,omitempty&quot;`
</a><a href="#h34-0-59" id="h34-0-59" class="i">+	Repo  *Repository `json:&quot;repo,omitempty&quot;`
</a><a href="#h34-0-60" id="h34-0-60" class="i">+	User  *User       `json:&quot;user,omitempty&quot;`
</a><a href="#h34-0-61" id="h34-0-61" class="i">+}
</a><a href="#h34-0-62" id="h34-0-62" class="i">+
</a><a href="#h34-0-63" id="h34-0-63" class="i">+// PullRequestListOptions specifies the optional parameters to the
</a><a href="#h34-0-64" id="h34-0-64" class="i">+// PullRequestsService.List method.
</a><a href="#h34-0-65" id="h34-0-65" class="i">+type PullRequestListOptions struct {
</a><a href="#h34-0-66" id="h34-0-66" class="i">+	// State filters pull requests based on their state.  Possible values are:
</a><a href="#h34-0-67" id="h34-0-67" class="i">+	// open, closed.  Default is &quot;open&quot;.
</a><a href="#h34-0-68" id="h34-0-68" class="i">+	State string `url:&quot;state,omitempty&quot;`
</a><a href="#h34-0-69" id="h34-0-69" class="i">+
</a><a href="#h34-0-70" id="h34-0-70" class="i">+	// Head filters pull requests by head user and branch name in the format of:
</a><a href="#h34-0-71" id="h34-0-71" class="i">+	// &quot;user:ref-name&quot;.
</a><a href="#h34-0-72" id="h34-0-72" class="i">+	Head string `url:&quot;head,omitempty&quot;`
</a><a href="#h34-0-73" id="h34-0-73" class="i">+
</a><a href="#h34-0-74" id="h34-0-74" class="i">+	// Base filters pull requests by base branch name.
</a><a href="#h34-0-75" id="h34-0-75" class="i">+	Base string `url:&quot;base,omitempty&quot;`
</a><a href="#h34-0-76" id="h34-0-76" class="i">+
</a><a href="#h34-0-77" id="h34-0-77" class="i">+	// Sort specifies how to sort pull requests. Possible values are: created,
</a><a href="#h34-0-78" id="h34-0-78" class="i">+	// updated, popularity, long-running. Default is &quot;created&quot;.
</a><a href="#h34-0-79" id="h34-0-79" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h34-0-80" id="h34-0-80" class="i">+
</a><a href="#h34-0-81" id="h34-0-81" class="i">+	// Direction in which to sort pull requests. Possible values are: asc, desc.
</a><a href="#h34-0-82" id="h34-0-82" class="i">+	// If Sort is &quot;created&quot; or not specified, Default is &quot;desc&quot;, otherwise Default
</a><a href="#h34-0-83" id="h34-0-83" class="i">+	// is &quot;asc&quot;
</a><a href="#h34-0-84" id="h34-0-84" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h34-0-85" id="h34-0-85" class="i">+
</a><a href="#h34-0-86" id="h34-0-86" class="i">+	ListOptions
</a><a href="#h34-0-87" id="h34-0-87" class="i">+}
</a><a href="#h34-0-88" id="h34-0-88" class="i">+
</a><a href="#h34-0-89" id="h34-0-89" class="i">+// List the pull requests for the specified repository.
</a><a href="#h34-0-90" id="h34-0-90" class="i">+//
</a><a href="#h34-0-91" id="h34-0-91" class="i">+// GitHub API docs: http://developer.github.com/v3/pulls/#list-pull-requests
</a><a href="#h34-0-92" id="h34-0-92" class="i">+func (s *PullRequestsService) List(owner string, repo string, opt *PullRequestListOptions) ([]PullRequest, *Response, error) {
</a><a href="#h34-0-93" id="h34-0-93" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls&quot;, owner, repo)
</a><a href="#h34-0-94" id="h34-0-94" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h34-0-95" id="h34-0-95" class="i">+	if err != nil {
</a><a href="#h34-0-96" id="h34-0-96" class="i">+		return nil, nil, err
</a><a href="#h34-0-97" id="h34-0-97" class="i">+	}
</a><a href="#h34-0-98" id="h34-0-98" class="i">+
</a><a href="#h34-0-99" id="h34-0-99" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h34-0-100" id="h34-0-100" class="i">+	if err != nil {
</a><a href="#h34-0-101" id="h34-0-101" class="i">+		return nil, nil, err
</a><a href="#h34-0-102" id="h34-0-102" class="i">+	}
</a><a href="#h34-0-103" id="h34-0-103" class="i">+
</a><a href="#h34-0-104" id="h34-0-104" class="i">+	pulls := new([]PullRequest)
</a><a href="#h34-0-105" id="h34-0-105" class="i">+	resp, err := s.client.Do(req, pulls)
</a><a href="#h34-0-106" id="h34-0-106" class="i">+	if err != nil {
</a><a href="#h34-0-107" id="h34-0-107" class="i">+		return nil, resp, err
</a><a href="#h34-0-108" id="h34-0-108" class="i">+	}
</a><a href="#h34-0-109" id="h34-0-109" class="i">+
</a><a href="#h34-0-110" id="h34-0-110" class="i">+	return *pulls, resp, err
</a><a href="#h34-0-111" id="h34-0-111" class="i">+}
</a><a href="#h34-0-112" id="h34-0-112" class="i">+
</a><a href="#h34-0-113" id="h34-0-113" class="i">+// Get a single pull request.
</a><a href="#h34-0-114" id="h34-0-114" class="i">+//
</a><a href="#h34-0-115" id="h34-0-115" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/#get-a-single-pull-request
</a><a href="#h34-0-116" id="h34-0-116" class="i">+func (s *PullRequestsService) Get(owner string, repo string, number int) (*PullRequest, *Response, error) {
</a><a href="#h34-0-117" id="h34-0-117" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/%d&quot;, owner, repo, number)
</a><a href="#h34-0-118" id="h34-0-118" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h34-0-119" id="h34-0-119" class="i">+	if err != nil {
</a><a href="#h34-0-120" id="h34-0-120" class="i">+		return nil, nil, err
</a><a href="#h34-0-121" id="h34-0-121" class="i">+	}
</a><a href="#h34-0-122" id="h34-0-122" class="i">+
</a><a href="#h34-0-123" id="h34-0-123" class="i">+	pull := new(PullRequest)
</a><a href="#h34-0-124" id="h34-0-124" class="i">+	resp, err := s.client.Do(req, pull)
</a><a href="#h34-0-125" id="h34-0-125" class="i">+	if err != nil {
</a><a href="#h34-0-126" id="h34-0-126" class="i">+		return nil, resp, err
</a><a href="#h34-0-127" id="h34-0-127" class="i">+	}
</a><a href="#h34-0-128" id="h34-0-128" class="i">+
</a><a href="#h34-0-129" id="h34-0-129" class="i">+	return pull, resp, err
</a><a href="#h34-0-130" id="h34-0-130" class="i">+}
</a><a href="#h34-0-131" id="h34-0-131" class="i">+
</a><a href="#h34-0-132" id="h34-0-132" class="i">+// NewPullRequest represents a new pull request to be created.
</a><a href="#h34-0-133" id="h34-0-133" class="i">+type NewPullRequest struct {
</a><a href="#h34-0-134" id="h34-0-134" class="i">+	Title *string `json:&quot;title,omitempty&quot;`
</a><a href="#h34-0-135" id="h34-0-135" class="i">+	Head  *string `json:&quot;head,omitempty&quot;`
</a><a href="#h34-0-136" id="h34-0-136" class="i">+	Base  *string `json:&quot;base,omitempty&quot;`
</a><a href="#h34-0-137" id="h34-0-137" class="i">+	Body  *string `json:&quot;body,omitempty&quot;`
</a><a href="#h34-0-138" id="h34-0-138" class="i">+	Issue *int    `json:&quot;issue,omitempty&quot;`
</a><a href="#h34-0-139" id="h34-0-139" class="i">+}
</a><a href="#h34-0-140" id="h34-0-140" class="i">+
</a><a href="#h34-0-141" id="h34-0-141" class="i">+// Create a new pull request on the specified repository.
</a><a href="#h34-0-142" id="h34-0-142" class="i">+//
</a><a href="#h34-0-143" id="h34-0-143" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/#create-a-pull-request
</a><a href="#h34-0-144" id="h34-0-144" class="i">+func (s *PullRequestsService) Create(owner string, repo string, pull *NewPullRequest) (*PullRequest, *Response, error) {
</a><a href="#h34-0-145" id="h34-0-145" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls&quot;, owner, repo)
</a><a href="#h34-0-146" id="h34-0-146" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, pull)
</a><a href="#h34-0-147" id="h34-0-147" class="i">+	if err != nil {
</a><a href="#h34-0-148" id="h34-0-148" class="i">+		return nil, nil, err
</a><a href="#h34-0-149" id="h34-0-149" class="i">+	}
</a><a href="#h34-0-150" id="h34-0-150" class="i">+
</a><a href="#h34-0-151" id="h34-0-151" class="i">+	p := new(PullRequest)
</a><a href="#h34-0-152" id="h34-0-152" class="i">+	resp, err := s.client.Do(req, p)
</a><a href="#h34-0-153" id="h34-0-153" class="i">+	if err != nil {
</a><a href="#h34-0-154" id="h34-0-154" class="i">+		return nil, resp, err
</a><a href="#h34-0-155" id="h34-0-155" class="i">+	}
</a><a href="#h34-0-156" id="h34-0-156" class="i">+
</a><a href="#h34-0-157" id="h34-0-157" class="i">+	return p, resp, err
</a><a href="#h34-0-158" id="h34-0-158" class="i">+}
</a><a href="#h34-0-159" id="h34-0-159" class="i">+
</a><a href="#h34-0-160" id="h34-0-160" class="i">+// Edit a pull request.
</a><a href="#h34-0-161" id="h34-0-161" class="i">+//
</a><a href="#h34-0-162" id="h34-0-162" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/#update-a-pull-request
</a><a href="#h34-0-163" id="h34-0-163" class="i">+func (s *PullRequestsService) Edit(owner string, repo string, number int, pull *PullRequest) (*PullRequest, *Response, error) {
</a><a href="#h34-0-164" id="h34-0-164" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/%d&quot;, owner, repo, number)
</a><a href="#h34-0-165" id="h34-0-165" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, pull)
</a><a href="#h34-0-166" id="h34-0-166" class="i">+	if err != nil {
</a><a href="#h34-0-167" id="h34-0-167" class="i">+		return nil, nil, err
</a><a href="#h34-0-168" id="h34-0-168" class="i">+	}
</a><a href="#h34-0-169" id="h34-0-169" class="i">+
</a><a href="#h34-0-170" id="h34-0-170" class="i">+	p := new(PullRequest)
</a><a href="#h34-0-171" id="h34-0-171" class="i">+	resp, err := s.client.Do(req, p)
</a><a href="#h34-0-172" id="h34-0-172" class="i">+	if err != nil {
</a><a href="#h34-0-173" id="h34-0-173" class="i">+		return nil, resp, err
</a><a href="#h34-0-174" id="h34-0-174" class="i">+	}
</a><a href="#h34-0-175" id="h34-0-175" class="i">+
</a><a href="#h34-0-176" id="h34-0-176" class="i">+	return p, resp, err
</a><a href="#h34-0-177" id="h34-0-177" class="i">+}
</a><a href="#h34-0-178" id="h34-0-178" class="i">+
</a><a href="#h34-0-179" id="h34-0-179" class="i">+// ListCommits lists the commits in a pull request.
</a><a href="#h34-0-180" id="h34-0-180" class="i">+//
</a><a href="#h34-0-181" id="h34-0-181" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
</a><a href="#h34-0-182" id="h34-0-182" class="i">+func (s *PullRequestsService) ListCommits(owner string, repo string, number int, opt *ListOptions) ([]RepositoryCommit, *Response, error) {
</a><a href="#h34-0-183" id="h34-0-183" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/%d/commits&quot;, owner, repo, number)
</a><a href="#h34-0-184" id="h34-0-184" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h34-0-185" id="h34-0-185" class="i">+	if err != nil {
</a><a href="#h34-0-186" id="h34-0-186" class="i">+		return nil, nil, err
</a><a href="#h34-0-187" id="h34-0-187" class="i">+	}
</a><a href="#h34-0-188" id="h34-0-188" class="i">+
</a><a href="#h34-0-189" id="h34-0-189" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h34-0-190" id="h34-0-190" class="i">+	if err != nil {
</a><a href="#h34-0-191" id="h34-0-191" class="i">+		return nil, nil, err
</a><a href="#h34-0-192" id="h34-0-192" class="i">+	}
</a><a href="#h34-0-193" id="h34-0-193" class="i">+
</a><a href="#h34-0-194" id="h34-0-194" class="i">+	commits := new([]RepositoryCommit)
</a><a href="#h34-0-195" id="h34-0-195" class="i">+	resp, err := s.client.Do(req, commits)
</a><a href="#h34-0-196" id="h34-0-196" class="i">+	if err != nil {
</a><a href="#h34-0-197" id="h34-0-197" class="i">+		return nil, resp, err
</a><a href="#h34-0-198" id="h34-0-198" class="i">+	}
</a><a href="#h34-0-199" id="h34-0-199" class="i">+
</a><a href="#h34-0-200" id="h34-0-200" class="i">+	return *commits, resp, err
</a><a href="#h34-0-201" id="h34-0-201" class="i">+}
</a><a href="#h34-0-202" id="h34-0-202" class="i">+
</a><a href="#h34-0-203" id="h34-0-203" class="i">+// ListFiles lists the files in a pull request.
</a><a href="#h34-0-204" id="h34-0-204" class="i">+//
</a><a href="#h34-0-205" id="h34-0-205" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/#list-pull-requests-files
</a><a href="#h34-0-206" id="h34-0-206" class="i">+func (s *PullRequestsService) ListFiles(owner string, repo string, number int, opt *ListOptions) ([]CommitFile, *Response, error) {
</a><a href="#h34-0-207" id="h34-0-207" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/%d/files&quot;, owner, repo, number)
</a><a href="#h34-0-208" id="h34-0-208" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h34-0-209" id="h34-0-209" class="i">+	if err != nil {
</a><a href="#h34-0-210" id="h34-0-210" class="i">+		return nil, nil, err
</a><a href="#h34-0-211" id="h34-0-211" class="i">+	}
</a><a href="#h34-0-212" id="h34-0-212" class="i">+
</a><a href="#h34-0-213" id="h34-0-213" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h34-0-214" id="h34-0-214" class="i">+	if err != nil {
</a><a href="#h34-0-215" id="h34-0-215" class="i">+		return nil, nil, err
</a><a href="#h34-0-216" id="h34-0-216" class="i">+	}
</a><a href="#h34-0-217" id="h34-0-217" class="i">+
</a><a href="#h34-0-218" id="h34-0-218" class="i">+	commitFiles := new([]CommitFile)
</a><a href="#h34-0-219" id="h34-0-219" class="i">+	resp, err := s.client.Do(req, commitFiles)
</a><a href="#h34-0-220" id="h34-0-220" class="i">+	if err != nil {
</a><a href="#h34-0-221" id="h34-0-221" class="i">+		return nil, resp, err
</a><a href="#h34-0-222" id="h34-0-222" class="i">+	}
</a><a href="#h34-0-223" id="h34-0-223" class="i">+
</a><a href="#h34-0-224" id="h34-0-224" class="i">+	return *commitFiles, resp, err
</a><a href="#h34-0-225" id="h34-0-225" class="i">+}
</a><a href="#h34-0-226" id="h34-0-226" class="i">+
</a><a href="#h34-0-227" id="h34-0-227" class="i">+// IsMerged checks if a pull request has been merged.
</a><a href="#h34-0-228" id="h34-0-228" class="i">+//
</a><a href="#h34-0-229" id="h34-0-229" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/#get-if-a-pull-request-has-been-merged
</a><a href="#h34-0-230" id="h34-0-230" class="i">+func (s *PullRequestsService) IsMerged(owner string, repo string, number int) (bool, *Response, error) {
</a><a href="#h34-0-231" id="h34-0-231" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/%d/merge&quot;, owner, repo, number)
</a><a href="#h34-0-232" id="h34-0-232" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h34-0-233" id="h34-0-233" class="i">+	if err != nil {
</a><a href="#h34-0-234" id="h34-0-234" class="i">+		return false, nil, err
</a><a href="#h34-0-235" id="h34-0-235" class="i">+	}
</a><a href="#h34-0-236" id="h34-0-236" class="i">+
</a><a href="#h34-0-237" id="h34-0-237" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h34-0-238" id="h34-0-238" class="i">+	merged, err := parseBoolResponse(err)
</a><a href="#h34-0-239" id="h34-0-239" class="i">+	return merged, resp, err
</a><a href="#h34-0-240" id="h34-0-240" class="i">+}
</a><a href="#h34-0-241" id="h34-0-241" class="i">+
</a><a href="#h34-0-242" id="h34-0-242" class="i">+// PullRequestMergeResult represents the result of merging a pull request.
</a><a href="#h34-0-243" id="h34-0-243" class="i">+type PullRequestMergeResult struct {
</a><a href="#h34-0-244" id="h34-0-244" class="i">+	SHA     *string `json:&quot;sha,omitempty&quot;`
</a><a href="#h34-0-245" id="h34-0-245" class="i">+	Merged  *bool   `json:&quot;merged,omitempty&quot;`
</a><a href="#h34-0-246" id="h34-0-246" class="i">+	Message *string `json:&quot;message,omitempty&quot;`
</a><a href="#h34-0-247" id="h34-0-247" class="i">+}
</a><a href="#h34-0-248" id="h34-0-248" class="i">+
</a><a href="#h34-0-249" id="h34-0-249" class="i">+type pullRequestMergeRequest struct {
</a><a href="#h34-0-250" id="h34-0-250" class="i">+	CommitMessage *string `json:&quot;commit_message&quot;`
</a><a href="#h34-0-251" id="h34-0-251" class="i">+}
</a><a href="#h34-0-252" id="h34-0-252" class="i">+
</a><a href="#h34-0-253" id="h34-0-253" class="i">+// Merge a pull request (Merge Button).
</a><a href="#h34-0-254" id="h34-0-254" class="i">+//
</a><a href="#h34-0-255" id="h34-0-255" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-buttontrade
</a><a href="#h34-0-256" id="h34-0-256" class="i">+func (s *PullRequestsService) Merge(owner string, repo string, number int, commitMessage string) (*PullRequestMergeResult, *Response, error) {
</a><a href="#h34-0-257" id="h34-0-257" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/%d/merge&quot;, owner, repo, number)
</a><a href="#h34-0-258" id="h34-0-258" class="i">+
</a><a href="#h34-0-259" id="h34-0-259" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, &amp;pullRequestMergeRequest{
</a><a href="#h34-0-260" id="h34-0-260" class="i">+		CommitMessage: &amp;commitMessage,
</a><a href="#h34-0-261" id="h34-0-261" class="i">+	})
</a><a href="#h34-0-262" id="h34-0-262" class="i">+
</a><a href="#h34-0-263" id="h34-0-263" class="i">+	if err != nil {
</a><a href="#h34-0-264" id="h34-0-264" class="i">+		return nil, nil, err
</a><a href="#h34-0-265" id="h34-0-265" class="i">+	}
</a><a href="#h34-0-266" id="h34-0-266" class="i">+
</a><a href="#h34-0-267" id="h34-0-267" class="i">+	mergeResult := new(PullRequestMergeResult)
</a><a href="#h34-0-268" id="h34-0-268" class="i">+	resp, err := s.client.Do(req, mergeResult)
</a><a href="#h34-0-269" id="h34-0-269" class="i">+	if err != nil {
</a><a href="#h34-0-270" id="h34-0-270" class="i">+		return nil, resp, err
</a><a href="#h34-0-271" id="h34-0-271" class="i">+	}
</a><a href="#h34-0-272" id="h34-0-272" class="i">+
</a><a href="#h34-0-273" id="h34-0-273" class="i">+	return mergeResult, resp, err
</a><a href="#h34-0-274" id="h34-0-274" class="i">+}
</a><b>diff --git a/<a id="h35" href="../file/vendor/github.com/google/go-github/github/pulls_comments.go">vendor/github.com/google/go-github/github/pulls_comments.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/pulls_comments.go">vendor/github.com/google/go-github/github/pulls_comments.go</a></b>
<a href="#h35-0" id="h35-0" class="h">@@ -0,0 +1,149 @@
</a><a href="#h35-0-0" id="h35-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h35-0-1" id="h35-0-1" class="i">+//
</a><a href="#h35-0-2" id="h35-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h35-0-3" id="h35-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h35-0-4" id="h35-0-4" class="i">+
</a><a href="#h35-0-5" id="h35-0-5" class="i">+package github
</a><a href="#h35-0-6" id="h35-0-6" class="i">+
</a><a href="#h35-0-7" id="h35-0-7" class="i">+import (
</a><a href="#h35-0-8" id="h35-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h35-0-9" id="h35-0-9" class="i">+	&quot;time&quot;
</a><a href="#h35-0-10" id="h35-0-10" class="i">+)
</a><a href="#h35-0-11" id="h35-0-11" class="i">+
</a><a href="#h35-0-12" id="h35-0-12" class="i">+// PullRequestComment represents a comment left on a pull request.
</a><a href="#h35-0-13" id="h35-0-13" class="i">+type PullRequestComment struct {
</a><a href="#h35-0-14" id="h35-0-14" class="i">+	ID               *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h35-0-15" id="h35-0-15" class="i">+	InReplyTo        *int       `json:&quot;in_reply_to,omitempty&quot;`
</a><a href="#h35-0-16" id="h35-0-16" class="i">+	Body             *string    `json:&quot;body,omitempty&quot;`
</a><a href="#h35-0-17" id="h35-0-17" class="i">+	Path             *string    `json:&quot;path,omitempty&quot;`
</a><a href="#h35-0-18" id="h35-0-18" class="i">+	DiffHunk         *string    `json:&quot;diff_hunk,omitempty&quot;`
</a><a href="#h35-0-19" id="h35-0-19" class="i">+	Position         *int       `json:&quot;position,omitempty&quot;`
</a><a href="#h35-0-20" id="h35-0-20" class="i">+	OriginalPosition *int       `json:&quot;original_position,omitempty&quot;`
</a><a href="#h35-0-21" id="h35-0-21" class="i">+	CommitID         *string    `json:&quot;commit_id,omitempty&quot;`
</a><a href="#h35-0-22" id="h35-0-22" class="i">+	OriginalCommitID *string    `json:&quot;original_commit_id,omitempty&quot;`
</a><a href="#h35-0-23" id="h35-0-23" class="i">+	User             *User      `json:&quot;user,omitempty&quot;`
</a><a href="#h35-0-24" id="h35-0-24" class="i">+	CreatedAt        *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h35-0-25" id="h35-0-25" class="i">+	UpdatedAt        *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h35-0-26" id="h35-0-26" class="i">+	URL              *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h35-0-27" id="h35-0-27" class="i">+	HTMLURL          *string    `json:&quot;html_url,omitempty&quot;`
</a><a href="#h35-0-28" id="h35-0-28" class="i">+	PullRequestURL   *string    `json:&quot;pull_request_url,omitempty&quot;`
</a><a href="#h35-0-29" id="h35-0-29" class="i">+}
</a><a href="#h35-0-30" id="h35-0-30" class="i">+
</a><a href="#h35-0-31" id="h35-0-31" class="i">+func (p PullRequestComment) String() string {
</a><a href="#h35-0-32" id="h35-0-32" class="i">+	return Stringify(p)
</a><a href="#h35-0-33" id="h35-0-33" class="i">+}
</a><a href="#h35-0-34" id="h35-0-34" class="i">+
</a><a href="#h35-0-35" id="h35-0-35" class="i">+// PullRequestListCommentsOptions specifies the optional parameters to the
</a><a href="#h35-0-36" id="h35-0-36" class="i">+// PullRequestsService.ListComments method.
</a><a href="#h35-0-37" id="h35-0-37" class="i">+type PullRequestListCommentsOptions struct {
</a><a href="#h35-0-38" id="h35-0-38" class="i">+	// Sort specifies how to sort comments.  Possible values are: created, updated.
</a><a href="#h35-0-39" id="h35-0-39" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h35-0-40" id="h35-0-40" class="i">+
</a><a href="#h35-0-41" id="h35-0-41" class="i">+	// Direction in which to sort comments.  Possible values are: asc, desc.
</a><a href="#h35-0-42" id="h35-0-42" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h35-0-43" id="h35-0-43" class="i">+
</a><a href="#h35-0-44" id="h35-0-44" class="i">+	// Since filters comments by time.
</a><a href="#h35-0-45" id="h35-0-45" class="i">+	Since time.Time `url:&quot;since,omitempty&quot;`
</a><a href="#h35-0-46" id="h35-0-46" class="i">+
</a><a href="#h35-0-47" id="h35-0-47" class="i">+	ListOptions
</a><a href="#h35-0-48" id="h35-0-48" class="i">+}
</a><a href="#h35-0-49" id="h35-0-49" class="i">+
</a><a href="#h35-0-50" id="h35-0-50" class="i">+// ListComments lists all comments on the specified pull request.  Specifying a
</a><a href="#h35-0-51" id="h35-0-51" class="i">+// pull request number of 0 will return all comments on all pull requests for
</a><a href="#h35-0-52" id="h35-0-52" class="i">+// the repository.
</a><a href="#h35-0-53" id="h35-0-53" class="i">+//
</a><a href="#h35-0-54" id="h35-0-54" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/comments/#list-comments-on-a-pull-request
</a><a href="#h35-0-55" id="h35-0-55" class="i">+func (s *PullRequestsService) ListComments(owner string, repo string, number int, opt *PullRequestListCommentsOptions) ([]PullRequestComment, *Response, error) {
</a><a href="#h35-0-56" id="h35-0-56" class="i">+	var u string
</a><a href="#h35-0-57" id="h35-0-57" class="i">+	if number == 0 {
</a><a href="#h35-0-58" id="h35-0-58" class="i">+		u = fmt.Sprintf(&quot;repos/%v/%v/pulls/comments&quot;, owner, repo)
</a><a href="#h35-0-59" id="h35-0-59" class="i">+	} else {
</a><a href="#h35-0-60" id="h35-0-60" class="i">+		u = fmt.Sprintf(&quot;repos/%v/%v/pulls/%d/comments&quot;, owner, repo, number)
</a><a href="#h35-0-61" id="h35-0-61" class="i">+	}
</a><a href="#h35-0-62" id="h35-0-62" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h35-0-63" id="h35-0-63" class="i">+	if err != nil {
</a><a href="#h35-0-64" id="h35-0-64" class="i">+		return nil, nil, err
</a><a href="#h35-0-65" id="h35-0-65" class="i">+	}
</a><a href="#h35-0-66" id="h35-0-66" class="i">+
</a><a href="#h35-0-67" id="h35-0-67" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h35-0-68" id="h35-0-68" class="i">+	if err != nil {
</a><a href="#h35-0-69" id="h35-0-69" class="i">+		return nil, nil, err
</a><a href="#h35-0-70" id="h35-0-70" class="i">+	}
</a><a href="#h35-0-71" id="h35-0-71" class="i">+
</a><a href="#h35-0-72" id="h35-0-72" class="i">+	comments := new([]PullRequestComment)
</a><a href="#h35-0-73" id="h35-0-73" class="i">+	resp, err := s.client.Do(req, comments)
</a><a href="#h35-0-74" id="h35-0-74" class="i">+	if err != nil {
</a><a href="#h35-0-75" id="h35-0-75" class="i">+		return nil, resp, err
</a><a href="#h35-0-76" id="h35-0-76" class="i">+	}
</a><a href="#h35-0-77" id="h35-0-77" class="i">+
</a><a href="#h35-0-78" id="h35-0-78" class="i">+	return *comments, resp, err
</a><a href="#h35-0-79" id="h35-0-79" class="i">+}
</a><a href="#h35-0-80" id="h35-0-80" class="i">+
</a><a href="#h35-0-81" id="h35-0-81" class="i">+// GetComment fetches the specified pull request comment.
</a><a href="#h35-0-82" id="h35-0-82" class="i">+//
</a><a href="#h35-0-83" id="h35-0-83" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/comments/#get-a-single-comment
</a><a href="#h35-0-84" id="h35-0-84" class="i">+func (s *PullRequestsService) GetComment(owner string, repo string, number int) (*PullRequestComment, *Response, error) {
</a><a href="#h35-0-85" id="h35-0-85" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/comments/%d&quot;, owner, repo, number)
</a><a href="#h35-0-86" id="h35-0-86" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h35-0-87" id="h35-0-87" class="i">+	if err != nil {
</a><a href="#h35-0-88" id="h35-0-88" class="i">+		return nil, nil, err
</a><a href="#h35-0-89" id="h35-0-89" class="i">+	}
</a><a href="#h35-0-90" id="h35-0-90" class="i">+
</a><a href="#h35-0-91" id="h35-0-91" class="i">+	comment := new(PullRequestComment)
</a><a href="#h35-0-92" id="h35-0-92" class="i">+	resp, err := s.client.Do(req, comment)
</a><a href="#h35-0-93" id="h35-0-93" class="i">+	if err != nil {
</a><a href="#h35-0-94" id="h35-0-94" class="i">+		return nil, resp, err
</a><a href="#h35-0-95" id="h35-0-95" class="i">+	}
</a><a href="#h35-0-96" id="h35-0-96" class="i">+
</a><a href="#h35-0-97" id="h35-0-97" class="i">+	return comment, resp, err
</a><a href="#h35-0-98" id="h35-0-98" class="i">+}
</a><a href="#h35-0-99" id="h35-0-99" class="i">+
</a><a href="#h35-0-100" id="h35-0-100" class="i">+// CreateComment creates a new comment on the specified pull request.
</a><a href="#h35-0-101" id="h35-0-101" class="i">+//
</a><a href="#h35-0-102" id="h35-0-102" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/comments/#create-a-comment
</a><a href="#h35-0-103" id="h35-0-103" class="i">+func (s *PullRequestsService) CreateComment(owner string, repo string, number int, comment *PullRequestComment) (*PullRequestComment, *Response, error) {
</a><a href="#h35-0-104" id="h35-0-104" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/%d/comments&quot;, owner, repo, number)
</a><a href="#h35-0-105" id="h35-0-105" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, comment)
</a><a href="#h35-0-106" id="h35-0-106" class="i">+	if err != nil {
</a><a href="#h35-0-107" id="h35-0-107" class="i">+		return nil, nil, err
</a><a href="#h35-0-108" id="h35-0-108" class="i">+	}
</a><a href="#h35-0-109" id="h35-0-109" class="i">+
</a><a href="#h35-0-110" id="h35-0-110" class="i">+	c := new(PullRequestComment)
</a><a href="#h35-0-111" id="h35-0-111" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h35-0-112" id="h35-0-112" class="i">+	if err != nil {
</a><a href="#h35-0-113" id="h35-0-113" class="i">+		return nil, resp, err
</a><a href="#h35-0-114" id="h35-0-114" class="i">+	}
</a><a href="#h35-0-115" id="h35-0-115" class="i">+
</a><a href="#h35-0-116" id="h35-0-116" class="i">+	return c, resp, err
</a><a href="#h35-0-117" id="h35-0-117" class="i">+}
</a><a href="#h35-0-118" id="h35-0-118" class="i">+
</a><a href="#h35-0-119" id="h35-0-119" class="i">+// EditComment updates a pull request comment.
</a><a href="#h35-0-120" id="h35-0-120" class="i">+//
</a><a href="#h35-0-121" id="h35-0-121" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/comments/#edit-a-comment
</a><a href="#h35-0-122" id="h35-0-122" class="i">+func (s *PullRequestsService) EditComment(owner string, repo string, number int, comment *PullRequestComment) (*PullRequestComment, *Response, error) {
</a><a href="#h35-0-123" id="h35-0-123" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/comments/%d&quot;, owner, repo, number)
</a><a href="#h35-0-124" id="h35-0-124" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, comment)
</a><a href="#h35-0-125" id="h35-0-125" class="i">+	if err != nil {
</a><a href="#h35-0-126" id="h35-0-126" class="i">+		return nil, nil, err
</a><a href="#h35-0-127" id="h35-0-127" class="i">+	}
</a><a href="#h35-0-128" id="h35-0-128" class="i">+
</a><a href="#h35-0-129" id="h35-0-129" class="i">+	c := new(PullRequestComment)
</a><a href="#h35-0-130" id="h35-0-130" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h35-0-131" id="h35-0-131" class="i">+	if err != nil {
</a><a href="#h35-0-132" id="h35-0-132" class="i">+		return nil, resp, err
</a><a href="#h35-0-133" id="h35-0-133" class="i">+	}
</a><a href="#h35-0-134" id="h35-0-134" class="i">+
</a><a href="#h35-0-135" id="h35-0-135" class="i">+	return c, resp, err
</a><a href="#h35-0-136" id="h35-0-136" class="i">+}
</a><a href="#h35-0-137" id="h35-0-137" class="i">+
</a><a href="#h35-0-138" id="h35-0-138" class="i">+// DeleteComment deletes a pull request comment.
</a><a href="#h35-0-139" id="h35-0-139" class="i">+//
</a><a href="#h35-0-140" id="h35-0-140" class="i">+// GitHub API docs: https://developer.github.com/v3/pulls/comments/#delete-a-comment
</a><a href="#h35-0-141" id="h35-0-141" class="i">+func (s *PullRequestsService) DeleteComment(owner string, repo string, number int) (*Response, error) {
</a><a href="#h35-0-142" id="h35-0-142" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pulls/comments/%d&quot;, owner, repo, number)
</a><a href="#h35-0-143" id="h35-0-143" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h35-0-144" id="h35-0-144" class="i">+	if err != nil {
</a><a href="#h35-0-145" id="h35-0-145" class="i">+		return nil, err
</a><a href="#h35-0-146" id="h35-0-146" class="i">+	}
</a><a href="#h35-0-147" id="h35-0-147" class="i">+	return s.client.Do(req, nil)
</a><a href="#h35-0-148" id="h35-0-148" class="i">+}
</a><b>diff --git a/<a id="h36" href="../file/vendor/github.com/google/go-github/github/repos.go">vendor/github.com/google/go-github/github/repos.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos.go">vendor/github.com/google/go-github/github/repos.go</a></b>
<a href="#h36-0" id="h36-0" class="h">@@ -0,0 +1,559 @@
</a><a href="#h36-0-0" id="h36-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h36-0-1" id="h36-0-1" class="i">+//
</a><a href="#h36-0-2" id="h36-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h36-0-3" id="h36-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h36-0-4" id="h36-0-4" class="i">+
</a><a href="#h36-0-5" id="h36-0-5" class="i">+package github
</a><a href="#h36-0-6" id="h36-0-6" class="i">+
</a><a href="#h36-0-7" id="h36-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h36-0-8" id="h36-0-8" class="i">+
</a><a href="#h36-0-9" id="h36-0-9" class="i">+// RepositoriesService handles communication with the repository related
</a><a href="#h36-0-10" id="h36-0-10" class="i">+// methods of the GitHub API.
</a><a href="#h36-0-11" id="h36-0-11" class="i">+//
</a><a href="#h36-0-12" id="h36-0-12" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/
</a><a href="#h36-0-13" id="h36-0-13" class="i">+type RepositoriesService struct {
</a><a href="#h36-0-14" id="h36-0-14" class="i">+	client *Client
</a><a href="#h36-0-15" id="h36-0-15" class="i">+}
</a><a href="#h36-0-16" id="h36-0-16" class="i">+
</a><a href="#h36-0-17" id="h36-0-17" class="i">+// Repository represents a GitHub repository.
</a><a href="#h36-0-18" id="h36-0-18" class="i">+type Repository struct {
</a><a href="#h36-0-19" id="h36-0-19" class="i">+	ID               *int             `json:&quot;id,omitempty&quot;`
</a><a href="#h36-0-20" id="h36-0-20" class="i">+	Owner            *User            `json:&quot;owner,omitempty&quot;`
</a><a href="#h36-0-21" id="h36-0-21" class="i">+	Name             *string          `json:&quot;name,omitempty&quot;`
</a><a href="#h36-0-22" id="h36-0-22" class="i">+	FullName         *string          `json:&quot;full_name,omitempty&quot;`
</a><a href="#h36-0-23" id="h36-0-23" class="i">+	Description      *string          `json:&quot;description,omitempty&quot;`
</a><a href="#h36-0-24" id="h36-0-24" class="i">+	Homepage         *string          `json:&quot;homepage,omitempty&quot;`
</a><a href="#h36-0-25" id="h36-0-25" class="i">+	DefaultBranch    *string          `json:&quot;default_branch,omitempty&quot;`
</a><a href="#h36-0-26" id="h36-0-26" class="i">+	MasterBranch     *string          `json:&quot;master_branch,omitempty&quot;`
</a><a href="#h36-0-27" id="h36-0-27" class="i">+	CreatedAt        *Timestamp       `json:&quot;created_at,omitempty&quot;`
</a><a href="#h36-0-28" id="h36-0-28" class="i">+	PushedAt         *Timestamp       `json:&quot;pushed_at,omitempty&quot;`
</a><a href="#h36-0-29" id="h36-0-29" class="i">+	UpdatedAt        *Timestamp       `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h36-0-30" id="h36-0-30" class="i">+	HTMLURL          *string          `json:&quot;html_url,omitempty&quot;`
</a><a href="#h36-0-31" id="h36-0-31" class="i">+	CloneURL         *string          `json:&quot;clone_url,omitempty&quot;`
</a><a href="#h36-0-32" id="h36-0-32" class="i">+	GitURL           *string          `json:&quot;git_url,omitempty&quot;`
</a><a href="#h36-0-33" id="h36-0-33" class="i">+	MirrorURL        *string          `json:&quot;mirror_url,omitempty&quot;`
</a><a href="#h36-0-34" id="h36-0-34" class="i">+	SSHURL           *string          `json:&quot;ssh_url,omitempty&quot;`
</a><a href="#h36-0-35" id="h36-0-35" class="i">+	SVNURL           *string          `json:&quot;svn_url,omitempty&quot;`
</a><a href="#h36-0-36" id="h36-0-36" class="i">+	Language         *string          `json:&quot;language,omitempty&quot;`
</a><a href="#h36-0-37" id="h36-0-37" class="i">+	Fork             *bool            `json:&quot;fork&quot;`
</a><a href="#h36-0-38" id="h36-0-38" class="i">+	ForksCount       *int             `json:&quot;forks_count,omitempty&quot;`
</a><a href="#h36-0-39" id="h36-0-39" class="i">+	NetworkCount     *int             `json:&quot;network_count,omitempty&quot;`
</a><a href="#h36-0-40" id="h36-0-40" class="i">+	OpenIssuesCount  *int             `json:&quot;open_issues_count,omitempty&quot;`
</a><a href="#h36-0-41" id="h36-0-41" class="i">+	StargazersCount  *int             `json:&quot;stargazers_count,omitempty&quot;`
</a><a href="#h36-0-42" id="h36-0-42" class="i">+	SubscribersCount *int             `json:&quot;subscribers_count,omitempty&quot;`
</a><a href="#h36-0-43" id="h36-0-43" class="i">+	WatchersCount    *int             `json:&quot;watchers_count,omitempty&quot;`
</a><a href="#h36-0-44" id="h36-0-44" class="i">+	Size             *int             `json:&quot;size,omitempty&quot;`
</a><a href="#h36-0-45" id="h36-0-45" class="i">+	AutoInit         *bool            `json:&quot;auto_init,omitempty&quot;`
</a><a href="#h36-0-46" id="h36-0-46" class="i">+	Parent           *Repository      `json:&quot;parent,omitempty&quot;`
</a><a href="#h36-0-47" id="h36-0-47" class="i">+	Source           *Repository      `json:&quot;source,omitempty&quot;`
</a><a href="#h36-0-48" id="h36-0-48" class="i">+	Organization     *Organization    `json:&quot;organization,omitempty&quot;`
</a><a href="#h36-0-49" id="h36-0-49" class="i">+	Permissions      *map[string]bool `json:&quot;permissions,omitempty&quot;`
</a><a href="#h36-0-50" id="h36-0-50" class="i">+
</a><a href="#h36-0-51" id="h36-0-51" class="i">+	// Only provided when using RepositoriesService.Get while in preview
</a><a href="#h36-0-52" id="h36-0-52" class="i">+	License *License `json:&quot;license,omitempty&quot;`
</a><a href="#h36-0-53" id="h36-0-53" class="i">+
</a><a href="#h36-0-54" id="h36-0-54" class="i">+	// Additional mutable fields when creating and editing a repository
</a><a href="#h36-0-55" id="h36-0-55" class="i">+	Private      *bool `json:&quot;private&quot;`
</a><a href="#h36-0-56" id="h36-0-56" class="i">+	HasIssues    *bool `json:&quot;has_issues&quot;`
</a><a href="#h36-0-57" id="h36-0-57" class="i">+	HasWiki      *bool `json:&quot;has_wiki&quot;`
</a><a href="#h36-0-58" id="h36-0-58" class="i">+	HasDownloads *bool `json:&quot;has_downloads&quot;`
</a><a href="#h36-0-59" id="h36-0-59" class="i">+	// Creating an organization repository. Required for non-owners.
</a><a href="#h36-0-60" id="h36-0-60" class="i">+	TeamID *int `json:&quot;team_id&quot;`
</a><a href="#h36-0-61" id="h36-0-61" class="i">+
</a><a href="#h36-0-62" id="h36-0-62" class="i">+	// API URLs
</a><a href="#h36-0-63" id="h36-0-63" class="i">+	URL              *string `json:&quot;url,omitempty&quot;`
</a><a href="#h36-0-64" id="h36-0-64" class="i">+	ArchiveURL       *string `json:&quot;archive_url,omitempty&quot;`
</a><a href="#h36-0-65" id="h36-0-65" class="i">+	AssigneesURL     *string `json:&quot;assignees_url,omitempty&quot;`
</a><a href="#h36-0-66" id="h36-0-66" class="i">+	BlobsURL         *string `json:&quot;blobs_url,omitempty&quot;`
</a><a href="#h36-0-67" id="h36-0-67" class="i">+	BranchesURL      *string `json:&quot;branches_url,omitempty&quot;`
</a><a href="#h36-0-68" id="h36-0-68" class="i">+	CollaboratorsURL *string `json:&quot;collaborators_url,omitempty&quot;`
</a><a href="#h36-0-69" id="h36-0-69" class="i">+	CommentsURL      *string `json:&quot;comments_url,omitempty&quot;`
</a><a href="#h36-0-70" id="h36-0-70" class="i">+	CommitsURL       *string `json:&quot;commits_url,omitempty&quot;`
</a><a href="#h36-0-71" id="h36-0-71" class="i">+	CompareURL       *string `json:&quot;compare_url,omitempty&quot;`
</a><a href="#h36-0-72" id="h36-0-72" class="i">+	ContentsURL      *string `json:&quot;contents_url,omitempty&quot;`
</a><a href="#h36-0-73" id="h36-0-73" class="i">+	ContributorsURL  *string `json:&quot;contributors_url,omitempty&quot;`
</a><a href="#h36-0-74" id="h36-0-74" class="i">+	DownloadsURL     *string `json:&quot;downloads_url,omitempty&quot;`
</a><a href="#h36-0-75" id="h36-0-75" class="i">+	EventsURL        *string `json:&quot;events_url,omitempty&quot;`
</a><a href="#h36-0-76" id="h36-0-76" class="i">+	ForksURL         *string `json:&quot;forks_url,omitempty&quot;`
</a><a href="#h36-0-77" id="h36-0-77" class="i">+	GitCommitsURL    *string `json:&quot;git_commits_url,omitempty&quot;`
</a><a href="#h36-0-78" id="h36-0-78" class="i">+	GitRefsURL       *string `json:&quot;git_refs_url,omitempty&quot;`
</a><a href="#h36-0-79" id="h36-0-79" class="i">+	GitTagsURL       *string `json:&quot;git_tags_url,omitempty&quot;`
</a><a href="#h36-0-80" id="h36-0-80" class="i">+	HooksURL         *string `json:&quot;hooks_url,omitempty&quot;`
</a><a href="#h36-0-81" id="h36-0-81" class="i">+	IssueCommentURL  *string `json:&quot;issue_comment_url,omitempty&quot;`
</a><a href="#h36-0-82" id="h36-0-82" class="i">+	IssueEventsURL   *string `json:&quot;issue_events_url,omitempty&quot;`
</a><a href="#h36-0-83" id="h36-0-83" class="i">+	IssuesURL        *string `json:&quot;issues_url,omitempty&quot;`
</a><a href="#h36-0-84" id="h36-0-84" class="i">+	KeysURL          *string `json:&quot;keys_url,omitempty&quot;`
</a><a href="#h36-0-85" id="h36-0-85" class="i">+	LabelsURL        *string `json:&quot;labels_url,omitempty&quot;`
</a><a href="#h36-0-86" id="h36-0-86" class="i">+	LanguagesURL     *string `json:&quot;languages_url,omitempty&quot;`
</a><a href="#h36-0-87" id="h36-0-87" class="i">+	MergesURL        *string `json:&quot;merges_url,omitempty&quot;`
</a><a href="#h36-0-88" id="h36-0-88" class="i">+	MilestonesURL    *string `json:&quot;milestones_url,omitempty&quot;`
</a><a href="#h36-0-89" id="h36-0-89" class="i">+	NotificationsURL *string `json:&quot;notifications_url,omitempty&quot;`
</a><a href="#h36-0-90" id="h36-0-90" class="i">+	PullsURL         *string `json:&quot;pulls_url,omitempty&quot;`
</a><a href="#h36-0-91" id="h36-0-91" class="i">+	ReleasesURL      *string `json:&quot;releases_url,omitempty&quot;`
</a><a href="#h36-0-92" id="h36-0-92" class="i">+	StargazersURL    *string `json:&quot;stargazers_url,omitempty&quot;`
</a><a href="#h36-0-93" id="h36-0-93" class="i">+	StatusesURL      *string `json:&quot;statuses_url,omitempty&quot;`
</a><a href="#h36-0-94" id="h36-0-94" class="i">+	SubscribersURL   *string `json:&quot;subscribers_url,omitempty&quot;`
</a><a href="#h36-0-95" id="h36-0-95" class="i">+	SubscriptionURL  *string `json:&quot;subscription_url,omitempty&quot;`
</a><a href="#h36-0-96" id="h36-0-96" class="i">+	TagsURL          *string `json:&quot;tags_url,omitempty&quot;`
</a><a href="#h36-0-97" id="h36-0-97" class="i">+	TreesURL         *string `json:&quot;trees_url,omitempty&quot;`
</a><a href="#h36-0-98" id="h36-0-98" class="i">+	TeamsURL         *string `json:&quot;teams_url,omitempty&quot;`
</a><a href="#h36-0-99" id="h36-0-99" class="i">+
</a><a href="#h36-0-100" id="h36-0-100" class="i">+	// TextMatches is only populated from search results that request text matches
</a><a href="#h36-0-101" id="h36-0-101" class="i">+	// See: search.go and https://developer.github.com/v3/search/#text-match-metadata
</a><a href="#h36-0-102" id="h36-0-102" class="i">+	TextMatches []TextMatch `json:&quot;text_matches,omitempty&quot;`
</a><a href="#h36-0-103" id="h36-0-103" class="i">+}
</a><a href="#h36-0-104" id="h36-0-104" class="i">+
</a><a href="#h36-0-105" id="h36-0-105" class="i">+func (r Repository) String() string {
</a><a href="#h36-0-106" id="h36-0-106" class="i">+	return Stringify(r)
</a><a href="#h36-0-107" id="h36-0-107" class="i">+}
</a><a href="#h36-0-108" id="h36-0-108" class="i">+
</a><a href="#h36-0-109" id="h36-0-109" class="i">+// RepositoryListOptions specifies the optional parameters to the
</a><a href="#h36-0-110" id="h36-0-110" class="i">+// RepositoriesService.List method.
</a><a href="#h36-0-111" id="h36-0-111" class="i">+type RepositoryListOptions struct {
</a><a href="#h36-0-112" id="h36-0-112" class="i">+	// Type of repositories to list.  Possible values are: all, owner, public,
</a><a href="#h36-0-113" id="h36-0-113" class="i">+	// private, member.  Default is &quot;all&quot;.
</a><a href="#h36-0-114" id="h36-0-114" class="i">+	Type string `url:&quot;type,omitempty&quot;`
</a><a href="#h36-0-115" id="h36-0-115" class="i">+
</a><a href="#h36-0-116" id="h36-0-116" class="i">+	// How to sort the repository list.  Possible values are: created, updated,
</a><a href="#h36-0-117" id="h36-0-117" class="i">+	// pushed, full_name.  Default is &quot;full_name&quot;.
</a><a href="#h36-0-118" id="h36-0-118" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h36-0-119" id="h36-0-119" class="i">+
</a><a href="#h36-0-120" id="h36-0-120" class="i">+	// Direction in which to sort repositories.  Possible values are: asc, desc.
</a><a href="#h36-0-121" id="h36-0-121" class="i">+	// Default is &quot;asc&quot; when sort is &quot;full_name&quot;, otherwise default is &quot;desc&quot;.
</a><a href="#h36-0-122" id="h36-0-122" class="i">+	Direction string `url:&quot;direction,omitempty&quot;`
</a><a href="#h36-0-123" id="h36-0-123" class="i">+
</a><a href="#h36-0-124" id="h36-0-124" class="i">+	ListOptions
</a><a href="#h36-0-125" id="h36-0-125" class="i">+}
</a><a href="#h36-0-126" id="h36-0-126" class="i">+
</a><a href="#h36-0-127" id="h36-0-127" class="i">+// List the repositories for a user.  Passing the empty string will list
</a><a href="#h36-0-128" id="h36-0-128" class="i">+// repositories for the authenticated user.
</a><a href="#h36-0-129" id="h36-0-129" class="i">+//
</a><a href="#h36-0-130" id="h36-0-130" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#list-user-repositories
</a><a href="#h36-0-131" id="h36-0-131" class="i">+func (s *RepositoriesService) List(user string, opt *RepositoryListOptions) ([]Repository, *Response, error) {
</a><a href="#h36-0-132" id="h36-0-132" class="i">+	var u string
</a><a href="#h36-0-133" id="h36-0-133" class="i">+	if user != &quot;&quot; {
</a><a href="#h36-0-134" id="h36-0-134" class="i">+		u = fmt.Sprintf(&quot;users/%v/repos&quot;, user)
</a><a href="#h36-0-135" id="h36-0-135" class="i">+	} else {
</a><a href="#h36-0-136" id="h36-0-136" class="i">+		u = &quot;user/repos&quot;
</a><a href="#h36-0-137" id="h36-0-137" class="i">+	}
</a><a href="#h36-0-138" id="h36-0-138" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h36-0-139" id="h36-0-139" class="i">+	if err != nil {
</a><a href="#h36-0-140" id="h36-0-140" class="i">+		return nil, nil, err
</a><a href="#h36-0-141" id="h36-0-141" class="i">+	}
</a><a href="#h36-0-142" id="h36-0-142" class="i">+
</a><a href="#h36-0-143" id="h36-0-143" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-144" id="h36-0-144" class="i">+	if err != nil {
</a><a href="#h36-0-145" id="h36-0-145" class="i">+		return nil, nil, err
</a><a href="#h36-0-146" id="h36-0-146" class="i">+	}
</a><a href="#h36-0-147" id="h36-0-147" class="i">+
</a><a href="#h36-0-148" id="h36-0-148" class="i">+	// TODO: remove custom Accept header when license support fully launches
</a><a href="#h36-0-149" id="h36-0-149" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeLicensesPreview)
</a><a href="#h36-0-150" id="h36-0-150" class="i">+
</a><a href="#h36-0-151" id="h36-0-151" class="i">+	repos := new([]Repository)
</a><a href="#h36-0-152" id="h36-0-152" class="i">+	resp, err := s.client.Do(req, repos)
</a><a href="#h36-0-153" id="h36-0-153" class="i">+	if err != nil {
</a><a href="#h36-0-154" id="h36-0-154" class="i">+		return nil, resp, err
</a><a href="#h36-0-155" id="h36-0-155" class="i">+	}
</a><a href="#h36-0-156" id="h36-0-156" class="i">+
</a><a href="#h36-0-157" id="h36-0-157" class="i">+	return *repos, resp, err
</a><a href="#h36-0-158" id="h36-0-158" class="i">+}
</a><a href="#h36-0-159" id="h36-0-159" class="i">+
</a><a href="#h36-0-160" id="h36-0-160" class="i">+// RepositoryListByOrgOptions specifies the optional parameters to the
</a><a href="#h36-0-161" id="h36-0-161" class="i">+// RepositoriesService.ListByOrg method.
</a><a href="#h36-0-162" id="h36-0-162" class="i">+type RepositoryListByOrgOptions struct {
</a><a href="#h36-0-163" id="h36-0-163" class="i">+	// Type of repositories to list.  Possible values are: all, public, private,
</a><a href="#h36-0-164" id="h36-0-164" class="i">+	// forks, sources, member.  Default is &quot;all&quot;.
</a><a href="#h36-0-165" id="h36-0-165" class="i">+	Type string `url:&quot;type,omitempty&quot;`
</a><a href="#h36-0-166" id="h36-0-166" class="i">+
</a><a href="#h36-0-167" id="h36-0-167" class="i">+	ListOptions
</a><a href="#h36-0-168" id="h36-0-168" class="i">+}
</a><a href="#h36-0-169" id="h36-0-169" class="i">+
</a><a href="#h36-0-170" id="h36-0-170" class="i">+// ListByOrg lists the repositories for an organization.
</a><a href="#h36-0-171" id="h36-0-171" class="i">+//
</a><a href="#h36-0-172" id="h36-0-172" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#list-organization-repositories
</a><a href="#h36-0-173" id="h36-0-173" class="i">+func (s *RepositoriesService) ListByOrg(org string, opt *RepositoryListByOrgOptions) ([]Repository, *Response, error) {
</a><a href="#h36-0-174" id="h36-0-174" class="i">+	u := fmt.Sprintf(&quot;orgs/%v/repos&quot;, org)
</a><a href="#h36-0-175" id="h36-0-175" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h36-0-176" id="h36-0-176" class="i">+	if err != nil {
</a><a href="#h36-0-177" id="h36-0-177" class="i">+		return nil, nil, err
</a><a href="#h36-0-178" id="h36-0-178" class="i">+	}
</a><a href="#h36-0-179" id="h36-0-179" class="i">+
</a><a href="#h36-0-180" id="h36-0-180" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-181" id="h36-0-181" class="i">+	if err != nil {
</a><a href="#h36-0-182" id="h36-0-182" class="i">+		return nil, nil, err
</a><a href="#h36-0-183" id="h36-0-183" class="i">+	}
</a><a href="#h36-0-184" id="h36-0-184" class="i">+
</a><a href="#h36-0-185" id="h36-0-185" class="i">+	// TODO: remove custom Accept header when license support fully launches
</a><a href="#h36-0-186" id="h36-0-186" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeLicensesPreview)
</a><a href="#h36-0-187" id="h36-0-187" class="i">+
</a><a href="#h36-0-188" id="h36-0-188" class="i">+	repos := new([]Repository)
</a><a href="#h36-0-189" id="h36-0-189" class="i">+	resp, err := s.client.Do(req, repos)
</a><a href="#h36-0-190" id="h36-0-190" class="i">+	if err != nil {
</a><a href="#h36-0-191" id="h36-0-191" class="i">+		return nil, resp, err
</a><a href="#h36-0-192" id="h36-0-192" class="i">+	}
</a><a href="#h36-0-193" id="h36-0-193" class="i">+
</a><a href="#h36-0-194" id="h36-0-194" class="i">+	return *repos, resp, err
</a><a href="#h36-0-195" id="h36-0-195" class="i">+}
</a><a href="#h36-0-196" id="h36-0-196" class="i">+
</a><a href="#h36-0-197" id="h36-0-197" class="i">+// RepositoryListAllOptions specifies the optional parameters to the
</a><a href="#h36-0-198" id="h36-0-198" class="i">+// RepositoriesService.ListAll method.
</a><a href="#h36-0-199" id="h36-0-199" class="i">+type RepositoryListAllOptions struct {
</a><a href="#h36-0-200" id="h36-0-200" class="i">+	// ID of the last repository seen
</a><a href="#h36-0-201" id="h36-0-201" class="i">+	Since int `url:&quot;since,omitempty&quot;`
</a><a href="#h36-0-202" id="h36-0-202" class="i">+
</a><a href="#h36-0-203" id="h36-0-203" class="i">+	ListOptions
</a><a href="#h36-0-204" id="h36-0-204" class="i">+}
</a><a href="#h36-0-205" id="h36-0-205" class="i">+
</a><a href="#h36-0-206" id="h36-0-206" class="i">+// ListAll lists all GitHub repositories in the order that they were created.
</a><a href="#h36-0-207" id="h36-0-207" class="i">+//
</a><a href="#h36-0-208" id="h36-0-208" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#list-all-public-repositories
</a><a href="#h36-0-209" id="h36-0-209" class="i">+func (s *RepositoriesService) ListAll(opt *RepositoryListAllOptions) ([]Repository, *Response, error) {
</a><a href="#h36-0-210" id="h36-0-210" class="i">+	u, err := addOptions(&quot;repositories&quot;, opt)
</a><a href="#h36-0-211" id="h36-0-211" class="i">+	if err != nil {
</a><a href="#h36-0-212" id="h36-0-212" class="i">+		return nil, nil, err
</a><a href="#h36-0-213" id="h36-0-213" class="i">+	}
</a><a href="#h36-0-214" id="h36-0-214" class="i">+
</a><a href="#h36-0-215" id="h36-0-215" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-216" id="h36-0-216" class="i">+	if err != nil {
</a><a href="#h36-0-217" id="h36-0-217" class="i">+		return nil, nil, err
</a><a href="#h36-0-218" id="h36-0-218" class="i">+	}
</a><a href="#h36-0-219" id="h36-0-219" class="i">+
</a><a href="#h36-0-220" id="h36-0-220" class="i">+	repos := new([]Repository)
</a><a href="#h36-0-221" id="h36-0-221" class="i">+	resp, err := s.client.Do(req, repos)
</a><a href="#h36-0-222" id="h36-0-222" class="i">+	if err != nil {
</a><a href="#h36-0-223" id="h36-0-223" class="i">+		return nil, resp, err
</a><a href="#h36-0-224" id="h36-0-224" class="i">+	}
</a><a href="#h36-0-225" id="h36-0-225" class="i">+
</a><a href="#h36-0-226" id="h36-0-226" class="i">+	return *repos, resp, err
</a><a href="#h36-0-227" id="h36-0-227" class="i">+}
</a><a href="#h36-0-228" id="h36-0-228" class="i">+
</a><a href="#h36-0-229" id="h36-0-229" class="i">+// Create a new repository.  If an organization is specified, the new
</a><a href="#h36-0-230" id="h36-0-230" class="i">+// repository will be created under that org.  If the empty string is
</a><a href="#h36-0-231" id="h36-0-231" class="i">+// specified, it will be created for the authenticated user.
</a><a href="#h36-0-232" id="h36-0-232" class="i">+//
</a><a href="#h36-0-233" id="h36-0-233" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#create
</a><a href="#h36-0-234" id="h36-0-234" class="i">+func (s *RepositoriesService) Create(org string, repo *Repository) (*Repository, *Response, error) {
</a><a href="#h36-0-235" id="h36-0-235" class="i">+	var u string
</a><a href="#h36-0-236" id="h36-0-236" class="i">+	if org != &quot;&quot; {
</a><a href="#h36-0-237" id="h36-0-237" class="i">+		u = fmt.Sprintf(&quot;orgs/%v/repos&quot;, org)
</a><a href="#h36-0-238" id="h36-0-238" class="i">+	} else {
</a><a href="#h36-0-239" id="h36-0-239" class="i">+		u = &quot;user/repos&quot;
</a><a href="#h36-0-240" id="h36-0-240" class="i">+	}
</a><a href="#h36-0-241" id="h36-0-241" class="i">+
</a><a href="#h36-0-242" id="h36-0-242" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, repo)
</a><a href="#h36-0-243" id="h36-0-243" class="i">+	if err != nil {
</a><a href="#h36-0-244" id="h36-0-244" class="i">+		return nil, nil, err
</a><a href="#h36-0-245" id="h36-0-245" class="i">+	}
</a><a href="#h36-0-246" id="h36-0-246" class="i">+
</a><a href="#h36-0-247" id="h36-0-247" class="i">+	r := new(Repository)
</a><a href="#h36-0-248" id="h36-0-248" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h36-0-249" id="h36-0-249" class="i">+	if err != nil {
</a><a href="#h36-0-250" id="h36-0-250" class="i">+		return nil, resp, err
</a><a href="#h36-0-251" id="h36-0-251" class="i">+	}
</a><a href="#h36-0-252" id="h36-0-252" class="i">+
</a><a href="#h36-0-253" id="h36-0-253" class="i">+	return r, resp, err
</a><a href="#h36-0-254" id="h36-0-254" class="i">+}
</a><a href="#h36-0-255" id="h36-0-255" class="i">+
</a><a href="#h36-0-256" id="h36-0-256" class="i">+// Get fetches a repository.
</a><a href="#h36-0-257" id="h36-0-257" class="i">+//
</a><a href="#h36-0-258" id="h36-0-258" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#get
</a><a href="#h36-0-259" id="h36-0-259" class="i">+func (s *RepositoriesService) Get(owner, repo string) (*Repository, *Response, error) {
</a><a href="#h36-0-260" id="h36-0-260" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v&quot;, owner, repo)
</a><a href="#h36-0-261" id="h36-0-261" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-262" id="h36-0-262" class="i">+	if err != nil {
</a><a href="#h36-0-263" id="h36-0-263" class="i">+		return nil, nil, err
</a><a href="#h36-0-264" id="h36-0-264" class="i">+	}
</a><a href="#h36-0-265" id="h36-0-265" class="i">+
</a><a href="#h36-0-266" id="h36-0-266" class="i">+	// TODO: remove custom Accept header when the license support fully launches
</a><a href="#h36-0-267" id="h36-0-267" class="i">+	// https://developer.github.com/v3/licenses/#get-a-repositorys-license
</a><a href="#h36-0-268" id="h36-0-268" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeLicensesPreview)
</a><a href="#h36-0-269" id="h36-0-269" class="i">+
</a><a href="#h36-0-270" id="h36-0-270" class="i">+	repository := new(Repository)
</a><a href="#h36-0-271" id="h36-0-271" class="i">+	resp, err := s.client.Do(req, repository)
</a><a href="#h36-0-272" id="h36-0-272" class="i">+	if err != nil {
</a><a href="#h36-0-273" id="h36-0-273" class="i">+		return nil, resp, err
</a><a href="#h36-0-274" id="h36-0-274" class="i">+	}
</a><a href="#h36-0-275" id="h36-0-275" class="i">+
</a><a href="#h36-0-276" id="h36-0-276" class="i">+	return repository, resp, err
</a><a href="#h36-0-277" id="h36-0-277" class="i">+}
</a><a href="#h36-0-278" id="h36-0-278" class="i">+
</a><a href="#h36-0-279" id="h36-0-279" class="i">+// Edit updates a repository.
</a><a href="#h36-0-280" id="h36-0-280" class="i">+//
</a><a href="#h36-0-281" id="h36-0-281" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#edit
</a><a href="#h36-0-282" id="h36-0-282" class="i">+func (s *RepositoriesService) Edit(owner, repo string, repository *Repository) (*Repository, *Response, error) {
</a><a href="#h36-0-283" id="h36-0-283" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v&quot;, owner, repo)
</a><a href="#h36-0-284" id="h36-0-284" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, repository)
</a><a href="#h36-0-285" id="h36-0-285" class="i">+	if err != nil {
</a><a href="#h36-0-286" id="h36-0-286" class="i">+		return nil, nil, err
</a><a href="#h36-0-287" id="h36-0-287" class="i">+	}
</a><a href="#h36-0-288" id="h36-0-288" class="i">+
</a><a href="#h36-0-289" id="h36-0-289" class="i">+	r := new(Repository)
</a><a href="#h36-0-290" id="h36-0-290" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h36-0-291" id="h36-0-291" class="i">+	if err != nil {
</a><a href="#h36-0-292" id="h36-0-292" class="i">+		return nil, resp, err
</a><a href="#h36-0-293" id="h36-0-293" class="i">+	}
</a><a href="#h36-0-294" id="h36-0-294" class="i">+
</a><a href="#h36-0-295" id="h36-0-295" class="i">+	return r, resp, err
</a><a href="#h36-0-296" id="h36-0-296" class="i">+}
</a><a href="#h36-0-297" id="h36-0-297" class="i">+
</a><a href="#h36-0-298" id="h36-0-298" class="i">+// Delete a repository.
</a><a href="#h36-0-299" id="h36-0-299" class="i">+//
</a><a href="#h36-0-300" id="h36-0-300" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/#delete-a-repository
</a><a href="#h36-0-301" id="h36-0-301" class="i">+func (s *RepositoriesService) Delete(owner, repo string) (*Response, error) {
</a><a href="#h36-0-302" id="h36-0-302" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v&quot;, owner, repo)
</a><a href="#h36-0-303" id="h36-0-303" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h36-0-304" id="h36-0-304" class="i">+	if err != nil {
</a><a href="#h36-0-305" id="h36-0-305" class="i">+		return nil, err
</a><a href="#h36-0-306" id="h36-0-306" class="i">+	}
</a><a href="#h36-0-307" id="h36-0-307" class="i">+
</a><a href="#h36-0-308" id="h36-0-308" class="i">+	return s.client.Do(req, nil)
</a><a href="#h36-0-309" id="h36-0-309" class="i">+}
</a><a href="#h36-0-310" id="h36-0-310" class="i">+
</a><a href="#h36-0-311" id="h36-0-311" class="i">+// Contributor represents a repository contributor
</a><a href="#h36-0-312" id="h36-0-312" class="i">+type Contributor struct {
</a><a href="#h36-0-313" id="h36-0-313" class="i">+	Login             *string `json:&quot;login,omitempty&quot;`
</a><a href="#h36-0-314" id="h36-0-314" class="i">+	ID                *int    `json:&quot;id,omitempty&quot;`
</a><a href="#h36-0-315" id="h36-0-315" class="i">+	AvatarURL         *string `json:&quot;avatar_url,omitempty&quot;`
</a><a href="#h36-0-316" id="h36-0-316" class="i">+	GravatarID        *string `json:&quot;gravatar_id,omitempty&quot;`
</a><a href="#h36-0-317" id="h36-0-317" class="i">+	URL               *string `json:&quot;url,omitempty&quot;`
</a><a href="#h36-0-318" id="h36-0-318" class="i">+	HTMLURL           *string `json:&quot;html_url,omitempty&quot;`
</a><a href="#h36-0-319" id="h36-0-319" class="i">+	FollowersURL      *string `json:&quot;followers_url,omitempty&quot;`
</a><a href="#h36-0-320" id="h36-0-320" class="i">+	FollowingURL      *string `json:&quot;following_url,omitempty&quot;`
</a><a href="#h36-0-321" id="h36-0-321" class="i">+	GistsURL          *string `json:&quot;gists_url,omitempty&quot;`
</a><a href="#h36-0-322" id="h36-0-322" class="i">+	StarredURL        *string `json:&quot;starred_url,omitempty&quot;`
</a><a href="#h36-0-323" id="h36-0-323" class="i">+	SubscriptionsURL  *string `json:&quot;subscriptions_url,omitempty&quot;`
</a><a href="#h36-0-324" id="h36-0-324" class="i">+	OrganizationsURL  *string `json:&quot;organizations_url,omitempty&quot;`
</a><a href="#h36-0-325" id="h36-0-325" class="i">+	ReposURL          *string `json:&quot;repos_url,omitempty&quot;`
</a><a href="#h36-0-326" id="h36-0-326" class="i">+	EventsURL         *string `json:&quot;events_url,omitempty&quot;`
</a><a href="#h36-0-327" id="h36-0-327" class="i">+	ReceivedEventsURL *string `json:&quot;received_events_url,omitempty&quot;`
</a><a href="#h36-0-328" id="h36-0-328" class="i">+	Type              *string `json:&quot;type,omitempty&quot;`
</a><a href="#h36-0-329" id="h36-0-329" class="i">+	SiteAdmin         *bool   `json:&quot;site_admin&quot;`
</a><a href="#h36-0-330" id="h36-0-330" class="i">+	Contributions     *int    `json:&quot;contributions,omitempty&quot;`
</a><a href="#h36-0-331" id="h36-0-331" class="i">+}
</a><a href="#h36-0-332" id="h36-0-332" class="i">+
</a><a href="#h36-0-333" id="h36-0-333" class="i">+// ListContributorsOptions specifies the optional parameters to the
</a><a href="#h36-0-334" id="h36-0-334" class="i">+// RepositoriesService.ListContributors method.
</a><a href="#h36-0-335" id="h36-0-335" class="i">+type ListContributorsOptions struct {
</a><a href="#h36-0-336" id="h36-0-336" class="i">+	// Include anonymous contributors in results or not
</a><a href="#h36-0-337" id="h36-0-337" class="i">+	Anon string `url:&quot;anon,omitempty&quot;`
</a><a href="#h36-0-338" id="h36-0-338" class="i">+
</a><a href="#h36-0-339" id="h36-0-339" class="i">+	ListOptions
</a><a href="#h36-0-340" id="h36-0-340" class="i">+}
</a><a href="#h36-0-341" id="h36-0-341" class="i">+
</a><a href="#h36-0-342" id="h36-0-342" class="i">+// ListContributors lists contributors for a repository.
</a><a href="#h36-0-343" id="h36-0-343" class="i">+//
</a><a href="#h36-0-344" id="h36-0-344" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#list-contributors
</a><a href="#h36-0-345" id="h36-0-345" class="i">+func (s *RepositoriesService) ListContributors(owner string, repository string, opt *ListContributorsOptions) ([]Contributor, *Response, error) {
</a><a href="#h36-0-346" id="h36-0-346" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/contributors&quot;, owner, repository)
</a><a href="#h36-0-347" id="h36-0-347" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h36-0-348" id="h36-0-348" class="i">+	if err != nil {
</a><a href="#h36-0-349" id="h36-0-349" class="i">+		return nil, nil, err
</a><a href="#h36-0-350" id="h36-0-350" class="i">+	}
</a><a href="#h36-0-351" id="h36-0-351" class="i">+
</a><a href="#h36-0-352" id="h36-0-352" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-353" id="h36-0-353" class="i">+	if err != nil {
</a><a href="#h36-0-354" id="h36-0-354" class="i">+		return nil, nil, err
</a><a href="#h36-0-355" id="h36-0-355" class="i">+	}
</a><a href="#h36-0-356" id="h36-0-356" class="i">+
</a><a href="#h36-0-357" id="h36-0-357" class="i">+	contributor := new([]Contributor)
</a><a href="#h36-0-358" id="h36-0-358" class="i">+	resp, err := s.client.Do(req, contributor)
</a><a href="#h36-0-359" id="h36-0-359" class="i">+	if err != nil {
</a><a href="#h36-0-360" id="h36-0-360" class="i">+		return nil, nil, err
</a><a href="#h36-0-361" id="h36-0-361" class="i">+	}
</a><a href="#h36-0-362" id="h36-0-362" class="i">+
</a><a href="#h36-0-363" id="h36-0-363" class="i">+	return *contributor, resp, err
</a><a href="#h36-0-364" id="h36-0-364" class="i">+}
</a><a href="#h36-0-365" id="h36-0-365" class="i">+
</a><a href="#h36-0-366" id="h36-0-366" class="i">+// ListLanguages lists languages for the specified repository. The returned map
</a><a href="#h36-0-367" id="h36-0-367" class="i">+// specifies the languages and the number of bytes of code written in that
</a><a href="#h36-0-368" id="h36-0-368" class="i">+// language. For example:
</a><a href="#h36-0-369" id="h36-0-369" class="i">+//
</a><a href="#h36-0-370" id="h36-0-370" class="i">+//     {
</a><a href="#h36-0-371" id="h36-0-371" class="i">+//       &quot;C&quot;: 78769,
</a><a href="#h36-0-372" id="h36-0-372" class="i">+//       &quot;Python&quot;: 7769
</a><a href="#h36-0-373" id="h36-0-373" class="i">+//     }
</a><a href="#h36-0-374" id="h36-0-374" class="i">+//
</a><a href="#h36-0-375" id="h36-0-375" class="i">+// GitHub API Docs: http://developer.github.com/v3/repos/#list-languages
</a><a href="#h36-0-376" id="h36-0-376" class="i">+func (s *RepositoriesService) ListLanguages(owner string, repo string) (map[string]int, *Response, error) {
</a><a href="#h36-0-377" id="h36-0-377" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/languages&quot;, owner, repo)
</a><a href="#h36-0-378" id="h36-0-378" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-379" id="h36-0-379" class="i">+	if err != nil {
</a><a href="#h36-0-380" id="h36-0-380" class="i">+		return nil, nil, err
</a><a href="#h36-0-381" id="h36-0-381" class="i">+	}
</a><a href="#h36-0-382" id="h36-0-382" class="i">+
</a><a href="#h36-0-383" id="h36-0-383" class="i">+	languages := make(map[string]int)
</a><a href="#h36-0-384" id="h36-0-384" class="i">+	resp, err := s.client.Do(req, &amp;languages)
</a><a href="#h36-0-385" id="h36-0-385" class="i">+	if err != nil {
</a><a href="#h36-0-386" id="h36-0-386" class="i">+		return nil, resp, err
</a><a href="#h36-0-387" id="h36-0-387" class="i">+	}
</a><a href="#h36-0-388" id="h36-0-388" class="i">+
</a><a href="#h36-0-389" id="h36-0-389" class="i">+	return languages, resp, err
</a><a href="#h36-0-390" id="h36-0-390" class="i">+}
</a><a href="#h36-0-391" id="h36-0-391" class="i">+
</a><a href="#h36-0-392" id="h36-0-392" class="i">+// ListTeams lists the teams for the specified repository.
</a><a href="#h36-0-393" id="h36-0-393" class="i">+//
</a><a href="#h36-0-394" id="h36-0-394" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/#list-teams
</a><a href="#h36-0-395" id="h36-0-395" class="i">+func (s *RepositoriesService) ListTeams(owner string, repo string, opt *ListOptions) ([]Team, *Response, error) {
</a><a href="#h36-0-396" id="h36-0-396" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/teams&quot;, owner, repo)
</a><a href="#h36-0-397" id="h36-0-397" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h36-0-398" id="h36-0-398" class="i">+	if err != nil {
</a><a href="#h36-0-399" id="h36-0-399" class="i">+		return nil, nil, err
</a><a href="#h36-0-400" id="h36-0-400" class="i">+	}
</a><a href="#h36-0-401" id="h36-0-401" class="i">+
</a><a href="#h36-0-402" id="h36-0-402" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-403" id="h36-0-403" class="i">+	if err != nil {
</a><a href="#h36-0-404" id="h36-0-404" class="i">+		return nil, nil, err
</a><a href="#h36-0-405" id="h36-0-405" class="i">+	}
</a><a href="#h36-0-406" id="h36-0-406" class="i">+
</a><a href="#h36-0-407" id="h36-0-407" class="i">+	teams := new([]Team)
</a><a href="#h36-0-408" id="h36-0-408" class="i">+	resp, err := s.client.Do(req, teams)
</a><a href="#h36-0-409" id="h36-0-409" class="i">+	if err != nil {
</a><a href="#h36-0-410" id="h36-0-410" class="i">+		return nil, resp, err
</a><a href="#h36-0-411" id="h36-0-411" class="i">+	}
</a><a href="#h36-0-412" id="h36-0-412" class="i">+
</a><a href="#h36-0-413" id="h36-0-413" class="i">+	return *teams, resp, err
</a><a href="#h36-0-414" id="h36-0-414" class="i">+}
</a><a href="#h36-0-415" id="h36-0-415" class="i">+
</a><a href="#h36-0-416" id="h36-0-416" class="i">+// RepositoryTag represents a repository tag.
</a><a href="#h36-0-417" id="h36-0-417" class="i">+type RepositoryTag struct {
</a><a href="#h36-0-418" id="h36-0-418" class="i">+	Name       *string `json:&quot;name,omitempty&quot;`
</a><a href="#h36-0-419" id="h36-0-419" class="i">+	Commit     *Commit `json:&quot;commit,omitempty&quot;`
</a><a href="#h36-0-420" id="h36-0-420" class="i">+	ZipballURL *string `json:&quot;zipball_url,omitempty&quot;`
</a><a href="#h36-0-421" id="h36-0-421" class="i">+	TarballURL *string `json:&quot;tarball_url,omitempty&quot;`
</a><a href="#h36-0-422" id="h36-0-422" class="i">+}
</a><a href="#h36-0-423" id="h36-0-423" class="i">+
</a><a href="#h36-0-424" id="h36-0-424" class="i">+// ListTags lists tags for the specified repository.
</a><a href="#h36-0-425" id="h36-0-425" class="i">+//
</a><a href="#h36-0-426" id="h36-0-426" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/#list-tags
</a><a href="#h36-0-427" id="h36-0-427" class="i">+func (s *RepositoriesService) ListTags(owner string, repo string, opt *ListOptions) ([]RepositoryTag, *Response, error) {
</a><a href="#h36-0-428" id="h36-0-428" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/tags&quot;, owner, repo)
</a><a href="#h36-0-429" id="h36-0-429" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h36-0-430" id="h36-0-430" class="i">+	if err != nil {
</a><a href="#h36-0-431" id="h36-0-431" class="i">+		return nil, nil, err
</a><a href="#h36-0-432" id="h36-0-432" class="i">+	}
</a><a href="#h36-0-433" id="h36-0-433" class="i">+
</a><a href="#h36-0-434" id="h36-0-434" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-435" id="h36-0-435" class="i">+	if err != nil {
</a><a href="#h36-0-436" id="h36-0-436" class="i">+		return nil, nil, err
</a><a href="#h36-0-437" id="h36-0-437" class="i">+	}
</a><a href="#h36-0-438" id="h36-0-438" class="i">+
</a><a href="#h36-0-439" id="h36-0-439" class="i">+	tags := new([]RepositoryTag)
</a><a href="#h36-0-440" id="h36-0-440" class="i">+	resp, err := s.client.Do(req, tags)
</a><a href="#h36-0-441" id="h36-0-441" class="i">+	if err != nil {
</a><a href="#h36-0-442" id="h36-0-442" class="i">+		return nil, resp, err
</a><a href="#h36-0-443" id="h36-0-443" class="i">+	}
</a><a href="#h36-0-444" id="h36-0-444" class="i">+
</a><a href="#h36-0-445" id="h36-0-445" class="i">+	return *tags, resp, err
</a><a href="#h36-0-446" id="h36-0-446" class="i">+}
</a><a href="#h36-0-447" id="h36-0-447" class="i">+
</a><a href="#h36-0-448" id="h36-0-448" class="i">+// Branch represents a repository branch
</a><a href="#h36-0-449" id="h36-0-449" class="i">+type Branch struct {
</a><a href="#h36-0-450" id="h36-0-450" class="i">+	Name       *string     `json:&quot;name,omitempty&quot;`
</a><a href="#h36-0-451" id="h36-0-451" class="i">+	Commit     *Commit     `json:&quot;commit,omitempty&quot;`
</a><a href="#h36-0-452" id="h36-0-452" class="i">+	Protection *Protection `json:&quot;protection,omitempty&quot;`
</a><a href="#h36-0-453" id="h36-0-453" class="i">+}
</a><a href="#h36-0-454" id="h36-0-454" class="i">+
</a><a href="#h36-0-455" id="h36-0-455" class="i">+// Protection represents a repository branch&#39;s protection
</a><a href="#h36-0-456" id="h36-0-456" class="i">+type Protection struct {
</a><a href="#h36-0-457" id="h36-0-457" class="i">+	Enabled              *bool                 `json:&quot;enabled,omitempty&quot;`
</a><a href="#h36-0-458" id="h36-0-458" class="i">+	RequiredStatusChecks *RequiredStatusChecks `json:&quot;required_status_checks,omitempty&quot;`
</a><a href="#h36-0-459" id="h36-0-459" class="i">+}
</a><a href="#h36-0-460" id="h36-0-460" class="i">+
</a><a href="#h36-0-461" id="h36-0-461" class="i">+// RequiredStatusChecks represents the protection status of a individual branch
</a><a href="#h36-0-462" id="h36-0-462" class="i">+type RequiredStatusChecks struct {
</a><a href="#h36-0-463" id="h36-0-463" class="i">+	// Who required status checks apply to.
</a><a href="#h36-0-464" id="h36-0-464" class="i">+	// Possible values are:
</a><a href="#h36-0-465" id="h36-0-465" class="i">+	//     off
</a><a href="#h36-0-466" id="h36-0-466" class="i">+	//     non_admins
</a><a href="#h36-0-467" id="h36-0-467" class="i">+	//     everyone
</a><a href="#h36-0-468" id="h36-0-468" class="i">+	EnforcementLevel *string `json:&quot;enforcement_level,omitempty&quot;`
</a><a href="#h36-0-469" id="h36-0-469" class="i">+	// The list of status checks which are required
</a><a href="#h36-0-470" id="h36-0-470" class="i">+	Contexts *[]string `json:&quot;contexts,omitempty&quot;`
</a><a href="#h36-0-471" id="h36-0-471" class="i">+}
</a><a href="#h36-0-472" id="h36-0-472" class="i">+
</a><a href="#h36-0-473" id="h36-0-473" class="i">+// ListBranches lists branches for the specified repository.
</a><a href="#h36-0-474" id="h36-0-474" class="i">+//
</a><a href="#h36-0-475" id="h36-0-475" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/#list-branches
</a><a href="#h36-0-476" id="h36-0-476" class="i">+func (s *RepositoriesService) ListBranches(owner string, repo string, opt *ListOptions) ([]Branch, *Response, error) {
</a><a href="#h36-0-477" id="h36-0-477" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/branches&quot;, owner, repo)
</a><a href="#h36-0-478" id="h36-0-478" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h36-0-479" id="h36-0-479" class="i">+	if err != nil {
</a><a href="#h36-0-480" id="h36-0-480" class="i">+		return nil, nil, err
</a><a href="#h36-0-481" id="h36-0-481" class="i">+	}
</a><a href="#h36-0-482" id="h36-0-482" class="i">+
</a><a href="#h36-0-483" id="h36-0-483" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-484" id="h36-0-484" class="i">+	if err != nil {
</a><a href="#h36-0-485" id="h36-0-485" class="i">+		return nil, nil, err
</a><a href="#h36-0-486" id="h36-0-486" class="i">+	}
</a><a href="#h36-0-487" id="h36-0-487" class="i">+
</a><a href="#h36-0-488" id="h36-0-488" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeProtectedBranchesPreview)
</a><a href="#h36-0-489" id="h36-0-489" class="i">+
</a><a href="#h36-0-490" id="h36-0-490" class="i">+	branches := new([]Branch)
</a><a href="#h36-0-491" id="h36-0-491" class="i">+	resp, err := s.client.Do(req, branches)
</a><a href="#h36-0-492" id="h36-0-492" class="i">+	if err != nil {
</a><a href="#h36-0-493" id="h36-0-493" class="i">+		return nil, resp, err
</a><a href="#h36-0-494" id="h36-0-494" class="i">+	}
</a><a href="#h36-0-495" id="h36-0-495" class="i">+
</a><a href="#h36-0-496" id="h36-0-496" class="i">+	return *branches, resp, err
</a><a href="#h36-0-497" id="h36-0-497" class="i">+}
</a><a href="#h36-0-498" id="h36-0-498" class="i">+
</a><a href="#h36-0-499" id="h36-0-499" class="i">+// GetBranch gets the specified branch for a repository.
</a><a href="#h36-0-500" id="h36-0-500" class="i">+//
</a><a href="#h36-0-501" id="h36-0-501" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/#get-branch
</a><a href="#h36-0-502" id="h36-0-502" class="i">+func (s *RepositoriesService) GetBranch(owner, repo, branch string) (*Branch, *Response, error) {
</a><a href="#h36-0-503" id="h36-0-503" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/branches/%v&quot;, owner, repo, branch)
</a><a href="#h36-0-504" id="h36-0-504" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-505" id="h36-0-505" class="i">+	if err != nil {
</a><a href="#h36-0-506" id="h36-0-506" class="i">+		return nil, nil, err
</a><a href="#h36-0-507" id="h36-0-507" class="i">+	}
</a><a href="#h36-0-508" id="h36-0-508" class="i">+
</a><a href="#h36-0-509" id="h36-0-509" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeProtectedBranchesPreview)
</a><a href="#h36-0-510" id="h36-0-510" class="i">+
</a><a href="#h36-0-511" id="h36-0-511" class="i">+	b := new(Branch)
</a><a href="#h36-0-512" id="h36-0-512" class="i">+	resp, err := s.client.Do(req, b)
</a><a href="#h36-0-513" id="h36-0-513" class="i">+	if err != nil {
</a><a href="#h36-0-514" id="h36-0-514" class="i">+		return nil, resp, err
</a><a href="#h36-0-515" id="h36-0-515" class="i">+	}
</a><a href="#h36-0-516" id="h36-0-516" class="i">+
</a><a href="#h36-0-517" id="h36-0-517" class="i">+	return b, resp, err
</a><a href="#h36-0-518" id="h36-0-518" class="i">+}
</a><a href="#h36-0-519" id="h36-0-519" class="i">+
</a><a href="#h36-0-520" id="h36-0-520" class="i">+// EditBranch edits the branch (currently only Branch Protection)
</a><a href="#h36-0-521" id="h36-0-521" class="i">+//
</a><a href="#h36-0-522" id="h36-0-522" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/#enabling-and-disabling-branch-protection
</a><a href="#h36-0-523" id="h36-0-523" class="i">+func (s *RepositoriesService) EditBranch(owner, repo, branchName string, branch *Branch) (*Branch, *Response, error) {
</a><a href="#h36-0-524" id="h36-0-524" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/branches/%v&quot;, owner, repo, branchName)
</a><a href="#h36-0-525" id="h36-0-525" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, branch)
</a><a href="#h36-0-526" id="h36-0-526" class="i">+	if err != nil {
</a><a href="#h36-0-527" id="h36-0-527" class="i">+		return nil, nil, err
</a><a href="#h36-0-528" id="h36-0-528" class="i">+	}
</a><a href="#h36-0-529" id="h36-0-529" class="i">+
</a><a href="#h36-0-530" id="h36-0-530" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeProtectedBranchesPreview)
</a><a href="#h36-0-531" id="h36-0-531" class="i">+
</a><a href="#h36-0-532" id="h36-0-532" class="i">+	b := new(Branch)
</a><a href="#h36-0-533" id="h36-0-533" class="i">+	resp, err := s.client.Do(req, b)
</a><a href="#h36-0-534" id="h36-0-534" class="i">+	if err != nil {
</a><a href="#h36-0-535" id="h36-0-535" class="i">+		return nil, resp, err
</a><a href="#h36-0-536" id="h36-0-536" class="i">+	}
</a><a href="#h36-0-537" id="h36-0-537" class="i">+
</a><a href="#h36-0-538" id="h36-0-538" class="i">+	return b, resp, err
</a><a href="#h36-0-539" id="h36-0-539" class="i">+}
</a><a href="#h36-0-540" id="h36-0-540" class="i">+
</a><a href="#h36-0-541" id="h36-0-541" class="i">+// License gets the contents of a repository&#39;s license if one is detected.
</a><a href="#h36-0-542" id="h36-0-542" class="i">+//
</a><a href="#h36-0-543" id="h36-0-543" class="i">+// GitHub API docs: https://developer.github.com/v3/licenses/#get-the-contents-of-a-repositorys-license
</a><a href="#h36-0-544" id="h36-0-544" class="i">+func (s *RepositoriesService) License(owner, repo string) (*License, *Response, error) {
</a><a href="#h36-0-545" id="h36-0-545" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/license&quot;, owner, repo)
</a><a href="#h36-0-546" id="h36-0-546" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h36-0-547" id="h36-0-547" class="i">+	if err != nil {
</a><a href="#h36-0-548" id="h36-0-548" class="i">+		return nil, nil, err
</a><a href="#h36-0-549" id="h36-0-549" class="i">+	}
</a><a href="#h36-0-550" id="h36-0-550" class="i">+
</a><a href="#h36-0-551" id="h36-0-551" class="i">+	r := &amp;Repository{}
</a><a href="#h36-0-552" id="h36-0-552" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h36-0-553" id="h36-0-553" class="i">+	if err != nil {
</a><a href="#h36-0-554" id="h36-0-554" class="i">+		return nil, resp, err
</a><a href="#h36-0-555" id="h36-0-555" class="i">+	}
</a><a href="#h36-0-556" id="h36-0-556" class="i">+
</a><a href="#h36-0-557" id="h36-0-557" class="i">+	return r.License, resp, err
</a><a href="#h36-0-558" id="h36-0-558" class="i">+}
</a><b>diff --git a/<a id="h37" href="../file/vendor/github.com/google/go-github/github/repos_collaborators.go">vendor/github.com/google/go-github/github/repos_collaborators.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_collaborators.go">vendor/github.com/google/go-github/github/repos_collaborators.go</a></b>
<a href="#h37-0" id="h37-0" class="h">@@ -0,0 +1,95 @@
</a><a href="#h37-0-0" id="h37-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h37-0-1" id="h37-0-1" class="i">+//
</a><a href="#h37-0-2" id="h37-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h37-0-3" id="h37-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h37-0-4" id="h37-0-4" class="i">+
</a><a href="#h37-0-5" id="h37-0-5" class="i">+package github
</a><a href="#h37-0-6" id="h37-0-6" class="i">+
</a><a href="#h37-0-7" id="h37-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h37-0-8" id="h37-0-8" class="i">+
</a><a href="#h37-0-9" id="h37-0-9" class="i">+// ListCollaborators lists the Github users that have access to the repository.
</a><a href="#h37-0-10" id="h37-0-10" class="i">+//
</a><a href="#h37-0-11" id="h37-0-11" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/collaborators/#list
</a><a href="#h37-0-12" id="h37-0-12" class="i">+func (s *RepositoriesService) ListCollaborators(owner, repo string, opt *ListOptions) ([]User, *Response, error) {
</a><a href="#h37-0-13" id="h37-0-13" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/collaborators&quot;, owner, repo)
</a><a href="#h37-0-14" id="h37-0-14" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h37-0-15" id="h37-0-15" class="i">+	if err != nil {
</a><a href="#h37-0-16" id="h37-0-16" class="i">+		return nil, nil, err
</a><a href="#h37-0-17" id="h37-0-17" class="i">+	}
</a><a href="#h37-0-18" id="h37-0-18" class="i">+
</a><a href="#h37-0-19" id="h37-0-19" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h37-0-20" id="h37-0-20" class="i">+	if err != nil {
</a><a href="#h37-0-21" id="h37-0-21" class="i">+		return nil, nil, err
</a><a href="#h37-0-22" id="h37-0-22" class="i">+	}
</a><a href="#h37-0-23" id="h37-0-23" class="i">+
</a><a href="#h37-0-24" id="h37-0-24" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h37-0-25" id="h37-0-25" class="i">+
</a><a href="#h37-0-26" id="h37-0-26" class="i">+	users := new([]User)
</a><a href="#h37-0-27" id="h37-0-27" class="i">+	resp, err := s.client.Do(req, users)
</a><a href="#h37-0-28" id="h37-0-28" class="i">+	if err != nil {
</a><a href="#h37-0-29" id="h37-0-29" class="i">+		return nil, resp, err
</a><a href="#h37-0-30" id="h37-0-30" class="i">+	}
</a><a href="#h37-0-31" id="h37-0-31" class="i">+
</a><a href="#h37-0-32" id="h37-0-32" class="i">+	return *users, resp, err
</a><a href="#h37-0-33" id="h37-0-33" class="i">+}
</a><a href="#h37-0-34" id="h37-0-34" class="i">+
</a><a href="#h37-0-35" id="h37-0-35" class="i">+// IsCollaborator checks whether the specified Github user has collaborator
</a><a href="#h37-0-36" id="h37-0-36" class="i">+// access to the given repo.
</a><a href="#h37-0-37" id="h37-0-37" class="i">+// Note: This will return false if the user is not a collaborator OR the user
</a><a href="#h37-0-38" id="h37-0-38" class="i">+// is not a GitHub user.
</a><a href="#h37-0-39" id="h37-0-39" class="i">+//
</a><a href="#h37-0-40" id="h37-0-40" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/collaborators/#get
</a><a href="#h37-0-41" id="h37-0-41" class="i">+func (s *RepositoriesService) IsCollaborator(owner, repo, user string) (bool, *Response, error) {
</a><a href="#h37-0-42" id="h37-0-42" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/collaborators/%v&quot;, owner, repo, user)
</a><a href="#h37-0-43" id="h37-0-43" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h37-0-44" id="h37-0-44" class="i">+	if err != nil {
</a><a href="#h37-0-45" id="h37-0-45" class="i">+		return false, nil, err
</a><a href="#h37-0-46" id="h37-0-46" class="i">+	}
</a><a href="#h37-0-47" id="h37-0-47" class="i">+
</a><a href="#h37-0-48" id="h37-0-48" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h37-0-49" id="h37-0-49" class="i">+	isCollab, err := parseBoolResponse(err)
</a><a href="#h37-0-50" id="h37-0-50" class="i">+	return isCollab, resp, err
</a><a href="#h37-0-51" id="h37-0-51" class="i">+}
</a><a href="#h37-0-52" id="h37-0-52" class="i">+
</a><a href="#h37-0-53" id="h37-0-53" class="i">+// RepositoryAddCollaboratorOptions specifies the optional parameters to the
</a><a href="#h37-0-54" id="h37-0-54" class="i">+// RepositoriesService.AddCollaborator method.
</a><a href="#h37-0-55" id="h37-0-55" class="i">+type RepositoryAddCollaboratorOptions struct {
</a><a href="#h37-0-56" id="h37-0-56" class="i">+	// Permission specifies the permission to grant the user on this repository.
</a><a href="#h37-0-57" id="h37-0-57" class="i">+	// Possible values are:
</a><a href="#h37-0-58" id="h37-0-58" class="i">+	//     pull - team members can pull, but not push to or administer this repository
</a><a href="#h37-0-59" id="h37-0-59" class="i">+	//     push - team members can pull and push, but not administer this repository
</a><a href="#h37-0-60" id="h37-0-60" class="i">+	//     admin - team members can pull, push and administer this repository
</a><a href="#h37-0-61" id="h37-0-61" class="i">+	//
</a><a href="#h37-0-62" id="h37-0-62" class="i">+	// Default value is &quot;pull&quot;.  This option is only valid for organization-owned repositories.
</a><a href="#h37-0-63" id="h37-0-63" class="i">+	Permission string `json:&quot;permission,omitempty&quot;`
</a><a href="#h37-0-64" id="h37-0-64" class="i">+}
</a><a href="#h37-0-65" id="h37-0-65" class="i">+
</a><a href="#h37-0-66" id="h37-0-66" class="i">+// AddCollaborator adds the specified Github user as collaborator to the given repo.
</a><a href="#h37-0-67" id="h37-0-67" class="i">+//
</a><a href="#h37-0-68" id="h37-0-68" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/collaborators/#add-collaborator
</a><a href="#h37-0-69" id="h37-0-69" class="i">+func (s *RepositoriesService) AddCollaborator(owner, repo, user string, opt *RepositoryAddCollaboratorOptions) (*Response, error) {
</a><a href="#h37-0-70" id="h37-0-70" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/collaborators/%v&quot;, owner, repo, user)
</a><a href="#h37-0-71" id="h37-0-71" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, opt)
</a><a href="#h37-0-72" id="h37-0-72" class="i">+	if err != nil {
</a><a href="#h37-0-73" id="h37-0-73" class="i">+		return nil, err
</a><a href="#h37-0-74" id="h37-0-74" class="i">+	}
</a><a href="#h37-0-75" id="h37-0-75" class="i">+
</a><a href="#h37-0-76" id="h37-0-76" class="i">+	if opt != nil {
</a><a href="#h37-0-77" id="h37-0-77" class="i">+		req.Header.Set(&quot;Accept&quot;, mediaTypeOrgPermissionPreview)
</a><a href="#h37-0-78" id="h37-0-78" class="i">+	}
</a><a href="#h37-0-79" id="h37-0-79" class="i">+
</a><a href="#h37-0-80" id="h37-0-80" class="i">+	return s.client.Do(req, nil)
</a><a href="#h37-0-81" id="h37-0-81" class="i">+}
</a><a href="#h37-0-82" id="h37-0-82" class="i">+
</a><a href="#h37-0-83" id="h37-0-83" class="i">+// RemoveCollaborator removes the specified Github user as collaborator from the given repo.
</a><a href="#h37-0-84" id="h37-0-84" class="i">+// Note: Does not return error if a valid user that is not a collaborator is removed.
</a><a href="#h37-0-85" id="h37-0-85" class="i">+//
</a><a href="#h37-0-86" id="h37-0-86" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/collaborators/#remove-collaborator
</a><a href="#h37-0-87" id="h37-0-87" class="i">+func (s *RepositoriesService) RemoveCollaborator(owner, repo, user string) (*Response, error) {
</a><a href="#h37-0-88" id="h37-0-88" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/collaborators/%v&quot;, owner, repo, user)
</a><a href="#h37-0-89" id="h37-0-89" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h37-0-90" id="h37-0-90" class="i">+	if err != nil {
</a><a href="#h37-0-91" id="h37-0-91" class="i">+		return nil, err
</a><a href="#h37-0-92" id="h37-0-92" class="i">+	}
</a><a href="#h37-0-93" id="h37-0-93" class="i">+	return s.client.Do(req, nil)
</a><a href="#h37-0-94" id="h37-0-94" class="i">+}
</a><b>diff --git a/<a id="h38" href="../file/vendor/github.com/google/go-github/github/repos_comments.go">vendor/github.com/google/go-github/github/repos_comments.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_comments.go">vendor/github.com/google/go-github/github/repos_comments.go</a></b>
<a href="#h38-0" id="h38-0" class="h">@@ -0,0 +1,150 @@
</a><a href="#h38-0-0" id="h38-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h38-0-1" id="h38-0-1" class="i">+//
</a><a href="#h38-0-2" id="h38-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h38-0-3" id="h38-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h38-0-4" id="h38-0-4" class="i">+
</a><a href="#h38-0-5" id="h38-0-5" class="i">+package github
</a><a href="#h38-0-6" id="h38-0-6" class="i">+
</a><a href="#h38-0-7" id="h38-0-7" class="i">+import (
</a><a href="#h38-0-8" id="h38-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h38-0-9" id="h38-0-9" class="i">+	&quot;time&quot;
</a><a href="#h38-0-10" id="h38-0-10" class="i">+)
</a><a href="#h38-0-11" id="h38-0-11" class="i">+
</a><a href="#h38-0-12" id="h38-0-12" class="i">+// RepositoryComment represents a comment for a commit, file, or line in a repository.
</a><a href="#h38-0-13" id="h38-0-13" class="i">+type RepositoryComment struct {
</a><a href="#h38-0-14" id="h38-0-14" class="i">+	HTMLURL   *string    `json:&quot;html_url,omitempty&quot;`
</a><a href="#h38-0-15" id="h38-0-15" class="i">+	URL       *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h38-0-16" id="h38-0-16" class="i">+	ID        *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h38-0-17" id="h38-0-17" class="i">+	CommitID  *string    `json:&quot;commit_id,omitempty&quot;`
</a><a href="#h38-0-18" id="h38-0-18" class="i">+	User      *User      `json:&quot;user,omitempty&quot;`
</a><a href="#h38-0-19" id="h38-0-19" class="i">+	CreatedAt *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h38-0-20" id="h38-0-20" class="i">+	UpdatedAt *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h38-0-21" id="h38-0-21" class="i">+
</a><a href="#h38-0-22" id="h38-0-22" class="i">+	// User-mutable fields
</a><a href="#h38-0-23" id="h38-0-23" class="i">+	Body *string `json:&quot;body&quot;`
</a><a href="#h38-0-24" id="h38-0-24" class="i">+	// User-initialized fields
</a><a href="#h38-0-25" id="h38-0-25" class="i">+	Path     *string `json:&quot;path,omitempty&quot;`
</a><a href="#h38-0-26" id="h38-0-26" class="i">+	Position *int    `json:&quot;position,omitempty&quot;`
</a><a href="#h38-0-27" id="h38-0-27" class="i">+}
</a><a href="#h38-0-28" id="h38-0-28" class="i">+
</a><a href="#h38-0-29" id="h38-0-29" class="i">+func (r RepositoryComment) String() string {
</a><a href="#h38-0-30" id="h38-0-30" class="i">+	return Stringify(r)
</a><a href="#h38-0-31" id="h38-0-31" class="i">+}
</a><a href="#h38-0-32" id="h38-0-32" class="i">+
</a><a href="#h38-0-33" id="h38-0-33" class="i">+// ListComments lists all the comments for the repository.
</a><a href="#h38-0-34" id="h38-0-34" class="i">+//
</a><a href="#h38-0-35" id="h38-0-35" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/comments/#list-commit-comments-for-a-repository
</a><a href="#h38-0-36" id="h38-0-36" class="i">+func (s *RepositoriesService) ListComments(owner, repo string, opt *ListOptions) ([]RepositoryComment, *Response, error) {
</a><a href="#h38-0-37" id="h38-0-37" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/comments&quot;, owner, repo)
</a><a href="#h38-0-38" id="h38-0-38" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h38-0-39" id="h38-0-39" class="i">+	if err != nil {
</a><a href="#h38-0-40" id="h38-0-40" class="i">+		return nil, nil, err
</a><a href="#h38-0-41" id="h38-0-41" class="i">+	}
</a><a href="#h38-0-42" id="h38-0-42" class="i">+
</a><a href="#h38-0-43" id="h38-0-43" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h38-0-44" id="h38-0-44" class="i">+	if err != nil {
</a><a href="#h38-0-45" id="h38-0-45" class="i">+		return nil, nil, err
</a><a href="#h38-0-46" id="h38-0-46" class="i">+	}
</a><a href="#h38-0-47" id="h38-0-47" class="i">+
</a><a href="#h38-0-48" id="h38-0-48" class="i">+	comments := new([]RepositoryComment)
</a><a href="#h38-0-49" id="h38-0-49" class="i">+	resp, err := s.client.Do(req, comments)
</a><a href="#h38-0-50" id="h38-0-50" class="i">+	if err != nil {
</a><a href="#h38-0-51" id="h38-0-51" class="i">+		return nil, resp, err
</a><a href="#h38-0-52" id="h38-0-52" class="i">+	}
</a><a href="#h38-0-53" id="h38-0-53" class="i">+
</a><a href="#h38-0-54" id="h38-0-54" class="i">+	return *comments, resp, err
</a><a href="#h38-0-55" id="h38-0-55" class="i">+}
</a><a href="#h38-0-56" id="h38-0-56" class="i">+
</a><a href="#h38-0-57" id="h38-0-57" class="i">+// ListCommitComments lists all the comments for a given commit SHA.
</a><a href="#h38-0-58" id="h38-0-58" class="i">+//
</a><a href="#h38-0-59" id="h38-0-59" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/comments/#list-comments-for-a-single-commit
</a><a href="#h38-0-60" id="h38-0-60" class="i">+func (s *RepositoriesService) ListCommitComments(owner, repo, sha string, opt *ListOptions) ([]RepositoryComment, *Response, error) {
</a><a href="#h38-0-61" id="h38-0-61" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/commits/%v/comments&quot;, owner, repo, sha)
</a><a href="#h38-0-62" id="h38-0-62" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h38-0-63" id="h38-0-63" class="i">+	if err != nil {
</a><a href="#h38-0-64" id="h38-0-64" class="i">+		return nil, nil, err
</a><a href="#h38-0-65" id="h38-0-65" class="i">+	}
</a><a href="#h38-0-66" id="h38-0-66" class="i">+
</a><a href="#h38-0-67" id="h38-0-67" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h38-0-68" id="h38-0-68" class="i">+	if err != nil {
</a><a href="#h38-0-69" id="h38-0-69" class="i">+		return nil, nil, err
</a><a href="#h38-0-70" id="h38-0-70" class="i">+	}
</a><a href="#h38-0-71" id="h38-0-71" class="i">+
</a><a href="#h38-0-72" id="h38-0-72" class="i">+	comments := new([]RepositoryComment)
</a><a href="#h38-0-73" id="h38-0-73" class="i">+	resp, err := s.client.Do(req, comments)
</a><a href="#h38-0-74" id="h38-0-74" class="i">+	if err != nil {
</a><a href="#h38-0-75" id="h38-0-75" class="i">+		return nil, resp, err
</a><a href="#h38-0-76" id="h38-0-76" class="i">+	}
</a><a href="#h38-0-77" id="h38-0-77" class="i">+
</a><a href="#h38-0-78" id="h38-0-78" class="i">+	return *comments, resp, err
</a><a href="#h38-0-79" id="h38-0-79" class="i">+}
</a><a href="#h38-0-80" id="h38-0-80" class="i">+
</a><a href="#h38-0-81" id="h38-0-81" class="i">+// CreateComment creates a comment for the given commit.
</a><a href="#h38-0-82" id="h38-0-82" class="i">+// Note: GitHub allows for comments to be created for non-existing files and positions.
</a><a href="#h38-0-83" id="h38-0-83" class="i">+//
</a><a href="#h38-0-84" id="h38-0-84" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/comments/#create-a-commit-comment
</a><a href="#h38-0-85" id="h38-0-85" class="i">+func (s *RepositoriesService) CreateComment(owner, repo, sha string, comment *RepositoryComment) (*RepositoryComment, *Response, error) {
</a><a href="#h38-0-86" id="h38-0-86" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/commits/%v/comments&quot;, owner, repo, sha)
</a><a href="#h38-0-87" id="h38-0-87" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, comment)
</a><a href="#h38-0-88" id="h38-0-88" class="i">+	if err != nil {
</a><a href="#h38-0-89" id="h38-0-89" class="i">+		return nil, nil, err
</a><a href="#h38-0-90" id="h38-0-90" class="i">+	}
</a><a href="#h38-0-91" id="h38-0-91" class="i">+
</a><a href="#h38-0-92" id="h38-0-92" class="i">+	c := new(RepositoryComment)
</a><a href="#h38-0-93" id="h38-0-93" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h38-0-94" id="h38-0-94" class="i">+	if err != nil {
</a><a href="#h38-0-95" id="h38-0-95" class="i">+		return nil, resp, err
</a><a href="#h38-0-96" id="h38-0-96" class="i">+	}
</a><a href="#h38-0-97" id="h38-0-97" class="i">+
</a><a href="#h38-0-98" id="h38-0-98" class="i">+	return c, resp, err
</a><a href="#h38-0-99" id="h38-0-99" class="i">+}
</a><a href="#h38-0-100" id="h38-0-100" class="i">+
</a><a href="#h38-0-101" id="h38-0-101" class="i">+// GetComment gets a single comment from a repository.
</a><a href="#h38-0-102" id="h38-0-102" class="i">+//
</a><a href="#h38-0-103" id="h38-0-103" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/comments/#get-a-single-commit-comment
</a><a href="#h38-0-104" id="h38-0-104" class="i">+func (s *RepositoriesService) GetComment(owner, repo string, id int) (*RepositoryComment, *Response, error) {
</a><a href="#h38-0-105" id="h38-0-105" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/comments/%v&quot;, owner, repo, id)
</a><a href="#h38-0-106" id="h38-0-106" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h38-0-107" id="h38-0-107" class="i">+	if err != nil {
</a><a href="#h38-0-108" id="h38-0-108" class="i">+		return nil, nil, err
</a><a href="#h38-0-109" id="h38-0-109" class="i">+	}
</a><a href="#h38-0-110" id="h38-0-110" class="i">+
</a><a href="#h38-0-111" id="h38-0-111" class="i">+	c := new(RepositoryComment)
</a><a href="#h38-0-112" id="h38-0-112" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h38-0-113" id="h38-0-113" class="i">+	if err != nil {
</a><a href="#h38-0-114" id="h38-0-114" class="i">+		return nil, resp, err
</a><a href="#h38-0-115" id="h38-0-115" class="i">+	}
</a><a href="#h38-0-116" id="h38-0-116" class="i">+
</a><a href="#h38-0-117" id="h38-0-117" class="i">+	return c, resp, err
</a><a href="#h38-0-118" id="h38-0-118" class="i">+}
</a><a href="#h38-0-119" id="h38-0-119" class="i">+
</a><a href="#h38-0-120" id="h38-0-120" class="i">+// UpdateComment updates the body of a single comment.
</a><a href="#h38-0-121" id="h38-0-121" class="i">+//
</a><a href="#h38-0-122" id="h38-0-122" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/comments/#update-a-commit-comment
</a><a href="#h38-0-123" id="h38-0-123" class="i">+func (s *RepositoriesService) UpdateComment(owner, repo string, id int, comment *RepositoryComment) (*RepositoryComment, *Response, error) {
</a><a href="#h38-0-124" id="h38-0-124" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/comments/%v&quot;, owner, repo, id)
</a><a href="#h38-0-125" id="h38-0-125" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, comment)
</a><a href="#h38-0-126" id="h38-0-126" class="i">+	if err != nil {
</a><a href="#h38-0-127" id="h38-0-127" class="i">+		return nil, nil, err
</a><a href="#h38-0-128" id="h38-0-128" class="i">+	}
</a><a href="#h38-0-129" id="h38-0-129" class="i">+
</a><a href="#h38-0-130" id="h38-0-130" class="i">+	c := new(RepositoryComment)
</a><a href="#h38-0-131" id="h38-0-131" class="i">+	resp, err := s.client.Do(req, c)
</a><a href="#h38-0-132" id="h38-0-132" class="i">+	if err != nil {
</a><a href="#h38-0-133" id="h38-0-133" class="i">+		return nil, resp, err
</a><a href="#h38-0-134" id="h38-0-134" class="i">+	}
</a><a href="#h38-0-135" id="h38-0-135" class="i">+
</a><a href="#h38-0-136" id="h38-0-136" class="i">+	return c, resp, err
</a><a href="#h38-0-137" id="h38-0-137" class="i">+}
</a><a href="#h38-0-138" id="h38-0-138" class="i">+
</a><a href="#h38-0-139" id="h38-0-139" class="i">+// DeleteComment deletes a single comment from a repository.
</a><a href="#h38-0-140" id="h38-0-140" class="i">+//
</a><a href="#h38-0-141" id="h38-0-141" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/comments/#delete-a-commit-comment
</a><a href="#h38-0-142" id="h38-0-142" class="i">+func (s *RepositoriesService) DeleteComment(owner, repo string, id int) (*Response, error) {
</a><a href="#h38-0-143" id="h38-0-143" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/comments/%v&quot;, owner, repo, id)
</a><a href="#h38-0-144" id="h38-0-144" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h38-0-145" id="h38-0-145" class="i">+	if err != nil {
</a><a href="#h38-0-146" id="h38-0-146" class="i">+		return nil, err
</a><a href="#h38-0-147" id="h38-0-147" class="i">+	}
</a><a href="#h38-0-148" id="h38-0-148" class="i">+	return s.client.Do(req, nil)
</a><a href="#h38-0-149" id="h38-0-149" class="i">+}
</a><b>diff --git a/<a id="h39" href="../file/vendor/github.com/google/go-github/github/repos_commits.go">vendor/github.com/google/go-github/github/repos_commits.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_commits.go">vendor/github.com/google/go-github/github/repos_commits.go</a></b>
<a href="#h39-0" id="h39-0" class="h">@@ -0,0 +1,196 @@
</a><a href="#h39-0-0" id="h39-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h39-0-1" id="h39-0-1" class="i">+//
</a><a href="#h39-0-2" id="h39-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h39-0-3" id="h39-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h39-0-4" id="h39-0-4" class="i">+
</a><a href="#h39-0-5" id="h39-0-5" class="i">+package github
</a><a href="#h39-0-6" id="h39-0-6" class="i">+
</a><a href="#h39-0-7" id="h39-0-7" class="i">+import (
</a><a href="#h39-0-8" id="h39-0-8" class="i">+	&quot;bytes&quot;
</a><a href="#h39-0-9" id="h39-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h39-0-10" id="h39-0-10" class="i">+	&quot;time&quot;
</a><a href="#h39-0-11" id="h39-0-11" class="i">+)
</a><a href="#h39-0-12" id="h39-0-12" class="i">+
</a><a href="#h39-0-13" id="h39-0-13" class="i">+// RepositoryCommit represents a commit in a repo.
</a><a href="#h39-0-14" id="h39-0-14" class="i">+// Note that it&#39;s wrapping a Commit, so author/committer information is in two places,
</a><a href="#h39-0-15" id="h39-0-15" class="i">+// but contain different details about them: in RepositoryCommit &quot;github details&quot;, in Commit - &quot;git details&quot;.
</a><a href="#h39-0-16" id="h39-0-16" class="i">+type RepositoryCommit struct {
</a><a href="#h39-0-17" id="h39-0-17" class="i">+	SHA       *string  `json:&quot;sha,omitempty&quot;`
</a><a href="#h39-0-18" id="h39-0-18" class="i">+	Commit    *Commit  `json:&quot;commit,omitempty&quot;`
</a><a href="#h39-0-19" id="h39-0-19" class="i">+	Author    *User    `json:&quot;author,omitempty&quot;`
</a><a href="#h39-0-20" id="h39-0-20" class="i">+	Committer *User    `json:&quot;committer,omitempty&quot;`
</a><a href="#h39-0-21" id="h39-0-21" class="i">+	Parents   []Commit `json:&quot;parents,omitempty&quot;`
</a><a href="#h39-0-22" id="h39-0-22" class="i">+	Message   *string  `json:&quot;message,omitempty&quot;`
</a><a href="#h39-0-23" id="h39-0-23" class="i">+	HTMLURL   *string  `json:&quot;html_url,omitempty&quot;`
</a><a href="#h39-0-24" id="h39-0-24" class="i">+
</a><a href="#h39-0-25" id="h39-0-25" class="i">+	// Details about how many changes were made in this commit. Only filled in during GetCommit!
</a><a href="#h39-0-26" id="h39-0-26" class="i">+	Stats *CommitStats `json:&quot;stats,omitempty&quot;`
</a><a href="#h39-0-27" id="h39-0-27" class="i">+	// Details about which files, and how this commit touched. Only filled in during GetCommit!
</a><a href="#h39-0-28" id="h39-0-28" class="i">+	Files []CommitFile `json:&quot;files,omitempty&quot;`
</a><a href="#h39-0-29" id="h39-0-29" class="i">+}
</a><a href="#h39-0-30" id="h39-0-30" class="i">+
</a><a href="#h39-0-31" id="h39-0-31" class="i">+func (r RepositoryCommit) String() string {
</a><a href="#h39-0-32" id="h39-0-32" class="i">+	return Stringify(r)
</a><a href="#h39-0-33" id="h39-0-33" class="i">+}
</a><a href="#h39-0-34" id="h39-0-34" class="i">+
</a><a href="#h39-0-35" id="h39-0-35" class="i">+// CommitStats represents the number of additions / deletions from a file in a given RepositoryCommit.
</a><a href="#h39-0-36" id="h39-0-36" class="i">+type CommitStats struct {
</a><a href="#h39-0-37" id="h39-0-37" class="i">+	Additions *int `json:&quot;additions,omitempty&quot;`
</a><a href="#h39-0-38" id="h39-0-38" class="i">+	Deletions *int `json:&quot;deletions,omitempty&quot;`
</a><a href="#h39-0-39" id="h39-0-39" class="i">+	Total     *int `json:&quot;total,omitempty&quot;`
</a><a href="#h39-0-40" id="h39-0-40" class="i">+}
</a><a href="#h39-0-41" id="h39-0-41" class="i">+
</a><a href="#h39-0-42" id="h39-0-42" class="i">+func (c CommitStats) String() string {
</a><a href="#h39-0-43" id="h39-0-43" class="i">+	return Stringify(c)
</a><a href="#h39-0-44" id="h39-0-44" class="i">+}
</a><a href="#h39-0-45" id="h39-0-45" class="i">+
</a><a href="#h39-0-46" id="h39-0-46" class="i">+// CommitFile represents a file modified in a commit.
</a><a href="#h39-0-47" id="h39-0-47" class="i">+type CommitFile struct {
</a><a href="#h39-0-48" id="h39-0-48" class="i">+	SHA       *string `json:&quot;sha,omitempty&quot;`
</a><a href="#h39-0-49" id="h39-0-49" class="i">+	Filename  *string `json:&quot;filename,omitempty&quot;`
</a><a href="#h39-0-50" id="h39-0-50" class="i">+	Additions *int    `json:&quot;additions,omitempty&quot;`
</a><a href="#h39-0-51" id="h39-0-51" class="i">+	Deletions *int    `json:&quot;deletions,omitempty&quot;`
</a><a href="#h39-0-52" id="h39-0-52" class="i">+	Changes   *int    `json:&quot;changes,omitempty&quot;`
</a><a href="#h39-0-53" id="h39-0-53" class="i">+	Status    *string `json:&quot;status,omitempty&quot;`
</a><a href="#h39-0-54" id="h39-0-54" class="i">+	Patch     *string `json:&quot;patch,omitempty&quot;`
</a><a href="#h39-0-55" id="h39-0-55" class="i">+}
</a><a href="#h39-0-56" id="h39-0-56" class="i">+
</a><a href="#h39-0-57" id="h39-0-57" class="i">+func (c CommitFile) String() string {
</a><a href="#h39-0-58" id="h39-0-58" class="i">+	return Stringify(c)
</a><a href="#h39-0-59" id="h39-0-59" class="i">+}
</a><a href="#h39-0-60" id="h39-0-60" class="i">+
</a><a href="#h39-0-61" id="h39-0-61" class="i">+// CommitsComparison is the result of comparing two commits.
</a><a href="#h39-0-62" id="h39-0-62" class="i">+// See CompareCommits() for details.
</a><a href="#h39-0-63" id="h39-0-63" class="i">+type CommitsComparison struct {
</a><a href="#h39-0-64" id="h39-0-64" class="i">+	BaseCommit      *RepositoryCommit `json:&quot;base_commit,omitempty&quot;`
</a><a href="#h39-0-65" id="h39-0-65" class="i">+	MergeBaseCommit *RepositoryCommit `json:&quot;merge_base_commit,omitempty&quot;`
</a><a href="#h39-0-66" id="h39-0-66" class="i">+
</a><a href="#h39-0-67" id="h39-0-67" class="i">+	// Head can be &#39;behind&#39; or &#39;ahead&#39;
</a><a href="#h39-0-68" id="h39-0-68" class="i">+	Status       *string `json:&quot;status,omitempty&quot;`
</a><a href="#h39-0-69" id="h39-0-69" class="i">+	AheadBy      *int    `json:&quot;ahead_by,omitempty&quot;`
</a><a href="#h39-0-70" id="h39-0-70" class="i">+	BehindBy     *int    `json:&quot;behind_by,omitempty&quot;`
</a><a href="#h39-0-71" id="h39-0-71" class="i">+	TotalCommits *int    `json:&quot;total_commits,omitempty&quot;`
</a><a href="#h39-0-72" id="h39-0-72" class="i">+
</a><a href="#h39-0-73" id="h39-0-73" class="i">+	Commits []RepositoryCommit `json:&quot;commits,omitempty&quot;`
</a><a href="#h39-0-74" id="h39-0-74" class="i">+
</a><a href="#h39-0-75" id="h39-0-75" class="i">+	Files []CommitFile `json:&quot;files,omitempty&quot;`
</a><a href="#h39-0-76" id="h39-0-76" class="i">+}
</a><a href="#h39-0-77" id="h39-0-77" class="i">+
</a><a href="#h39-0-78" id="h39-0-78" class="i">+func (c CommitsComparison) String() string {
</a><a href="#h39-0-79" id="h39-0-79" class="i">+	return Stringify(c)
</a><a href="#h39-0-80" id="h39-0-80" class="i">+}
</a><a href="#h39-0-81" id="h39-0-81" class="i">+
</a><a href="#h39-0-82" id="h39-0-82" class="i">+// CommitsListOptions specifies the optional parameters to the
</a><a href="#h39-0-83" id="h39-0-83" class="i">+// RepositoriesService.ListCommits method.
</a><a href="#h39-0-84" id="h39-0-84" class="i">+type CommitsListOptions struct {
</a><a href="#h39-0-85" id="h39-0-85" class="i">+	// SHA or branch to start listing Commits from.
</a><a href="#h39-0-86" id="h39-0-86" class="i">+	SHA string `url:&quot;sha,omitempty&quot;`
</a><a href="#h39-0-87" id="h39-0-87" class="i">+
</a><a href="#h39-0-88" id="h39-0-88" class="i">+	// Path that should be touched by the returned Commits.
</a><a href="#h39-0-89" id="h39-0-89" class="i">+	Path string `url:&quot;path,omitempty&quot;`
</a><a href="#h39-0-90" id="h39-0-90" class="i">+
</a><a href="#h39-0-91" id="h39-0-91" class="i">+	// Author of by which to filter Commits.
</a><a href="#h39-0-92" id="h39-0-92" class="i">+	Author string `url:&quot;author,omitempty&quot;`
</a><a href="#h39-0-93" id="h39-0-93" class="i">+
</a><a href="#h39-0-94" id="h39-0-94" class="i">+	// Since when should Commits be included in the response.
</a><a href="#h39-0-95" id="h39-0-95" class="i">+	Since time.Time `url:&quot;since,omitempty&quot;`
</a><a href="#h39-0-96" id="h39-0-96" class="i">+
</a><a href="#h39-0-97" id="h39-0-97" class="i">+	// Until when should Commits be included in the response.
</a><a href="#h39-0-98" id="h39-0-98" class="i">+	Until time.Time `url:&quot;until,omitempty&quot;`
</a><a href="#h39-0-99" id="h39-0-99" class="i">+
</a><a href="#h39-0-100" id="h39-0-100" class="i">+	ListOptions
</a><a href="#h39-0-101" id="h39-0-101" class="i">+}
</a><a href="#h39-0-102" id="h39-0-102" class="i">+
</a><a href="#h39-0-103" id="h39-0-103" class="i">+// ListCommits lists the commits of a repository.
</a><a href="#h39-0-104" id="h39-0-104" class="i">+//
</a><a href="#h39-0-105" id="h39-0-105" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/commits/#list
</a><a href="#h39-0-106" id="h39-0-106" class="i">+func (s *RepositoriesService) ListCommits(owner, repo string, opt *CommitsListOptions) ([]RepositoryCommit, *Response, error) {
</a><a href="#h39-0-107" id="h39-0-107" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/commits&quot;, owner, repo)
</a><a href="#h39-0-108" id="h39-0-108" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h39-0-109" id="h39-0-109" class="i">+	if err != nil {
</a><a href="#h39-0-110" id="h39-0-110" class="i">+		return nil, nil, err
</a><a href="#h39-0-111" id="h39-0-111" class="i">+	}
</a><a href="#h39-0-112" id="h39-0-112" class="i">+
</a><a href="#h39-0-113" id="h39-0-113" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h39-0-114" id="h39-0-114" class="i">+	if err != nil {
</a><a href="#h39-0-115" id="h39-0-115" class="i">+		return nil, nil, err
</a><a href="#h39-0-116" id="h39-0-116" class="i">+	}
</a><a href="#h39-0-117" id="h39-0-117" class="i">+
</a><a href="#h39-0-118" id="h39-0-118" class="i">+	commits := new([]RepositoryCommit)
</a><a href="#h39-0-119" id="h39-0-119" class="i">+	resp, err := s.client.Do(req, commits)
</a><a href="#h39-0-120" id="h39-0-120" class="i">+	if err != nil {
</a><a href="#h39-0-121" id="h39-0-121" class="i">+		return nil, resp, err
</a><a href="#h39-0-122" id="h39-0-122" class="i">+	}
</a><a href="#h39-0-123" id="h39-0-123" class="i">+
</a><a href="#h39-0-124" id="h39-0-124" class="i">+	return *commits, resp, err
</a><a href="#h39-0-125" id="h39-0-125" class="i">+}
</a><a href="#h39-0-126" id="h39-0-126" class="i">+
</a><a href="#h39-0-127" id="h39-0-127" class="i">+// GetCommit fetches the specified commit, including all details about it.
</a><a href="#h39-0-128" id="h39-0-128" class="i">+// todo: support media formats - https://github.com/google/go-github/issues/6
</a><a href="#h39-0-129" id="h39-0-129" class="i">+//
</a><a href="#h39-0-130" id="h39-0-130" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/commits/#get-a-single-commit
</a><a href="#h39-0-131" id="h39-0-131" class="i">+// See also: http://developer.github.com//v3/git/commits/#get-a-single-commit provides the same functionality
</a><a href="#h39-0-132" id="h39-0-132" class="i">+func (s *RepositoriesService) GetCommit(owner, repo, sha string) (*RepositoryCommit, *Response, error) {
</a><a href="#h39-0-133" id="h39-0-133" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/commits/%v&quot;, owner, repo, sha)
</a><a href="#h39-0-134" id="h39-0-134" class="i">+
</a><a href="#h39-0-135" id="h39-0-135" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h39-0-136" id="h39-0-136" class="i">+	if err != nil {
</a><a href="#h39-0-137" id="h39-0-137" class="i">+		return nil, nil, err
</a><a href="#h39-0-138" id="h39-0-138" class="i">+	}
</a><a href="#h39-0-139" id="h39-0-139" class="i">+
</a><a href="#h39-0-140" id="h39-0-140" class="i">+	commit := new(RepositoryCommit)
</a><a href="#h39-0-141" id="h39-0-141" class="i">+	resp, err := s.client.Do(req, commit)
</a><a href="#h39-0-142" id="h39-0-142" class="i">+	if err != nil {
</a><a href="#h39-0-143" id="h39-0-143" class="i">+		return nil, resp, err
</a><a href="#h39-0-144" id="h39-0-144" class="i">+	}
</a><a href="#h39-0-145" id="h39-0-145" class="i">+
</a><a href="#h39-0-146" id="h39-0-146" class="i">+	return commit, resp, err
</a><a href="#h39-0-147" id="h39-0-147" class="i">+}
</a><a href="#h39-0-148" id="h39-0-148" class="i">+
</a><a href="#h39-0-149" id="h39-0-149" class="i">+// GetCommitSHA1 gets the SHA-1 of a commit reference.  If a last-known SHA1 is
</a><a href="#h39-0-150" id="h39-0-150" class="i">+// supplied and no new commits have occurred, a 304 Unmodified response is returned.
</a><a href="#h39-0-151" id="h39-0-151" class="i">+//
</a><a href="#h39-0-152" id="h39-0-152" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/commits/#get-the-sha-1-of-a-commit-reference
</a><a href="#h39-0-153" id="h39-0-153" class="i">+func (s *RepositoriesService) GetCommitSHA1(owner, repo, ref, lastSHA string) (string, *Response, error) {
</a><a href="#h39-0-154" id="h39-0-154" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/commits/%v&quot;, owner, repo, ref)
</a><a href="#h39-0-155" id="h39-0-155" class="i">+
</a><a href="#h39-0-156" id="h39-0-156" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h39-0-157" id="h39-0-157" class="i">+	if err != nil {
</a><a href="#h39-0-158" id="h39-0-158" class="i">+		return &quot;&quot;, nil, err
</a><a href="#h39-0-159" id="h39-0-159" class="i">+	}
</a><a href="#h39-0-160" id="h39-0-160" class="i">+	if lastSHA != &quot;&quot; {
</a><a href="#h39-0-161" id="h39-0-161" class="i">+		req.Header.Set(&quot;If-None-Match&quot;, `&quot;`+lastSHA+`&quot;`)
</a><a href="#h39-0-162" id="h39-0-162" class="i">+	}
</a><a href="#h39-0-163" id="h39-0-163" class="i">+
</a><a href="#h39-0-164" id="h39-0-164" class="i">+	// TODO: remove custom Accept header when this API fully launches.
</a><a href="#h39-0-165" id="h39-0-165" class="i">+	req.Header.Set(&quot;Accept&quot;, mediaTypeCommitReferenceSHAPreview)
</a><a href="#h39-0-166" id="h39-0-166" class="i">+
</a><a href="#h39-0-167" id="h39-0-167" class="i">+	var buf bytes.Buffer
</a><a href="#h39-0-168" id="h39-0-168" class="i">+	resp, err := s.client.Do(req, &amp;buf)
</a><a href="#h39-0-169" id="h39-0-169" class="i">+	if err != nil {
</a><a href="#h39-0-170" id="h39-0-170" class="i">+		return &quot;&quot;, resp, err
</a><a href="#h39-0-171" id="h39-0-171" class="i">+	}
</a><a href="#h39-0-172" id="h39-0-172" class="i">+
</a><a href="#h39-0-173" id="h39-0-173" class="i">+	return buf.String(), resp, err
</a><a href="#h39-0-174" id="h39-0-174" class="i">+}
</a><a href="#h39-0-175" id="h39-0-175" class="i">+
</a><a href="#h39-0-176" id="h39-0-176" class="i">+// CompareCommits compares a range of commits with each other.
</a><a href="#h39-0-177" id="h39-0-177" class="i">+// todo: support media formats - https://github.com/google/go-github/issues/6
</a><a href="#h39-0-178" id="h39-0-178" class="i">+//
</a><a href="#h39-0-179" id="h39-0-179" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/commits/index.html#compare-two-commits
</a><a href="#h39-0-180" id="h39-0-180" class="i">+func (s *RepositoriesService) CompareCommits(owner, repo string, base, head string) (*CommitsComparison, *Response, error) {
</a><a href="#h39-0-181" id="h39-0-181" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/compare/%v...%v&quot;, owner, repo, base, head)
</a><a href="#h39-0-182" id="h39-0-182" class="i">+
</a><a href="#h39-0-183" id="h39-0-183" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h39-0-184" id="h39-0-184" class="i">+	if err != nil {
</a><a href="#h39-0-185" id="h39-0-185" class="i">+		return nil, nil, err
</a><a href="#h39-0-186" id="h39-0-186" class="i">+	}
</a><a href="#h39-0-187" id="h39-0-187" class="i">+
</a><a href="#h39-0-188" id="h39-0-188" class="i">+	comp := new(CommitsComparison)
</a><a href="#h39-0-189" id="h39-0-189" class="i">+	resp, err := s.client.Do(req, comp)
</a><a href="#h39-0-190" id="h39-0-190" class="i">+	if err != nil {
</a><a href="#h39-0-191" id="h39-0-191" class="i">+		return nil, resp, err
</a><a href="#h39-0-192" id="h39-0-192" class="i">+	}
</a><a href="#h39-0-193" id="h39-0-193" class="i">+
</a><a href="#h39-0-194" id="h39-0-194" class="i">+	return comp, resp, err
</a><a href="#h39-0-195" id="h39-0-195" class="i">+}
</a><b>diff --git a/<a id="h40" href="../file/vendor/github.com/google/go-github/github/repos_contents.go">vendor/github.com/google/go-github/github/repos_contents.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_contents.go">vendor/github.com/google/go-github/github/repos_contents.go</a></b>
<a href="#h40-0" id="h40-0" class="h">@@ -0,0 +1,248 @@
</a><a href="#h40-0-0" id="h40-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h40-0-1" id="h40-0-1" class="i">+//
</a><a href="#h40-0-2" id="h40-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h40-0-3" id="h40-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h40-0-4" id="h40-0-4" class="i">+
</a><a href="#h40-0-5" id="h40-0-5" class="i">+// Repository contents API methods.
</a><a href="#h40-0-6" id="h40-0-6" class="i">+// http://developer.github.com/v3/repos/contents/
</a><a href="#h40-0-7" id="h40-0-7" class="i">+
</a><a href="#h40-0-8" id="h40-0-8" class="i">+package github
</a><a href="#h40-0-9" id="h40-0-9" class="i">+
</a><a href="#h40-0-10" id="h40-0-10" class="i">+import (
</a><a href="#h40-0-11" id="h40-0-11" class="i">+	&quot;encoding/base64&quot;
</a><a href="#h40-0-12" id="h40-0-12" class="i">+	&quot;encoding/json&quot;
</a><a href="#h40-0-13" id="h40-0-13" class="i">+	&quot;errors&quot;
</a><a href="#h40-0-14" id="h40-0-14" class="i">+	&quot;fmt&quot;
</a><a href="#h40-0-15" id="h40-0-15" class="i">+	&quot;io&quot;
</a><a href="#h40-0-16" id="h40-0-16" class="i">+	&quot;net/http&quot;
</a><a href="#h40-0-17" id="h40-0-17" class="i">+	&quot;net/url&quot;
</a><a href="#h40-0-18" id="h40-0-18" class="i">+	&quot;path&quot;
</a><a href="#h40-0-19" id="h40-0-19" class="i">+)
</a><a href="#h40-0-20" id="h40-0-20" class="i">+
</a><a href="#h40-0-21" id="h40-0-21" class="i">+// RepositoryContent represents a file or directory in a github repository.
</a><a href="#h40-0-22" id="h40-0-22" class="i">+type RepositoryContent struct {
</a><a href="#h40-0-23" id="h40-0-23" class="i">+	Type        *string `json:&quot;type,omitempty&quot;`
</a><a href="#h40-0-24" id="h40-0-24" class="i">+	Encoding    *string `json:&quot;encoding,omitempty&quot;`
</a><a href="#h40-0-25" id="h40-0-25" class="i">+	Size        *int    `json:&quot;size,omitempty&quot;`
</a><a href="#h40-0-26" id="h40-0-26" class="i">+	Name        *string `json:&quot;name,omitempty&quot;`
</a><a href="#h40-0-27" id="h40-0-27" class="i">+	Path        *string `json:&quot;path,omitempty&quot;`
</a><a href="#h40-0-28" id="h40-0-28" class="i">+	Content     *string `json:&quot;content,omitempty&quot;`
</a><a href="#h40-0-29" id="h40-0-29" class="i">+	SHA         *string `json:&quot;sha,omitempty&quot;`
</a><a href="#h40-0-30" id="h40-0-30" class="i">+	URL         *string `json:&quot;url,omitempty&quot;`
</a><a href="#h40-0-31" id="h40-0-31" class="i">+	GitURL      *string `json:&quot;git_url,omitempty&quot;`
</a><a href="#h40-0-32" id="h40-0-32" class="i">+	HTMLURL     *string `json:&quot;html_url,omitempty&quot;`
</a><a href="#h40-0-33" id="h40-0-33" class="i">+	DownloadURL *string `json:&quot;download_url,omitempty&quot;`
</a><a href="#h40-0-34" id="h40-0-34" class="i">+}
</a><a href="#h40-0-35" id="h40-0-35" class="i">+
</a><a href="#h40-0-36" id="h40-0-36" class="i">+// RepositoryContentResponse holds the parsed response from CreateFile, UpdateFile, and DeleteFile.
</a><a href="#h40-0-37" id="h40-0-37" class="i">+type RepositoryContentResponse struct {
</a><a href="#h40-0-38" id="h40-0-38" class="i">+	Content *RepositoryContent `json:&quot;content,omitempty&quot;`
</a><a href="#h40-0-39" id="h40-0-39" class="i">+	Commit  `json:&quot;commit,omitempty&quot;`
</a><a href="#h40-0-40" id="h40-0-40" class="i">+}
</a><a href="#h40-0-41" id="h40-0-41" class="i">+
</a><a href="#h40-0-42" id="h40-0-42" class="i">+// RepositoryContentFileOptions specifies optional parameters for CreateFile, UpdateFile, and DeleteFile.
</a><a href="#h40-0-43" id="h40-0-43" class="i">+type RepositoryContentFileOptions struct {
</a><a href="#h40-0-44" id="h40-0-44" class="i">+	Message   *string       `json:&quot;message,omitempty&quot;`
</a><a href="#h40-0-45" id="h40-0-45" class="i">+	Content   []byte        `json:&quot;content,omitempty&quot;` // unencoded
</a><a href="#h40-0-46" id="h40-0-46" class="i">+	SHA       *string       `json:&quot;sha,omitempty&quot;`
</a><a href="#h40-0-47" id="h40-0-47" class="i">+	Branch    *string       `json:&quot;branch,omitempty&quot;`
</a><a href="#h40-0-48" id="h40-0-48" class="i">+	Author    *CommitAuthor `json:&quot;author,omitempty&quot;`
</a><a href="#h40-0-49" id="h40-0-49" class="i">+	Committer *CommitAuthor `json:&quot;committer,omitempty&quot;`
</a><a href="#h40-0-50" id="h40-0-50" class="i">+}
</a><a href="#h40-0-51" id="h40-0-51" class="i">+
</a><a href="#h40-0-52" id="h40-0-52" class="i">+// RepositoryContentGetOptions represents an optional ref parameter, which can be a SHA,
</a><a href="#h40-0-53" id="h40-0-53" class="i">+// branch, or tag
</a><a href="#h40-0-54" id="h40-0-54" class="i">+type RepositoryContentGetOptions struct {
</a><a href="#h40-0-55" id="h40-0-55" class="i">+	Ref string `url:&quot;ref,omitempty&quot;`
</a><a href="#h40-0-56" id="h40-0-56" class="i">+}
</a><a href="#h40-0-57" id="h40-0-57" class="i">+
</a><a href="#h40-0-58" id="h40-0-58" class="i">+func (r RepositoryContent) String() string {
</a><a href="#h40-0-59" id="h40-0-59" class="i">+	return Stringify(r)
</a><a href="#h40-0-60" id="h40-0-60" class="i">+}
</a><a href="#h40-0-61" id="h40-0-61" class="i">+
</a><a href="#h40-0-62" id="h40-0-62" class="i">+// Decode decodes the file content if it is base64 encoded.
</a><a href="#h40-0-63" id="h40-0-63" class="i">+func (r *RepositoryContent) Decode() ([]byte, error) {
</a><a href="#h40-0-64" id="h40-0-64" class="i">+	if *r.Encoding != &quot;base64&quot; {
</a><a href="#h40-0-65" id="h40-0-65" class="i">+		return nil, errors.New(&quot;cannot decode non-base64&quot;)
</a><a href="#h40-0-66" id="h40-0-66" class="i">+	}
</a><a href="#h40-0-67" id="h40-0-67" class="i">+	o, err := base64.StdEncoding.DecodeString(*r.Content)
</a><a href="#h40-0-68" id="h40-0-68" class="i">+	if err != nil {
</a><a href="#h40-0-69" id="h40-0-69" class="i">+		return nil, err
</a><a href="#h40-0-70" id="h40-0-70" class="i">+	}
</a><a href="#h40-0-71" id="h40-0-71" class="i">+	return o, nil
</a><a href="#h40-0-72" id="h40-0-72" class="i">+}
</a><a href="#h40-0-73" id="h40-0-73" class="i">+
</a><a href="#h40-0-74" id="h40-0-74" class="i">+// GetReadme gets the Readme file for the repository.
</a><a href="#h40-0-75" id="h40-0-75" class="i">+//
</a><a href="#h40-0-76" id="h40-0-76" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/contents/#get-the-readme
</a><a href="#h40-0-77" id="h40-0-77" class="i">+func (s *RepositoriesService) GetReadme(owner, repo string, opt *RepositoryContentGetOptions) (*RepositoryContent, *Response, error) {
</a><a href="#h40-0-78" id="h40-0-78" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/readme&quot;, owner, repo)
</a><a href="#h40-0-79" id="h40-0-79" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h40-0-80" id="h40-0-80" class="i">+	if err != nil {
</a><a href="#h40-0-81" id="h40-0-81" class="i">+		return nil, nil, err
</a><a href="#h40-0-82" id="h40-0-82" class="i">+	}
</a><a href="#h40-0-83" id="h40-0-83" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h40-0-84" id="h40-0-84" class="i">+	if err != nil {
</a><a href="#h40-0-85" id="h40-0-85" class="i">+		return nil, nil, err
</a><a href="#h40-0-86" id="h40-0-86" class="i">+	}
</a><a href="#h40-0-87" id="h40-0-87" class="i">+	readme := new(RepositoryContent)
</a><a href="#h40-0-88" id="h40-0-88" class="i">+	resp, err := s.client.Do(req, readme)
</a><a href="#h40-0-89" id="h40-0-89" class="i">+	if err != nil {
</a><a href="#h40-0-90" id="h40-0-90" class="i">+		return nil, resp, err
</a><a href="#h40-0-91" id="h40-0-91" class="i">+	}
</a><a href="#h40-0-92" id="h40-0-92" class="i">+	return readme, resp, err
</a><a href="#h40-0-93" id="h40-0-93" class="i">+}
</a><a href="#h40-0-94" id="h40-0-94" class="i">+
</a><a href="#h40-0-95" id="h40-0-95" class="i">+// DownloadContents returns an io.ReadCloser that reads the contents of the
</a><a href="#h40-0-96" id="h40-0-96" class="i">+// specified file. This function will work with files of any size, as opposed
</a><a href="#h40-0-97" id="h40-0-97" class="i">+// to GetContents which is limited to 1 Mb files. It is the caller&#39;s
</a><a href="#h40-0-98" id="h40-0-98" class="i">+// responsibility to close the ReadCloser.
</a><a href="#h40-0-99" id="h40-0-99" class="i">+func (s *RepositoriesService) DownloadContents(owner, repo, filepath string, opt *RepositoryContentGetOptions) (io.ReadCloser, error) {
</a><a href="#h40-0-100" id="h40-0-100" class="i">+	dir := path.Dir(filepath)
</a><a href="#h40-0-101" id="h40-0-101" class="i">+	filename := path.Base(filepath)
</a><a href="#h40-0-102" id="h40-0-102" class="i">+	_, dirContents, _, err := s.GetContents(owner, repo, dir, opt)
</a><a href="#h40-0-103" id="h40-0-103" class="i">+	if err != nil {
</a><a href="#h40-0-104" id="h40-0-104" class="i">+		return nil, err
</a><a href="#h40-0-105" id="h40-0-105" class="i">+	}
</a><a href="#h40-0-106" id="h40-0-106" class="i">+	for _, contents := range dirContents {
</a><a href="#h40-0-107" id="h40-0-107" class="i">+		if *contents.Name == filename {
</a><a href="#h40-0-108" id="h40-0-108" class="i">+			if contents.DownloadURL == nil || *contents.DownloadURL == &quot;&quot; {
</a><a href="#h40-0-109" id="h40-0-109" class="i">+				return nil, fmt.Errorf(&quot;No download link found for %s&quot;, filepath)
</a><a href="#h40-0-110" id="h40-0-110" class="i">+			}
</a><a href="#h40-0-111" id="h40-0-111" class="i">+			resp, err := s.client.client.Get(*contents.DownloadURL)
</a><a href="#h40-0-112" id="h40-0-112" class="i">+			if err != nil {
</a><a href="#h40-0-113" id="h40-0-113" class="i">+				return nil, err
</a><a href="#h40-0-114" id="h40-0-114" class="i">+			}
</a><a href="#h40-0-115" id="h40-0-115" class="i">+			return resp.Body, nil
</a><a href="#h40-0-116" id="h40-0-116" class="i">+		}
</a><a href="#h40-0-117" id="h40-0-117" class="i">+	}
</a><a href="#h40-0-118" id="h40-0-118" class="i">+	return nil, fmt.Errorf(&quot;No file named %s found in %s&quot;, filename, dir)
</a><a href="#h40-0-119" id="h40-0-119" class="i">+}
</a><a href="#h40-0-120" id="h40-0-120" class="i">+
</a><a href="#h40-0-121" id="h40-0-121" class="i">+// GetContents can return either the metadata and content of a single file
</a><a href="#h40-0-122" id="h40-0-122" class="i">+// (when path references a file) or the metadata of all the files and/or
</a><a href="#h40-0-123" id="h40-0-123" class="i">+// subdirectories of a directory (when path references a directory). To make it
</a><a href="#h40-0-124" id="h40-0-124" class="i">+// easy to distinguish between both result types and to mimic the API as much
</a><a href="#h40-0-125" id="h40-0-125" class="i">+// as possible, both result types will be returned but only one will contain a
</a><a href="#h40-0-126" id="h40-0-126" class="i">+// value and the other will be nil.
</a><a href="#h40-0-127" id="h40-0-127" class="i">+//
</a><a href="#h40-0-128" id="h40-0-128" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/contents/#get-contents
</a><a href="#h40-0-129" id="h40-0-129" class="i">+func (s *RepositoriesService) GetContents(owner, repo, path string, opt *RepositoryContentGetOptions) (fileContent *RepositoryContent, directoryContent []*RepositoryContent, resp *Response, err error) {
</a><a href="#h40-0-130" id="h40-0-130" class="i">+	escapedPath := (&amp;url.URL{Path: path}).String()
</a><a href="#h40-0-131" id="h40-0-131" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/contents/%s&quot;, owner, repo, escapedPath)
</a><a href="#h40-0-132" id="h40-0-132" class="i">+	u, err = addOptions(u, opt)
</a><a href="#h40-0-133" id="h40-0-133" class="i">+	if err != nil {
</a><a href="#h40-0-134" id="h40-0-134" class="i">+		return nil, nil, nil, err
</a><a href="#h40-0-135" id="h40-0-135" class="i">+	}
</a><a href="#h40-0-136" id="h40-0-136" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h40-0-137" id="h40-0-137" class="i">+	if err != nil {
</a><a href="#h40-0-138" id="h40-0-138" class="i">+		return nil, nil, nil, err
</a><a href="#h40-0-139" id="h40-0-139" class="i">+	}
</a><a href="#h40-0-140" id="h40-0-140" class="i">+	var rawJSON json.RawMessage
</a><a href="#h40-0-141" id="h40-0-141" class="i">+	resp, err = s.client.Do(req, &amp;rawJSON)
</a><a href="#h40-0-142" id="h40-0-142" class="i">+	if err != nil {
</a><a href="#h40-0-143" id="h40-0-143" class="i">+		return nil, nil, resp, err
</a><a href="#h40-0-144" id="h40-0-144" class="i">+	}
</a><a href="#h40-0-145" id="h40-0-145" class="i">+	fileUnmarshalError := json.Unmarshal(rawJSON, &amp;fileContent)
</a><a href="#h40-0-146" id="h40-0-146" class="i">+	if fileUnmarshalError == nil {
</a><a href="#h40-0-147" id="h40-0-147" class="i">+		return fileContent, nil, resp, fileUnmarshalError
</a><a href="#h40-0-148" id="h40-0-148" class="i">+	}
</a><a href="#h40-0-149" id="h40-0-149" class="i">+	directoryUnmarshalError := json.Unmarshal(rawJSON, &amp;directoryContent)
</a><a href="#h40-0-150" id="h40-0-150" class="i">+	if directoryUnmarshalError == nil {
</a><a href="#h40-0-151" id="h40-0-151" class="i">+		return nil, directoryContent, resp, directoryUnmarshalError
</a><a href="#h40-0-152" id="h40-0-152" class="i">+	}
</a><a href="#h40-0-153" id="h40-0-153" class="i">+	return nil, nil, resp, fmt.Errorf(&quot;unmarshalling failed for both file and directory content: %s and %s &quot;, fileUnmarshalError, directoryUnmarshalError)
</a><a href="#h40-0-154" id="h40-0-154" class="i">+}
</a><a href="#h40-0-155" id="h40-0-155" class="i">+
</a><a href="#h40-0-156" id="h40-0-156" class="i">+// CreateFile creates a new file in a repository at the given path and returns
</a><a href="#h40-0-157" id="h40-0-157" class="i">+// the commit and file metadata.
</a><a href="#h40-0-158" id="h40-0-158" class="i">+//
</a><a href="#h40-0-159" id="h40-0-159" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/contents/#create-a-file
</a><a href="#h40-0-160" id="h40-0-160" class="i">+func (s *RepositoriesService) CreateFile(owner, repo, path string, opt *RepositoryContentFileOptions) (*RepositoryContentResponse, *Response, error) {
</a><a href="#h40-0-161" id="h40-0-161" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/contents/%s&quot;, owner, repo, path)
</a><a href="#h40-0-162" id="h40-0-162" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, opt)
</a><a href="#h40-0-163" id="h40-0-163" class="i">+	if err != nil {
</a><a href="#h40-0-164" id="h40-0-164" class="i">+		return nil, nil, err
</a><a href="#h40-0-165" id="h40-0-165" class="i">+	}
</a><a href="#h40-0-166" id="h40-0-166" class="i">+	createResponse := new(RepositoryContentResponse)
</a><a href="#h40-0-167" id="h40-0-167" class="i">+	resp, err := s.client.Do(req, createResponse)
</a><a href="#h40-0-168" id="h40-0-168" class="i">+	if err != nil {
</a><a href="#h40-0-169" id="h40-0-169" class="i">+		return nil, resp, err
</a><a href="#h40-0-170" id="h40-0-170" class="i">+	}
</a><a href="#h40-0-171" id="h40-0-171" class="i">+	return createResponse, resp, err
</a><a href="#h40-0-172" id="h40-0-172" class="i">+}
</a><a href="#h40-0-173" id="h40-0-173" class="i">+
</a><a href="#h40-0-174" id="h40-0-174" class="i">+// UpdateFile updates a file in a repository at the given path and returns the
</a><a href="#h40-0-175" id="h40-0-175" class="i">+// commit and file metadata. Requires the blob SHA of the file being updated.
</a><a href="#h40-0-176" id="h40-0-176" class="i">+//
</a><a href="#h40-0-177" id="h40-0-177" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/contents/#update-a-file
</a><a href="#h40-0-178" id="h40-0-178" class="i">+func (s *RepositoriesService) UpdateFile(owner, repo, path string, opt *RepositoryContentFileOptions) (*RepositoryContentResponse, *Response, error) {
</a><a href="#h40-0-179" id="h40-0-179" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/contents/%s&quot;, owner, repo, path)
</a><a href="#h40-0-180" id="h40-0-180" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, opt)
</a><a href="#h40-0-181" id="h40-0-181" class="i">+	if err != nil {
</a><a href="#h40-0-182" id="h40-0-182" class="i">+		return nil, nil, err
</a><a href="#h40-0-183" id="h40-0-183" class="i">+	}
</a><a href="#h40-0-184" id="h40-0-184" class="i">+	updateResponse := new(RepositoryContentResponse)
</a><a href="#h40-0-185" id="h40-0-185" class="i">+	resp, err := s.client.Do(req, updateResponse)
</a><a href="#h40-0-186" id="h40-0-186" class="i">+	if err != nil {
</a><a href="#h40-0-187" id="h40-0-187" class="i">+		return nil, resp, err
</a><a href="#h40-0-188" id="h40-0-188" class="i">+	}
</a><a href="#h40-0-189" id="h40-0-189" class="i">+	return updateResponse, resp, err
</a><a href="#h40-0-190" id="h40-0-190" class="i">+}
</a><a href="#h40-0-191" id="h40-0-191" class="i">+
</a><a href="#h40-0-192" id="h40-0-192" class="i">+// DeleteFile deletes a file from a repository and returns the commit.
</a><a href="#h40-0-193" id="h40-0-193" class="i">+// Requires the blob SHA of the file to be deleted.
</a><a href="#h40-0-194" id="h40-0-194" class="i">+//
</a><a href="#h40-0-195" id="h40-0-195" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/contents/#delete-a-file
</a><a href="#h40-0-196" id="h40-0-196" class="i">+func (s *RepositoriesService) DeleteFile(owner, repo, path string, opt *RepositoryContentFileOptions) (*RepositoryContentResponse, *Response, error) {
</a><a href="#h40-0-197" id="h40-0-197" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/contents/%s&quot;, owner, repo, path)
</a><a href="#h40-0-198" id="h40-0-198" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, opt)
</a><a href="#h40-0-199" id="h40-0-199" class="i">+	if err != nil {
</a><a href="#h40-0-200" id="h40-0-200" class="i">+		return nil, nil, err
</a><a href="#h40-0-201" id="h40-0-201" class="i">+	}
</a><a href="#h40-0-202" id="h40-0-202" class="i">+	deleteResponse := new(RepositoryContentResponse)
</a><a href="#h40-0-203" id="h40-0-203" class="i">+	resp, err := s.client.Do(req, deleteResponse)
</a><a href="#h40-0-204" id="h40-0-204" class="i">+	if err != nil {
</a><a href="#h40-0-205" id="h40-0-205" class="i">+		return nil, resp, err
</a><a href="#h40-0-206" id="h40-0-206" class="i">+	}
</a><a href="#h40-0-207" id="h40-0-207" class="i">+	return deleteResponse, resp, err
</a><a href="#h40-0-208" id="h40-0-208" class="i">+}
</a><a href="#h40-0-209" id="h40-0-209" class="i">+
</a><a href="#h40-0-210" id="h40-0-210" class="i">+// archiveFormat is used to define the archive type when calling GetArchiveLink.
</a><a href="#h40-0-211" id="h40-0-211" class="i">+type archiveFormat string
</a><a href="#h40-0-212" id="h40-0-212" class="i">+
</a><a href="#h40-0-213" id="h40-0-213" class="i">+const (
</a><a href="#h40-0-214" id="h40-0-214" class="i">+	// Tarball specifies an archive in gzipped tar format.
</a><a href="#h40-0-215" id="h40-0-215" class="i">+	Tarball archiveFormat = &quot;tarball&quot;
</a><a href="#h40-0-216" id="h40-0-216" class="i">+
</a><a href="#h40-0-217" id="h40-0-217" class="i">+	// Zipball specifies an archive in zip format.
</a><a href="#h40-0-218" id="h40-0-218" class="i">+	Zipball archiveFormat = &quot;zipball&quot;
</a><a href="#h40-0-219" id="h40-0-219" class="i">+)
</a><a href="#h40-0-220" id="h40-0-220" class="i">+
</a><a href="#h40-0-221" id="h40-0-221" class="i">+// GetArchiveLink returns an URL to download a tarball or zipball archive for a
</a><a href="#h40-0-222" id="h40-0-222" class="i">+// repository. The archiveFormat can be specified by either the github.Tarball
</a><a href="#h40-0-223" id="h40-0-223" class="i">+// or github.Zipball constant.
</a><a href="#h40-0-224" id="h40-0-224" class="i">+//
</a><a href="#h40-0-225" id="h40-0-225" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/contents/#get-archive-link
</a><a href="#h40-0-226" id="h40-0-226" class="i">+func (s *RepositoriesService) GetArchiveLink(owner, repo string, archiveformat archiveFormat, opt *RepositoryContentGetOptions) (*url.URL, *Response, error) {
</a><a href="#h40-0-227" id="h40-0-227" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/%s&quot;, owner, repo, archiveformat)
</a><a href="#h40-0-228" id="h40-0-228" class="i">+	if opt != nil &amp;&amp; opt.Ref != &quot;&quot; {
</a><a href="#h40-0-229" id="h40-0-229" class="i">+		u += fmt.Sprintf(&quot;/%s&quot;, opt.Ref)
</a><a href="#h40-0-230" id="h40-0-230" class="i">+	}
</a><a href="#h40-0-231" id="h40-0-231" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h40-0-232" id="h40-0-232" class="i">+	if err != nil {
</a><a href="#h40-0-233" id="h40-0-233" class="i">+		return nil, nil, err
</a><a href="#h40-0-234" id="h40-0-234" class="i">+	}
</a><a href="#h40-0-235" id="h40-0-235" class="i">+	var resp *http.Response
</a><a href="#h40-0-236" id="h40-0-236" class="i">+	// Use http.DefaultTransport if no custom Transport is configured
</a><a href="#h40-0-237" id="h40-0-237" class="i">+	if s.client.client.Transport == nil {
</a><a href="#h40-0-238" id="h40-0-238" class="i">+		resp, err = http.DefaultTransport.RoundTrip(req)
</a><a href="#h40-0-239" id="h40-0-239" class="i">+	} else {
</a><a href="#h40-0-240" id="h40-0-240" class="i">+		resp, err = s.client.client.Transport.RoundTrip(req)
</a><a href="#h40-0-241" id="h40-0-241" class="i">+	}
</a><a href="#h40-0-242" id="h40-0-242" class="i">+	if err != nil || resp.StatusCode != http.StatusFound {
</a><a href="#h40-0-243" id="h40-0-243" class="i">+		return nil, newResponse(resp), err
</a><a href="#h40-0-244" id="h40-0-244" class="i">+	}
</a><a href="#h40-0-245" id="h40-0-245" class="i">+	parsedURL, err := url.Parse(resp.Header.Get(&quot;Location&quot;))
</a><a href="#h40-0-246" id="h40-0-246" class="i">+	return parsedURL, newResponse(resp), err
</a><a href="#h40-0-247" id="h40-0-247" class="i">+}
</a><b>diff --git a/<a id="h41" href="../file/vendor/github.com/google/go-github/github/repos_deployments.go">vendor/github.com/google/go-github/github/repos_deployments.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_deployments.go">vendor/github.com/google/go-github/github/repos_deployments.go</a></b>
<a href="#h41-0" id="h41-0" class="h">@@ -0,0 +1,168 @@
</a><a href="#h41-0-0" id="h41-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h41-0-1" id="h41-0-1" class="i">+//
</a><a href="#h41-0-2" id="h41-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h41-0-3" id="h41-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h41-0-4" id="h41-0-4" class="i">+
</a><a href="#h41-0-5" id="h41-0-5" class="i">+package github
</a><a href="#h41-0-6" id="h41-0-6" class="i">+
</a><a href="#h41-0-7" id="h41-0-7" class="i">+import (
</a><a href="#h41-0-8" id="h41-0-8" class="i">+	&quot;encoding/json&quot;
</a><a href="#h41-0-9" id="h41-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h41-0-10" id="h41-0-10" class="i">+)
</a><a href="#h41-0-11" id="h41-0-11" class="i">+
</a><a href="#h41-0-12" id="h41-0-12" class="i">+// Deployment represents a deployment in a repo
</a><a href="#h41-0-13" id="h41-0-13" class="i">+type Deployment struct {
</a><a href="#h41-0-14" id="h41-0-14" class="i">+	URL           *string         `json:&quot;url,omitempty&quot;`
</a><a href="#h41-0-15" id="h41-0-15" class="i">+	ID            *int            `json:&quot;id,omitempty&quot;`
</a><a href="#h41-0-16" id="h41-0-16" class="i">+	SHA           *string         `json:&quot;sha,omitempty&quot;`
</a><a href="#h41-0-17" id="h41-0-17" class="i">+	Ref           *string         `json:&quot;ref,omitempty&quot;`
</a><a href="#h41-0-18" id="h41-0-18" class="i">+	Task          *string         `json:&quot;task,omitempty&quot;`
</a><a href="#h41-0-19" id="h41-0-19" class="i">+	Payload       json.RawMessage `json:&quot;payload,omitempty&quot;`
</a><a href="#h41-0-20" id="h41-0-20" class="i">+	Environment   *string         `json:&quot;environment,omitempty&quot;`
</a><a href="#h41-0-21" id="h41-0-21" class="i">+	Description   *string         `json:&quot;description,omitempty&quot;`
</a><a href="#h41-0-22" id="h41-0-22" class="i">+	Creator       *User           `json:&quot;creator,omitempty&quot;`
</a><a href="#h41-0-23" id="h41-0-23" class="i">+	CreatedAt     *Timestamp      `json:&quot;created_at,omitempty&quot;`
</a><a href="#h41-0-24" id="h41-0-24" class="i">+	UpdatedAt     *Timestamp      `json:&quot;pushed_at,omitempty&quot;`
</a><a href="#h41-0-25" id="h41-0-25" class="i">+	StatusesURL   *string         `json:&quot;statuses_url,omitempty&quot;`
</a><a href="#h41-0-26" id="h41-0-26" class="i">+	RepositoryURL *string         `json:&quot;repository_url,omitempty&quot;`
</a><a href="#h41-0-27" id="h41-0-27" class="i">+}
</a><a href="#h41-0-28" id="h41-0-28" class="i">+
</a><a href="#h41-0-29" id="h41-0-29" class="i">+// DeploymentRequest represents a deployment request
</a><a href="#h41-0-30" id="h41-0-30" class="i">+type DeploymentRequest struct {
</a><a href="#h41-0-31" id="h41-0-31" class="i">+	Ref              *string   `json:&quot;ref,omitempty&quot;`
</a><a href="#h41-0-32" id="h41-0-32" class="i">+	Task             *string   `json:&quot;task,omitempty&quot;`
</a><a href="#h41-0-33" id="h41-0-33" class="i">+	AutoMerge        *bool     `json:&quot;auto_merge,omitempty&quot;`
</a><a href="#h41-0-34" id="h41-0-34" class="i">+	RequiredContexts *[]string `json:&quot;required_contexts,omitempty&quot;`
</a><a href="#h41-0-35" id="h41-0-35" class="i">+	Payload          *string   `json:&quot;payload,omitempty&quot;`
</a><a href="#h41-0-36" id="h41-0-36" class="i">+	Environment      *string   `json:&quot;environment,omitempty&quot;`
</a><a href="#h41-0-37" id="h41-0-37" class="i">+	Description      *string   `json:&quot;description,omitempty&quot;`
</a><a href="#h41-0-38" id="h41-0-38" class="i">+}
</a><a href="#h41-0-39" id="h41-0-39" class="i">+
</a><a href="#h41-0-40" id="h41-0-40" class="i">+// DeploymentsListOptions specifies the optional parameters to the
</a><a href="#h41-0-41" id="h41-0-41" class="i">+// RepositoriesService.ListDeployments method.
</a><a href="#h41-0-42" id="h41-0-42" class="i">+type DeploymentsListOptions struct {
</a><a href="#h41-0-43" id="h41-0-43" class="i">+	// SHA of the Deployment.
</a><a href="#h41-0-44" id="h41-0-44" class="i">+	SHA string `url:&quot;sha,omitempty&quot;`
</a><a href="#h41-0-45" id="h41-0-45" class="i">+
</a><a href="#h41-0-46" id="h41-0-46" class="i">+	// List deployments for a given ref.
</a><a href="#h41-0-47" id="h41-0-47" class="i">+	Ref string `url:&quot;ref,omitempty&quot;`
</a><a href="#h41-0-48" id="h41-0-48" class="i">+
</a><a href="#h41-0-49" id="h41-0-49" class="i">+	// List deployments for a given task.
</a><a href="#h41-0-50" id="h41-0-50" class="i">+	Task string `url:&quot;task,omitempty&quot;`
</a><a href="#h41-0-51" id="h41-0-51" class="i">+
</a><a href="#h41-0-52" id="h41-0-52" class="i">+	// List deployments for a given environment.
</a><a href="#h41-0-53" id="h41-0-53" class="i">+	Environment string `url:&quot;environment,omitempty&quot;`
</a><a href="#h41-0-54" id="h41-0-54" class="i">+
</a><a href="#h41-0-55" id="h41-0-55" class="i">+	ListOptions
</a><a href="#h41-0-56" id="h41-0-56" class="i">+}
</a><a href="#h41-0-57" id="h41-0-57" class="i">+
</a><a href="#h41-0-58" id="h41-0-58" class="i">+// ListDeployments lists the deployments of a repository.
</a><a href="#h41-0-59" id="h41-0-59" class="i">+//
</a><a href="#h41-0-60" id="h41-0-60" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/deployments/#list-deployments
</a><a href="#h41-0-61" id="h41-0-61" class="i">+func (s *RepositoriesService) ListDeployments(owner, repo string, opt *DeploymentsListOptions) ([]Deployment, *Response, error) {
</a><a href="#h41-0-62" id="h41-0-62" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/deployments&quot;, owner, repo)
</a><a href="#h41-0-63" id="h41-0-63" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h41-0-64" id="h41-0-64" class="i">+	if err != nil {
</a><a href="#h41-0-65" id="h41-0-65" class="i">+		return nil, nil, err
</a><a href="#h41-0-66" id="h41-0-66" class="i">+	}
</a><a href="#h41-0-67" id="h41-0-67" class="i">+
</a><a href="#h41-0-68" id="h41-0-68" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h41-0-69" id="h41-0-69" class="i">+	if err != nil {
</a><a href="#h41-0-70" id="h41-0-70" class="i">+		return nil, nil, err
</a><a href="#h41-0-71" id="h41-0-71" class="i">+	}
</a><a href="#h41-0-72" id="h41-0-72" class="i">+
</a><a href="#h41-0-73" id="h41-0-73" class="i">+	deployments := new([]Deployment)
</a><a href="#h41-0-74" id="h41-0-74" class="i">+	resp, err := s.client.Do(req, deployments)
</a><a href="#h41-0-75" id="h41-0-75" class="i">+	if err != nil {
</a><a href="#h41-0-76" id="h41-0-76" class="i">+		return nil, resp, err
</a><a href="#h41-0-77" id="h41-0-77" class="i">+	}
</a><a href="#h41-0-78" id="h41-0-78" class="i">+
</a><a href="#h41-0-79" id="h41-0-79" class="i">+	return *deployments, resp, err
</a><a href="#h41-0-80" id="h41-0-80" class="i">+}
</a><a href="#h41-0-81" id="h41-0-81" class="i">+
</a><a href="#h41-0-82" id="h41-0-82" class="i">+// CreateDeployment creates a new deployment for a repository.
</a><a href="#h41-0-83" id="h41-0-83" class="i">+//
</a><a href="#h41-0-84" id="h41-0-84" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/deployments/#create-a-deployment
</a><a href="#h41-0-85" id="h41-0-85" class="i">+func (s *RepositoriesService) CreateDeployment(owner, repo string, request *DeploymentRequest) (*Deployment, *Response, error) {
</a><a href="#h41-0-86" id="h41-0-86" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/deployments&quot;, owner, repo)
</a><a href="#h41-0-87" id="h41-0-87" class="i">+
</a><a href="#h41-0-88" id="h41-0-88" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, request)
</a><a href="#h41-0-89" id="h41-0-89" class="i">+	if err != nil {
</a><a href="#h41-0-90" id="h41-0-90" class="i">+		return nil, nil, err
</a><a href="#h41-0-91" id="h41-0-91" class="i">+	}
</a><a href="#h41-0-92" id="h41-0-92" class="i">+
</a><a href="#h41-0-93" id="h41-0-93" class="i">+	d := new(Deployment)
</a><a href="#h41-0-94" id="h41-0-94" class="i">+	resp, err := s.client.Do(req, d)
</a><a href="#h41-0-95" id="h41-0-95" class="i">+	if err != nil {
</a><a href="#h41-0-96" id="h41-0-96" class="i">+		return nil, resp, err
</a><a href="#h41-0-97" id="h41-0-97" class="i">+	}
</a><a href="#h41-0-98" id="h41-0-98" class="i">+
</a><a href="#h41-0-99" id="h41-0-99" class="i">+	return d, resp, err
</a><a href="#h41-0-100" id="h41-0-100" class="i">+}
</a><a href="#h41-0-101" id="h41-0-101" class="i">+
</a><a href="#h41-0-102" id="h41-0-102" class="i">+// DeploymentStatus represents the status of a
</a><a href="#h41-0-103" id="h41-0-103" class="i">+// particular deployment.
</a><a href="#h41-0-104" id="h41-0-104" class="i">+type DeploymentStatus struct {
</a><a href="#h41-0-105" id="h41-0-105" class="i">+	ID *int `json:&quot;id,omitempty&quot;`
</a><a href="#h41-0-106" id="h41-0-106" class="i">+	// State is the deployment state.
</a><a href="#h41-0-107" id="h41-0-107" class="i">+	// Possible values are: &quot;pending&quot;, &quot;success&quot;, &quot;failure&quot;, &quot;error&quot;.
</a><a href="#h41-0-108" id="h41-0-108" class="i">+	State         *string    `json:&quot;state,omitempty&quot;`
</a><a href="#h41-0-109" id="h41-0-109" class="i">+	Creator       *User      `json:&quot;creator,omitempty&quot;`
</a><a href="#h41-0-110" id="h41-0-110" class="i">+	Description   *string    `json:&quot;description,omitempty&quot;`
</a><a href="#h41-0-111" id="h41-0-111" class="i">+	TargetURL     *string    `json:&quot;target_url,omitempty&quot;`
</a><a href="#h41-0-112" id="h41-0-112" class="i">+	CreatedAt     *Timestamp `json:&quot;created_at,omitempty&quot;`
</a><a href="#h41-0-113" id="h41-0-113" class="i">+	UpdatedAt     *Timestamp `json:&quot;pushed_at,omitempty&quot;`
</a><a href="#h41-0-114" id="h41-0-114" class="i">+	DeploymentURL *string    `json:&quot;deployment_url,omitempty&quot;`
</a><a href="#h41-0-115" id="h41-0-115" class="i">+	RepositoryURL *string    `json:&quot;repository_url,omitempty&quot;`
</a><a href="#h41-0-116" id="h41-0-116" class="i">+}
</a><a href="#h41-0-117" id="h41-0-117" class="i">+
</a><a href="#h41-0-118" id="h41-0-118" class="i">+// DeploymentStatusRequest represents a deployment request
</a><a href="#h41-0-119" id="h41-0-119" class="i">+type DeploymentStatusRequest struct {
</a><a href="#h41-0-120" id="h41-0-120" class="i">+	State       *string `json:&quot;state,omitempty&quot;`
</a><a href="#h41-0-121" id="h41-0-121" class="i">+	TargetURL   *string `json:&quot;target_url,omitempty&quot;`
</a><a href="#h41-0-122" id="h41-0-122" class="i">+	Description *string `json:&quot;description,omitempty&quot;`
</a><a href="#h41-0-123" id="h41-0-123" class="i">+}
</a><a href="#h41-0-124" id="h41-0-124" class="i">+
</a><a href="#h41-0-125" id="h41-0-125" class="i">+// ListDeploymentStatuses lists the statuses of a given deployment of a repository.
</a><a href="#h41-0-126" id="h41-0-126" class="i">+//
</a><a href="#h41-0-127" id="h41-0-127" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/deployments/#list-deployment-statuses
</a><a href="#h41-0-128" id="h41-0-128" class="i">+func (s *RepositoriesService) ListDeploymentStatuses(owner, repo string, deployment int, opt *ListOptions) ([]DeploymentStatus, *Response, error) {
</a><a href="#h41-0-129" id="h41-0-129" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/deployments/%v/statuses&quot;, owner, repo, deployment)
</a><a href="#h41-0-130" id="h41-0-130" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h41-0-131" id="h41-0-131" class="i">+	if err != nil {
</a><a href="#h41-0-132" id="h41-0-132" class="i">+		return nil, nil, err
</a><a href="#h41-0-133" id="h41-0-133" class="i">+	}
</a><a href="#h41-0-134" id="h41-0-134" class="i">+
</a><a href="#h41-0-135" id="h41-0-135" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h41-0-136" id="h41-0-136" class="i">+	if err != nil {
</a><a href="#h41-0-137" id="h41-0-137" class="i">+		return nil, nil, err
</a><a href="#h41-0-138" id="h41-0-138" class="i">+	}
</a><a href="#h41-0-139" id="h41-0-139" class="i">+
</a><a href="#h41-0-140" id="h41-0-140" class="i">+	statuses := new([]DeploymentStatus)
</a><a href="#h41-0-141" id="h41-0-141" class="i">+	resp, err := s.client.Do(req, statuses)
</a><a href="#h41-0-142" id="h41-0-142" class="i">+	if err != nil {
</a><a href="#h41-0-143" id="h41-0-143" class="i">+		return nil, resp, err
</a><a href="#h41-0-144" id="h41-0-144" class="i">+	}
</a><a href="#h41-0-145" id="h41-0-145" class="i">+
</a><a href="#h41-0-146" id="h41-0-146" class="i">+	return *statuses, resp, err
</a><a href="#h41-0-147" id="h41-0-147" class="i">+}
</a><a href="#h41-0-148" id="h41-0-148" class="i">+
</a><a href="#h41-0-149" id="h41-0-149" class="i">+// CreateDeploymentStatus creates a new status for a deployment.
</a><a href="#h41-0-150" id="h41-0-150" class="i">+//
</a><a href="#h41-0-151" id="h41-0-151" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/deployments/#create-a-deployment-status
</a><a href="#h41-0-152" id="h41-0-152" class="i">+func (s *RepositoriesService) CreateDeploymentStatus(owner, repo string, deployment int, request *DeploymentStatusRequest) (*DeploymentStatus, *Response, error) {
</a><a href="#h41-0-153" id="h41-0-153" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/deployments/%v/statuses&quot;, owner, repo, deployment)
</a><a href="#h41-0-154" id="h41-0-154" class="i">+
</a><a href="#h41-0-155" id="h41-0-155" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, request)
</a><a href="#h41-0-156" id="h41-0-156" class="i">+	if err != nil {
</a><a href="#h41-0-157" id="h41-0-157" class="i">+		return nil, nil, err
</a><a href="#h41-0-158" id="h41-0-158" class="i">+	}
</a><a href="#h41-0-159" id="h41-0-159" class="i">+
</a><a href="#h41-0-160" id="h41-0-160" class="i">+	d := new(DeploymentStatus)
</a><a href="#h41-0-161" id="h41-0-161" class="i">+	resp, err := s.client.Do(req, d)
</a><a href="#h41-0-162" id="h41-0-162" class="i">+	if err != nil {
</a><a href="#h41-0-163" id="h41-0-163" class="i">+		return nil, resp, err
</a><a href="#h41-0-164" id="h41-0-164" class="i">+	}
</a><a href="#h41-0-165" id="h41-0-165" class="i">+
</a><a href="#h41-0-166" id="h41-0-166" class="i">+	return d, resp, err
</a><a href="#h41-0-167" id="h41-0-167" class="i">+}
</a><b>diff --git a/<a id="h42" href="../file/vendor/github.com/google/go-github/github/repos_forks.go">vendor/github.com/google/go-github/github/repos_forks.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_forks.go">vendor/github.com/google/go-github/github/repos_forks.go</a></b>
<a href="#h42-0" id="h42-0" class="h">@@ -0,0 +1,73 @@
</a><a href="#h42-0-0" id="h42-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h42-0-1" id="h42-0-1" class="i">+//
</a><a href="#h42-0-2" id="h42-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h42-0-3" id="h42-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h42-0-4" id="h42-0-4" class="i">+
</a><a href="#h42-0-5" id="h42-0-5" class="i">+package github
</a><a href="#h42-0-6" id="h42-0-6" class="i">+
</a><a href="#h42-0-7" id="h42-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h42-0-8" id="h42-0-8" class="i">+
</a><a href="#h42-0-9" id="h42-0-9" class="i">+// RepositoryListForksOptions specifies the optional parameters to the
</a><a href="#h42-0-10" id="h42-0-10" class="i">+// RepositoriesService.ListForks method.
</a><a href="#h42-0-11" id="h42-0-11" class="i">+type RepositoryListForksOptions struct {
</a><a href="#h42-0-12" id="h42-0-12" class="i">+	// How to sort the forks list.  Possible values are: newest, oldest,
</a><a href="#h42-0-13" id="h42-0-13" class="i">+	// watchers.  Default is &quot;newest&quot;.
</a><a href="#h42-0-14" id="h42-0-14" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h42-0-15" id="h42-0-15" class="i">+
</a><a href="#h42-0-16" id="h42-0-16" class="i">+	ListOptions
</a><a href="#h42-0-17" id="h42-0-17" class="i">+}
</a><a href="#h42-0-18" id="h42-0-18" class="i">+
</a><a href="#h42-0-19" id="h42-0-19" class="i">+// ListForks lists the forks of the specified repository.
</a><a href="#h42-0-20" id="h42-0-20" class="i">+//
</a><a href="#h42-0-21" id="h42-0-21" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/forks/#list-forks
</a><a href="#h42-0-22" id="h42-0-22" class="i">+func (s *RepositoriesService) ListForks(owner, repo string, opt *RepositoryListForksOptions) ([]Repository, *Response, error) {
</a><a href="#h42-0-23" id="h42-0-23" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/forks&quot;, owner, repo)
</a><a href="#h42-0-24" id="h42-0-24" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h42-0-25" id="h42-0-25" class="i">+	if err != nil {
</a><a href="#h42-0-26" id="h42-0-26" class="i">+		return nil, nil, err
</a><a href="#h42-0-27" id="h42-0-27" class="i">+	}
</a><a href="#h42-0-28" id="h42-0-28" class="i">+
</a><a href="#h42-0-29" id="h42-0-29" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h42-0-30" id="h42-0-30" class="i">+	if err != nil {
</a><a href="#h42-0-31" id="h42-0-31" class="i">+		return nil, nil, err
</a><a href="#h42-0-32" id="h42-0-32" class="i">+	}
</a><a href="#h42-0-33" id="h42-0-33" class="i">+
</a><a href="#h42-0-34" id="h42-0-34" class="i">+	repos := new([]Repository)
</a><a href="#h42-0-35" id="h42-0-35" class="i">+	resp, err := s.client.Do(req, repos)
</a><a href="#h42-0-36" id="h42-0-36" class="i">+	if err != nil {
</a><a href="#h42-0-37" id="h42-0-37" class="i">+		return nil, resp, err
</a><a href="#h42-0-38" id="h42-0-38" class="i">+	}
</a><a href="#h42-0-39" id="h42-0-39" class="i">+
</a><a href="#h42-0-40" id="h42-0-40" class="i">+	return *repos, resp, err
</a><a href="#h42-0-41" id="h42-0-41" class="i">+}
</a><a href="#h42-0-42" id="h42-0-42" class="i">+
</a><a href="#h42-0-43" id="h42-0-43" class="i">+// RepositoryCreateForkOptions specifies the optional parameters to the
</a><a href="#h42-0-44" id="h42-0-44" class="i">+// RepositoriesService.CreateFork method.
</a><a href="#h42-0-45" id="h42-0-45" class="i">+type RepositoryCreateForkOptions struct {
</a><a href="#h42-0-46" id="h42-0-46" class="i">+	// The organization to fork the repository into.
</a><a href="#h42-0-47" id="h42-0-47" class="i">+	Organization string `url:&quot;organization,omitempty&quot;`
</a><a href="#h42-0-48" id="h42-0-48" class="i">+}
</a><a href="#h42-0-49" id="h42-0-49" class="i">+
</a><a href="#h42-0-50" id="h42-0-50" class="i">+// CreateFork creates a fork of the specified repository.
</a><a href="#h42-0-51" id="h42-0-51" class="i">+//
</a><a href="#h42-0-52" id="h42-0-52" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/forks/#list-forks
</a><a href="#h42-0-53" id="h42-0-53" class="i">+func (s *RepositoriesService) CreateFork(owner, repo string, opt *RepositoryCreateForkOptions) (*Repository, *Response, error) {
</a><a href="#h42-0-54" id="h42-0-54" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/forks&quot;, owner, repo)
</a><a href="#h42-0-55" id="h42-0-55" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h42-0-56" id="h42-0-56" class="i">+	if err != nil {
</a><a href="#h42-0-57" id="h42-0-57" class="i">+		return nil, nil, err
</a><a href="#h42-0-58" id="h42-0-58" class="i">+	}
</a><a href="#h42-0-59" id="h42-0-59" class="i">+
</a><a href="#h42-0-60" id="h42-0-60" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, nil)
</a><a href="#h42-0-61" id="h42-0-61" class="i">+	if err != nil {
</a><a href="#h42-0-62" id="h42-0-62" class="i">+		return nil, nil, err
</a><a href="#h42-0-63" id="h42-0-63" class="i">+	}
</a><a href="#h42-0-64" id="h42-0-64" class="i">+
</a><a href="#h42-0-65" id="h42-0-65" class="i">+	fork := new(Repository)
</a><a href="#h42-0-66" id="h42-0-66" class="i">+	resp, err := s.client.Do(req, fork)
</a><a href="#h42-0-67" id="h42-0-67" class="i">+	if err != nil {
</a><a href="#h42-0-68" id="h42-0-68" class="i">+		return nil, resp, err
</a><a href="#h42-0-69" id="h42-0-69" class="i">+	}
</a><a href="#h42-0-70" id="h42-0-70" class="i">+
</a><a href="#h42-0-71" id="h42-0-71" class="i">+	return fork, resp, err
</a><a href="#h42-0-72" id="h42-0-72" class="i">+}
</a><b>diff --git a/<a id="h43" href="../file/vendor/github.com/google/go-github/github/repos_hooks.go">vendor/github.com/google/go-github/github/repos_hooks.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_hooks.go">vendor/github.com/google/go-github/github/repos_hooks.go</a></b>
<a href="#h43-0" id="h43-0" class="h">@@ -0,0 +1,196 @@
</a><a href="#h43-0-0" id="h43-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h43-0-1" id="h43-0-1" class="i">+//
</a><a href="#h43-0-2" id="h43-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h43-0-3" id="h43-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h43-0-4" id="h43-0-4" class="i">+
</a><a href="#h43-0-5" id="h43-0-5" class="i">+package github
</a><a href="#h43-0-6" id="h43-0-6" class="i">+
</a><a href="#h43-0-7" id="h43-0-7" class="i">+import (
</a><a href="#h43-0-8" id="h43-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h43-0-9" id="h43-0-9" class="i">+	&quot;time&quot;
</a><a href="#h43-0-10" id="h43-0-10" class="i">+)
</a><a href="#h43-0-11" id="h43-0-11" class="i">+
</a><a href="#h43-0-12" id="h43-0-12" class="i">+// WebHookPayload represents the data that is received from GitHub when a push
</a><a href="#h43-0-13" id="h43-0-13" class="i">+// event hook is triggered.  The format of these payloads pre-date most of the
</a><a href="#h43-0-14" id="h43-0-14" class="i">+// GitHub v3 API, so there are lots of minor incompatibilities with the types
</a><a href="#h43-0-15" id="h43-0-15" class="i">+// defined in the rest of the API.  Therefore, several types are duplicated
</a><a href="#h43-0-16" id="h43-0-16" class="i">+// here to account for these differences.
</a><a href="#h43-0-17" id="h43-0-17" class="i">+//
</a><a href="#h43-0-18" id="h43-0-18" class="i">+// GitHub API docs: https://help.github.com/articles/post-receive-hooks
</a><a href="#h43-0-19" id="h43-0-19" class="i">+type WebHookPayload struct {
</a><a href="#h43-0-20" id="h43-0-20" class="i">+	After      *string         `json:&quot;after,omitempty&quot;`
</a><a href="#h43-0-21" id="h43-0-21" class="i">+	Before     *string         `json:&quot;before,omitempty&quot;`
</a><a href="#h43-0-22" id="h43-0-22" class="i">+	Commits    []WebHookCommit `json:&quot;commits,omitempty&quot;`
</a><a href="#h43-0-23" id="h43-0-23" class="i">+	Compare    *string         `json:&quot;compare,omitempty&quot;`
</a><a href="#h43-0-24" id="h43-0-24" class="i">+	Created    *bool           `json:&quot;created,omitempty&quot;`
</a><a href="#h43-0-25" id="h43-0-25" class="i">+	Deleted    *bool           `json:&quot;deleted,omitempty&quot;`
</a><a href="#h43-0-26" id="h43-0-26" class="i">+	Forced     *bool           `json:&quot;forced,omitempty&quot;`
</a><a href="#h43-0-27" id="h43-0-27" class="i">+	HeadCommit *WebHookCommit  `json:&quot;head_commit,omitempty&quot;`
</a><a href="#h43-0-28" id="h43-0-28" class="i">+	Pusher     *User           `json:&quot;pusher,omitempty&quot;`
</a><a href="#h43-0-29" id="h43-0-29" class="i">+	Ref        *string         `json:&quot;ref,omitempty&quot;`
</a><a href="#h43-0-30" id="h43-0-30" class="i">+	Repo       *Repository     `json:&quot;repository,omitempty&quot;`
</a><a href="#h43-0-31" id="h43-0-31" class="i">+	Sender     *User           `json:&quot;sender,omitempty&quot;`
</a><a href="#h43-0-32" id="h43-0-32" class="i">+}
</a><a href="#h43-0-33" id="h43-0-33" class="i">+
</a><a href="#h43-0-34" id="h43-0-34" class="i">+func (w WebHookPayload) String() string {
</a><a href="#h43-0-35" id="h43-0-35" class="i">+	return Stringify(w)
</a><a href="#h43-0-36" id="h43-0-36" class="i">+}
</a><a href="#h43-0-37" id="h43-0-37" class="i">+
</a><a href="#h43-0-38" id="h43-0-38" class="i">+// WebHookCommit represents the commit variant we receive from GitHub in a
</a><a href="#h43-0-39" id="h43-0-39" class="i">+// WebHookPayload.
</a><a href="#h43-0-40" id="h43-0-40" class="i">+type WebHookCommit struct {
</a><a href="#h43-0-41" id="h43-0-41" class="i">+	Added     []string       `json:&quot;added,omitempty&quot;`
</a><a href="#h43-0-42" id="h43-0-42" class="i">+	Author    *WebHookAuthor `json:&quot;author,omitempty&quot;`
</a><a href="#h43-0-43" id="h43-0-43" class="i">+	Committer *WebHookAuthor `json:&quot;committer,omitempty&quot;`
</a><a href="#h43-0-44" id="h43-0-44" class="i">+	Distinct  *bool          `json:&quot;distinct,omitempty&quot;`
</a><a href="#h43-0-45" id="h43-0-45" class="i">+	ID        *string        `json:&quot;id,omitempty&quot;`
</a><a href="#h43-0-46" id="h43-0-46" class="i">+	Message   *string        `json:&quot;message,omitempty&quot;`
</a><a href="#h43-0-47" id="h43-0-47" class="i">+	Modified  []string       `json:&quot;modified,omitempty&quot;`
</a><a href="#h43-0-48" id="h43-0-48" class="i">+	Removed   []string       `json:&quot;removed,omitempty&quot;`
</a><a href="#h43-0-49" id="h43-0-49" class="i">+	Timestamp *time.Time     `json:&quot;timestamp,omitempty&quot;`
</a><a href="#h43-0-50" id="h43-0-50" class="i">+}
</a><a href="#h43-0-51" id="h43-0-51" class="i">+
</a><a href="#h43-0-52" id="h43-0-52" class="i">+func (w WebHookCommit) String() string {
</a><a href="#h43-0-53" id="h43-0-53" class="i">+	return Stringify(w)
</a><a href="#h43-0-54" id="h43-0-54" class="i">+}
</a><a href="#h43-0-55" id="h43-0-55" class="i">+
</a><a href="#h43-0-56" id="h43-0-56" class="i">+// WebHookAuthor represents the author or committer of a commit, as specified
</a><a href="#h43-0-57" id="h43-0-57" class="i">+// in a WebHookCommit.  The commit author may not correspond to a GitHub User.
</a><a href="#h43-0-58" id="h43-0-58" class="i">+type WebHookAuthor struct {
</a><a href="#h43-0-59" id="h43-0-59" class="i">+	Email    *string `json:&quot;email,omitempty&quot;`
</a><a href="#h43-0-60" id="h43-0-60" class="i">+	Name     *string `json:&quot;name,omitempty&quot;`
</a><a href="#h43-0-61" id="h43-0-61" class="i">+	Username *string `json:&quot;username,omitempty&quot;`
</a><a href="#h43-0-62" id="h43-0-62" class="i">+}
</a><a href="#h43-0-63" id="h43-0-63" class="i">+
</a><a href="#h43-0-64" id="h43-0-64" class="i">+func (w WebHookAuthor) String() string {
</a><a href="#h43-0-65" id="h43-0-65" class="i">+	return Stringify(w)
</a><a href="#h43-0-66" id="h43-0-66" class="i">+}
</a><a href="#h43-0-67" id="h43-0-67" class="i">+
</a><a href="#h43-0-68" id="h43-0-68" class="i">+// Hook represents a GitHub (web and service) hook for a repository.
</a><a href="#h43-0-69" id="h43-0-69" class="i">+type Hook struct {
</a><a href="#h43-0-70" id="h43-0-70" class="i">+	CreatedAt *time.Time             `json:&quot;created_at,omitempty&quot;`
</a><a href="#h43-0-71" id="h43-0-71" class="i">+	UpdatedAt *time.Time             `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h43-0-72" id="h43-0-72" class="i">+	Name      *string                `json:&quot;name,omitempty&quot;`
</a><a href="#h43-0-73" id="h43-0-73" class="i">+	URL       *string                `json:&quot;url,omitempty&quot;`
</a><a href="#h43-0-74" id="h43-0-74" class="i">+	Events    []string               `json:&quot;events,omitempty&quot;`
</a><a href="#h43-0-75" id="h43-0-75" class="i">+	Active    *bool                  `json:&quot;active,omitempty&quot;`
</a><a href="#h43-0-76" id="h43-0-76" class="i">+	Config    map[string]interface{} `json:&quot;config,omitempty&quot;`
</a><a href="#h43-0-77" id="h43-0-77" class="i">+	ID        *int                   `json:&quot;id,omitempty&quot;`
</a><a href="#h43-0-78" id="h43-0-78" class="i">+}
</a><a href="#h43-0-79" id="h43-0-79" class="i">+
</a><a href="#h43-0-80" id="h43-0-80" class="i">+func (h Hook) String() string {
</a><a href="#h43-0-81" id="h43-0-81" class="i">+	return Stringify(h)
</a><a href="#h43-0-82" id="h43-0-82" class="i">+}
</a><a href="#h43-0-83" id="h43-0-83" class="i">+
</a><a href="#h43-0-84" id="h43-0-84" class="i">+// CreateHook creates a Hook for the specified repository.
</a><a href="#h43-0-85" id="h43-0-85" class="i">+// Name and Config are required fields.
</a><a href="#h43-0-86" id="h43-0-86" class="i">+//
</a><a href="#h43-0-87" id="h43-0-87" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/hooks/#create-a-hook
</a><a href="#h43-0-88" id="h43-0-88" class="i">+func (s *RepositoriesService) CreateHook(owner, repo string, hook *Hook) (*Hook, *Response, error) {
</a><a href="#h43-0-89" id="h43-0-89" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/hooks&quot;, owner, repo)
</a><a href="#h43-0-90" id="h43-0-90" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, hook)
</a><a href="#h43-0-91" id="h43-0-91" class="i">+	if err != nil {
</a><a href="#h43-0-92" id="h43-0-92" class="i">+		return nil, nil, err
</a><a href="#h43-0-93" id="h43-0-93" class="i">+	}
</a><a href="#h43-0-94" id="h43-0-94" class="i">+
</a><a href="#h43-0-95" id="h43-0-95" class="i">+	h := new(Hook)
</a><a href="#h43-0-96" id="h43-0-96" class="i">+	resp, err := s.client.Do(req, h)
</a><a href="#h43-0-97" id="h43-0-97" class="i">+	if err != nil {
</a><a href="#h43-0-98" id="h43-0-98" class="i">+		return nil, resp, err
</a><a href="#h43-0-99" id="h43-0-99" class="i">+	}
</a><a href="#h43-0-100" id="h43-0-100" class="i">+
</a><a href="#h43-0-101" id="h43-0-101" class="i">+	return h, resp, err
</a><a href="#h43-0-102" id="h43-0-102" class="i">+}
</a><a href="#h43-0-103" id="h43-0-103" class="i">+
</a><a href="#h43-0-104" id="h43-0-104" class="i">+// ListHooks lists all Hooks for the specified repository.
</a><a href="#h43-0-105" id="h43-0-105" class="i">+//
</a><a href="#h43-0-106" id="h43-0-106" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/hooks/#list
</a><a href="#h43-0-107" id="h43-0-107" class="i">+func (s *RepositoriesService) ListHooks(owner, repo string, opt *ListOptions) ([]Hook, *Response, error) {
</a><a href="#h43-0-108" id="h43-0-108" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/hooks&quot;, owner, repo)
</a><a href="#h43-0-109" id="h43-0-109" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h43-0-110" id="h43-0-110" class="i">+	if err != nil {
</a><a href="#h43-0-111" id="h43-0-111" class="i">+		return nil, nil, err
</a><a href="#h43-0-112" id="h43-0-112" class="i">+	}
</a><a href="#h43-0-113" id="h43-0-113" class="i">+
</a><a href="#h43-0-114" id="h43-0-114" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h43-0-115" id="h43-0-115" class="i">+	if err != nil {
</a><a href="#h43-0-116" id="h43-0-116" class="i">+		return nil, nil, err
</a><a href="#h43-0-117" id="h43-0-117" class="i">+	}
</a><a href="#h43-0-118" id="h43-0-118" class="i">+
</a><a href="#h43-0-119" id="h43-0-119" class="i">+	hooks := new([]Hook)
</a><a href="#h43-0-120" id="h43-0-120" class="i">+	resp, err := s.client.Do(req, hooks)
</a><a href="#h43-0-121" id="h43-0-121" class="i">+	if err != nil {
</a><a href="#h43-0-122" id="h43-0-122" class="i">+		return nil, resp, err
</a><a href="#h43-0-123" id="h43-0-123" class="i">+	}
</a><a href="#h43-0-124" id="h43-0-124" class="i">+
</a><a href="#h43-0-125" id="h43-0-125" class="i">+	return *hooks, resp, err
</a><a href="#h43-0-126" id="h43-0-126" class="i">+}
</a><a href="#h43-0-127" id="h43-0-127" class="i">+
</a><a href="#h43-0-128" id="h43-0-128" class="i">+// GetHook returns a single specified Hook.
</a><a href="#h43-0-129" id="h43-0-129" class="i">+//
</a><a href="#h43-0-130" id="h43-0-130" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/hooks/#get-single-hook
</a><a href="#h43-0-131" id="h43-0-131" class="i">+func (s *RepositoriesService) GetHook(owner, repo string, id int) (*Hook, *Response, error) {
</a><a href="#h43-0-132" id="h43-0-132" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/hooks/%d&quot;, owner, repo, id)
</a><a href="#h43-0-133" id="h43-0-133" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h43-0-134" id="h43-0-134" class="i">+	if err != nil {
</a><a href="#h43-0-135" id="h43-0-135" class="i">+		return nil, nil, err
</a><a href="#h43-0-136" id="h43-0-136" class="i">+	}
</a><a href="#h43-0-137" id="h43-0-137" class="i">+	hook := new(Hook)
</a><a href="#h43-0-138" id="h43-0-138" class="i">+	resp, err := s.client.Do(req, hook)
</a><a href="#h43-0-139" id="h43-0-139" class="i">+	return hook, resp, err
</a><a href="#h43-0-140" id="h43-0-140" class="i">+}
</a><a href="#h43-0-141" id="h43-0-141" class="i">+
</a><a href="#h43-0-142" id="h43-0-142" class="i">+// EditHook updates a specified Hook.
</a><a href="#h43-0-143" id="h43-0-143" class="i">+//
</a><a href="#h43-0-144" id="h43-0-144" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/hooks/#edit-a-hook
</a><a href="#h43-0-145" id="h43-0-145" class="i">+func (s *RepositoriesService) EditHook(owner, repo string, id int, hook *Hook) (*Hook, *Response, error) {
</a><a href="#h43-0-146" id="h43-0-146" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/hooks/%d&quot;, owner, repo, id)
</a><a href="#h43-0-147" id="h43-0-147" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, hook)
</a><a href="#h43-0-148" id="h43-0-148" class="i">+	if err != nil {
</a><a href="#h43-0-149" id="h43-0-149" class="i">+		return nil, nil, err
</a><a href="#h43-0-150" id="h43-0-150" class="i">+	}
</a><a href="#h43-0-151" id="h43-0-151" class="i">+	h := new(Hook)
</a><a href="#h43-0-152" id="h43-0-152" class="i">+	resp, err := s.client.Do(req, h)
</a><a href="#h43-0-153" id="h43-0-153" class="i">+	return h, resp, err
</a><a href="#h43-0-154" id="h43-0-154" class="i">+}
</a><a href="#h43-0-155" id="h43-0-155" class="i">+
</a><a href="#h43-0-156" id="h43-0-156" class="i">+// DeleteHook deletes a specified Hook.
</a><a href="#h43-0-157" id="h43-0-157" class="i">+//
</a><a href="#h43-0-158" id="h43-0-158" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/hooks/#delete-a-hook
</a><a href="#h43-0-159" id="h43-0-159" class="i">+func (s *RepositoriesService) DeleteHook(owner, repo string, id int) (*Response, error) {
</a><a href="#h43-0-160" id="h43-0-160" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/hooks/%d&quot;, owner, repo, id)
</a><a href="#h43-0-161" id="h43-0-161" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h43-0-162" id="h43-0-162" class="i">+	if err != nil {
</a><a href="#h43-0-163" id="h43-0-163" class="i">+		return nil, err
</a><a href="#h43-0-164" id="h43-0-164" class="i">+	}
</a><a href="#h43-0-165" id="h43-0-165" class="i">+	return s.client.Do(req, nil)
</a><a href="#h43-0-166" id="h43-0-166" class="i">+}
</a><a href="#h43-0-167" id="h43-0-167" class="i">+
</a><a href="#h43-0-168" id="h43-0-168" class="i">+// PingHook triggers a &#39;ping&#39; event to be sent to the Hook.
</a><a href="#h43-0-169" id="h43-0-169" class="i">+//
</a><a href="#h43-0-170" id="h43-0-170" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/hooks/#ping-a-hook
</a><a href="#h43-0-171" id="h43-0-171" class="i">+func (s *RepositoriesService) PingHook(owner, repo string, id int) (*Response, error) {
</a><a href="#h43-0-172" id="h43-0-172" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/hooks/%d/pings&quot;, owner, repo, id)
</a><a href="#h43-0-173" id="h43-0-173" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, nil)
</a><a href="#h43-0-174" id="h43-0-174" class="i">+	if err != nil {
</a><a href="#h43-0-175" id="h43-0-175" class="i">+		return nil, err
</a><a href="#h43-0-176" id="h43-0-176" class="i">+	}
</a><a href="#h43-0-177" id="h43-0-177" class="i">+	return s.client.Do(req, nil)
</a><a href="#h43-0-178" id="h43-0-178" class="i">+}
</a><a href="#h43-0-179" id="h43-0-179" class="i">+
</a><a href="#h43-0-180" id="h43-0-180" class="i">+// TestHook triggers a test Hook by github.
</a><a href="#h43-0-181" id="h43-0-181" class="i">+//
</a><a href="#h43-0-182" id="h43-0-182" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/hooks/#test-a-push-hook
</a><a href="#h43-0-183" id="h43-0-183" class="i">+func (s *RepositoriesService) TestHook(owner, repo string, id int) (*Response, error) {
</a><a href="#h43-0-184" id="h43-0-184" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/hooks/%d/tests&quot;, owner, repo, id)
</a><a href="#h43-0-185" id="h43-0-185" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, nil)
</a><a href="#h43-0-186" id="h43-0-186" class="i">+	if err != nil {
</a><a href="#h43-0-187" id="h43-0-187" class="i">+		return nil, err
</a><a href="#h43-0-188" id="h43-0-188" class="i">+	}
</a><a href="#h43-0-189" id="h43-0-189" class="i">+	return s.client.Do(req, nil)
</a><a href="#h43-0-190" id="h43-0-190" class="i">+}
</a><a href="#h43-0-191" id="h43-0-191" class="i">+
</a><a href="#h43-0-192" id="h43-0-192" class="i">+// ListServiceHooks is deprecated.  Use Client.ListServiceHooks instead.
</a><a href="#h43-0-193" id="h43-0-193" class="i">+func (s *RepositoriesService) ListServiceHooks() ([]ServiceHook, *Response, error) {
</a><a href="#h43-0-194" id="h43-0-194" class="i">+	return s.client.ListServiceHooks()
</a><a href="#h43-0-195" id="h43-0-195" class="i">+}
</a><b>diff --git a/<a id="h44" href="../file/vendor/github.com/google/go-github/github/repos_keys.go">vendor/github.com/google/go-github/github/repos_keys.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_keys.go">vendor/github.com/google/go-github/github/repos_keys.go</a></b>
<a href="#h44-0" id="h44-0" class="h">@@ -0,0 +1,108 @@
</a><a href="#h44-0-0" id="h44-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h44-0-1" id="h44-0-1" class="i">+//
</a><a href="#h44-0-2" id="h44-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h44-0-3" id="h44-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h44-0-4" id="h44-0-4" class="i">+
</a><a href="#h44-0-5" id="h44-0-5" class="i">+package github
</a><a href="#h44-0-6" id="h44-0-6" class="i">+
</a><a href="#h44-0-7" id="h44-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h44-0-8" id="h44-0-8" class="i">+
</a><a href="#h44-0-9" id="h44-0-9" class="i">+// The Key type is defined in users_keys.go
</a><a href="#h44-0-10" id="h44-0-10" class="i">+
</a><a href="#h44-0-11" id="h44-0-11" class="i">+// ListKeys lists the deploy keys for a repository.
</a><a href="#h44-0-12" id="h44-0-12" class="i">+//
</a><a href="#h44-0-13" id="h44-0-13" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/keys/#list
</a><a href="#h44-0-14" id="h44-0-14" class="i">+func (s *RepositoriesService) ListKeys(owner string, repo string, opt *ListOptions) ([]Key, *Response, error) {
</a><a href="#h44-0-15" id="h44-0-15" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/keys&quot;, owner, repo)
</a><a href="#h44-0-16" id="h44-0-16" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h44-0-17" id="h44-0-17" class="i">+	if err != nil {
</a><a href="#h44-0-18" id="h44-0-18" class="i">+		return nil, nil, err
</a><a href="#h44-0-19" id="h44-0-19" class="i">+	}
</a><a href="#h44-0-20" id="h44-0-20" class="i">+
</a><a href="#h44-0-21" id="h44-0-21" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h44-0-22" id="h44-0-22" class="i">+	if err != nil {
</a><a href="#h44-0-23" id="h44-0-23" class="i">+		return nil, nil, err
</a><a href="#h44-0-24" id="h44-0-24" class="i">+	}
</a><a href="#h44-0-25" id="h44-0-25" class="i">+
</a><a href="#h44-0-26" id="h44-0-26" class="i">+	keys := new([]Key)
</a><a href="#h44-0-27" id="h44-0-27" class="i">+	resp, err := s.client.Do(req, keys)
</a><a href="#h44-0-28" id="h44-0-28" class="i">+	if err != nil {
</a><a href="#h44-0-29" id="h44-0-29" class="i">+		return nil, resp, err
</a><a href="#h44-0-30" id="h44-0-30" class="i">+	}
</a><a href="#h44-0-31" id="h44-0-31" class="i">+
</a><a href="#h44-0-32" id="h44-0-32" class="i">+	return *keys, resp, err
</a><a href="#h44-0-33" id="h44-0-33" class="i">+}
</a><a href="#h44-0-34" id="h44-0-34" class="i">+
</a><a href="#h44-0-35" id="h44-0-35" class="i">+// GetKey fetches a single deploy key.
</a><a href="#h44-0-36" id="h44-0-36" class="i">+//
</a><a href="#h44-0-37" id="h44-0-37" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/keys/#get
</a><a href="#h44-0-38" id="h44-0-38" class="i">+func (s *RepositoriesService) GetKey(owner string, repo string, id int) (*Key, *Response, error) {
</a><a href="#h44-0-39" id="h44-0-39" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/keys/%v&quot;, owner, repo, id)
</a><a href="#h44-0-40" id="h44-0-40" class="i">+
</a><a href="#h44-0-41" id="h44-0-41" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h44-0-42" id="h44-0-42" class="i">+	if err != nil {
</a><a href="#h44-0-43" id="h44-0-43" class="i">+		return nil, nil, err
</a><a href="#h44-0-44" id="h44-0-44" class="i">+	}
</a><a href="#h44-0-45" id="h44-0-45" class="i">+
</a><a href="#h44-0-46" id="h44-0-46" class="i">+	key := new(Key)
</a><a href="#h44-0-47" id="h44-0-47" class="i">+	resp, err := s.client.Do(req, key)
</a><a href="#h44-0-48" id="h44-0-48" class="i">+	if err != nil {
</a><a href="#h44-0-49" id="h44-0-49" class="i">+		return nil, resp, err
</a><a href="#h44-0-50" id="h44-0-50" class="i">+	}
</a><a href="#h44-0-51" id="h44-0-51" class="i">+
</a><a href="#h44-0-52" id="h44-0-52" class="i">+	return key, resp, err
</a><a href="#h44-0-53" id="h44-0-53" class="i">+}
</a><a href="#h44-0-54" id="h44-0-54" class="i">+
</a><a href="#h44-0-55" id="h44-0-55" class="i">+// CreateKey adds a deploy key for a repository.
</a><a href="#h44-0-56" id="h44-0-56" class="i">+//
</a><a href="#h44-0-57" id="h44-0-57" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/keys/#create
</a><a href="#h44-0-58" id="h44-0-58" class="i">+func (s *RepositoriesService) CreateKey(owner string, repo string, key *Key) (*Key, *Response, error) {
</a><a href="#h44-0-59" id="h44-0-59" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/keys&quot;, owner, repo)
</a><a href="#h44-0-60" id="h44-0-60" class="i">+
</a><a href="#h44-0-61" id="h44-0-61" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, key)
</a><a href="#h44-0-62" id="h44-0-62" class="i">+	if err != nil {
</a><a href="#h44-0-63" id="h44-0-63" class="i">+		return nil, nil, err
</a><a href="#h44-0-64" id="h44-0-64" class="i">+	}
</a><a href="#h44-0-65" id="h44-0-65" class="i">+
</a><a href="#h44-0-66" id="h44-0-66" class="i">+	k := new(Key)
</a><a href="#h44-0-67" id="h44-0-67" class="i">+	resp, err := s.client.Do(req, k)
</a><a href="#h44-0-68" id="h44-0-68" class="i">+	if err != nil {
</a><a href="#h44-0-69" id="h44-0-69" class="i">+		return nil, resp, err
</a><a href="#h44-0-70" id="h44-0-70" class="i">+	}
</a><a href="#h44-0-71" id="h44-0-71" class="i">+
</a><a href="#h44-0-72" id="h44-0-72" class="i">+	return k, resp, err
</a><a href="#h44-0-73" id="h44-0-73" class="i">+}
</a><a href="#h44-0-74" id="h44-0-74" class="i">+
</a><a href="#h44-0-75" id="h44-0-75" class="i">+// EditKey edits a deploy key.
</a><a href="#h44-0-76" id="h44-0-76" class="i">+//
</a><a href="#h44-0-77" id="h44-0-77" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/keys/#edit
</a><a href="#h44-0-78" id="h44-0-78" class="i">+func (s *RepositoriesService) EditKey(owner string, repo string, id int, key *Key) (*Key, *Response, error) {
</a><a href="#h44-0-79" id="h44-0-79" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/keys/%v&quot;, owner, repo, id)
</a><a href="#h44-0-80" id="h44-0-80" class="i">+
</a><a href="#h44-0-81" id="h44-0-81" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, key)
</a><a href="#h44-0-82" id="h44-0-82" class="i">+	if err != nil {
</a><a href="#h44-0-83" id="h44-0-83" class="i">+		return nil, nil, err
</a><a href="#h44-0-84" id="h44-0-84" class="i">+	}
</a><a href="#h44-0-85" id="h44-0-85" class="i">+
</a><a href="#h44-0-86" id="h44-0-86" class="i">+	k := new(Key)
</a><a href="#h44-0-87" id="h44-0-87" class="i">+	resp, err := s.client.Do(req, k)
</a><a href="#h44-0-88" id="h44-0-88" class="i">+	if err != nil {
</a><a href="#h44-0-89" id="h44-0-89" class="i">+		return nil, resp, err
</a><a href="#h44-0-90" id="h44-0-90" class="i">+	}
</a><a href="#h44-0-91" id="h44-0-91" class="i">+
</a><a href="#h44-0-92" id="h44-0-92" class="i">+	return k, resp, err
</a><a href="#h44-0-93" id="h44-0-93" class="i">+}
</a><a href="#h44-0-94" id="h44-0-94" class="i">+
</a><a href="#h44-0-95" id="h44-0-95" class="i">+// DeleteKey deletes a deploy key.
</a><a href="#h44-0-96" id="h44-0-96" class="i">+//
</a><a href="#h44-0-97" id="h44-0-97" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/keys/#delete
</a><a href="#h44-0-98" id="h44-0-98" class="i">+func (s *RepositoriesService) DeleteKey(owner string, repo string, id int) (*Response, error) {
</a><a href="#h44-0-99" id="h44-0-99" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/keys/%v&quot;, owner, repo, id)
</a><a href="#h44-0-100" id="h44-0-100" class="i">+
</a><a href="#h44-0-101" id="h44-0-101" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h44-0-102" id="h44-0-102" class="i">+	if err != nil {
</a><a href="#h44-0-103" id="h44-0-103" class="i">+		return nil, err
</a><a href="#h44-0-104" id="h44-0-104" class="i">+	}
</a><a href="#h44-0-105" id="h44-0-105" class="i">+
</a><a href="#h44-0-106" id="h44-0-106" class="i">+	return s.client.Do(req, nil)
</a><a href="#h44-0-107" id="h44-0-107" class="i">+}
</a><b>diff --git a/<a id="h45" href="../file/vendor/github.com/google/go-github/github/repos_merging.go">vendor/github.com/google/go-github/github/repos_merging.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_merging.go">vendor/github.com/google/go-github/github/repos_merging.go</a></b>
<a href="#h45-0" id="h45-0" class="h">@@ -0,0 +1,37 @@
</a><a href="#h45-0-0" id="h45-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h45-0-1" id="h45-0-1" class="i">+//
</a><a href="#h45-0-2" id="h45-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h45-0-3" id="h45-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h45-0-4" id="h45-0-4" class="i">+
</a><a href="#h45-0-5" id="h45-0-5" class="i">+package github
</a><a href="#h45-0-6" id="h45-0-6" class="i">+
</a><a href="#h45-0-7" id="h45-0-7" class="i">+import (
</a><a href="#h45-0-8" id="h45-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h45-0-9" id="h45-0-9" class="i">+)
</a><a href="#h45-0-10" id="h45-0-10" class="i">+
</a><a href="#h45-0-11" id="h45-0-11" class="i">+// RepositoryMergeRequest represents a request to merge a branch in a
</a><a href="#h45-0-12" id="h45-0-12" class="i">+// repository.
</a><a href="#h45-0-13" id="h45-0-13" class="i">+type RepositoryMergeRequest struct {
</a><a href="#h45-0-14" id="h45-0-14" class="i">+	Base          *string `json:&quot;base,omitempty&quot;`
</a><a href="#h45-0-15" id="h45-0-15" class="i">+	Head          *string `json:&quot;head,omitempty&quot;`
</a><a href="#h45-0-16" id="h45-0-16" class="i">+	CommitMessage *string `json:&quot;commit_message,omitempty&quot;`
</a><a href="#h45-0-17" id="h45-0-17" class="i">+}
</a><a href="#h45-0-18" id="h45-0-18" class="i">+
</a><a href="#h45-0-19" id="h45-0-19" class="i">+// Merge a branch in the specified repository.
</a><a href="#h45-0-20" id="h45-0-20" class="i">+//
</a><a href="#h45-0-21" id="h45-0-21" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/merging/#perform-a-merge
</a><a href="#h45-0-22" id="h45-0-22" class="i">+func (s *RepositoriesService) Merge(owner, repo string, request *RepositoryMergeRequest) (*RepositoryCommit, *Response, error) {
</a><a href="#h45-0-23" id="h45-0-23" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/merges&quot;, owner, repo)
</a><a href="#h45-0-24" id="h45-0-24" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, request)
</a><a href="#h45-0-25" id="h45-0-25" class="i">+	if err != nil {
</a><a href="#h45-0-26" id="h45-0-26" class="i">+		return nil, nil, err
</a><a href="#h45-0-27" id="h45-0-27" class="i">+	}
</a><a href="#h45-0-28" id="h45-0-28" class="i">+
</a><a href="#h45-0-29" id="h45-0-29" class="i">+	commit := new(RepositoryCommit)
</a><a href="#h45-0-30" id="h45-0-30" class="i">+	resp, err := s.client.Do(req, commit)
</a><a href="#h45-0-31" id="h45-0-31" class="i">+	if err != nil {
</a><a href="#h45-0-32" id="h45-0-32" class="i">+		return nil, resp, err
</a><a href="#h45-0-33" id="h45-0-33" class="i">+	}
</a><a href="#h45-0-34" id="h45-0-34" class="i">+
</a><a href="#h45-0-35" id="h45-0-35" class="i">+	return commit, resp, err
</a><a href="#h45-0-36" id="h45-0-36" class="i">+}
</a><b>diff --git a/<a id="h46" href="../file/vendor/github.com/google/go-github/github/repos_pages.go">vendor/github.com/google/go-github/github/repos_pages.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_pages.go">vendor/github.com/google/go-github/github/repos_pages.go</a></b>
<a href="#h46-0" id="h46-0" class="h">@@ -0,0 +1,90 @@
</a><a href="#h46-0-0" id="h46-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h46-0-1" id="h46-0-1" class="i">+//
</a><a href="#h46-0-2" id="h46-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h46-0-3" id="h46-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h46-0-4" id="h46-0-4" class="i">+
</a><a href="#h46-0-5" id="h46-0-5" class="i">+package github
</a><a href="#h46-0-6" id="h46-0-6" class="i">+
</a><a href="#h46-0-7" id="h46-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h46-0-8" id="h46-0-8" class="i">+
</a><a href="#h46-0-9" id="h46-0-9" class="i">+// Pages represents a GitHub Pages site configuration.
</a><a href="#h46-0-10" id="h46-0-10" class="i">+type Pages struct {
</a><a href="#h46-0-11" id="h46-0-11" class="i">+	URL       *string `json:&quot;url,omitempty&quot;`
</a><a href="#h46-0-12" id="h46-0-12" class="i">+	Status    *string `json:&quot;status,omitempty&quot;`
</a><a href="#h46-0-13" id="h46-0-13" class="i">+	CNAME     *string `json:&quot;cname,omitempty&quot;`
</a><a href="#h46-0-14" id="h46-0-14" class="i">+	Custom404 *bool   `json:&quot;custom_404,omitempty&quot;`
</a><a href="#h46-0-15" id="h46-0-15" class="i">+}
</a><a href="#h46-0-16" id="h46-0-16" class="i">+
</a><a href="#h46-0-17" id="h46-0-17" class="i">+// PagesError represents a build error for a GitHub Pages site.
</a><a href="#h46-0-18" id="h46-0-18" class="i">+type PagesError struct {
</a><a href="#h46-0-19" id="h46-0-19" class="i">+	Message *string `json:&quot;message,omitempty&quot;`
</a><a href="#h46-0-20" id="h46-0-20" class="i">+}
</a><a href="#h46-0-21" id="h46-0-21" class="i">+
</a><a href="#h46-0-22" id="h46-0-22" class="i">+// PagesBuild represents the build information for a GitHub Pages site.
</a><a href="#h46-0-23" id="h46-0-23" class="i">+type PagesBuild struct {
</a><a href="#h46-0-24" id="h46-0-24" class="i">+	URL       *string     `json:&quot;url,omitempty&quot;`
</a><a href="#h46-0-25" id="h46-0-25" class="i">+	Status    *string     `json:&quot;status,omitempty&quot;`
</a><a href="#h46-0-26" id="h46-0-26" class="i">+	Error     *PagesError `json:&quot;error,omitempty&quot;`
</a><a href="#h46-0-27" id="h46-0-27" class="i">+	Pusher    *User       `json:&quot;pusher,omitempty&quot;`
</a><a href="#h46-0-28" id="h46-0-28" class="i">+	Commit    *string     `json:&quot;commit,omitempty&quot;`
</a><a href="#h46-0-29" id="h46-0-29" class="i">+	Duration  *int        `json:&quot;duration,omitempty&quot;`
</a><a href="#h46-0-30" id="h46-0-30" class="i">+	CreatedAt *Timestamp  `json:&quot;created_at,omitempty&quot;`
</a><a href="#h46-0-31" id="h46-0-31" class="i">+	UpdatedAt *Timestamp  `json:&quot;created_at,omitempty&quot;`
</a><a href="#h46-0-32" id="h46-0-32" class="i">+}
</a><a href="#h46-0-33" id="h46-0-33" class="i">+
</a><a href="#h46-0-34" id="h46-0-34" class="i">+// GetPagesInfo fetches information about a GitHub Pages site.
</a><a href="#h46-0-35" id="h46-0-35" class="i">+//
</a><a href="#h46-0-36" id="h46-0-36" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/pages/#get-information-about-a-pages-site
</a><a href="#h46-0-37" id="h46-0-37" class="i">+func (s *RepositoriesService) GetPagesInfo(owner string, repo string) (*Pages, *Response, error) {
</a><a href="#h46-0-38" id="h46-0-38" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pages&quot;, owner, repo)
</a><a href="#h46-0-39" id="h46-0-39" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h46-0-40" id="h46-0-40" class="i">+	if err != nil {
</a><a href="#h46-0-41" id="h46-0-41" class="i">+		return nil, nil, err
</a><a href="#h46-0-42" id="h46-0-42" class="i">+	}
</a><a href="#h46-0-43" id="h46-0-43" class="i">+
</a><a href="#h46-0-44" id="h46-0-44" class="i">+	site := new(Pages)
</a><a href="#h46-0-45" id="h46-0-45" class="i">+	resp, err := s.client.Do(req, site)
</a><a href="#h46-0-46" id="h46-0-46" class="i">+	if err != nil {
</a><a href="#h46-0-47" id="h46-0-47" class="i">+		return nil, resp, err
</a><a href="#h46-0-48" id="h46-0-48" class="i">+	}
</a><a href="#h46-0-49" id="h46-0-49" class="i">+
</a><a href="#h46-0-50" id="h46-0-50" class="i">+	return site, resp, err
</a><a href="#h46-0-51" id="h46-0-51" class="i">+}
</a><a href="#h46-0-52" id="h46-0-52" class="i">+
</a><a href="#h46-0-53" id="h46-0-53" class="i">+// ListPagesBuilds lists the builds for a GitHub Pages site.
</a><a href="#h46-0-54" id="h46-0-54" class="i">+//
</a><a href="#h46-0-55" id="h46-0-55" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/pages/#list-pages-builds
</a><a href="#h46-0-56" id="h46-0-56" class="i">+func (s *RepositoriesService) ListPagesBuilds(owner string, repo string) ([]PagesBuild, *Response, error) {
</a><a href="#h46-0-57" id="h46-0-57" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pages/builds&quot;, owner, repo)
</a><a href="#h46-0-58" id="h46-0-58" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h46-0-59" id="h46-0-59" class="i">+	if err != nil {
</a><a href="#h46-0-60" id="h46-0-60" class="i">+		return nil, nil, err
</a><a href="#h46-0-61" id="h46-0-61" class="i">+	}
</a><a href="#h46-0-62" id="h46-0-62" class="i">+
</a><a href="#h46-0-63" id="h46-0-63" class="i">+	var pages []PagesBuild
</a><a href="#h46-0-64" id="h46-0-64" class="i">+	resp, err := s.client.Do(req, &amp;pages)
</a><a href="#h46-0-65" id="h46-0-65" class="i">+	if err != nil {
</a><a href="#h46-0-66" id="h46-0-66" class="i">+		return nil, resp, err
</a><a href="#h46-0-67" id="h46-0-67" class="i">+	}
</a><a href="#h46-0-68" id="h46-0-68" class="i">+
</a><a href="#h46-0-69" id="h46-0-69" class="i">+	return pages, resp, err
</a><a href="#h46-0-70" id="h46-0-70" class="i">+}
</a><a href="#h46-0-71" id="h46-0-71" class="i">+
</a><a href="#h46-0-72" id="h46-0-72" class="i">+// GetLatestPagesBuild fetches the latest build information for a GitHub pages site.
</a><a href="#h46-0-73" id="h46-0-73" class="i">+//
</a><a href="#h46-0-74" id="h46-0-74" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/pages/#list-latest-pages-build
</a><a href="#h46-0-75" id="h46-0-75" class="i">+func (s *RepositoriesService) GetLatestPagesBuild(owner string, repo string) (*PagesBuild, *Response, error) {
</a><a href="#h46-0-76" id="h46-0-76" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/pages/builds/latest&quot;, owner, repo)
</a><a href="#h46-0-77" id="h46-0-77" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h46-0-78" id="h46-0-78" class="i">+	if err != nil {
</a><a href="#h46-0-79" id="h46-0-79" class="i">+		return nil, nil, err
</a><a href="#h46-0-80" id="h46-0-80" class="i">+	}
</a><a href="#h46-0-81" id="h46-0-81" class="i">+
</a><a href="#h46-0-82" id="h46-0-82" class="i">+	build := new(PagesBuild)
</a><a href="#h46-0-83" id="h46-0-83" class="i">+	resp, err := s.client.Do(req, build)
</a><a href="#h46-0-84" id="h46-0-84" class="i">+	if err != nil {
</a><a href="#h46-0-85" id="h46-0-85" class="i">+		return nil, resp, err
</a><a href="#h46-0-86" id="h46-0-86" class="i">+	}
</a><a href="#h46-0-87" id="h46-0-87" class="i">+
</a><a href="#h46-0-88" id="h46-0-88" class="i">+	return build, resp, err
</a><a href="#h46-0-89" id="h46-0-89" class="i">+}
</a><b>diff --git a/<a id="h47" href="../file/vendor/github.com/google/go-github/github/repos_releases.go">vendor/github.com/google/go-github/github/repos_releases.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_releases.go">vendor/github.com/google/go-github/github/repos_releases.go</a></b>
<a href="#h47-0" id="h47-0" class="h">@@ -0,0 +1,320 @@
</a><a href="#h47-0-0" id="h47-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h47-0-1" id="h47-0-1" class="i">+//
</a><a href="#h47-0-2" id="h47-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h47-0-3" id="h47-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h47-0-4" id="h47-0-4" class="i">+
</a><a href="#h47-0-5" id="h47-0-5" class="i">+package github
</a><a href="#h47-0-6" id="h47-0-6" class="i">+
</a><a href="#h47-0-7" id="h47-0-7" class="i">+import (
</a><a href="#h47-0-8" id="h47-0-8" class="i">+	&quot;errors&quot;
</a><a href="#h47-0-9" id="h47-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h47-0-10" id="h47-0-10" class="i">+	&quot;io&quot;
</a><a href="#h47-0-11" id="h47-0-11" class="i">+	&quot;mime&quot;
</a><a href="#h47-0-12" id="h47-0-12" class="i">+	&quot;net/http&quot;
</a><a href="#h47-0-13" id="h47-0-13" class="i">+	&quot;os&quot;
</a><a href="#h47-0-14" id="h47-0-14" class="i">+	&quot;path/filepath&quot;
</a><a href="#h47-0-15" id="h47-0-15" class="i">+	&quot;strings&quot;
</a><a href="#h47-0-16" id="h47-0-16" class="i">+)
</a><a href="#h47-0-17" id="h47-0-17" class="i">+
</a><a href="#h47-0-18" id="h47-0-18" class="i">+// RepositoryRelease represents a GitHub release in a repository.
</a><a href="#h47-0-19" id="h47-0-19" class="i">+type RepositoryRelease struct {
</a><a href="#h47-0-20" id="h47-0-20" class="i">+	ID              *int           `json:&quot;id,omitempty&quot;`
</a><a href="#h47-0-21" id="h47-0-21" class="i">+	TagName         *string        `json:&quot;tag_name,omitempty&quot;`
</a><a href="#h47-0-22" id="h47-0-22" class="i">+	TargetCommitish *string        `json:&quot;target_commitish,omitempty&quot;`
</a><a href="#h47-0-23" id="h47-0-23" class="i">+	Name            *string        `json:&quot;name,omitempty&quot;`
</a><a href="#h47-0-24" id="h47-0-24" class="i">+	Body            *string        `json:&quot;body,omitempty&quot;`
</a><a href="#h47-0-25" id="h47-0-25" class="i">+	Draft           *bool          `json:&quot;draft,omitempty&quot;`
</a><a href="#h47-0-26" id="h47-0-26" class="i">+	Prerelease      *bool          `json:&quot;prerelease,omitempty&quot;`
</a><a href="#h47-0-27" id="h47-0-27" class="i">+	CreatedAt       *Timestamp     `json:&quot;created_at,omitempty&quot;`
</a><a href="#h47-0-28" id="h47-0-28" class="i">+	PublishedAt     *Timestamp     `json:&quot;published_at,omitempty&quot;`
</a><a href="#h47-0-29" id="h47-0-29" class="i">+	URL             *string        `json:&quot;url,omitempty&quot;`
</a><a href="#h47-0-30" id="h47-0-30" class="i">+	HTMLURL         *string        `json:&quot;html_url,omitempty&quot;`
</a><a href="#h47-0-31" id="h47-0-31" class="i">+	AssetsURL       *string        `json:&quot;assets_url,omitempty&quot;`
</a><a href="#h47-0-32" id="h47-0-32" class="i">+	Assets          []ReleaseAsset `json:&quot;assets,omitempty&quot;`
</a><a href="#h47-0-33" id="h47-0-33" class="i">+	UploadURL       *string        `json:&quot;upload_url,omitempty&quot;`
</a><a href="#h47-0-34" id="h47-0-34" class="i">+	ZipballURL      *string        `json:&quot;zipball_url,omitempty&quot;`
</a><a href="#h47-0-35" id="h47-0-35" class="i">+	TarballURL      *string        `json:&quot;tarball_url,omitempty&quot;`
</a><a href="#h47-0-36" id="h47-0-36" class="i">+	Author          *CommitAuthor  `json:&quot;author,omitempty&quot;`
</a><a href="#h47-0-37" id="h47-0-37" class="i">+}
</a><a href="#h47-0-38" id="h47-0-38" class="i">+
</a><a href="#h47-0-39" id="h47-0-39" class="i">+func (r RepositoryRelease) String() string {
</a><a href="#h47-0-40" id="h47-0-40" class="i">+	return Stringify(r)
</a><a href="#h47-0-41" id="h47-0-41" class="i">+}
</a><a href="#h47-0-42" id="h47-0-42" class="i">+
</a><a href="#h47-0-43" id="h47-0-43" class="i">+// ReleaseAsset represents a Github release asset in a repository.
</a><a href="#h47-0-44" id="h47-0-44" class="i">+type ReleaseAsset struct {
</a><a href="#h47-0-45" id="h47-0-45" class="i">+	ID                 *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h47-0-46" id="h47-0-46" class="i">+	URL                *string    `json:&quot;url,omitempty&quot;`
</a><a href="#h47-0-47" id="h47-0-47" class="i">+	Name               *string    `json:&quot;name,omitempty&quot;`
</a><a href="#h47-0-48" id="h47-0-48" class="i">+	Label              *string    `json:&quot;label,omitempty&quot;`
</a><a href="#h47-0-49" id="h47-0-49" class="i">+	State              *string    `json:&quot;state,omitempty&quot;`
</a><a href="#h47-0-50" id="h47-0-50" class="i">+	ContentType        *string    `json:&quot;content_type,omitempty&quot;`
</a><a href="#h47-0-51" id="h47-0-51" class="i">+	Size               *int       `json:&quot;size,omitempty&quot;`
</a><a href="#h47-0-52" id="h47-0-52" class="i">+	DownloadCount      *int       `json:&quot;download_count,omitempty&quot;`
</a><a href="#h47-0-53" id="h47-0-53" class="i">+	CreatedAt          *Timestamp `json:&quot;created_at,omitempty&quot;`
</a><a href="#h47-0-54" id="h47-0-54" class="i">+	UpdatedAt          *Timestamp `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h47-0-55" id="h47-0-55" class="i">+	BrowserDownloadURL *string    `json:&quot;browser_download_url,omitempty&quot;`
</a><a href="#h47-0-56" id="h47-0-56" class="i">+	Uploader           *User      `json:&quot;uploader,omitempty&quot;`
</a><a href="#h47-0-57" id="h47-0-57" class="i">+}
</a><a href="#h47-0-58" id="h47-0-58" class="i">+
</a><a href="#h47-0-59" id="h47-0-59" class="i">+func (r ReleaseAsset) String() string {
</a><a href="#h47-0-60" id="h47-0-60" class="i">+	return Stringify(r)
</a><a href="#h47-0-61" id="h47-0-61" class="i">+}
</a><a href="#h47-0-62" id="h47-0-62" class="i">+
</a><a href="#h47-0-63" id="h47-0-63" class="i">+// ListReleases lists the releases for a repository.
</a><a href="#h47-0-64" id="h47-0-64" class="i">+//
</a><a href="#h47-0-65" id="h47-0-65" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/releases/#list-releases-for-a-repository
</a><a href="#h47-0-66" id="h47-0-66" class="i">+func (s *RepositoriesService) ListReleases(owner, repo string, opt *ListOptions) ([]RepositoryRelease, *Response, error) {
</a><a href="#h47-0-67" id="h47-0-67" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases&quot;, owner, repo)
</a><a href="#h47-0-68" id="h47-0-68" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h47-0-69" id="h47-0-69" class="i">+	if err != nil {
</a><a href="#h47-0-70" id="h47-0-70" class="i">+		return nil, nil, err
</a><a href="#h47-0-71" id="h47-0-71" class="i">+	}
</a><a href="#h47-0-72" id="h47-0-72" class="i">+
</a><a href="#h47-0-73" id="h47-0-73" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h47-0-74" id="h47-0-74" class="i">+	if err != nil {
</a><a href="#h47-0-75" id="h47-0-75" class="i">+		return nil, nil, err
</a><a href="#h47-0-76" id="h47-0-76" class="i">+	}
</a><a href="#h47-0-77" id="h47-0-77" class="i">+
</a><a href="#h47-0-78" id="h47-0-78" class="i">+	releases := new([]RepositoryRelease)
</a><a href="#h47-0-79" id="h47-0-79" class="i">+	resp, err := s.client.Do(req, releases)
</a><a href="#h47-0-80" id="h47-0-80" class="i">+	if err != nil {
</a><a href="#h47-0-81" id="h47-0-81" class="i">+		return nil, resp, err
</a><a href="#h47-0-82" id="h47-0-82" class="i">+	}
</a><a href="#h47-0-83" id="h47-0-83" class="i">+	return *releases, resp, err
</a><a href="#h47-0-84" id="h47-0-84" class="i">+}
</a><a href="#h47-0-85" id="h47-0-85" class="i">+
</a><a href="#h47-0-86" id="h47-0-86" class="i">+// GetRelease fetches a single release.
</a><a href="#h47-0-87" id="h47-0-87" class="i">+//
</a><a href="#h47-0-88" id="h47-0-88" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/releases/#get-a-single-release
</a><a href="#h47-0-89" id="h47-0-89" class="i">+func (s *RepositoriesService) GetRelease(owner, repo string, id int) (*RepositoryRelease, *Response, error) {
</a><a href="#h47-0-90" id="h47-0-90" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/%d&quot;, owner, repo, id)
</a><a href="#h47-0-91" id="h47-0-91" class="i">+	return s.getSingleRelease(u)
</a><a href="#h47-0-92" id="h47-0-92" class="i">+}
</a><a href="#h47-0-93" id="h47-0-93" class="i">+
</a><a href="#h47-0-94" id="h47-0-94" class="i">+// GetLatestRelease fetches the latest published release for the repository.
</a><a href="#h47-0-95" id="h47-0-95" class="i">+//
</a><a href="#h47-0-96" id="h47-0-96" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/releases/#get-the-latest-release
</a><a href="#h47-0-97" id="h47-0-97" class="i">+func (s *RepositoriesService) GetLatestRelease(owner, repo string) (*RepositoryRelease, *Response, error) {
</a><a href="#h47-0-98" id="h47-0-98" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/latest&quot;, owner, repo)
</a><a href="#h47-0-99" id="h47-0-99" class="i">+	return s.getSingleRelease(u)
</a><a href="#h47-0-100" id="h47-0-100" class="i">+}
</a><a href="#h47-0-101" id="h47-0-101" class="i">+
</a><a href="#h47-0-102" id="h47-0-102" class="i">+// GetReleaseByTag fetches a release with the specified tag.
</a><a href="#h47-0-103" id="h47-0-103" class="i">+//
</a><a href="#h47-0-104" id="h47-0-104" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/releases/#get-a-release-by-tag-name
</a><a href="#h47-0-105" id="h47-0-105" class="i">+func (s *RepositoriesService) GetReleaseByTag(owner, repo, tag string) (*RepositoryRelease, *Response, error) {
</a><a href="#h47-0-106" id="h47-0-106" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/tags/%s&quot;, owner, repo, tag)
</a><a href="#h47-0-107" id="h47-0-107" class="i">+	return s.getSingleRelease(u)
</a><a href="#h47-0-108" id="h47-0-108" class="i">+}
</a><a href="#h47-0-109" id="h47-0-109" class="i">+
</a><a href="#h47-0-110" id="h47-0-110" class="i">+func (s *RepositoriesService) getSingleRelease(url string) (*RepositoryRelease, *Response, error) {
</a><a href="#h47-0-111" id="h47-0-111" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, url, nil)
</a><a href="#h47-0-112" id="h47-0-112" class="i">+	if err != nil {
</a><a href="#h47-0-113" id="h47-0-113" class="i">+		return nil, nil, err
</a><a href="#h47-0-114" id="h47-0-114" class="i">+	}
</a><a href="#h47-0-115" id="h47-0-115" class="i">+
</a><a href="#h47-0-116" id="h47-0-116" class="i">+	release := new(RepositoryRelease)
</a><a href="#h47-0-117" id="h47-0-117" class="i">+	resp, err := s.client.Do(req, release)
</a><a href="#h47-0-118" id="h47-0-118" class="i">+	if err != nil {
</a><a href="#h47-0-119" id="h47-0-119" class="i">+		return nil, resp, err
</a><a href="#h47-0-120" id="h47-0-120" class="i">+	}
</a><a href="#h47-0-121" id="h47-0-121" class="i">+	return release, resp, err
</a><a href="#h47-0-122" id="h47-0-122" class="i">+}
</a><a href="#h47-0-123" id="h47-0-123" class="i">+
</a><a href="#h47-0-124" id="h47-0-124" class="i">+// CreateRelease adds a new release for a repository.
</a><a href="#h47-0-125" id="h47-0-125" class="i">+//
</a><a href="#h47-0-126" id="h47-0-126" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#create-a-release
</a><a href="#h47-0-127" id="h47-0-127" class="i">+func (s *RepositoriesService) CreateRelease(owner, repo string, release *RepositoryRelease) (*RepositoryRelease, *Response, error) {
</a><a href="#h47-0-128" id="h47-0-128" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases&quot;, owner, repo)
</a><a href="#h47-0-129" id="h47-0-129" class="i">+
</a><a href="#h47-0-130" id="h47-0-130" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, release)
</a><a href="#h47-0-131" id="h47-0-131" class="i">+	if err != nil {
</a><a href="#h47-0-132" id="h47-0-132" class="i">+		return nil, nil, err
</a><a href="#h47-0-133" id="h47-0-133" class="i">+	}
</a><a href="#h47-0-134" id="h47-0-134" class="i">+
</a><a href="#h47-0-135" id="h47-0-135" class="i">+	r := new(RepositoryRelease)
</a><a href="#h47-0-136" id="h47-0-136" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h47-0-137" id="h47-0-137" class="i">+	if err != nil {
</a><a href="#h47-0-138" id="h47-0-138" class="i">+		return nil, resp, err
</a><a href="#h47-0-139" id="h47-0-139" class="i">+	}
</a><a href="#h47-0-140" id="h47-0-140" class="i">+	return r, resp, err
</a><a href="#h47-0-141" id="h47-0-141" class="i">+}
</a><a href="#h47-0-142" id="h47-0-142" class="i">+
</a><a href="#h47-0-143" id="h47-0-143" class="i">+// EditRelease edits a repository release.
</a><a href="#h47-0-144" id="h47-0-144" class="i">+//
</a><a href="#h47-0-145" id="h47-0-145" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#edit-a-release
</a><a href="#h47-0-146" id="h47-0-146" class="i">+func (s *RepositoriesService) EditRelease(owner, repo string, id int, release *RepositoryRelease) (*RepositoryRelease, *Response, error) {
</a><a href="#h47-0-147" id="h47-0-147" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/%d&quot;, owner, repo, id)
</a><a href="#h47-0-148" id="h47-0-148" class="i">+
</a><a href="#h47-0-149" id="h47-0-149" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, release)
</a><a href="#h47-0-150" id="h47-0-150" class="i">+	if err != nil {
</a><a href="#h47-0-151" id="h47-0-151" class="i">+		return nil, nil, err
</a><a href="#h47-0-152" id="h47-0-152" class="i">+	}
</a><a href="#h47-0-153" id="h47-0-153" class="i">+
</a><a href="#h47-0-154" id="h47-0-154" class="i">+	r := new(RepositoryRelease)
</a><a href="#h47-0-155" id="h47-0-155" class="i">+	resp, err := s.client.Do(req, r)
</a><a href="#h47-0-156" id="h47-0-156" class="i">+	if err != nil {
</a><a href="#h47-0-157" id="h47-0-157" class="i">+		return nil, resp, err
</a><a href="#h47-0-158" id="h47-0-158" class="i">+	}
</a><a href="#h47-0-159" id="h47-0-159" class="i">+	return r, resp, err
</a><a href="#h47-0-160" id="h47-0-160" class="i">+}
</a><a href="#h47-0-161" id="h47-0-161" class="i">+
</a><a href="#h47-0-162" id="h47-0-162" class="i">+// DeleteRelease delete a single release from a repository.
</a><a href="#h47-0-163" id="h47-0-163" class="i">+//
</a><a href="#h47-0-164" id="h47-0-164" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#delete-a-release
</a><a href="#h47-0-165" id="h47-0-165" class="i">+func (s *RepositoriesService) DeleteRelease(owner, repo string, id int) (*Response, error) {
</a><a href="#h47-0-166" id="h47-0-166" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/%d&quot;, owner, repo, id)
</a><a href="#h47-0-167" id="h47-0-167" class="i">+
</a><a href="#h47-0-168" id="h47-0-168" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h47-0-169" id="h47-0-169" class="i">+	if err != nil {
</a><a href="#h47-0-170" id="h47-0-170" class="i">+		return nil, err
</a><a href="#h47-0-171" id="h47-0-171" class="i">+	}
</a><a href="#h47-0-172" id="h47-0-172" class="i">+	return s.client.Do(req, nil)
</a><a href="#h47-0-173" id="h47-0-173" class="i">+}
</a><a href="#h47-0-174" id="h47-0-174" class="i">+
</a><a href="#h47-0-175" id="h47-0-175" class="i">+// ListReleaseAssets lists the release&#39;s assets.
</a><a href="#h47-0-176" id="h47-0-176" class="i">+//
</a><a href="#h47-0-177" id="h47-0-177" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#list-assets-for-a-release
</a><a href="#h47-0-178" id="h47-0-178" class="i">+func (s *RepositoriesService) ListReleaseAssets(owner, repo string, id int, opt *ListOptions) ([]ReleaseAsset, *Response, error) {
</a><a href="#h47-0-179" id="h47-0-179" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/%d/assets&quot;, owner, repo, id)
</a><a href="#h47-0-180" id="h47-0-180" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h47-0-181" id="h47-0-181" class="i">+	if err != nil {
</a><a href="#h47-0-182" id="h47-0-182" class="i">+		return nil, nil, err
</a><a href="#h47-0-183" id="h47-0-183" class="i">+	}
</a><a href="#h47-0-184" id="h47-0-184" class="i">+
</a><a href="#h47-0-185" id="h47-0-185" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h47-0-186" id="h47-0-186" class="i">+	if err != nil {
</a><a href="#h47-0-187" id="h47-0-187" class="i">+		return nil, nil, err
</a><a href="#h47-0-188" id="h47-0-188" class="i">+	}
</a><a href="#h47-0-189" id="h47-0-189" class="i">+
</a><a href="#h47-0-190" id="h47-0-190" class="i">+	assets := new([]ReleaseAsset)
</a><a href="#h47-0-191" id="h47-0-191" class="i">+	resp, err := s.client.Do(req, assets)
</a><a href="#h47-0-192" id="h47-0-192" class="i">+	if err != nil {
</a><a href="#h47-0-193" id="h47-0-193" class="i">+		return nil, resp, nil
</a><a href="#h47-0-194" id="h47-0-194" class="i">+	}
</a><a href="#h47-0-195" id="h47-0-195" class="i">+	return *assets, resp, err
</a><a href="#h47-0-196" id="h47-0-196" class="i">+}
</a><a href="#h47-0-197" id="h47-0-197" class="i">+
</a><a href="#h47-0-198" id="h47-0-198" class="i">+// GetReleaseAsset fetches a single release asset.
</a><a href="#h47-0-199" id="h47-0-199" class="i">+//
</a><a href="#h47-0-200" id="h47-0-200" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#get-a-single-release-asset
</a><a href="#h47-0-201" id="h47-0-201" class="i">+func (s *RepositoriesService) GetReleaseAsset(owner, repo string, id int) (*ReleaseAsset, *Response, error) {
</a><a href="#h47-0-202" id="h47-0-202" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/assets/%d&quot;, owner, repo, id)
</a><a href="#h47-0-203" id="h47-0-203" class="i">+
</a><a href="#h47-0-204" id="h47-0-204" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h47-0-205" id="h47-0-205" class="i">+	if err != nil {
</a><a href="#h47-0-206" id="h47-0-206" class="i">+		return nil, nil, err
</a><a href="#h47-0-207" id="h47-0-207" class="i">+	}
</a><a href="#h47-0-208" id="h47-0-208" class="i">+
</a><a href="#h47-0-209" id="h47-0-209" class="i">+	asset := new(ReleaseAsset)
</a><a href="#h47-0-210" id="h47-0-210" class="i">+	resp, err := s.client.Do(req, asset)
</a><a href="#h47-0-211" id="h47-0-211" class="i">+	if err != nil {
</a><a href="#h47-0-212" id="h47-0-212" class="i">+		return nil, resp, nil
</a><a href="#h47-0-213" id="h47-0-213" class="i">+	}
</a><a href="#h47-0-214" id="h47-0-214" class="i">+	return asset, resp, err
</a><a href="#h47-0-215" id="h47-0-215" class="i">+}
</a><a href="#h47-0-216" id="h47-0-216" class="i">+
</a><a href="#h47-0-217" id="h47-0-217" class="i">+// DownloadReleaseAsset downloads a release asset or returns a redirect URL.
</a><a href="#h47-0-218" id="h47-0-218" class="i">+//
</a><a href="#h47-0-219" id="h47-0-219" class="i">+// DownloadReleaseAsset returns an io.ReadCloser that reads the contents of the
</a><a href="#h47-0-220" id="h47-0-220" class="i">+// specified release asset. It is the caller&#39;s responsibility to close the ReadCloser.
</a><a href="#h47-0-221" id="h47-0-221" class="i">+// If a redirect is returned, the redirect URL will be returned as a string instead
</a><a href="#h47-0-222" id="h47-0-222" class="i">+// of the io.ReadCloser. Exactly one of rc and redirectURL will be zero.
</a><a href="#h47-0-223" id="h47-0-223" class="i">+//
</a><a href="#h47-0-224" id="h47-0-224" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#get-a-single-release-asset
</a><a href="#h47-0-225" id="h47-0-225" class="i">+func (s *RepositoriesService) DownloadReleaseAsset(owner, repo string, id int) (rc io.ReadCloser, redirectURL string, err error) {
</a><a href="#h47-0-226" id="h47-0-226" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/assets/%d&quot;, owner, repo, id)
</a><a href="#h47-0-227" id="h47-0-227" class="i">+
</a><a href="#h47-0-228" id="h47-0-228" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h47-0-229" id="h47-0-229" class="i">+	if err != nil {
</a><a href="#h47-0-230" id="h47-0-230" class="i">+		return nil, &quot;&quot;, err
</a><a href="#h47-0-231" id="h47-0-231" class="i">+	}
</a><a href="#h47-0-232" id="h47-0-232" class="i">+	req.Header.Set(&quot;Accept&quot;, defaultMediaType)
</a><a href="#h47-0-233" id="h47-0-233" class="i">+
</a><a href="#h47-0-234" id="h47-0-234" class="i">+	s.client.clientMu.Lock()
</a><a href="#h47-0-235" id="h47-0-235" class="i">+	defer s.client.clientMu.Unlock()
</a><a href="#h47-0-236" id="h47-0-236" class="i">+
</a><a href="#h47-0-237" id="h47-0-237" class="i">+	var loc string
</a><a href="#h47-0-238" id="h47-0-238" class="i">+	saveRedirect := s.client.client.CheckRedirect
</a><a href="#h47-0-239" id="h47-0-239" class="i">+	s.client.client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
</a><a href="#h47-0-240" id="h47-0-240" class="i">+		loc = req.URL.String()
</a><a href="#h47-0-241" id="h47-0-241" class="i">+		return errors.New(&quot;disable redirect&quot;)
</a><a href="#h47-0-242" id="h47-0-242" class="i">+	}
</a><a href="#h47-0-243" id="h47-0-243" class="i">+	defer func() { s.client.client.CheckRedirect = saveRedirect }()
</a><a href="#h47-0-244" id="h47-0-244" class="i">+
</a><a href="#h47-0-245" id="h47-0-245" class="i">+	resp, err := s.client.client.Do(req)
</a><a href="#h47-0-246" id="h47-0-246" class="i">+	if err != nil {
</a><a href="#h47-0-247" id="h47-0-247" class="i">+		if !strings.Contains(err.Error(), &quot;disable redirect&quot;) {
</a><a href="#h47-0-248" id="h47-0-248" class="i">+			return nil, &quot;&quot;, err
</a><a href="#h47-0-249" id="h47-0-249" class="i">+		}
</a><a href="#h47-0-250" id="h47-0-250" class="i">+		return nil, loc, nil
</a><a href="#h47-0-251" id="h47-0-251" class="i">+	}
</a><a href="#h47-0-252" id="h47-0-252" class="i">+
</a><a href="#h47-0-253" id="h47-0-253" class="i">+	return resp.Body, &quot;&quot;, nil
</a><a href="#h47-0-254" id="h47-0-254" class="i">+}
</a><a href="#h47-0-255" id="h47-0-255" class="i">+
</a><a href="#h47-0-256" id="h47-0-256" class="i">+// EditReleaseAsset edits a repository release asset.
</a><a href="#h47-0-257" id="h47-0-257" class="i">+//
</a><a href="#h47-0-258" id="h47-0-258" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#edit-a-release-asset
</a><a href="#h47-0-259" id="h47-0-259" class="i">+func (s *RepositoriesService) EditReleaseAsset(owner, repo string, id int, release *ReleaseAsset) (*ReleaseAsset, *Response, error) {
</a><a href="#h47-0-260" id="h47-0-260" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/assets/%d&quot;, owner, repo, id)
</a><a href="#h47-0-261" id="h47-0-261" class="i">+
</a><a href="#h47-0-262" id="h47-0-262" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, release)
</a><a href="#h47-0-263" id="h47-0-263" class="i">+	if err != nil {
</a><a href="#h47-0-264" id="h47-0-264" class="i">+		return nil, nil, err
</a><a href="#h47-0-265" id="h47-0-265" class="i">+	}
</a><a href="#h47-0-266" id="h47-0-266" class="i">+
</a><a href="#h47-0-267" id="h47-0-267" class="i">+	asset := new(ReleaseAsset)
</a><a href="#h47-0-268" id="h47-0-268" class="i">+	resp, err := s.client.Do(req, asset)
</a><a href="#h47-0-269" id="h47-0-269" class="i">+	if err != nil {
</a><a href="#h47-0-270" id="h47-0-270" class="i">+		return nil, resp, err
</a><a href="#h47-0-271" id="h47-0-271" class="i">+	}
</a><a href="#h47-0-272" id="h47-0-272" class="i">+	return asset, resp, err
</a><a href="#h47-0-273" id="h47-0-273" class="i">+}
</a><a href="#h47-0-274" id="h47-0-274" class="i">+
</a><a href="#h47-0-275" id="h47-0-275" class="i">+// DeleteReleaseAsset delete a single release asset from a repository.
</a><a href="#h47-0-276" id="h47-0-276" class="i">+//
</a><a href="#h47-0-277" id="h47-0-277" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#delete-a-release-asset
</a><a href="#h47-0-278" id="h47-0-278" class="i">+func (s *RepositoriesService) DeleteReleaseAsset(owner, repo string, id int) (*Response, error) {
</a><a href="#h47-0-279" id="h47-0-279" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/assets/%d&quot;, owner, repo, id)
</a><a href="#h47-0-280" id="h47-0-280" class="i">+
</a><a href="#h47-0-281" id="h47-0-281" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h47-0-282" id="h47-0-282" class="i">+	if err != nil {
</a><a href="#h47-0-283" id="h47-0-283" class="i">+		return nil, err
</a><a href="#h47-0-284" id="h47-0-284" class="i">+	}
</a><a href="#h47-0-285" id="h47-0-285" class="i">+	return s.client.Do(req, nil)
</a><a href="#h47-0-286" id="h47-0-286" class="i">+}
</a><a href="#h47-0-287" id="h47-0-287" class="i">+
</a><a href="#h47-0-288" id="h47-0-288" class="i">+// UploadReleaseAsset creates an asset by uploading a file into a release repository.
</a><a href="#h47-0-289" id="h47-0-289" class="i">+// To upload assets that cannot be represented by an os.File, call NewUploadRequest directly.
</a><a href="#h47-0-290" id="h47-0-290" class="i">+//
</a><a href="#h47-0-291" id="h47-0-291" class="i">+// GitHub API docs : http://developer.github.com/v3/repos/releases/#upload-a-release-asset
</a><a href="#h47-0-292" id="h47-0-292" class="i">+func (s *RepositoriesService) UploadReleaseAsset(owner, repo string, id int, opt *UploadOptions, file *os.File) (*ReleaseAsset, *Response, error) {
</a><a href="#h47-0-293" id="h47-0-293" class="i">+	u := fmt.Sprintf(&quot;repos/%s/%s/releases/%d/assets&quot;, owner, repo, id)
</a><a href="#h47-0-294" id="h47-0-294" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h47-0-295" id="h47-0-295" class="i">+	if err != nil {
</a><a href="#h47-0-296" id="h47-0-296" class="i">+		return nil, nil, err
</a><a href="#h47-0-297" id="h47-0-297" class="i">+	}
</a><a href="#h47-0-298" id="h47-0-298" class="i">+
</a><a href="#h47-0-299" id="h47-0-299" class="i">+	stat, err := file.Stat()
</a><a href="#h47-0-300" id="h47-0-300" class="i">+	if err != nil {
</a><a href="#h47-0-301" id="h47-0-301" class="i">+		return nil, nil, err
</a><a href="#h47-0-302" id="h47-0-302" class="i">+	}
</a><a href="#h47-0-303" id="h47-0-303" class="i">+	if stat.IsDir() {
</a><a href="#h47-0-304" id="h47-0-304" class="i">+		return nil, nil, errors.New(&quot;the asset to upload can&#39;t be a directory&quot;)
</a><a href="#h47-0-305" id="h47-0-305" class="i">+	}
</a><a href="#h47-0-306" id="h47-0-306" class="i">+
</a><a href="#h47-0-307" id="h47-0-307" class="i">+	mediaType := mime.TypeByExtension(filepath.Ext(file.Name()))
</a><a href="#h47-0-308" id="h47-0-308" class="i">+	req, err := s.client.NewUploadRequest(u, file, stat.Size(), mediaType)
</a><a href="#h47-0-309" id="h47-0-309" class="i">+	if err != nil {
</a><a href="#h47-0-310" id="h47-0-310" class="i">+		return nil, nil, err
</a><a href="#h47-0-311" id="h47-0-311" class="i">+	}
</a><a href="#h47-0-312" id="h47-0-312" class="i">+
</a><a href="#h47-0-313" id="h47-0-313" class="i">+	asset := new(ReleaseAsset)
</a><a href="#h47-0-314" id="h47-0-314" class="i">+	resp, err := s.client.Do(req, asset)
</a><a href="#h47-0-315" id="h47-0-315" class="i">+	if err != nil {
</a><a href="#h47-0-316" id="h47-0-316" class="i">+		return nil, resp, err
</a><a href="#h47-0-317" id="h47-0-317" class="i">+	}
</a><a href="#h47-0-318" id="h47-0-318" class="i">+	return asset, resp, err
</a><a href="#h47-0-319" id="h47-0-319" class="i">+}
</a><b>diff --git a/<a id="h48" href="../file/vendor/github.com/google/go-github/github/repos_stats.go">vendor/github.com/google/go-github/github/repos_stats.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_stats.go">vendor/github.com/google/go-github/github/repos_stats.go</a></b>
<a href="#h48-0" id="h48-0" class="h">@@ -0,0 +1,214 @@
</a><a href="#h48-0-0" id="h48-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h48-0-1" id="h48-0-1" class="i">+//
</a><a href="#h48-0-2" id="h48-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h48-0-3" id="h48-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h48-0-4" id="h48-0-4" class="i">+
</a><a href="#h48-0-5" id="h48-0-5" class="i">+package github
</a><a href="#h48-0-6" id="h48-0-6" class="i">+
</a><a href="#h48-0-7" id="h48-0-7" class="i">+import (
</a><a href="#h48-0-8" id="h48-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h48-0-9" id="h48-0-9" class="i">+	&quot;time&quot;
</a><a href="#h48-0-10" id="h48-0-10" class="i">+)
</a><a href="#h48-0-11" id="h48-0-11" class="i">+
</a><a href="#h48-0-12" id="h48-0-12" class="i">+// ContributorStats represents a contributor to a repository and their
</a><a href="#h48-0-13" id="h48-0-13" class="i">+// weekly contributions to a given repo.
</a><a href="#h48-0-14" id="h48-0-14" class="i">+type ContributorStats struct {
</a><a href="#h48-0-15" id="h48-0-15" class="i">+	Author *Contributor  `json:&quot;author,omitempty&quot;`
</a><a href="#h48-0-16" id="h48-0-16" class="i">+	Total  *int          `json:&quot;total,omitempty&quot;`
</a><a href="#h48-0-17" id="h48-0-17" class="i">+	Weeks  []WeeklyStats `json:&quot;weeks,omitempty&quot;`
</a><a href="#h48-0-18" id="h48-0-18" class="i">+}
</a><a href="#h48-0-19" id="h48-0-19" class="i">+
</a><a href="#h48-0-20" id="h48-0-20" class="i">+func (c ContributorStats) String() string {
</a><a href="#h48-0-21" id="h48-0-21" class="i">+	return Stringify(c)
</a><a href="#h48-0-22" id="h48-0-22" class="i">+}
</a><a href="#h48-0-23" id="h48-0-23" class="i">+
</a><a href="#h48-0-24" id="h48-0-24" class="i">+// WeeklyStats represents the number of additions, deletions and commits
</a><a href="#h48-0-25" id="h48-0-25" class="i">+// a Contributor made in a given week.
</a><a href="#h48-0-26" id="h48-0-26" class="i">+type WeeklyStats struct {
</a><a href="#h48-0-27" id="h48-0-27" class="i">+	Week      *Timestamp `json:&quot;w,omitempty&quot;`
</a><a href="#h48-0-28" id="h48-0-28" class="i">+	Additions *int       `json:&quot;a,omitempty&quot;`
</a><a href="#h48-0-29" id="h48-0-29" class="i">+	Deletions *int       `json:&quot;d,omitempty&quot;`
</a><a href="#h48-0-30" id="h48-0-30" class="i">+	Commits   *int       `json:&quot;c,omitempty&quot;`
</a><a href="#h48-0-31" id="h48-0-31" class="i">+}
</a><a href="#h48-0-32" id="h48-0-32" class="i">+
</a><a href="#h48-0-33" id="h48-0-33" class="i">+func (w WeeklyStats) String() string {
</a><a href="#h48-0-34" id="h48-0-34" class="i">+	return Stringify(w)
</a><a href="#h48-0-35" id="h48-0-35" class="i">+}
</a><a href="#h48-0-36" id="h48-0-36" class="i">+
</a><a href="#h48-0-37" id="h48-0-37" class="i">+// ListContributorsStats gets a repo&#39;s contributor list with additions,
</a><a href="#h48-0-38" id="h48-0-38" class="i">+// deletions and commit counts.
</a><a href="#h48-0-39" id="h48-0-39" class="i">+//
</a><a href="#h48-0-40" id="h48-0-40" class="i">+// If this is the first time these statistics are requested for the given
</a><a href="#h48-0-41" id="h48-0-41" class="i">+// repository, this method will return a non-nil error and a status code of
</a><a href="#h48-0-42" id="h48-0-42" class="i">+// 202. This is because this is the status that github returns to signify that
</a><a href="#h48-0-43" id="h48-0-43" class="i">+// it is now computing the requested statistics. A follow up request, after a
</a><a href="#h48-0-44" id="h48-0-44" class="i">+// delay of a second or so, should result in a successful request.
</a><a href="#h48-0-45" id="h48-0-45" class="i">+//
</a><a href="#h48-0-46" id="h48-0-46" class="i">+// GitHub API Docs: https://developer.github.com/v3/repos/statistics/#contributors
</a><a href="#h48-0-47" id="h48-0-47" class="i">+func (s *RepositoriesService) ListContributorsStats(owner, repo string) ([]ContributorStats, *Response, error) {
</a><a href="#h48-0-48" id="h48-0-48" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/stats/contributors&quot;, owner, repo)
</a><a href="#h48-0-49" id="h48-0-49" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h48-0-50" id="h48-0-50" class="i">+	if err != nil {
</a><a href="#h48-0-51" id="h48-0-51" class="i">+		return nil, nil, err
</a><a href="#h48-0-52" id="h48-0-52" class="i">+	}
</a><a href="#h48-0-53" id="h48-0-53" class="i">+
</a><a href="#h48-0-54" id="h48-0-54" class="i">+	var contributorStats []ContributorStats
</a><a href="#h48-0-55" id="h48-0-55" class="i">+	resp, err := s.client.Do(req, &amp;contributorStats)
</a><a href="#h48-0-56" id="h48-0-56" class="i">+	if err != nil {
</a><a href="#h48-0-57" id="h48-0-57" class="i">+		return nil, resp, err
</a><a href="#h48-0-58" id="h48-0-58" class="i">+	}
</a><a href="#h48-0-59" id="h48-0-59" class="i">+
</a><a href="#h48-0-60" id="h48-0-60" class="i">+	return contributorStats, resp, err
</a><a href="#h48-0-61" id="h48-0-61" class="i">+}
</a><a href="#h48-0-62" id="h48-0-62" class="i">+
</a><a href="#h48-0-63" id="h48-0-63" class="i">+// WeeklyCommitActivity represents the weekly commit activity for a repository.
</a><a href="#h48-0-64" id="h48-0-64" class="i">+// The days array is a group of commits per day, starting on Sunday.
</a><a href="#h48-0-65" id="h48-0-65" class="i">+type WeeklyCommitActivity struct {
</a><a href="#h48-0-66" id="h48-0-66" class="i">+	Days  []int      `json:&quot;days,omitempty&quot;`
</a><a href="#h48-0-67" id="h48-0-67" class="i">+	Total *int       `json:&quot;total,omitempty&quot;`
</a><a href="#h48-0-68" id="h48-0-68" class="i">+	Week  *Timestamp `json:&quot;week,omitempty&quot;`
</a><a href="#h48-0-69" id="h48-0-69" class="i">+}
</a><a href="#h48-0-70" id="h48-0-70" class="i">+
</a><a href="#h48-0-71" id="h48-0-71" class="i">+func (w WeeklyCommitActivity) String() string {
</a><a href="#h48-0-72" id="h48-0-72" class="i">+	return Stringify(w)
</a><a href="#h48-0-73" id="h48-0-73" class="i">+}
</a><a href="#h48-0-74" id="h48-0-74" class="i">+
</a><a href="#h48-0-75" id="h48-0-75" class="i">+// ListCommitActivity returns the last year of commit activity
</a><a href="#h48-0-76" id="h48-0-76" class="i">+// grouped by week. The days array is a group of commits per day,
</a><a href="#h48-0-77" id="h48-0-77" class="i">+// starting on Sunday.
</a><a href="#h48-0-78" id="h48-0-78" class="i">+//
</a><a href="#h48-0-79" id="h48-0-79" class="i">+// If this is the first time these statistics are requested for the given
</a><a href="#h48-0-80" id="h48-0-80" class="i">+// repository, this method will return a non-nil error and a status code of
</a><a href="#h48-0-81" id="h48-0-81" class="i">+// 202. This is because this is the status that github returns to signify that
</a><a href="#h48-0-82" id="h48-0-82" class="i">+// it is now computing the requested statistics. A follow up request, after a
</a><a href="#h48-0-83" id="h48-0-83" class="i">+// delay of a second or so, should result in a successful request.
</a><a href="#h48-0-84" id="h48-0-84" class="i">+//
</a><a href="#h48-0-85" id="h48-0-85" class="i">+// GitHub API Docs: https://developer.github.com/v3/repos/statistics/#commit-activity
</a><a href="#h48-0-86" id="h48-0-86" class="i">+func (s *RepositoriesService) ListCommitActivity(owner, repo string) ([]WeeklyCommitActivity, *Response, error) {
</a><a href="#h48-0-87" id="h48-0-87" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/stats/commit_activity&quot;, owner, repo)
</a><a href="#h48-0-88" id="h48-0-88" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h48-0-89" id="h48-0-89" class="i">+	if err != nil {
</a><a href="#h48-0-90" id="h48-0-90" class="i">+		return nil, nil, err
</a><a href="#h48-0-91" id="h48-0-91" class="i">+	}
</a><a href="#h48-0-92" id="h48-0-92" class="i">+
</a><a href="#h48-0-93" id="h48-0-93" class="i">+	var weeklyCommitActivity []WeeklyCommitActivity
</a><a href="#h48-0-94" id="h48-0-94" class="i">+	resp, err := s.client.Do(req, &amp;weeklyCommitActivity)
</a><a href="#h48-0-95" id="h48-0-95" class="i">+	if err != nil {
</a><a href="#h48-0-96" id="h48-0-96" class="i">+		return nil, resp, err
</a><a href="#h48-0-97" id="h48-0-97" class="i">+	}
</a><a href="#h48-0-98" id="h48-0-98" class="i">+
</a><a href="#h48-0-99" id="h48-0-99" class="i">+	return weeklyCommitActivity, resp, err
</a><a href="#h48-0-100" id="h48-0-100" class="i">+}
</a><a href="#h48-0-101" id="h48-0-101" class="i">+
</a><a href="#h48-0-102" id="h48-0-102" class="i">+// ListCodeFrequency returns a weekly aggregate of the number of additions and
</a><a href="#h48-0-103" id="h48-0-103" class="i">+// deletions pushed to a repository.  Returned WeeklyStats will contain
</a><a href="#h48-0-104" id="h48-0-104" class="i">+// additions and deletions, but not total commits.
</a><a href="#h48-0-105" id="h48-0-105" class="i">+//
</a><a href="#h48-0-106" id="h48-0-106" class="i">+// GitHub API Docs: https://developer.github.com/v3/repos/statistics/#code-frequency
</a><a href="#h48-0-107" id="h48-0-107" class="i">+func (s *RepositoriesService) ListCodeFrequency(owner, repo string) ([]WeeklyStats, *Response, error) {
</a><a href="#h48-0-108" id="h48-0-108" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/stats/code_frequency&quot;, owner, repo)
</a><a href="#h48-0-109" id="h48-0-109" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h48-0-110" id="h48-0-110" class="i">+	if err != nil {
</a><a href="#h48-0-111" id="h48-0-111" class="i">+		return nil, nil, err
</a><a href="#h48-0-112" id="h48-0-112" class="i">+	}
</a><a href="#h48-0-113" id="h48-0-113" class="i">+
</a><a href="#h48-0-114" id="h48-0-114" class="i">+	var weeks [][]int
</a><a href="#h48-0-115" id="h48-0-115" class="i">+	resp, err := s.client.Do(req, &amp;weeks)
</a><a href="#h48-0-116" id="h48-0-116" class="i">+
</a><a href="#h48-0-117" id="h48-0-117" class="i">+	// convert int slices into WeeklyStats
</a><a href="#h48-0-118" id="h48-0-118" class="i">+	var stats []WeeklyStats
</a><a href="#h48-0-119" id="h48-0-119" class="i">+	for _, week := range weeks {
</a><a href="#h48-0-120" id="h48-0-120" class="i">+		if len(week) != 3 {
</a><a href="#h48-0-121" id="h48-0-121" class="i">+			continue
</a><a href="#h48-0-122" id="h48-0-122" class="i">+		}
</a><a href="#h48-0-123" id="h48-0-123" class="i">+		stat := WeeklyStats{
</a><a href="#h48-0-124" id="h48-0-124" class="i">+			Week:      &amp;Timestamp{time.Unix(int64(week[0]), 0)},
</a><a href="#h48-0-125" id="h48-0-125" class="i">+			Additions: Int(week[1]),
</a><a href="#h48-0-126" id="h48-0-126" class="i">+			Deletions: Int(week[2]),
</a><a href="#h48-0-127" id="h48-0-127" class="i">+		}
</a><a href="#h48-0-128" id="h48-0-128" class="i">+		stats = append(stats, stat)
</a><a href="#h48-0-129" id="h48-0-129" class="i">+	}
</a><a href="#h48-0-130" id="h48-0-130" class="i">+
</a><a href="#h48-0-131" id="h48-0-131" class="i">+	return stats, resp, err
</a><a href="#h48-0-132" id="h48-0-132" class="i">+}
</a><a href="#h48-0-133" id="h48-0-133" class="i">+
</a><a href="#h48-0-134" id="h48-0-134" class="i">+// RepositoryParticipation is the number of commits by everyone
</a><a href="#h48-0-135" id="h48-0-135" class="i">+// who has contributed to the repository (including the owner)
</a><a href="#h48-0-136" id="h48-0-136" class="i">+// as well as the number of commits by the owner themself.
</a><a href="#h48-0-137" id="h48-0-137" class="i">+type RepositoryParticipation struct {
</a><a href="#h48-0-138" id="h48-0-138" class="i">+	All   []int `json:&quot;all,omitempty&quot;`
</a><a href="#h48-0-139" id="h48-0-139" class="i">+	Owner []int `json:&quot;owner,omitempty&quot;`
</a><a href="#h48-0-140" id="h48-0-140" class="i">+}
</a><a href="#h48-0-141" id="h48-0-141" class="i">+
</a><a href="#h48-0-142" id="h48-0-142" class="i">+func (r RepositoryParticipation) String() string {
</a><a href="#h48-0-143" id="h48-0-143" class="i">+	return Stringify(r)
</a><a href="#h48-0-144" id="h48-0-144" class="i">+}
</a><a href="#h48-0-145" id="h48-0-145" class="i">+
</a><a href="#h48-0-146" id="h48-0-146" class="i">+// ListParticipation returns the total commit counts for the &#39;owner&#39;
</a><a href="#h48-0-147" id="h48-0-147" class="i">+// and total commit counts in &#39;all&#39;. &#39;all&#39; is everyone combined,
</a><a href="#h48-0-148" id="h48-0-148" class="i">+// including the &#39;owner&#39; in the last 52 weeks. If youd like to get
</a><a href="#h48-0-149" id="h48-0-149" class="i">+// the commit counts for non-owners, you can subtract &#39;all&#39; from &#39;owner&#39;.
</a><a href="#h48-0-150" id="h48-0-150" class="i">+//
</a><a href="#h48-0-151" id="h48-0-151" class="i">+// The array order is oldest week (index 0) to most recent week.
</a><a href="#h48-0-152" id="h48-0-152" class="i">+//
</a><a href="#h48-0-153" id="h48-0-153" class="i">+// If this is the first time these statistics are requested for the given
</a><a href="#h48-0-154" id="h48-0-154" class="i">+// repository, this method will return a non-nil error and a status code
</a><a href="#h48-0-155" id="h48-0-155" class="i">+// of 202. This is because this is the status that github returns to
</a><a href="#h48-0-156" id="h48-0-156" class="i">+// signify that it is now computing the requested statistics. A follow
</a><a href="#h48-0-157" id="h48-0-157" class="i">+// up request, after a delay of a second or so, should result in a
</a><a href="#h48-0-158" id="h48-0-158" class="i">+// successful request.
</a><a href="#h48-0-159" id="h48-0-159" class="i">+//
</a><a href="#h48-0-160" id="h48-0-160" class="i">+// GitHub API Docs: https://developer.github.com/v3/repos/statistics/#participation
</a><a href="#h48-0-161" id="h48-0-161" class="i">+func (s *RepositoriesService) ListParticipation(owner, repo string) (*RepositoryParticipation, *Response, error) {
</a><a href="#h48-0-162" id="h48-0-162" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/stats/participation&quot;, owner, repo)
</a><a href="#h48-0-163" id="h48-0-163" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h48-0-164" id="h48-0-164" class="i">+	if err != nil {
</a><a href="#h48-0-165" id="h48-0-165" class="i">+		return nil, nil, err
</a><a href="#h48-0-166" id="h48-0-166" class="i">+	}
</a><a href="#h48-0-167" id="h48-0-167" class="i">+
</a><a href="#h48-0-168" id="h48-0-168" class="i">+	participation := new(RepositoryParticipation)
</a><a href="#h48-0-169" id="h48-0-169" class="i">+	resp, err := s.client.Do(req, participation)
</a><a href="#h48-0-170" id="h48-0-170" class="i">+	if err != nil {
</a><a href="#h48-0-171" id="h48-0-171" class="i">+		return nil, resp, err
</a><a href="#h48-0-172" id="h48-0-172" class="i">+	}
</a><a href="#h48-0-173" id="h48-0-173" class="i">+
</a><a href="#h48-0-174" id="h48-0-174" class="i">+	return participation, resp, err
</a><a href="#h48-0-175" id="h48-0-175" class="i">+}
</a><a href="#h48-0-176" id="h48-0-176" class="i">+
</a><a href="#h48-0-177" id="h48-0-177" class="i">+// PunchCard represents the number of commits made during a given hour of a
</a><a href="#h48-0-178" id="h48-0-178" class="i">+// day of thew eek.
</a><a href="#h48-0-179" id="h48-0-179" class="i">+type PunchCard struct {
</a><a href="#h48-0-180" id="h48-0-180" class="i">+	Day     *int // Day of the week (0-6: =Sunday - Saturday).
</a><a href="#h48-0-181" id="h48-0-181" class="i">+	Hour    *int // Hour of day (0-23).
</a><a href="#h48-0-182" id="h48-0-182" class="i">+	Commits *int // Number of commits.
</a><a href="#h48-0-183" id="h48-0-183" class="i">+}
</a><a href="#h48-0-184" id="h48-0-184" class="i">+
</a><a href="#h48-0-185" id="h48-0-185" class="i">+// ListPunchCard returns the number of commits per hour in each day.
</a><a href="#h48-0-186" id="h48-0-186" class="i">+//
</a><a href="#h48-0-187" id="h48-0-187" class="i">+// GitHub API Docs: https://developer.github.com/v3/repos/statistics/#punch-card
</a><a href="#h48-0-188" id="h48-0-188" class="i">+func (s *RepositoriesService) ListPunchCard(owner, repo string) ([]PunchCard, *Response, error) {
</a><a href="#h48-0-189" id="h48-0-189" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/stats/punch_card&quot;, owner, repo)
</a><a href="#h48-0-190" id="h48-0-190" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h48-0-191" id="h48-0-191" class="i">+	if err != nil {
</a><a href="#h48-0-192" id="h48-0-192" class="i">+		return nil, nil, err
</a><a href="#h48-0-193" id="h48-0-193" class="i">+	}
</a><a href="#h48-0-194" id="h48-0-194" class="i">+
</a><a href="#h48-0-195" id="h48-0-195" class="i">+	var results [][]int
</a><a href="#h48-0-196" id="h48-0-196" class="i">+	resp, err := s.client.Do(req, &amp;results)
</a><a href="#h48-0-197" id="h48-0-197" class="i">+
</a><a href="#h48-0-198" id="h48-0-198" class="i">+	// convert int slices into Punchcards
</a><a href="#h48-0-199" id="h48-0-199" class="i">+	var cards []PunchCard
</a><a href="#h48-0-200" id="h48-0-200" class="i">+	for _, result := range results {
</a><a href="#h48-0-201" id="h48-0-201" class="i">+		if len(result) != 3 {
</a><a href="#h48-0-202" id="h48-0-202" class="i">+			continue
</a><a href="#h48-0-203" id="h48-0-203" class="i">+		}
</a><a href="#h48-0-204" id="h48-0-204" class="i">+		card := PunchCard{
</a><a href="#h48-0-205" id="h48-0-205" class="i">+			Day:     Int(result[0]),
</a><a href="#h48-0-206" id="h48-0-206" class="i">+			Hour:    Int(result[1]),
</a><a href="#h48-0-207" id="h48-0-207" class="i">+			Commits: Int(result[2]),
</a><a href="#h48-0-208" id="h48-0-208" class="i">+		}
</a><a href="#h48-0-209" id="h48-0-209" class="i">+		cards = append(cards, card)
</a><a href="#h48-0-210" id="h48-0-210" class="i">+	}
</a><a href="#h48-0-211" id="h48-0-211" class="i">+
</a><a href="#h48-0-212" id="h48-0-212" class="i">+	return cards, resp, err
</a><a href="#h48-0-213" id="h48-0-213" class="i">+}
</a><b>diff --git a/<a id="h49" href="../file/vendor/github.com/google/go-github/github/repos_statuses.go">vendor/github.com/google/go-github/github/repos_statuses.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/repos_statuses.go">vendor/github.com/google/go-github/github/repos_statuses.go</a></b>
<a href="#h49-0" id="h49-0" class="h">@@ -0,0 +1,128 @@
</a><a href="#h49-0-0" id="h49-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h49-0-1" id="h49-0-1" class="i">+//
</a><a href="#h49-0-2" id="h49-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h49-0-3" id="h49-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h49-0-4" id="h49-0-4" class="i">+
</a><a href="#h49-0-5" id="h49-0-5" class="i">+package github
</a><a href="#h49-0-6" id="h49-0-6" class="i">+
</a><a href="#h49-0-7" id="h49-0-7" class="i">+import (
</a><a href="#h49-0-8" id="h49-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h49-0-9" id="h49-0-9" class="i">+	&quot;time&quot;
</a><a href="#h49-0-10" id="h49-0-10" class="i">+)
</a><a href="#h49-0-11" id="h49-0-11" class="i">+
</a><a href="#h49-0-12" id="h49-0-12" class="i">+// RepoStatus represents the status of a repository at a particular reference.
</a><a href="#h49-0-13" id="h49-0-13" class="i">+type RepoStatus struct {
</a><a href="#h49-0-14" id="h49-0-14" class="i">+	ID  *int    `json:&quot;id,omitempty&quot;`
</a><a href="#h49-0-15" id="h49-0-15" class="i">+	URL *string `json:&quot;url,omitempty&quot;`
</a><a href="#h49-0-16" id="h49-0-16" class="i">+
</a><a href="#h49-0-17" id="h49-0-17" class="i">+	// State is the current state of the repository.  Possible values are:
</a><a href="#h49-0-18" id="h49-0-18" class="i">+	// pending, success, error, or failure.
</a><a href="#h49-0-19" id="h49-0-19" class="i">+	State *string `json:&quot;state,omitempty&quot;`
</a><a href="#h49-0-20" id="h49-0-20" class="i">+
</a><a href="#h49-0-21" id="h49-0-21" class="i">+	// TargetURL is the URL of the page representing this status.  It will be
</a><a href="#h49-0-22" id="h49-0-22" class="i">+	// linked from the GitHub UI to allow users to see the source of the status.
</a><a href="#h49-0-23" id="h49-0-23" class="i">+	TargetURL *string `json:&quot;target_url,omitempty&quot;`
</a><a href="#h49-0-24" id="h49-0-24" class="i">+
</a><a href="#h49-0-25" id="h49-0-25" class="i">+	// Description is a short high level summary of the status.
</a><a href="#h49-0-26" id="h49-0-26" class="i">+	Description *string `json:&quot;description,omitempty&quot;`
</a><a href="#h49-0-27" id="h49-0-27" class="i">+
</a><a href="#h49-0-28" id="h49-0-28" class="i">+	// A string label to differentiate this status from the statuses of other systems.
</a><a href="#h49-0-29" id="h49-0-29" class="i">+	Context *string `json:&quot;context,omitempty&quot;`
</a><a href="#h49-0-30" id="h49-0-30" class="i">+
</a><a href="#h49-0-31" id="h49-0-31" class="i">+	Creator   *User      `json:&quot;creator,omitempty&quot;`
</a><a href="#h49-0-32" id="h49-0-32" class="i">+	CreatedAt *time.Time `json:&quot;created_at,omitempty&quot;`
</a><a href="#h49-0-33" id="h49-0-33" class="i">+	UpdatedAt *time.Time `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h49-0-34" id="h49-0-34" class="i">+}
</a><a href="#h49-0-35" id="h49-0-35" class="i">+
</a><a href="#h49-0-36" id="h49-0-36" class="i">+func (r RepoStatus) String() string {
</a><a href="#h49-0-37" id="h49-0-37" class="i">+	return Stringify(r)
</a><a href="#h49-0-38" id="h49-0-38" class="i">+}
</a><a href="#h49-0-39" id="h49-0-39" class="i">+
</a><a href="#h49-0-40" id="h49-0-40" class="i">+// ListStatuses lists the statuses of a repository at the specified
</a><a href="#h49-0-41" id="h49-0-41" class="i">+// reference.  ref can be a SHA, a branch name, or a tag name.
</a><a href="#h49-0-42" id="h49-0-42" class="i">+//
</a><a href="#h49-0-43" id="h49-0-43" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref
</a><a href="#h49-0-44" id="h49-0-44" class="i">+func (s *RepositoriesService) ListStatuses(owner, repo, ref string, opt *ListOptions) ([]RepoStatus, *Response, error) {
</a><a href="#h49-0-45" id="h49-0-45" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/commits/%v/statuses&quot;, owner, repo, ref)
</a><a href="#h49-0-46" id="h49-0-46" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h49-0-47" id="h49-0-47" class="i">+	if err != nil {
</a><a href="#h49-0-48" id="h49-0-48" class="i">+		return nil, nil, err
</a><a href="#h49-0-49" id="h49-0-49" class="i">+	}
</a><a href="#h49-0-50" id="h49-0-50" class="i">+
</a><a href="#h49-0-51" id="h49-0-51" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h49-0-52" id="h49-0-52" class="i">+	if err != nil {
</a><a href="#h49-0-53" id="h49-0-53" class="i">+		return nil, nil, err
</a><a href="#h49-0-54" id="h49-0-54" class="i">+	}
</a><a href="#h49-0-55" id="h49-0-55" class="i">+
</a><a href="#h49-0-56" id="h49-0-56" class="i">+	statuses := new([]RepoStatus)
</a><a href="#h49-0-57" id="h49-0-57" class="i">+	resp, err := s.client.Do(req, statuses)
</a><a href="#h49-0-58" id="h49-0-58" class="i">+	if err != nil {
</a><a href="#h49-0-59" id="h49-0-59" class="i">+		return nil, resp, err
</a><a href="#h49-0-60" id="h49-0-60" class="i">+	}
</a><a href="#h49-0-61" id="h49-0-61" class="i">+
</a><a href="#h49-0-62" id="h49-0-62" class="i">+	return *statuses, resp, err
</a><a href="#h49-0-63" id="h49-0-63" class="i">+}
</a><a href="#h49-0-64" id="h49-0-64" class="i">+
</a><a href="#h49-0-65" id="h49-0-65" class="i">+// CreateStatus creates a new status for a repository at the specified
</a><a href="#h49-0-66" id="h49-0-66" class="i">+// reference.  Ref can be a SHA, a branch name, or a tag name.
</a><a href="#h49-0-67" id="h49-0-67" class="i">+//
</a><a href="#h49-0-68" id="h49-0-68" class="i">+// GitHub API docs: http://developer.github.com/v3/repos/statuses/#create-a-status
</a><a href="#h49-0-69" id="h49-0-69" class="i">+func (s *RepositoriesService) CreateStatus(owner, repo, ref string, status *RepoStatus) (*RepoStatus, *Response, error) {
</a><a href="#h49-0-70" id="h49-0-70" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/statuses/%v&quot;, owner, repo, ref)
</a><a href="#h49-0-71" id="h49-0-71" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, status)
</a><a href="#h49-0-72" id="h49-0-72" class="i">+	if err != nil {
</a><a href="#h49-0-73" id="h49-0-73" class="i">+		return nil, nil, err
</a><a href="#h49-0-74" id="h49-0-74" class="i">+	}
</a><a href="#h49-0-75" id="h49-0-75" class="i">+
</a><a href="#h49-0-76" id="h49-0-76" class="i">+	repoStatus := new(RepoStatus)
</a><a href="#h49-0-77" id="h49-0-77" class="i">+	resp, err := s.client.Do(req, repoStatus)
</a><a href="#h49-0-78" id="h49-0-78" class="i">+	if err != nil {
</a><a href="#h49-0-79" id="h49-0-79" class="i">+		return nil, resp, err
</a><a href="#h49-0-80" id="h49-0-80" class="i">+	}
</a><a href="#h49-0-81" id="h49-0-81" class="i">+
</a><a href="#h49-0-82" id="h49-0-82" class="i">+	return repoStatus, resp, err
</a><a href="#h49-0-83" id="h49-0-83" class="i">+}
</a><a href="#h49-0-84" id="h49-0-84" class="i">+
</a><a href="#h49-0-85" id="h49-0-85" class="i">+// CombinedStatus represents the combined status of a repository at a particular reference.
</a><a href="#h49-0-86" id="h49-0-86" class="i">+type CombinedStatus struct {
</a><a href="#h49-0-87" id="h49-0-87" class="i">+	// State is the combined state of the repository.  Possible values are:
</a><a href="#h49-0-88" id="h49-0-88" class="i">+	// failure, pending, or success.
</a><a href="#h49-0-89" id="h49-0-89" class="i">+	State *string `json:&quot;state,omitempty&quot;`
</a><a href="#h49-0-90" id="h49-0-90" class="i">+
</a><a href="#h49-0-91" id="h49-0-91" class="i">+	Name       *string      `json:&quot;name,omitempty&quot;`
</a><a href="#h49-0-92" id="h49-0-92" class="i">+	SHA        *string      `json:&quot;sha,omitempty&quot;`
</a><a href="#h49-0-93" id="h49-0-93" class="i">+	TotalCount *int         `json:&quot;total_count,omitempty&quot;`
</a><a href="#h49-0-94" id="h49-0-94" class="i">+	Statuses   []RepoStatus `json:&quot;statuses,omitempty&quot;`
</a><a href="#h49-0-95" id="h49-0-95" class="i">+
</a><a href="#h49-0-96" id="h49-0-96" class="i">+	CommitURL     *string `json:&quot;commit_url,omitempty&quot;`
</a><a href="#h49-0-97" id="h49-0-97" class="i">+	RepositoryURL *string `json:&quot;repository_url,omitempty&quot;`
</a><a href="#h49-0-98" id="h49-0-98" class="i">+}
</a><a href="#h49-0-99" id="h49-0-99" class="i">+
</a><a href="#h49-0-100" id="h49-0-100" class="i">+func (s CombinedStatus) String() string {
</a><a href="#h49-0-101" id="h49-0-101" class="i">+	return Stringify(s)
</a><a href="#h49-0-102" id="h49-0-102" class="i">+}
</a><a href="#h49-0-103" id="h49-0-103" class="i">+
</a><a href="#h49-0-104" id="h49-0-104" class="i">+// GetCombinedStatus returns the combined status of a repository at the specified
</a><a href="#h49-0-105" id="h49-0-105" class="i">+// reference.  ref can be a SHA, a branch name, or a tag name.
</a><a href="#h49-0-106" id="h49-0-106" class="i">+//
</a><a href="#h49-0-107" id="h49-0-107" class="i">+// GitHub API docs: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
</a><a href="#h49-0-108" id="h49-0-108" class="i">+func (s *RepositoriesService) GetCombinedStatus(owner, repo, ref string, opt *ListOptions) (*CombinedStatus, *Response, error) {
</a><a href="#h49-0-109" id="h49-0-109" class="i">+	u := fmt.Sprintf(&quot;repos/%v/%v/commits/%v/status&quot;, owner, repo, ref)
</a><a href="#h49-0-110" id="h49-0-110" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h49-0-111" id="h49-0-111" class="i">+	if err != nil {
</a><a href="#h49-0-112" id="h49-0-112" class="i">+		return nil, nil, err
</a><a href="#h49-0-113" id="h49-0-113" class="i">+	}
</a><a href="#h49-0-114" id="h49-0-114" class="i">+
</a><a href="#h49-0-115" id="h49-0-115" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h49-0-116" id="h49-0-116" class="i">+	if err != nil {
</a><a href="#h49-0-117" id="h49-0-117" class="i">+		return nil, nil, err
</a><a href="#h49-0-118" id="h49-0-118" class="i">+	}
</a><a href="#h49-0-119" id="h49-0-119" class="i">+
</a><a href="#h49-0-120" id="h49-0-120" class="i">+	status := new(CombinedStatus)
</a><a href="#h49-0-121" id="h49-0-121" class="i">+	resp, err := s.client.Do(req, status)
</a><a href="#h49-0-122" id="h49-0-122" class="i">+	if err != nil {
</a><a href="#h49-0-123" id="h49-0-123" class="i">+		return nil, resp, err
</a><a href="#h49-0-124" id="h49-0-124" class="i">+	}
</a><a href="#h49-0-125" id="h49-0-125" class="i">+
</a><a href="#h49-0-126" id="h49-0-126" class="i">+	return status, resp, err
</a><a href="#h49-0-127" id="h49-0-127" class="i">+}
</a><b>diff --git a/<a id="h50" href="../file/vendor/github.com/google/go-github/github/search.go">vendor/github.com/google/go-github/github/search.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/search.go">vendor/github.com/google/go-github/github/search.go</a></b>
<a href="#h50-0" id="h50-0" class="h">@@ -0,0 +1,158 @@
</a><a href="#h50-0-0" id="h50-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h50-0-1" id="h50-0-1" class="i">+//
</a><a href="#h50-0-2" id="h50-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h50-0-3" id="h50-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h50-0-4" id="h50-0-4" class="i">+
</a><a href="#h50-0-5" id="h50-0-5" class="i">+package github
</a><a href="#h50-0-6" id="h50-0-6" class="i">+
</a><a href="#h50-0-7" id="h50-0-7" class="i">+import (
</a><a href="#h50-0-8" id="h50-0-8" class="i">+	&quot;fmt&quot;
</a><a href="#h50-0-9" id="h50-0-9" class="i">+
</a><a href="#h50-0-10" id="h50-0-10" class="i">+	qs &quot;github.com/google/go-querystring/query&quot;
</a><a href="#h50-0-11" id="h50-0-11" class="i">+)
</a><a href="#h50-0-12" id="h50-0-12" class="i">+
</a><a href="#h50-0-13" id="h50-0-13" class="i">+// SearchService provides access to the search related functions
</a><a href="#h50-0-14" id="h50-0-14" class="i">+// in the GitHub API.
</a><a href="#h50-0-15" id="h50-0-15" class="i">+//
</a><a href="#h50-0-16" id="h50-0-16" class="i">+// GitHub API docs: http://developer.github.com/v3/search/
</a><a href="#h50-0-17" id="h50-0-17" class="i">+type SearchService struct {
</a><a href="#h50-0-18" id="h50-0-18" class="i">+	client *Client
</a><a href="#h50-0-19" id="h50-0-19" class="i">+}
</a><a href="#h50-0-20" id="h50-0-20" class="i">+
</a><a href="#h50-0-21" id="h50-0-21" class="i">+// SearchOptions specifies optional parameters to the SearchService methods.
</a><a href="#h50-0-22" id="h50-0-22" class="i">+type SearchOptions struct {
</a><a href="#h50-0-23" id="h50-0-23" class="i">+	// How to sort the search results.  Possible values are:
</a><a href="#h50-0-24" id="h50-0-24" class="i">+	//   - for repositories: stars, fork, updated
</a><a href="#h50-0-25" id="h50-0-25" class="i">+	//   - for code: indexed
</a><a href="#h50-0-26" id="h50-0-26" class="i">+	//   - for issues: comments, created, updated
</a><a href="#h50-0-27" id="h50-0-27" class="i">+	//   - for users: followers, repositories, joined
</a><a href="#h50-0-28" id="h50-0-28" class="i">+	//
</a><a href="#h50-0-29" id="h50-0-29" class="i">+	// Default is to sort by best match.
</a><a href="#h50-0-30" id="h50-0-30" class="i">+	Sort string `url:&quot;sort,omitempty&quot;`
</a><a href="#h50-0-31" id="h50-0-31" class="i">+
</a><a href="#h50-0-32" id="h50-0-32" class="i">+	// Sort order if sort parameter is provided. Possible values are: asc,
</a><a href="#h50-0-33" id="h50-0-33" class="i">+	// desc. Default is desc.
</a><a href="#h50-0-34" id="h50-0-34" class="i">+	Order string `url:&quot;order,omitempty&quot;`
</a><a href="#h50-0-35" id="h50-0-35" class="i">+
</a><a href="#h50-0-36" id="h50-0-36" class="i">+	// Whether to retrieve text match metadata with a query
</a><a href="#h50-0-37" id="h50-0-37" class="i">+	TextMatch bool `url:&quot;-&quot;`
</a><a href="#h50-0-38" id="h50-0-38" class="i">+
</a><a href="#h50-0-39" id="h50-0-39" class="i">+	ListOptions
</a><a href="#h50-0-40" id="h50-0-40" class="i">+}
</a><a href="#h50-0-41" id="h50-0-41" class="i">+
</a><a href="#h50-0-42" id="h50-0-42" class="i">+// RepositoriesSearchResult represents the result of a repositories search.
</a><a href="#h50-0-43" id="h50-0-43" class="i">+type RepositoriesSearchResult struct {
</a><a href="#h50-0-44" id="h50-0-44" class="i">+	Total        *int         `json:&quot;total_count,omitempty&quot;`
</a><a href="#h50-0-45" id="h50-0-45" class="i">+	Repositories []Repository `json:&quot;items,omitempty&quot;`
</a><a href="#h50-0-46" id="h50-0-46" class="i">+}
</a><a href="#h50-0-47" id="h50-0-47" class="i">+
</a><a href="#h50-0-48" id="h50-0-48" class="i">+// Repositories searches repositories via various criteria.
</a><a href="#h50-0-49" id="h50-0-49" class="i">+//
</a><a href="#h50-0-50" id="h50-0-50" class="i">+// GitHub API docs: http://developer.github.com/v3/search/#search-repositories
</a><a href="#h50-0-51" id="h50-0-51" class="i">+func (s *SearchService) Repositories(query string, opt *SearchOptions) (*RepositoriesSearchResult, *Response, error) {
</a><a href="#h50-0-52" id="h50-0-52" class="i">+	result := new(RepositoriesSearchResult)
</a><a href="#h50-0-53" id="h50-0-53" class="i">+	resp, err := s.search(&quot;repositories&quot;, query, opt, result)
</a><a href="#h50-0-54" id="h50-0-54" class="i">+	return result, resp, err
</a><a href="#h50-0-55" id="h50-0-55" class="i">+}
</a><a href="#h50-0-56" id="h50-0-56" class="i">+
</a><a href="#h50-0-57" id="h50-0-57" class="i">+// IssuesSearchResult represents the result of an issues search.
</a><a href="#h50-0-58" id="h50-0-58" class="i">+type IssuesSearchResult struct {
</a><a href="#h50-0-59" id="h50-0-59" class="i">+	Total  *int    `json:&quot;total_count,omitempty&quot;`
</a><a href="#h50-0-60" id="h50-0-60" class="i">+	Issues []Issue `json:&quot;items,omitempty&quot;`
</a><a href="#h50-0-61" id="h50-0-61" class="i">+}
</a><a href="#h50-0-62" id="h50-0-62" class="i">+
</a><a href="#h50-0-63" id="h50-0-63" class="i">+// Issues searches issues via various criteria.
</a><a href="#h50-0-64" id="h50-0-64" class="i">+//
</a><a href="#h50-0-65" id="h50-0-65" class="i">+// GitHub API docs: http://developer.github.com/v3/search/#search-issues
</a><a href="#h50-0-66" id="h50-0-66" class="i">+func (s *SearchService) Issues(query string, opt *SearchOptions) (*IssuesSearchResult, *Response, error) {
</a><a href="#h50-0-67" id="h50-0-67" class="i">+	result := new(IssuesSearchResult)
</a><a href="#h50-0-68" id="h50-0-68" class="i">+	resp, err := s.search(&quot;issues&quot;, query, opt, result)
</a><a href="#h50-0-69" id="h50-0-69" class="i">+	return result, resp, err
</a><a href="#h50-0-70" id="h50-0-70" class="i">+}
</a><a href="#h50-0-71" id="h50-0-71" class="i">+
</a><a href="#h50-0-72" id="h50-0-72" class="i">+// UsersSearchResult represents the result of an issues search.
</a><a href="#h50-0-73" id="h50-0-73" class="i">+type UsersSearchResult struct {
</a><a href="#h50-0-74" id="h50-0-74" class="i">+	Total *int   `json:&quot;total_count,omitempty&quot;`
</a><a href="#h50-0-75" id="h50-0-75" class="i">+	Users []User `json:&quot;items,omitempty&quot;`
</a><a href="#h50-0-76" id="h50-0-76" class="i">+}
</a><a href="#h50-0-77" id="h50-0-77" class="i">+
</a><a href="#h50-0-78" id="h50-0-78" class="i">+// Users searches users via various criteria.
</a><a href="#h50-0-79" id="h50-0-79" class="i">+//
</a><a href="#h50-0-80" id="h50-0-80" class="i">+// GitHub API docs: http://developer.github.com/v3/search/#search-users
</a><a href="#h50-0-81" id="h50-0-81" class="i">+func (s *SearchService) Users(query string, opt *SearchOptions) (*UsersSearchResult, *Response, error) {
</a><a href="#h50-0-82" id="h50-0-82" class="i">+	result := new(UsersSearchResult)
</a><a href="#h50-0-83" id="h50-0-83" class="i">+	resp, err := s.search(&quot;users&quot;, query, opt, result)
</a><a href="#h50-0-84" id="h50-0-84" class="i">+	return result, resp, err
</a><a href="#h50-0-85" id="h50-0-85" class="i">+}
</a><a href="#h50-0-86" id="h50-0-86" class="i">+
</a><a href="#h50-0-87" id="h50-0-87" class="i">+// Match represents a single text match.
</a><a href="#h50-0-88" id="h50-0-88" class="i">+type Match struct {
</a><a href="#h50-0-89" id="h50-0-89" class="i">+	Text    *string `json:&quot;text,omitempty&quot;`
</a><a href="#h50-0-90" id="h50-0-90" class="i">+	Indices []int   `json:&quot;indices,omitempty&quot;`
</a><a href="#h50-0-91" id="h50-0-91" class="i">+}
</a><a href="#h50-0-92" id="h50-0-92" class="i">+
</a><a href="#h50-0-93" id="h50-0-93" class="i">+// TextMatch represents a text match for a SearchResult
</a><a href="#h50-0-94" id="h50-0-94" class="i">+type TextMatch struct {
</a><a href="#h50-0-95" id="h50-0-95" class="i">+	ObjectURL  *string `json:&quot;object_url,omitempty&quot;`
</a><a href="#h50-0-96" id="h50-0-96" class="i">+	ObjectType *string `json:&quot;object_type,omitempty&quot;`
</a><a href="#h50-0-97" id="h50-0-97" class="i">+	Property   *string `json:&quot;property,omitempty&quot;`
</a><a href="#h50-0-98" id="h50-0-98" class="i">+	Fragment   *string `json:&quot;fragment,omitempty&quot;`
</a><a href="#h50-0-99" id="h50-0-99" class="i">+	Matches    []Match `json:&quot;matches,omitempty&quot;`
</a><a href="#h50-0-100" id="h50-0-100" class="i">+}
</a><a href="#h50-0-101" id="h50-0-101" class="i">+
</a><a href="#h50-0-102" id="h50-0-102" class="i">+func (tm TextMatch) String() string {
</a><a href="#h50-0-103" id="h50-0-103" class="i">+	return Stringify(tm)
</a><a href="#h50-0-104" id="h50-0-104" class="i">+}
</a><a href="#h50-0-105" id="h50-0-105" class="i">+
</a><a href="#h50-0-106" id="h50-0-106" class="i">+// CodeSearchResult represents the result of an code search.
</a><a href="#h50-0-107" id="h50-0-107" class="i">+type CodeSearchResult struct {
</a><a href="#h50-0-108" id="h50-0-108" class="i">+	Total       *int         `json:&quot;total_count,omitempty&quot;`
</a><a href="#h50-0-109" id="h50-0-109" class="i">+	CodeResults []CodeResult `json:&quot;items,omitempty&quot;`
</a><a href="#h50-0-110" id="h50-0-110" class="i">+}
</a><a href="#h50-0-111" id="h50-0-111" class="i">+
</a><a href="#h50-0-112" id="h50-0-112" class="i">+// CodeResult represents a single search result.
</a><a href="#h50-0-113" id="h50-0-113" class="i">+type CodeResult struct {
</a><a href="#h50-0-114" id="h50-0-114" class="i">+	Name        *string     `json:&quot;name,omitempty&quot;`
</a><a href="#h50-0-115" id="h50-0-115" class="i">+	Path        *string     `json:&quot;path,omitempty&quot;`
</a><a href="#h50-0-116" id="h50-0-116" class="i">+	SHA         *string     `json:&quot;sha,omitempty&quot;`
</a><a href="#h50-0-117" id="h50-0-117" class="i">+	HTMLURL     *string     `json:&quot;html_url,omitempty&quot;`
</a><a href="#h50-0-118" id="h50-0-118" class="i">+	Repository  *Repository `json:&quot;repository,omitempty&quot;`
</a><a href="#h50-0-119" id="h50-0-119" class="i">+	TextMatches []TextMatch `json:&quot;text_matches,omitempty&quot;`
</a><a href="#h50-0-120" id="h50-0-120" class="i">+}
</a><a href="#h50-0-121" id="h50-0-121" class="i">+
</a><a href="#h50-0-122" id="h50-0-122" class="i">+func (c CodeResult) String() string {
</a><a href="#h50-0-123" id="h50-0-123" class="i">+	return Stringify(c)
</a><a href="#h50-0-124" id="h50-0-124" class="i">+}
</a><a href="#h50-0-125" id="h50-0-125" class="i">+
</a><a href="#h50-0-126" id="h50-0-126" class="i">+// Code searches code via various criteria.
</a><a href="#h50-0-127" id="h50-0-127" class="i">+//
</a><a href="#h50-0-128" id="h50-0-128" class="i">+// GitHub API docs: http://developer.github.com/v3/search/#search-code
</a><a href="#h50-0-129" id="h50-0-129" class="i">+func (s *SearchService) Code(query string, opt *SearchOptions) (*CodeSearchResult, *Response, error) {
</a><a href="#h50-0-130" id="h50-0-130" class="i">+	result := new(CodeSearchResult)
</a><a href="#h50-0-131" id="h50-0-131" class="i">+	resp, err := s.search(&quot;code&quot;, query, opt, result)
</a><a href="#h50-0-132" id="h50-0-132" class="i">+	return result, resp, err
</a><a href="#h50-0-133" id="h50-0-133" class="i">+}
</a><a href="#h50-0-134" id="h50-0-134" class="i">+
</a><a href="#h50-0-135" id="h50-0-135" class="i">+// Helper function that executes search queries against different
</a><a href="#h50-0-136" id="h50-0-136" class="i">+// GitHub search types (repositories, code, issues, users)
</a><a href="#h50-0-137" id="h50-0-137" class="i">+func (s *SearchService) search(searchType string, query string, opt *SearchOptions, result interface{}) (*Response, error) {
</a><a href="#h50-0-138" id="h50-0-138" class="i">+	params, err := qs.Values(opt)
</a><a href="#h50-0-139" id="h50-0-139" class="i">+	if err != nil {
</a><a href="#h50-0-140" id="h50-0-140" class="i">+		return nil, err
</a><a href="#h50-0-141" id="h50-0-141" class="i">+	}
</a><a href="#h50-0-142" id="h50-0-142" class="i">+	params.Add(&quot;q&quot;, query)
</a><a href="#h50-0-143" id="h50-0-143" class="i">+	u := fmt.Sprintf(&quot;search/%s?%s&quot;, searchType, params.Encode())
</a><a href="#h50-0-144" id="h50-0-144" class="i">+
</a><a href="#h50-0-145" id="h50-0-145" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h50-0-146" id="h50-0-146" class="i">+	if err != nil {
</a><a href="#h50-0-147" id="h50-0-147" class="i">+		return nil, err
</a><a href="#h50-0-148" id="h50-0-148" class="i">+	}
</a><a href="#h50-0-149" id="h50-0-149" class="i">+
</a><a href="#h50-0-150" id="h50-0-150" class="i">+	if opt != nil &amp;&amp; opt.TextMatch {
</a><a href="#h50-0-151" id="h50-0-151" class="i">+		// Accept header defaults to &quot;application/vnd.github.v3+json&quot;
</a><a href="#h50-0-152" id="h50-0-152" class="i">+		// We change it here to fetch back text-match metadata
</a><a href="#h50-0-153" id="h50-0-153" class="i">+		req.Header.Set(&quot;Accept&quot;, &quot;application/vnd.github.v3.text-match+json&quot;)
</a><a href="#h50-0-154" id="h50-0-154" class="i">+	}
</a><a href="#h50-0-155" id="h50-0-155" class="i">+
</a><a href="#h50-0-156" id="h50-0-156" class="i">+	return s.client.Do(req, result)
</a><a href="#h50-0-157" id="h50-0-157" class="i">+}
</a><b>diff --git a/<a id="h51" href="../file/vendor/github.com/google/go-github/github/strings.go">vendor/github.com/google/go-github/github/strings.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/strings.go">vendor/github.com/google/go-github/github/strings.go</a></b>
<a href="#h51-0" id="h51-0" class="h">@@ -0,0 +1,93 @@
</a><a href="#h51-0-0" id="h51-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h51-0-1" id="h51-0-1" class="i">+//
</a><a href="#h51-0-2" id="h51-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h51-0-3" id="h51-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h51-0-4" id="h51-0-4" class="i">+
</a><a href="#h51-0-5" id="h51-0-5" class="i">+package github
</a><a href="#h51-0-6" id="h51-0-6" class="i">+
</a><a href="#h51-0-7" id="h51-0-7" class="i">+import (
</a><a href="#h51-0-8" id="h51-0-8" class="i">+	&quot;bytes&quot;
</a><a href="#h51-0-9" id="h51-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h51-0-10" id="h51-0-10" class="i">+	&quot;io&quot;
</a><a href="#h51-0-11" id="h51-0-11" class="i">+
</a><a href="#h51-0-12" id="h51-0-12" class="i">+	&quot;reflect&quot;
</a><a href="#h51-0-13" id="h51-0-13" class="i">+)
</a><a href="#h51-0-14" id="h51-0-14" class="i">+
</a><a href="#h51-0-15" id="h51-0-15" class="i">+var timestampType = reflect.TypeOf(Timestamp{})
</a><a href="#h51-0-16" id="h51-0-16" class="i">+
</a><a href="#h51-0-17" id="h51-0-17" class="i">+// Stringify attempts to create a reasonable string representation of types in
</a><a href="#h51-0-18" id="h51-0-18" class="i">+// the GitHub library.  It does things like resolve pointers to their values
</a><a href="#h51-0-19" id="h51-0-19" class="i">+// and omits struct fields with nil values.
</a><a href="#h51-0-20" id="h51-0-20" class="i">+func Stringify(message interface{}) string {
</a><a href="#h51-0-21" id="h51-0-21" class="i">+	var buf bytes.Buffer
</a><a href="#h51-0-22" id="h51-0-22" class="i">+	v := reflect.ValueOf(message)
</a><a href="#h51-0-23" id="h51-0-23" class="i">+	stringifyValue(&amp;buf, v)
</a><a href="#h51-0-24" id="h51-0-24" class="i">+	return buf.String()
</a><a href="#h51-0-25" id="h51-0-25" class="i">+}
</a><a href="#h51-0-26" id="h51-0-26" class="i">+
</a><a href="#h51-0-27" id="h51-0-27" class="i">+// stringifyValue was heavily inspired by the goprotobuf library.
</a><a href="#h51-0-28" id="h51-0-28" class="i">+
</a><a href="#h51-0-29" id="h51-0-29" class="i">+func stringifyValue(w io.Writer, val reflect.Value) {
</a><a href="#h51-0-30" id="h51-0-30" class="i">+	if val.Kind() == reflect.Ptr &amp;&amp; val.IsNil() {
</a><a href="#h51-0-31" id="h51-0-31" class="i">+		w.Write([]byte(&quot;&lt;nil&gt;&quot;))
</a><a href="#h51-0-32" id="h51-0-32" class="i">+		return
</a><a href="#h51-0-33" id="h51-0-33" class="i">+	}
</a><a href="#h51-0-34" id="h51-0-34" class="i">+
</a><a href="#h51-0-35" id="h51-0-35" class="i">+	v := reflect.Indirect(val)
</a><a href="#h51-0-36" id="h51-0-36" class="i">+
</a><a href="#h51-0-37" id="h51-0-37" class="i">+	switch v.Kind() {
</a><a href="#h51-0-38" id="h51-0-38" class="i">+	case reflect.String:
</a><a href="#h51-0-39" id="h51-0-39" class="i">+		fmt.Fprintf(w, `&quot;%s&quot;`, v)
</a><a href="#h51-0-40" id="h51-0-40" class="i">+	case reflect.Slice:
</a><a href="#h51-0-41" id="h51-0-41" class="i">+		w.Write([]byte{&#39;[&#39;})
</a><a href="#h51-0-42" id="h51-0-42" class="i">+		for i := 0; i &lt; v.Len(); i++ {
</a><a href="#h51-0-43" id="h51-0-43" class="i">+			if i &gt; 0 {
</a><a href="#h51-0-44" id="h51-0-44" class="i">+				w.Write([]byte{&#39; &#39;})
</a><a href="#h51-0-45" id="h51-0-45" class="i">+			}
</a><a href="#h51-0-46" id="h51-0-46" class="i">+
</a><a href="#h51-0-47" id="h51-0-47" class="i">+			stringifyValue(w, v.Index(i))
</a><a href="#h51-0-48" id="h51-0-48" class="i">+		}
</a><a href="#h51-0-49" id="h51-0-49" class="i">+
</a><a href="#h51-0-50" id="h51-0-50" class="i">+		w.Write([]byte{&#39;]&#39;})
</a><a href="#h51-0-51" id="h51-0-51" class="i">+		return
</a><a href="#h51-0-52" id="h51-0-52" class="i">+	case reflect.Struct:
</a><a href="#h51-0-53" id="h51-0-53" class="i">+		if v.Type().Name() != &quot;&quot; {
</a><a href="#h51-0-54" id="h51-0-54" class="i">+			w.Write([]byte(v.Type().String()))
</a><a href="#h51-0-55" id="h51-0-55" class="i">+		}
</a><a href="#h51-0-56" id="h51-0-56" class="i">+
</a><a href="#h51-0-57" id="h51-0-57" class="i">+		// special handling of Timestamp values
</a><a href="#h51-0-58" id="h51-0-58" class="i">+		if v.Type() == timestampType {
</a><a href="#h51-0-59" id="h51-0-59" class="i">+			fmt.Fprintf(w, &quot;{%s}&quot;, v.Interface())
</a><a href="#h51-0-60" id="h51-0-60" class="i">+			return
</a><a href="#h51-0-61" id="h51-0-61" class="i">+		}
</a><a href="#h51-0-62" id="h51-0-62" class="i">+
</a><a href="#h51-0-63" id="h51-0-63" class="i">+		w.Write([]byte{&#39;{&#39;})
</a><a href="#h51-0-64" id="h51-0-64" class="i">+
</a><a href="#h51-0-65" id="h51-0-65" class="i">+		var sep bool
</a><a href="#h51-0-66" id="h51-0-66" class="i">+		for i := 0; i &lt; v.NumField(); i++ {
</a><a href="#h51-0-67" id="h51-0-67" class="i">+			fv := v.Field(i)
</a><a href="#h51-0-68" id="h51-0-68" class="i">+			if fv.Kind() == reflect.Ptr &amp;&amp; fv.IsNil() {
</a><a href="#h51-0-69" id="h51-0-69" class="i">+				continue
</a><a href="#h51-0-70" id="h51-0-70" class="i">+			}
</a><a href="#h51-0-71" id="h51-0-71" class="i">+			if fv.Kind() == reflect.Slice &amp;&amp; fv.IsNil() {
</a><a href="#h51-0-72" id="h51-0-72" class="i">+				continue
</a><a href="#h51-0-73" id="h51-0-73" class="i">+			}
</a><a href="#h51-0-74" id="h51-0-74" class="i">+
</a><a href="#h51-0-75" id="h51-0-75" class="i">+			if sep {
</a><a href="#h51-0-76" id="h51-0-76" class="i">+				w.Write([]byte(&quot;, &quot;))
</a><a href="#h51-0-77" id="h51-0-77" class="i">+			} else {
</a><a href="#h51-0-78" id="h51-0-78" class="i">+				sep = true
</a><a href="#h51-0-79" id="h51-0-79" class="i">+			}
</a><a href="#h51-0-80" id="h51-0-80" class="i">+
</a><a href="#h51-0-81" id="h51-0-81" class="i">+			w.Write([]byte(v.Type().Field(i).Name))
</a><a href="#h51-0-82" id="h51-0-82" class="i">+			w.Write([]byte{&#39;:&#39;})
</a><a href="#h51-0-83" id="h51-0-83" class="i">+			stringifyValue(w, fv)
</a><a href="#h51-0-84" id="h51-0-84" class="i">+		}
</a><a href="#h51-0-85" id="h51-0-85" class="i">+
</a><a href="#h51-0-86" id="h51-0-86" class="i">+		w.Write([]byte{&#39;}&#39;})
</a><a href="#h51-0-87" id="h51-0-87" class="i">+	default:
</a><a href="#h51-0-88" id="h51-0-88" class="i">+		if v.CanInterface() {
</a><a href="#h51-0-89" id="h51-0-89" class="i">+			fmt.Fprint(w, v.Interface())
</a><a href="#h51-0-90" id="h51-0-90" class="i">+		}
</a><a href="#h51-0-91" id="h51-0-91" class="i">+	}
</a><a href="#h51-0-92" id="h51-0-92" class="i">+}
</a><b>diff --git a/<a id="h52" href="../file/vendor/github.com/google/go-github/github/timestamp.go">vendor/github.com/google/go-github/github/timestamp.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/timestamp.go">vendor/github.com/google/go-github/github/timestamp.go</a></b>
<a href="#h52-0" id="h52-0" class="h">@@ -0,0 +1,41 @@
</a><a href="#h52-0-0" id="h52-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h52-0-1" id="h52-0-1" class="i">+//
</a><a href="#h52-0-2" id="h52-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h52-0-3" id="h52-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h52-0-4" id="h52-0-4" class="i">+
</a><a href="#h52-0-5" id="h52-0-5" class="i">+package github
</a><a href="#h52-0-6" id="h52-0-6" class="i">+
</a><a href="#h52-0-7" id="h52-0-7" class="i">+import (
</a><a href="#h52-0-8" id="h52-0-8" class="i">+	&quot;strconv&quot;
</a><a href="#h52-0-9" id="h52-0-9" class="i">+	&quot;time&quot;
</a><a href="#h52-0-10" id="h52-0-10" class="i">+)
</a><a href="#h52-0-11" id="h52-0-11" class="i">+
</a><a href="#h52-0-12" id="h52-0-12" class="i">+// Timestamp represents a time that can be unmarshalled from a JSON string
</a><a href="#h52-0-13" id="h52-0-13" class="i">+// formatted as either an RFC3339 or Unix timestamp. This is necessary for some
</a><a href="#h52-0-14" id="h52-0-14" class="i">+// fields since the GitHub API is inconsistent in how it represents times. All
</a><a href="#h52-0-15" id="h52-0-15" class="i">+// exported methods of time.Time can be called on Timestamp.
</a><a href="#h52-0-16" id="h52-0-16" class="i">+type Timestamp struct {
</a><a href="#h52-0-17" id="h52-0-17" class="i">+	time.Time
</a><a href="#h52-0-18" id="h52-0-18" class="i">+}
</a><a href="#h52-0-19" id="h52-0-19" class="i">+
</a><a href="#h52-0-20" id="h52-0-20" class="i">+func (t Timestamp) String() string {
</a><a href="#h52-0-21" id="h52-0-21" class="i">+	return t.Time.String()
</a><a href="#h52-0-22" id="h52-0-22" class="i">+}
</a><a href="#h52-0-23" id="h52-0-23" class="i">+
</a><a href="#h52-0-24" id="h52-0-24" class="i">+// UnmarshalJSON implements the json.Unmarshaler interface.
</a><a href="#h52-0-25" id="h52-0-25" class="i">+// Time is expected in RFC3339 or Unix format.
</a><a href="#h52-0-26" id="h52-0-26" class="i">+func (t *Timestamp) UnmarshalJSON(data []byte) (err error) {
</a><a href="#h52-0-27" id="h52-0-27" class="i">+	str := string(data)
</a><a href="#h52-0-28" id="h52-0-28" class="i">+	i, err := strconv.ParseInt(str, 10, 64)
</a><a href="#h52-0-29" id="h52-0-29" class="i">+	if err == nil {
</a><a href="#h52-0-30" id="h52-0-30" class="i">+		(*t).Time = time.Unix(i, 0)
</a><a href="#h52-0-31" id="h52-0-31" class="i">+	} else {
</a><a href="#h52-0-32" id="h52-0-32" class="i">+		(*t).Time, err = time.Parse(`&quot;`+time.RFC3339+`&quot;`, str)
</a><a href="#h52-0-33" id="h52-0-33" class="i">+	}
</a><a href="#h52-0-34" id="h52-0-34" class="i">+	return
</a><a href="#h52-0-35" id="h52-0-35" class="i">+}
</a><a href="#h52-0-36" id="h52-0-36" class="i">+
</a><a href="#h52-0-37" id="h52-0-37" class="i">+// Equal reports whether t and u are equal based on time.Equal
</a><a href="#h52-0-38" id="h52-0-38" class="i">+func (t Timestamp) Equal(u Timestamp) bool {
</a><a href="#h52-0-39" id="h52-0-39" class="i">+	return t.Time.Equal(u.Time)
</a><a href="#h52-0-40" id="h52-0-40" class="i">+}
</a><b>diff --git a/<a id="h53" href="../file/vendor/github.com/google/go-github/github/users.go">vendor/github.com/google/go-github/github/users.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/users.go">vendor/github.com/google/go-github/github/users.go</a></b>
<a href="#h53-0" id="h53-0" class="h">@@ -0,0 +1,145 @@
</a><a href="#h53-0-0" id="h53-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h53-0-1" id="h53-0-1" class="i">+//
</a><a href="#h53-0-2" id="h53-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h53-0-3" id="h53-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h53-0-4" id="h53-0-4" class="i">+
</a><a href="#h53-0-5" id="h53-0-5" class="i">+package github
</a><a href="#h53-0-6" id="h53-0-6" class="i">+
</a><a href="#h53-0-7" id="h53-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h53-0-8" id="h53-0-8" class="i">+
</a><a href="#h53-0-9" id="h53-0-9" class="i">+// UsersService handles communication with the user related
</a><a href="#h53-0-10" id="h53-0-10" class="i">+// methods of the GitHub API.
</a><a href="#h53-0-11" id="h53-0-11" class="i">+//
</a><a href="#h53-0-12" id="h53-0-12" class="i">+// GitHub API docs: http://developer.github.com/v3/users/
</a><a href="#h53-0-13" id="h53-0-13" class="i">+type UsersService struct {
</a><a href="#h53-0-14" id="h53-0-14" class="i">+	client *Client
</a><a href="#h53-0-15" id="h53-0-15" class="i">+}
</a><a href="#h53-0-16" id="h53-0-16" class="i">+
</a><a href="#h53-0-17" id="h53-0-17" class="i">+// User represents a GitHub user.
</a><a href="#h53-0-18" id="h53-0-18" class="i">+type User struct {
</a><a href="#h53-0-19" id="h53-0-19" class="i">+	Login             *string    `json:&quot;login,omitempty&quot;`
</a><a href="#h53-0-20" id="h53-0-20" class="i">+	ID                *int       `json:&quot;id,omitempty&quot;`
</a><a href="#h53-0-21" id="h53-0-21" class="i">+	AvatarURL         *string    `json:&quot;avatar_url,omitempty&quot;`
</a><a href="#h53-0-22" id="h53-0-22" class="i">+	HTMLURL           *string    `json:&quot;html_url,omitempty&quot;`
</a><a href="#h53-0-23" id="h53-0-23" class="i">+	GravatarID        *string    `json:&quot;gravatar_id,omitempty&quot;`
</a><a href="#h53-0-24" id="h53-0-24" class="i">+	Name              *string    `json:&quot;name,omitempty&quot;`
</a><a href="#h53-0-25" id="h53-0-25" class="i">+	Company           *string    `json:&quot;company,omitempty&quot;`
</a><a href="#h53-0-26" id="h53-0-26" class="i">+	Blog              *string    `json:&quot;blog,omitempty&quot;`
</a><a href="#h53-0-27" id="h53-0-27" class="i">+	Location          *string    `json:&quot;location,omitempty&quot;`
</a><a href="#h53-0-28" id="h53-0-28" class="i">+	Email             *string    `json:&quot;email,omitempty&quot;`
</a><a href="#h53-0-29" id="h53-0-29" class="i">+	Hireable          *bool      `json:&quot;hireable,omitempty&quot;`
</a><a href="#h53-0-30" id="h53-0-30" class="i">+	Bio               *string    `json:&quot;bio,omitempty&quot;`
</a><a href="#h53-0-31" id="h53-0-31" class="i">+	PublicRepos       *int       `json:&quot;public_repos,omitempty&quot;`
</a><a href="#h53-0-32" id="h53-0-32" class="i">+	PublicGists       *int       `json:&quot;public_gists,omitempty&quot;`
</a><a href="#h53-0-33" id="h53-0-33" class="i">+	Followers         *int       `json:&quot;followers,omitempty&quot;`
</a><a href="#h53-0-34" id="h53-0-34" class="i">+	Following         *int       `json:&quot;following,omitempty&quot;`
</a><a href="#h53-0-35" id="h53-0-35" class="i">+	CreatedAt         *Timestamp `json:&quot;created_at,omitempty&quot;`
</a><a href="#h53-0-36" id="h53-0-36" class="i">+	UpdatedAt         *Timestamp `json:&quot;updated_at,omitempty&quot;`
</a><a href="#h53-0-37" id="h53-0-37" class="i">+	SuspendedAt       *Timestamp `json:&quot;suspended_at,omitempty&quot;`
</a><a href="#h53-0-38" id="h53-0-38" class="i">+	Type              *string    `json:&quot;type,omitempty&quot;`
</a><a href="#h53-0-39" id="h53-0-39" class="i">+	SiteAdmin         *bool      `json:&quot;site_admin,omitempty&quot;`
</a><a href="#h53-0-40" id="h53-0-40" class="i">+	TotalPrivateRepos *int       `json:&quot;total_private_repos,omitempty&quot;`
</a><a href="#h53-0-41" id="h53-0-41" class="i">+	OwnedPrivateRepos *int       `json:&quot;owned_private_repos,omitempty&quot;`
</a><a href="#h53-0-42" id="h53-0-42" class="i">+	PrivateGists      *int       `json:&quot;private_gists,omitempty&quot;`
</a><a href="#h53-0-43" id="h53-0-43" class="i">+	DiskUsage         *int       `json:&quot;disk_usage,omitempty&quot;`
</a><a href="#h53-0-44" id="h53-0-44" class="i">+	Collaborators     *int       `json:&quot;collaborators,omitempty&quot;`
</a><a href="#h53-0-45" id="h53-0-45" class="i">+	Plan              *Plan      `json:&quot;plan,omitempty&quot;`
</a><a href="#h53-0-46" id="h53-0-46" class="i">+
</a><a href="#h53-0-47" id="h53-0-47" class="i">+	// API URLs
</a><a href="#h53-0-48" id="h53-0-48" class="i">+	URL               *string `json:&quot;url,omitempty&quot;`
</a><a href="#h53-0-49" id="h53-0-49" class="i">+	EventsURL         *string `json:&quot;events_url,omitempty&quot;`
</a><a href="#h53-0-50" id="h53-0-50" class="i">+	FollowingURL      *string `json:&quot;following_url,omitempty&quot;`
</a><a href="#h53-0-51" id="h53-0-51" class="i">+	FollowersURL      *string `json:&quot;followers_url,omitempty&quot;`
</a><a href="#h53-0-52" id="h53-0-52" class="i">+	GistsURL          *string `json:&quot;gists_url,omitempty&quot;`
</a><a href="#h53-0-53" id="h53-0-53" class="i">+	OrganizationsURL  *string `json:&quot;organizations_url,omitempty&quot;`
</a><a href="#h53-0-54" id="h53-0-54" class="i">+	ReceivedEventsURL *string `json:&quot;received_events_url,omitempty&quot;`
</a><a href="#h53-0-55" id="h53-0-55" class="i">+	ReposURL          *string `json:&quot;repos_url,omitempty&quot;`
</a><a href="#h53-0-56" id="h53-0-56" class="i">+	StarredURL        *string `json:&quot;starred_url,omitempty&quot;`
</a><a href="#h53-0-57" id="h53-0-57" class="i">+	SubscriptionsURL  *string `json:&quot;subscriptions_url,omitempty&quot;`
</a><a href="#h53-0-58" id="h53-0-58" class="i">+
</a><a href="#h53-0-59" id="h53-0-59" class="i">+	// TextMatches is only populated from search results that request text matches
</a><a href="#h53-0-60" id="h53-0-60" class="i">+	// See: search.go and https://developer.github.com/v3/search/#text-match-metadata
</a><a href="#h53-0-61" id="h53-0-61" class="i">+	TextMatches []TextMatch `json:&quot;text_matches,omitempty&quot;`
</a><a href="#h53-0-62" id="h53-0-62" class="i">+
</a><a href="#h53-0-63" id="h53-0-63" class="i">+	// Permissions identifies the permissions that a user has on a given
</a><a href="#h53-0-64" id="h53-0-64" class="i">+	// repository. This is only populated when calling Repositories.ListCollaborators.
</a><a href="#h53-0-65" id="h53-0-65" class="i">+	Permissions *map[string]bool `json:&quot;permissions,omitempty&quot;`
</a><a href="#h53-0-66" id="h53-0-66" class="i">+}
</a><a href="#h53-0-67" id="h53-0-67" class="i">+
</a><a href="#h53-0-68" id="h53-0-68" class="i">+func (u User) String() string {
</a><a href="#h53-0-69" id="h53-0-69" class="i">+	return Stringify(u)
</a><a href="#h53-0-70" id="h53-0-70" class="i">+}
</a><a href="#h53-0-71" id="h53-0-71" class="i">+
</a><a href="#h53-0-72" id="h53-0-72" class="i">+// Get fetches a user.  Passing the empty string will fetch the authenticated
</a><a href="#h53-0-73" id="h53-0-73" class="i">+// user.
</a><a href="#h53-0-74" id="h53-0-74" class="i">+//
</a><a href="#h53-0-75" id="h53-0-75" class="i">+// GitHub API docs: http://developer.github.com/v3/users/#get-a-single-user
</a><a href="#h53-0-76" id="h53-0-76" class="i">+func (s *UsersService) Get(user string) (*User, *Response, error) {
</a><a href="#h53-0-77" id="h53-0-77" class="i">+	var u string
</a><a href="#h53-0-78" id="h53-0-78" class="i">+	if user != &quot;&quot; {
</a><a href="#h53-0-79" id="h53-0-79" class="i">+		u = fmt.Sprintf(&quot;users/%v&quot;, user)
</a><a href="#h53-0-80" id="h53-0-80" class="i">+	} else {
</a><a href="#h53-0-81" id="h53-0-81" class="i">+		u = &quot;user&quot;
</a><a href="#h53-0-82" id="h53-0-82" class="i">+	}
</a><a href="#h53-0-83" id="h53-0-83" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h53-0-84" id="h53-0-84" class="i">+	if err != nil {
</a><a href="#h53-0-85" id="h53-0-85" class="i">+		return nil, nil, err
</a><a href="#h53-0-86" id="h53-0-86" class="i">+	}
</a><a href="#h53-0-87" id="h53-0-87" class="i">+
</a><a href="#h53-0-88" id="h53-0-88" class="i">+	uResp := new(User)
</a><a href="#h53-0-89" id="h53-0-89" class="i">+	resp, err := s.client.Do(req, uResp)
</a><a href="#h53-0-90" id="h53-0-90" class="i">+	if err != nil {
</a><a href="#h53-0-91" id="h53-0-91" class="i">+		return nil, resp, err
</a><a href="#h53-0-92" id="h53-0-92" class="i">+	}
</a><a href="#h53-0-93" id="h53-0-93" class="i">+
</a><a href="#h53-0-94" id="h53-0-94" class="i">+	return uResp, resp, err
</a><a href="#h53-0-95" id="h53-0-95" class="i">+}
</a><a href="#h53-0-96" id="h53-0-96" class="i">+
</a><a href="#h53-0-97" id="h53-0-97" class="i">+// Edit the authenticated user.
</a><a href="#h53-0-98" id="h53-0-98" class="i">+//
</a><a href="#h53-0-99" id="h53-0-99" class="i">+// GitHub API docs: http://developer.github.com/v3/users/#update-the-authenticated-user
</a><a href="#h53-0-100" id="h53-0-100" class="i">+func (s *UsersService) Edit(user *User) (*User, *Response, error) {
</a><a href="#h53-0-101" id="h53-0-101" class="i">+	u := &quot;user&quot;
</a><a href="#h53-0-102" id="h53-0-102" class="i">+	req, err := s.client.NewRequest(&quot;PATCH&quot;, u, user)
</a><a href="#h53-0-103" id="h53-0-103" class="i">+	if err != nil {
</a><a href="#h53-0-104" id="h53-0-104" class="i">+		return nil, nil, err
</a><a href="#h53-0-105" id="h53-0-105" class="i">+	}
</a><a href="#h53-0-106" id="h53-0-106" class="i">+
</a><a href="#h53-0-107" id="h53-0-107" class="i">+	uResp := new(User)
</a><a href="#h53-0-108" id="h53-0-108" class="i">+	resp, err := s.client.Do(req, uResp)
</a><a href="#h53-0-109" id="h53-0-109" class="i">+	if err != nil {
</a><a href="#h53-0-110" id="h53-0-110" class="i">+		return nil, resp, err
</a><a href="#h53-0-111" id="h53-0-111" class="i">+	}
</a><a href="#h53-0-112" id="h53-0-112" class="i">+
</a><a href="#h53-0-113" id="h53-0-113" class="i">+	return uResp, resp, err
</a><a href="#h53-0-114" id="h53-0-114" class="i">+}
</a><a href="#h53-0-115" id="h53-0-115" class="i">+
</a><a href="#h53-0-116" id="h53-0-116" class="i">+// UserListOptions specifies optional parameters to the UsersService.ListAll
</a><a href="#h53-0-117" id="h53-0-117" class="i">+// method.
</a><a href="#h53-0-118" id="h53-0-118" class="i">+type UserListOptions struct {
</a><a href="#h53-0-119" id="h53-0-119" class="i">+	// ID of the last user seen
</a><a href="#h53-0-120" id="h53-0-120" class="i">+	Since int `url:&quot;since,omitempty&quot;`
</a><a href="#h53-0-121" id="h53-0-121" class="i">+}
</a><a href="#h53-0-122" id="h53-0-122" class="i">+
</a><a href="#h53-0-123" id="h53-0-123" class="i">+// ListAll lists all GitHub users.
</a><a href="#h53-0-124" id="h53-0-124" class="i">+//
</a><a href="#h53-0-125" id="h53-0-125" class="i">+// GitHub API docs: http://developer.github.com/v3/users/#get-all-users
</a><a href="#h53-0-126" id="h53-0-126" class="i">+func (s *UsersService) ListAll(opt *UserListOptions) ([]User, *Response, error) {
</a><a href="#h53-0-127" id="h53-0-127" class="i">+	u, err := addOptions(&quot;users&quot;, opt)
</a><a href="#h53-0-128" id="h53-0-128" class="i">+	if err != nil {
</a><a href="#h53-0-129" id="h53-0-129" class="i">+		return nil, nil, err
</a><a href="#h53-0-130" id="h53-0-130" class="i">+	}
</a><a href="#h53-0-131" id="h53-0-131" class="i">+
</a><a href="#h53-0-132" id="h53-0-132" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h53-0-133" id="h53-0-133" class="i">+	if err != nil {
</a><a href="#h53-0-134" id="h53-0-134" class="i">+		return nil, nil, err
</a><a href="#h53-0-135" id="h53-0-135" class="i">+	}
</a><a href="#h53-0-136" id="h53-0-136" class="i">+
</a><a href="#h53-0-137" id="h53-0-137" class="i">+	users := new([]User)
</a><a href="#h53-0-138" id="h53-0-138" class="i">+	resp, err := s.client.Do(req, users)
</a><a href="#h53-0-139" id="h53-0-139" class="i">+	if err != nil {
</a><a href="#h53-0-140" id="h53-0-140" class="i">+		return nil, resp, err
</a><a href="#h53-0-141" id="h53-0-141" class="i">+	}
</a><a href="#h53-0-142" id="h53-0-142" class="i">+
</a><a href="#h53-0-143" id="h53-0-143" class="i">+	return *users, resp, err
</a><a href="#h53-0-144" id="h53-0-144" class="i">+}
</a><b>diff --git a/<a id="h54" href="../file/vendor/github.com/google/go-github/github/users_administration.go">vendor/github.com/google/go-github/github/users_administration.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/users_administration.go">vendor/github.com/google/go-github/github/users_administration.go</a></b>
<a href="#h54-0" id="h54-0" class="h">@@ -0,0 +1,64 @@
</a><a href="#h54-0-0" id="h54-0-0" class="i">+// Copyright 2014 The go-github AUTHORS. All rights reserved.
</a><a href="#h54-0-1" id="h54-0-1" class="i">+//
</a><a href="#h54-0-2" id="h54-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h54-0-3" id="h54-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h54-0-4" id="h54-0-4" class="i">+
</a><a href="#h54-0-5" id="h54-0-5" class="i">+package github
</a><a href="#h54-0-6" id="h54-0-6" class="i">+
</a><a href="#h54-0-7" id="h54-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h54-0-8" id="h54-0-8" class="i">+
</a><a href="#h54-0-9" id="h54-0-9" class="i">+// PromoteSiteAdmin promotes a user to a site administrator of a GitHub Enterprise instance.
</a><a href="#h54-0-10" id="h54-0-10" class="i">+//
</a><a href="#h54-0-11" id="h54-0-11" class="i">+// GitHub API docs: https://developer.github.com/v3/users/administration/#promote-an-ordinary-user-to-a-site-administrator
</a><a href="#h54-0-12" id="h54-0-12" class="i">+func (s *UsersService) PromoteSiteAdmin(user string) (*Response, error) {
</a><a href="#h54-0-13" id="h54-0-13" class="i">+	u := fmt.Sprintf(&quot;users/%v/site_admin&quot;, user)
</a><a href="#h54-0-14" id="h54-0-14" class="i">+
</a><a href="#h54-0-15" id="h54-0-15" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h54-0-16" id="h54-0-16" class="i">+	if err != nil {
</a><a href="#h54-0-17" id="h54-0-17" class="i">+		return nil, err
</a><a href="#h54-0-18" id="h54-0-18" class="i">+	}
</a><a href="#h54-0-19" id="h54-0-19" class="i">+
</a><a href="#h54-0-20" id="h54-0-20" class="i">+	return s.client.Do(req, nil)
</a><a href="#h54-0-21" id="h54-0-21" class="i">+}
</a><a href="#h54-0-22" id="h54-0-22" class="i">+
</a><a href="#h54-0-23" id="h54-0-23" class="i">+// DemoteSiteAdmin demotes a user from site administrator of a GitHub Enterprise instance.
</a><a href="#h54-0-24" id="h54-0-24" class="i">+//
</a><a href="#h54-0-25" id="h54-0-25" class="i">+// GitHub API docs: https://developer.github.com/v3/users/administration/#demote-a-site-administrator-to-an-ordinary-user
</a><a href="#h54-0-26" id="h54-0-26" class="i">+func (s *UsersService) DemoteSiteAdmin(user string) (*Response, error) {
</a><a href="#h54-0-27" id="h54-0-27" class="i">+	u := fmt.Sprintf(&quot;users/%v/site_admin&quot;, user)
</a><a href="#h54-0-28" id="h54-0-28" class="i">+
</a><a href="#h54-0-29" id="h54-0-29" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h54-0-30" id="h54-0-30" class="i">+	if err != nil {
</a><a href="#h54-0-31" id="h54-0-31" class="i">+		return nil, err
</a><a href="#h54-0-32" id="h54-0-32" class="i">+	}
</a><a href="#h54-0-33" id="h54-0-33" class="i">+
</a><a href="#h54-0-34" id="h54-0-34" class="i">+	return s.client.Do(req, nil)
</a><a href="#h54-0-35" id="h54-0-35" class="i">+}
</a><a href="#h54-0-36" id="h54-0-36" class="i">+
</a><a href="#h54-0-37" id="h54-0-37" class="i">+// Suspend a user on a GitHub Enterprise instance.
</a><a href="#h54-0-38" id="h54-0-38" class="i">+//
</a><a href="#h54-0-39" id="h54-0-39" class="i">+// GitHub API docs: https://developer.github.com/v3/users/administration/#suspend-a-user
</a><a href="#h54-0-40" id="h54-0-40" class="i">+func (s *UsersService) Suspend(user string) (*Response, error) {
</a><a href="#h54-0-41" id="h54-0-41" class="i">+	u := fmt.Sprintf(&quot;users/%v/suspended&quot;, user)
</a><a href="#h54-0-42" id="h54-0-42" class="i">+
</a><a href="#h54-0-43" id="h54-0-43" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h54-0-44" id="h54-0-44" class="i">+	if err != nil {
</a><a href="#h54-0-45" id="h54-0-45" class="i">+		return nil, err
</a><a href="#h54-0-46" id="h54-0-46" class="i">+	}
</a><a href="#h54-0-47" id="h54-0-47" class="i">+
</a><a href="#h54-0-48" id="h54-0-48" class="i">+	return s.client.Do(req, nil)
</a><a href="#h54-0-49" id="h54-0-49" class="i">+}
</a><a href="#h54-0-50" id="h54-0-50" class="i">+
</a><a href="#h54-0-51" id="h54-0-51" class="i">+// Unsuspend a user on a GitHub Enterprise instance.
</a><a href="#h54-0-52" id="h54-0-52" class="i">+//
</a><a href="#h54-0-53" id="h54-0-53" class="i">+// GitHub API docs: https://developer.github.com/v3/users/administration/#unsuspend-a-user
</a><a href="#h54-0-54" id="h54-0-54" class="i">+func (s *UsersService) Unsuspend(user string) (*Response, error) {
</a><a href="#h54-0-55" id="h54-0-55" class="i">+	u := fmt.Sprintf(&quot;users/%v/suspended&quot;, user)
</a><a href="#h54-0-56" id="h54-0-56" class="i">+
</a><a href="#h54-0-57" id="h54-0-57" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h54-0-58" id="h54-0-58" class="i">+	if err != nil {
</a><a href="#h54-0-59" id="h54-0-59" class="i">+		return nil, err
</a><a href="#h54-0-60" id="h54-0-60" class="i">+	}
</a><a href="#h54-0-61" id="h54-0-61" class="i">+
</a><a href="#h54-0-62" id="h54-0-62" class="i">+	return s.client.Do(req, nil)
</a><a href="#h54-0-63" id="h54-0-63" class="i">+}
</a><b>diff --git a/<a id="h55" href="../file/vendor/github.com/google/go-github/github/users_emails.go">vendor/github.com/google/go-github/github/users_emails.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/users_emails.go">vendor/github.com/google/go-github/github/users_emails.go</a></b>
<a href="#h55-0" id="h55-0" class="h">@@ -0,0 +1,69 @@
</a><a href="#h55-0-0" id="h55-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h55-0-1" id="h55-0-1" class="i">+//
</a><a href="#h55-0-2" id="h55-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h55-0-3" id="h55-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h55-0-4" id="h55-0-4" class="i">+
</a><a href="#h55-0-5" id="h55-0-5" class="i">+package github
</a><a href="#h55-0-6" id="h55-0-6" class="i">+
</a><a href="#h55-0-7" id="h55-0-7" class="i">+// UserEmail represents user&#39;s email address
</a><a href="#h55-0-8" id="h55-0-8" class="i">+type UserEmail struct {
</a><a href="#h55-0-9" id="h55-0-9" class="i">+	Email    *string `json:&quot;email,omitempty&quot;`
</a><a href="#h55-0-10" id="h55-0-10" class="i">+	Primary  *bool   `json:&quot;primary,omitempty&quot;`
</a><a href="#h55-0-11" id="h55-0-11" class="i">+	Verified *bool   `json:&quot;verified,omitempty&quot;`
</a><a href="#h55-0-12" id="h55-0-12" class="i">+}
</a><a href="#h55-0-13" id="h55-0-13" class="i">+
</a><a href="#h55-0-14" id="h55-0-14" class="i">+// ListEmails lists all email addresses for the authenticated user.
</a><a href="#h55-0-15" id="h55-0-15" class="i">+//
</a><a href="#h55-0-16" id="h55-0-16" class="i">+// GitHub API docs: http://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user
</a><a href="#h55-0-17" id="h55-0-17" class="i">+func (s *UsersService) ListEmails(opt *ListOptions) ([]UserEmail, *Response, error) {
</a><a href="#h55-0-18" id="h55-0-18" class="i">+	u := &quot;user/emails&quot;
</a><a href="#h55-0-19" id="h55-0-19" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h55-0-20" id="h55-0-20" class="i">+	if err != nil {
</a><a href="#h55-0-21" id="h55-0-21" class="i">+		return nil, nil, err
</a><a href="#h55-0-22" id="h55-0-22" class="i">+	}
</a><a href="#h55-0-23" id="h55-0-23" class="i">+
</a><a href="#h55-0-24" id="h55-0-24" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h55-0-25" id="h55-0-25" class="i">+	if err != nil {
</a><a href="#h55-0-26" id="h55-0-26" class="i">+		return nil, nil, err
</a><a href="#h55-0-27" id="h55-0-27" class="i">+	}
</a><a href="#h55-0-28" id="h55-0-28" class="i">+
</a><a href="#h55-0-29" id="h55-0-29" class="i">+	emails := new([]UserEmail)
</a><a href="#h55-0-30" id="h55-0-30" class="i">+	resp, err := s.client.Do(req, emails)
</a><a href="#h55-0-31" id="h55-0-31" class="i">+	if err != nil {
</a><a href="#h55-0-32" id="h55-0-32" class="i">+		return nil, resp, err
</a><a href="#h55-0-33" id="h55-0-33" class="i">+	}
</a><a href="#h55-0-34" id="h55-0-34" class="i">+
</a><a href="#h55-0-35" id="h55-0-35" class="i">+	return *emails, resp, err
</a><a href="#h55-0-36" id="h55-0-36" class="i">+}
</a><a href="#h55-0-37" id="h55-0-37" class="i">+
</a><a href="#h55-0-38" id="h55-0-38" class="i">+// AddEmails adds email addresses of the authenticated user.
</a><a href="#h55-0-39" id="h55-0-39" class="i">+//
</a><a href="#h55-0-40" id="h55-0-40" class="i">+// GitHub API docs: http://developer.github.com/v3/users/emails/#add-email-addresses
</a><a href="#h55-0-41" id="h55-0-41" class="i">+func (s *UsersService) AddEmails(emails []string) ([]UserEmail, *Response, error) {
</a><a href="#h55-0-42" id="h55-0-42" class="i">+	u := &quot;user/emails&quot;
</a><a href="#h55-0-43" id="h55-0-43" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, emails)
</a><a href="#h55-0-44" id="h55-0-44" class="i">+	if err != nil {
</a><a href="#h55-0-45" id="h55-0-45" class="i">+		return nil, nil, err
</a><a href="#h55-0-46" id="h55-0-46" class="i">+	}
</a><a href="#h55-0-47" id="h55-0-47" class="i">+
</a><a href="#h55-0-48" id="h55-0-48" class="i">+	e := new([]UserEmail)
</a><a href="#h55-0-49" id="h55-0-49" class="i">+	resp, err := s.client.Do(req, e)
</a><a href="#h55-0-50" id="h55-0-50" class="i">+	if err != nil {
</a><a href="#h55-0-51" id="h55-0-51" class="i">+		return nil, resp, err
</a><a href="#h55-0-52" id="h55-0-52" class="i">+	}
</a><a href="#h55-0-53" id="h55-0-53" class="i">+
</a><a href="#h55-0-54" id="h55-0-54" class="i">+	return *e, resp, err
</a><a href="#h55-0-55" id="h55-0-55" class="i">+}
</a><a href="#h55-0-56" id="h55-0-56" class="i">+
</a><a href="#h55-0-57" id="h55-0-57" class="i">+// DeleteEmails deletes email addresses from authenticated user.
</a><a href="#h55-0-58" id="h55-0-58" class="i">+//
</a><a href="#h55-0-59" id="h55-0-59" class="i">+// GitHub API docs: http://developer.github.com/v3/users/emails/#delete-email-addresses
</a><a href="#h55-0-60" id="h55-0-60" class="i">+func (s *UsersService) DeleteEmails(emails []string) (*Response, error) {
</a><a href="#h55-0-61" id="h55-0-61" class="i">+	u := &quot;user/emails&quot;
</a><a href="#h55-0-62" id="h55-0-62" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, emails)
</a><a href="#h55-0-63" id="h55-0-63" class="i">+	if err != nil {
</a><a href="#h55-0-64" id="h55-0-64" class="i">+		return nil, err
</a><a href="#h55-0-65" id="h55-0-65" class="i">+	}
</a><a href="#h55-0-66" id="h55-0-66" class="i">+
</a><a href="#h55-0-67" id="h55-0-67" class="i">+	return s.client.Do(req, nil)
</a><a href="#h55-0-68" id="h55-0-68" class="i">+}
</a><b>diff --git a/<a id="h56" href="../file/vendor/github.com/google/go-github/github/users_followers.go">vendor/github.com/google/go-github/github/users_followers.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/users_followers.go">vendor/github.com/google/go-github/github/users_followers.go</a></b>
<a href="#h56-0" id="h56-0" class="h">@@ -0,0 +1,116 @@
</a><a href="#h56-0-0" id="h56-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h56-0-1" id="h56-0-1" class="i">+//
</a><a href="#h56-0-2" id="h56-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h56-0-3" id="h56-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h56-0-4" id="h56-0-4" class="i">+
</a><a href="#h56-0-5" id="h56-0-5" class="i">+package github
</a><a href="#h56-0-6" id="h56-0-6" class="i">+
</a><a href="#h56-0-7" id="h56-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h56-0-8" id="h56-0-8" class="i">+
</a><a href="#h56-0-9" id="h56-0-9" class="i">+// ListFollowers lists the followers for a user.  Passing the empty string will
</a><a href="#h56-0-10" id="h56-0-10" class="i">+// fetch followers for the authenticated user.
</a><a href="#h56-0-11" id="h56-0-11" class="i">+//
</a><a href="#h56-0-12" id="h56-0-12" class="i">+// GitHub API docs: http://developer.github.com/v3/users/followers/#list-followers-of-a-user
</a><a href="#h56-0-13" id="h56-0-13" class="i">+func (s *UsersService) ListFollowers(user string, opt *ListOptions) ([]User, *Response, error) {
</a><a href="#h56-0-14" id="h56-0-14" class="i">+	var u string
</a><a href="#h56-0-15" id="h56-0-15" class="i">+	if user != &quot;&quot; {
</a><a href="#h56-0-16" id="h56-0-16" class="i">+		u = fmt.Sprintf(&quot;users/%v/followers&quot;, user)
</a><a href="#h56-0-17" id="h56-0-17" class="i">+	} else {
</a><a href="#h56-0-18" id="h56-0-18" class="i">+		u = &quot;user/followers&quot;
</a><a href="#h56-0-19" id="h56-0-19" class="i">+	}
</a><a href="#h56-0-20" id="h56-0-20" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h56-0-21" id="h56-0-21" class="i">+	if err != nil {
</a><a href="#h56-0-22" id="h56-0-22" class="i">+		return nil, nil, err
</a><a href="#h56-0-23" id="h56-0-23" class="i">+	}
</a><a href="#h56-0-24" id="h56-0-24" class="i">+
</a><a href="#h56-0-25" id="h56-0-25" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h56-0-26" id="h56-0-26" class="i">+	if err != nil {
</a><a href="#h56-0-27" id="h56-0-27" class="i">+		return nil, nil, err
</a><a href="#h56-0-28" id="h56-0-28" class="i">+	}
</a><a href="#h56-0-29" id="h56-0-29" class="i">+
</a><a href="#h56-0-30" id="h56-0-30" class="i">+	users := new([]User)
</a><a href="#h56-0-31" id="h56-0-31" class="i">+	resp, err := s.client.Do(req, users)
</a><a href="#h56-0-32" id="h56-0-32" class="i">+	if err != nil {
</a><a href="#h56-0-33" id="h56-0-33" class="i">+		return nil, resp, err
</a><a href="#h56-0-34" id="h56-0-34" class="i">+	}
</a><a href="#h56-0-35" id="h56-0-35" class="i">+
</a><a href="#h56-0-36" id="h56-0-36" class="i">+	return *users, resp, err
</a><a href="#h56-0-37" id="h56-0-37" class="i">+}
</a><a href="#h56-0-38" id="h56-0-38" class="i">+
</a><a href="#h56-0-39" id="h56-0-39" class="i">+// ListFollowing lists the people that a user is following.  Passing the empty
</a><a href="#h56-0-40" id="h56-0-40" class="i">+// string will list people the authenticated user is following.
</a><a href="#h56-0-41" id="h56-0-41" class="i">+//
</a><a href="#h56-0-42" id="h56-0-42" class="i">+// GitHub API docs: http://developer.github.com/v3/users/followers/#list-users-followed-by-another-user
</a><a href="#h56-0-43" id="h56-0-43" class="i">+func (s *UsersService) ListFollowing(user string, opt *ListOptions) ([]User, *Response, error) {
</a><a href="#h56-0-44" id="h56-0-44" class="i">+	var u string
</a><a href="#h56-0-45" id="h56-0-45" class="i">+	if user != &quot;&quot; {
</a><a href="#h56-0-46" id="h56-0-46" class="i">+		u = fmt.Sprintf(&quot;users/%v/following&quot;, user)
</a><a href="#h56-0-47" id="h56-0-47" class="i">+	} else {
</a><a href="#h56-0-48" id="h56-0-48" class="i">+		u = &quot;user/following&quot;
</a><a href="#h56-0-49" id="h56-0-49" class="i">+	}
</a><a href="#h56-0-50" id="h56-0-50" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h56-0-51" id="h56-0-51" class="i">+	if err != nil {
</a><a href="#h56-0-52" id="h56-0-52" class="i">+		return nil, nil, err
</a><a href="#h56-0-53" id="h56-0-53" class="i">+	}
</a><a href="#h56-0-54" id="h56-0-54" class="i">+
</a><a href="#h56-0-55" id="h56-0-55" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h56-0-56" id="h56-0-56" class="i">+	if err != nil {
</a><a href="#h56-0-57" id="h56-0-57" class="i">+		return nil, nil, err
</a><a href="#h56-0-58" id="h56-0-58" class="i">+	}
</a><a href="#h56-0-59" id="h56-0-59" class="i">+
</a><a href="#h56-0-60" id="h56-0-60" class="i">+	users := new([]User)
</a><a href="#h56-0-61" id="h56-0-61" class="i">+	resp, err := s.client.Do(req, users)
</a><a href="#h56-0-62" id="h56-0-62" class="i">+	if err != nil {
</a><a href="#h56-0-63" id="h56-0-63" class="i">+		return nil, resp, err
</a><a href="#h56-0-64" id="h56-0-64" class="i">+	}
</a><a href="#h56-0-65" id="h56-0-65" class="i">+
</a><a href="#h56-0-66" id="h56-0-66" class="i">+	return *users, resp, err
</a><a href="#h56-0-67" id="h56-0-67" class="i">+}
</a><a href="#h56-0-68" id="h56-0-68" class="i">+
</a><a href="#h56-0-69" id="h56-0-69" class="i">+// IsFollowing checks if &quot;user&quot; is following &quot;target&quot;.  Passing the empty
</a><a href="#h56-0-70" id="h56-0-70" class="i">+// string for &quot;user&quot; will check if the authenticated user is following &quot;target&quot;.
</a><a href="#h56-0-71" id="h56-0-71" class="i">+//
</a><a href="#h56-0-72" id="h56-0-72" class="i">+// GitHub API docs: http://developer.github.com/v3/users/followers/#check-if-you-are-following-a-user
</a><a href="#h56-0-73" id="h56-0-73" class="i">+func (s *UsersService) IsFollowing(user, target string) (bool, *Response, error) {
</a><a href="#h56-0-74" id="h56-0-74" class="i">+	var u string
</a><a href="#h56-0-75" id="h56-0-75" class="i">+	if user != &quot;&quot; {
</a><a href="#h56-0-76" id="h56-0-76" class="i">+		u = fmt.Sprintf(&quot;users/%v/following/%v&quot;, user, target)
</a><a href="#h56-0-77" id="h56-0-77" class="i">+	} else {
</a><a href="#h56-0-78" id="h56-0-78" class="i">+		u = fmt.Sprintf(&quot;user/following/%v&quot;, target)
</a><a href="#h56-0-79" id="h56-0-79" class="i">+	}
</a><a href="#h56-0-80" id="h56-0-80" class="i">+
</a><a href="#h56-0-81" id="h56-0-81" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h56-0-82" id="h56-0-82" class="i">+	if err != nil {
</a><a href="#h56-0-83" id="h56-0-83" class="i">+		return false, nil, err
</a><a href="#h56-0-84" id="h56-0-84" class="i">+	}
</a><a href="#h56-0-85" id="h56-0-85" class="i">+
</a><a href="#h56-0-86" id="h56-0-86" class="i">+	resp, err := s.client.Do(req, nil)
</a><a href="#h56-0-87" id="h56-0-87" class="i">+	following, err := parseBoolResponse(err)
</a><a href="#h56-0-88" id="h56-0-88" class="i">+	return following, resp, err
</a><a href="#h56-0-89" id="h56-0-89" class="i">+}
</a><a href="#h56-0-90" id="h56-0-90" class="i">+
</a><a href="#h56-0-91" id="h56-0-91" class="i">+// Follow will cause the authenticated user to follow the specified user.
</a><a href="#h56-0-92" id="h56-0-92" class="i">+//
</a><a href="#h56-0-93" id="h56-0-93" class="i">+// GitHub API docs: http://developer.github.com/v3/users/followers/#follow-a-user
</a><a href="#h56-0-94" id="h56-0-94" class="i">+func (s *UsersService) Follow(user string) (*Response, error) {
</a><a href="#h56-0-95" id="h56-0-95" class="i">+	u := fmt.Sprintf(&quot;user/following/%v&quot;, user)
</a><a href="#h56-0-96" id="h56-0-96" class="i">+	req, err := s.client.NewRequest(&quot;PUT&quot;, u, nil)
</a><a href="#h56-0-97" id="h56-0-97" class="i">+	if err != nil {
</a><a href="#h56-0-98" id="h56-0-98" class="i">+		return nil, err
</a><a href="#h56-0-99" id="h56-0-99" class="i">+	}
</a><a href="#h56-0-100" id="h56-0-100" class="i">+
</a><a href="#h56-0-101" id="h56-0-101" class="i">+	return s.client.Do(req, nil)
</a><a href="#h56-0-102" id="h56-0-102" class="i">+}
</a><a href="#h56-0-103" id="h56-0-103" class="i">+
</a><a href="#h56-0-104" id="h56-0-104" class="i">+// Unfollow will cause the authenticated user to unfollow the specified user.
</a><a href="#h56-0-105" id="h56-0-105" class="i">+//
</a><a href="#h56-0-106" id="h56-0-106" class="i">+// GitHub API docs: http://developer.github.com/v3/users/followers/#unfollow-a-user
</a><a href="#h56-0-107" id="h56-0-107" class="i">+func (s *UsersService) Unfollow(user string) (*Response, error) {
</a><a href="#h56-0-108" id="h56-0-108" class="i">+	u := fmt.Sprintf(&quot;user/following/%v&quot;, user)
</a><a href="#h56-0-109" id="h56-0-109" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h56-0-110" id="h56-0-110" class="i">+	if err != nil {
</a><a href="#h56-0-111" id="h56-0-111" class="i">+		return nil, err
</a><a href="#h56-0-112" id="h56-0-112" class="i">+	}
</a><a href="#h56-0-113" id="h56-0-113" class="i">+
</a><a href="#h56-0-114" id="h56-0-114" class="i">+	return s.client.Do(req, nil)
</a><a href="#h56-0-115" id="h56-0-115" class="i">+}
</a><b>diff --git a/<a id="h57" href="../file/vendor/github.com/google/go-github/github/users_keys.go">vendor/github.com/google/go-github/github/users_keys.go</a> b/<a href="../file/vendor/github.com/google/go-github/github/users_keys.go">vendor/github.com/google/go-github/github/users_keys.go</a></b>
<a href="#h57-0" id="h57-0" class="h">@@ -0,0 +1,104 @@
</a><a href="#h57-0-0" id="h57-0-0" class="i">+// Copyright 2013 The go-github AUTHORS. All rights reserved.
</a><a href="#h57-0-1" id="h57-0-1" class="i">+//
</a><a href="#h57-0-2" id="h57-0-2" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h57-0-3" id="h57-0-3" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h57-0-4" id="h57-0-4" class="i">+
</a><a href="#h57-0-5" id="h57-0-5" class="i">+package github
</a><a href="#h57-0-6" id="h57-0-6" class="i">+
</a><a href="#h57-0-7" id="h57-0-7" class="i">+import &quot;fmt&quot;
</a><a href="#h57-0-8" id="h57-0-8" class="i">+
</a><a href="#h57-0-9" id="h57-0-9" class="i">+// Key represents a public SSH key used to authenticate a user or deploy script.
</a><a href="#h57-0-10" id="h57-0-10" class="i">+type Key struct {
</a><a href="#h57-0-11" id="h57-0-11" class="i">+	ID    *int    `json:&quot;id,omitempty&quot;`
</a><a href="#h57-0-12" id="h57-0-12" class="i">+	Key   *string `json:&quot;key,omitempty&quot;`
</a><a href="#h57-0-13" id="h57-0-13" class="i">+	URL   *string `json:&quot;url,omitempty&quot;`
</a><a href="#h57-0-14" id="h57-0-14" class="i">+	Title *string `json:&quot;title,omitempty&quot;`
</a><a href="#h57-0-15" id="h57-0-15" class="i">+}
</a><a href="#h57-0-16" id="h57-0-16" class="i">+
</a><a href="#h57-0-17" id="h57-0-17" class="i">+func (k Key) String() string {
</a><a href="#h57-0-18" id="h57-0-18" class="i">+	return Stringify(k)
</a><a href="#h57-0-19" id="h57-0-19" class="i">+}
</a><a href="#h57-0-20" id="h57-0-20" class="i">+
</a><a href="#h57-0-21" id="h57-0-21" class="i">+// ListKeys lists the verified public keys for a user.  Passing the empty
</a><a href="#h57-0-22" id="h57-0-22" class="i">+// string will fetch keys for the authenticated user.
</a><a href="#h57-0-23" id="h57-0-23" class="i">+//
</a><a href="#h57-0-24" id="h57-0-24" class="i">+// GitHub API docs: http://developer.github.com/v3/users/keys/#list-public-keys-for-a-user
</a><a href="#h57-0-25" id="h57-0-25" class="i">+func (s *UsersService) ListKeys(user string, opt *ListOptions) ([]Key, *Response, error) {
</a><a href="#h57-0-26" id="h57-0-26" class="i">+	var u string
</a><a href="#h57-0-27" id="h57-0-27" class="i">+	if user != &quot;&quot; {
</a><a href="#h57-0-28" id="h57-0-28" class="i">+		u = fmt.Sprintf(&quot;users/%v/keys&quot;, user)
</a><a href="#h57-0-29" id="h57-0-29" class="i">+	} else {
</a><a href="#h57-0-30" id="h57-0-30" class="i">+		u = &quot;user/keys&quot;
</a><a href="#h57-0-31" id="h57-0-31" class="i">+	}
</a><a href="#h57-0-32" id="h57-0-32" class="i">+	u, err := addOptions(u, opt)
</a><a href="#h57-0-33" id="h57-0-33" class="i">+	if err != nil {
</a><a href="#h57-0-34" id="h57-0-34" class="i">+		return nil, nil, err
</a><a href="#h57-0-35" id="h57-0-35" class="i">+	}
</a><a href="#h57-0-36" id="h57-0-36" class="i">+
</a><a href="#h57-0-37" id="h57-0-37" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h57-0-38" id="h57-0-38" class="i">+	if err != nil {
</a><a href="#h57-0-39" id="h57-0-39" class="i">+		return nil, nil, err
</a><a href="#h57-0-40" id="h57-0-40" class="i">+	}
</a><a href="#h57-0-41" id="h57-0-41" class="i">+
</a><a href="#h57-0-42" id="h57-0-42" class="i">+	keys := new([]Key)
</a><a href="#h57-0-43" id="h57-0-43" class="i">+	resp, err := s.client.Do(req, keys)
</a><a href="#h57-0-44" id="h57-0-44" class="i">+	if err != nil {
</a><a href="#h57-0-45" id="h57-0-45" class="i">+		return nil, resp, err
</a><a href="#h57-0-46" id="h57-0-46" class="i">+	}
</a><a href="#h57-0-47" id="h57-0-47" class="i">+
</a><a href="#h57-0-48" id="h57-0-48" class="i">+	return *keys, resp, err
</a><a href="#h57-0-49" id="h57-0-49" class="i">+}
</a><a href="#h57-0-50" id="h57-0-50" class="i">+
</a><a href="#h57-0-51" id="h57-0-51" class="i">+// GetKey fetches a single public key.
</a><a href="#h57-0-52" id="h57-0-52" class="i">+//
</a><a href="#h57-0-53" id="h57-0-53" class="i">+// GitHub API docs: http://developer.github.com/v3/users/keys/#get-a-single-public-key
</a><a href="#h57-0-54" id="h57-0-54" class="i">+func (s *UsersService) GetKey(id int) (*Key, *Response, error) {
</a><a href="#h57-0-55" id="h57-0-55" class="i">+	u := fmt.Sprintf(&quot;user/keys/%v&quot;, id)
</a><a href="#h57-0-56" id="h57-0-56" class="i">+
</a><a href="#h57-0-57" id="h57-0-57" class="i">+	req, err := s.client.NewRequest(&quot;GET&quot;, u, nil)
</a><a href="#h57-0-58" id="h57-0-58" class="i">+	if err != nil {
</a><a href="#h57-0-59" id="h57-0-59" class="i">+		return nil, nil, err
</a><a href="#h57-0-60" id="h57-0-60" class="i">+	}
</a><a href="#h57-0-61" id="h57-0-61" class="i">+
</a><a href="#h57-0-62" id="h57-0-62" class="i">+	key := new(Key)
</a><a href="#h57-0-63" id="h57-0-63" class="i">+	resp, err := s.client.Do(req, key)
</a><a href="#h57-0-64" id="h57-0-64" class="i">+	if err != nil {
</a><a href="#h57-0-65" id="h57-0-65" class="i">+		return nil, resp, err
</a><a href="#h57-0-66" id="h57-0-66" class="i">+	}
</a><a href="#h57-0-67" id="h57-0-67" class="i">+
</a><a href="#h57-0-68" id="h57-0-68" class="i">+	return key, resp, err
</a><a href="#h57-0-69" id="h57-0-69" class="i">+}
</a><a href="#h57-0-70" id="h57-0-70" class="i">+
</a><a href="#h57-0-71" id="h57-0-71" class="i">+// CreateKey adds a public key for the authenticated user.
</a><a href="#h57-0-72" id="h57-0-72" class="i">+//
</a><a href="#h57-0-73" id="h57-0-73" class="i">+// GitHub API docs: http://developer.github.com/v3/users/keys/#create-a-public-key
</a><a href="#h57-0-74" id="h57-0-74" class="i">+func (s *UsersService) CreateKey(key *Key) (*Key, *Response, error) {
</a><a href="#h57-0-75" id="h57-0-75" class="i">+	u := &quot;user/keys&quot;
</a><a href="#h57-0-76" id="h57-0-76" class="i">+
</a><a href="#h57-0-77" id="h57-0-77" class="i">+	req, err := s.client.NewRequest(&quot;POST&quot;, u, key)
</a><a href="#h57-0-78" id="h57-0-78" class="i">+	if err != nil {
</a><a href="#h57-0-79" id="h57-0-79" class="i">+		return nil, nil, err
</a><a href="#h57-0-80" id="h57-0-80" class="i">+	}
</a><a href="#h57-0-81" id="h57-0-81" class="i">+
</a><a href="#h57-0-82" id="h57-0-82" class="i">+	k := new(Key)
</a><a href="#h57-0-83" id="h57-0-83" class="i">+	resp, err := s.client.Do(req, k)
</a><a href="#h57-0-84" id="h57-0-84" class="i">+	if err != nil {
</a><a href="#h57-0-85" id="h57-0-85" class="i">+		return nil, resp, err
</a><a href="#h57-0-86" id="h57-0-86" class="i">+	}
</a><a href="#h57-0-87" id="h57-0-87" class="i">+
</a><a href="#h57-0-88" id="h57-0-88" class="i">+	return k, resp, err
</a><a href="#h57-0-89" id="h57-0-89" class="i">+}
</a><a href="#h57-0-90" id="h57-0-90" class="i">+
</a><a href="#h57-0-91" id="h57-0-91" class="i">+// DeleteKey deletes a public key.
</a><a href="#h57-0-92" id="h57-0-92" class="i">+//
</a><a href="#h57-0-93" id="h57-0-93" class="i">+// GitHub API docs: http://developer.github.com/v3/users/keys/#delete-a-public-key
</a><a href="#h57-0-94" id="h57-0-94" class="i">+func (s *UsersService) DeleteKey(id int) (*Response, error) {
</a><a href="#h57-0-95" id="h57-0-95" class="i">+	u := fmt.Sprintf(&quot;user/keys/%v&quot;, id)
</a><a href="#h57-0-96" id="h57-0-96" class="i">+
</a><a href="#h57-0-97" id="h57-0-97" class="i">+	req, err := s.client.NewRequest(&quot;DELETE&quot;, u, nil)
</a><a href="#h57-0-98" id="h57-0-98" class="i">+	if err != nil {
</a><a href="#h57-0-99" id="h57-0-99" class="i">+		return nil, err
</a><a href="#h57-0-100" id="h57-0-100" class="i">+	}
</a><a href="#h57-0-101" id="h57-0-101" class="i">+
</a><a href="#h57-0-102" id="h57-0-102" class="i">+	return s.client.Do(req, nil)
</a><a href="#h57-0-103" id="h57-0-103" class="i">+}
</a><b>diff --git a/<a id="h58" href="../file/vendor/github.com/google/go-querystring/LICENSE">vendor/github.com/google/go-querystring/LICENSE</a> b/<a href="../file/vendor/github.com/google/go-querystring/LICENSE">vendor/github.com/google/go-querystring/LICENSE</a></b>
<a href="#h58-0" id="h58-0" class="h">@@ -0,0 +1,27 @@
</a><a href="#h58-0-0" id="h58-0-0" class="i">+Copyright (c) 2013 Google. All rights reserved.
</a><a href="#h58-0-1" id="h58-0-1" class="i">+
</a><a href="#h58-0-2" id="h58-0-2" class="i">+Redistribution and use in source and binary forms, with or without
</a><a href="#h58-0-3" id="h58-0-3" class="i">+modification, are permitted provided that the following conditions are
</a><a href="#h58-0-4" id="h58-0-4" class="i">+met:
</a><a href="#h58-0-5" id="h58-0-5" class="i">+
</a><a href="#h58-0-6" id="h58-0-6" class="i">+   * Redistributions of source code must retain the above copyright
</a><a href="#h58-0-7" id="h58-0-7" class="i">+notice, this list of conditions and the following disclaimer.
</a><a href="#h58-0-8" id="h58-0-8" class="i">+   * Redistributions in binary form must reproduce the above
</a><a href="#h58-0-9" id="h58-0-9" class="i">+copyright notice, this list of conditions and the following disclaimer
</a><a href="#h58-0-10" id="h58-0-10" class="i">+in the documentation and/or other materials provided with the
</a><a href="#h58-0-11" id="h58-0-11" class="i">+distribution.
</a><a href="#h58-0-12" id="h58-0-12" class="i">+   * Neither the name of Google Inc. nor the names of its
</a><a href="#h58-0-13" id="h58-0-13" class="i">+contributors may be used to endorse or promote products derived from
</a><a href="#h58-0-14" id="h58-0-14" class="i">+this software without specific prior written permission.
</a><a href="#h58-0-15" id="h58-0-15" class="i">+
</a><a href="#h58-0-16" id="h58-0-16" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h58-0-17" id="h58-0-17" class="i">+&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h58-0-18" id="h58-0-18" class="i">+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h58-0-19" id="h58-0-19" class="i">+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h58-0-20" id="h58-0-20" class="i">+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h58-0-21" id="h58-0-21" class="i">+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h58-0-22" id="h58-0-22" class="i">+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h58-0-23" id="h58-0-23" class="i">+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h58-0-24" id="h58-0-24" class="i">+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h58-0-25" id="h58-0-25" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h58-0-26" id="h58-0-26" class="i">+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><b>diff --git a/<a id="h59" href="../file/vendor/github.com/google/go-querystring/query/encode.go">vendor/github.com/google/go-querystring/query/encode.go</a> b/<a href="../file/vendor/github.com/google/go-querystring/query/encode.go">vendor/github.com/google/go-querystring/query/encode.go</a></b>
<a href="#h59-0" id="h59-0" class="h">@@ -0,0 +1,311 @@
</a><a href="#h59-0-0" id="h59-0-0" class="i">+// Copyright 2013 The Go Authors. All rights reserved.
</a><a href="#h59-0-1" id="h59-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h59-0-2" id="h59-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h59-0-3" id="h59-0-3" class="i">+
</a><a href="#h59-0-4" id="h59-0-4" class="i">+// Package query implements encoding of structs into URL query parameters.
</a><a href="#h59-0-5" id="h59-0-5" class="i">+//
</a><a href="#h59-0-6" id="h59-0-6" class="i">+// As a simple example:
</a><a href="#h59-0-7" id="h59-0-7" class="i">+//
</a><a href="#h59-0-8" id="h59-0-8" class="i">+// 	type Options struct {
</a><a href="#h59-0-9" id="h59-0-9" class="i">+// 		Query   string `url:&quot;q&quot;`
</a><a href="#h59-0-10" id="h59-0-10" class="i">+// 		ShowAll bool   `url:&quot;all&quot;`
</a><a href="#h59-0-11" id="h59-0-11" class="i">+// 		Page    int    `url:&quot;page&quot;`
</a><a href="#h59-0-12" id="h59-0-12" class="i">+// 	}
</a><a href="#h59-0-13" id="h59-0-13" class="i">+//
</a><a href="#h59-0-14" id="h59-0-14" class="i">+// 	opt := Options{ &quot;foo&quot;, true, 2 }
</a><a href="#h59-0-15" id="h59-0-15" class="i">+// 	v, _ := query.Values(opt)
</a><a href="#h59-0-16" id="h59-0-16" class="i">+// 	fmt.Print(v.Encode()) // will output: &quot;q=foo&amp;all=true&amp;page=2&quot;
</a><a href="#h59-0-17" id="h59-0-17" class="i">+//
</a><a href="#h59-0-18" id="h59-0-18" class="i">+// The exact mapping between Go values and url.Values is described in the
</a><a href="#h59-0-19" id="h59-0-19" class="i">+// documentation for the Values() function.
</a><a href="#h59-0-20" id="h59-0-20" class="i">+package query
</a><a href="#h59-0-21" id="h59-0-21" class="i">+
</a><a href="#h59-0-22" id="h59-0-22" class="i">+import (
</a><a href="#h59-0-23" id="h59-0-23" class="i">+	&quot;bytes&quot;
</a><a href="#h59-0-24" id="h59-0-24" class="i">+	&quot;fmt&quot;
</a><a href="#h59-0-25" id="h59-0-25" class="i">+	&quot;net/url&quot;
</a><a href="#h59-0-26" id="h59-0-26" class="i">+	&quot;reflect&quot;
</a><a href="#h59-0-27" id="h59-0-27" class="i">+	&quot;strconv&quot;
</a><a href="#h59-0-28" id="h59-0-28" class="i">+	&quot;strings&quot;
</a><a href="#h59-0-29" id="h59-0-29" class="i">+	&quot;time&quot;
</a><a href="#h59-0-30" id="h59-0-30" class="i">+)
</a><a href="#h59-0-31" id="h59-0-31" class="i">+
</a><a href="#h59-0-32" id="h59-0-32" class="i">+var timeType = reflect.TypeOf(time.Time{})
</a><a href="#h59-0-33" id="h59-0-33" class="i">+
</a><a href="#h59-0-34" id="h59-0-34" class="i">+var encoderType = reflect.TypeOf(new(Encoder)).Elem()
</a><a href="#h59-0-35" id="h59-0-35" class="i">+
</a><a href="#h59-0-36" id="h59-0-36" class="i">+// Encoder is an interface implemented by any type that wishes to encode
</a><a href="#h59-0-37" id="h59-0-37" class="i">+// itself into URL values in a non-standard way.
</a><a href="#h59-0-38" id="h59-0-38" class="i">+type Encoder interface {
</a><a href="#h59-0-39" id="h59-0-39" class="i">+	EncodeValues(key string, v *url.Values) error
</a><a href="#h59-0-40" id="h59-0-40" class="i">+}
</a><a href="#h59-0-41" id="h59-0-41" class="i">+
</a><a href="#h59-0-42" id="h59-0-42" class="i">+// Values returns the url.Values encoding of v.
</a><a href="#h59-0-43" id="h59-0-43" class="i">+//
</a><a href="#h59-0-44" id="h59-0-44" class="i">+// Values expects to be passed a struct, and traverses it recursively using the
</a><a href="#h59-0-45" id="h59-0-45" class="i">+// following encoding rules.
</a><a href="#h59-0-46" id="h59-0-46" class="i">+//
</a><a href="#h59-0-47" id="h59-0-47" class="i">+// Each exported struct field is encoded as a URL parameter unless
</a><a href="#h59-0-48" id="h59-0-48" class="i">+//
</a><a href="#h59-0-49" id="h59-0-49" class="i">+//	- the field&#39;s tag is &quot;-&quot;, or
</a><a href="#h59-0-50" id="h59-0-50" class="i">+//	- the field is empty and its tag specifies the &quot;omitempty&quot; option
</a><a href="#h59-0-51" id="h59-0-51" class="i">+//
</a><a href="#h59-0-52" id="h59-0-52" class="i">+// The empty values are false, 0, any nil pointer or interface value, any array
</a><a href="#h59-0-53" id="h59-0-53" class="i">+// slice, map, or string of length zero, and any time.Time that returns true
</a><a href="#h59-0-54" id="h59-0-54" class="i">+// for IsZero().
</a><a href="#h59-0-55" id="h59-0-55" class="i">+//
</a><a href="#h59-0-56" id="h59-0-56" class="i">+// The URL parameter name defaults to the struct field name but can be
</a><a href="#h59-0-57" id="h59-0-57" class="i">+// specified in the struct field&#39;s tag value.  The &quot;url&quot; key in the struct
</a><a href="#h59-0-58" id="h59-0-58" class="i">+// field&#39;s tag value is the key name, followed by an optional comma and
</a><a href="#h59-0-59" id="h59-0-59" class="i">+// options.  For example:
</a><a href="#h59-0-60" id="h59-0-60" class="i">+//
</a><a href="#h59-0-61" id="h59-0-61" class="i">+// 	// Field is ignored by this package.
</a><a href="#h59-0-62" id="h59-0-62" class="i">+// 	Field int `url:&quot;-&quot;`
</a><a href="#h59-0-63" id="h59-0-63" class="i">+//
</a><a href="#h59-0-64" id="h59-0-64" class="i">+// 	// Field appears as URL parameter &quot;myName&quot;.
</a><a href="#h59-0-65" id="h59-0-65" class="i">+// 	Field int `url:&quot;myName&quot;`
</a><a href="#h59-0-66" id="h59-0-66" class="i">+//
</a><a href="#h59-0-67" id="h59-0-67" class="i">+// 	// Field appears as URL parameter &quot;myName&quot; and the field is omitted if
</a><a href="#h59-0-68" id="h59-0-68" class="i">+// 	// its value is empty
</a><a href="#h59-0-69" id="h59-0-69" class="i">+// 	Field int `url:&quot;myName,omitempty&quot;`
</a><a href="#h59-0-70" id="h59-0-70" class="i">+//
</a><a href="#h59-0-71" id="h59-0-71" class="i">+// 	// Field appears as URL parameter &quot;Field&quot; (the default), but the field
</a><a href="#h59-0-72" id="h59-0-72" class="i">+// 	// is skipped if empty.  Note the leading comma.
</a><a href="#h59-0-73" id="h59-0-73" class="i">+// 	Field int `url:&quot;,omitempty&quot;`
</a><a href="#h59-0-74" id="h59-0-74" class="i">+//
</a><a href="#h59-0-75" id="h59-0-75" class="i">+// For encoding individual field values, the following type-dependent rules
</a><a href="#h59-0-76" id="h59-0-76" class="i">+// apply:
</a><a href="#h59-0-77" id="h59-0-77" class="i">+//
</a><a href="#h59-0-78" id="h59-0-78" class="i">+// Boolean values default to encoding as the strings &quot;true&quot; or &quot;false&quot;.
</a><a href="#h59-0-79" id="h59-0-79" class="i">+// Including the &quot;int&quot; option signals that the field should be encoded as the
</a><a href="#h59-0-80" id="h59-0-80" class="i">+// strings &quot;1&quot; or &quot;0&quot;.
</a><a href="#h59-0-81" id="h59-0-81" class="i">+//
</a><a href="#h59-0-82" id="h59-0-82" class="i">+// time.Time values default to encoding as RFC3339 timestamps.  Including the
</a><a href="#h59-0-83" id="h59-0-83" class="i">+// &quot;unix&quot; option signals that the field should be encoded as a Unix time (see
</a><a href="#h59-0-84" id="h59-0-84" class="i">+// time.Unix())
</a><a href="#h59-0-85" id="h59-0-85" class="i">+//
</a><a href="#h59-0-86" id="h59-0-86" class="i">+// Slice and Array values default to encoding as multiple URL values of the
</a><a href="#h59-0-87" id="h59-0-87" class="i">+// same name.  Including the &quot;comma&quot; option signals that the field should be
</a><a href="#h59-0-88" id="h59-0-88" class="i">+// encoded as a single comma-delimited value.  Including the &quot;space&quot; option
</a><a href="#h59-0-89" id="h59-0-89" class="i">+// similarly encodes the value as a single space-delimited string. Including
</a><a href="#h59-0-90" id="h59-0-90" class="i">+// the &quot;brackets&quot; option signals that the multiple URL values should have &quot;[]&quot;
</a><a href="#h59-0-91" id="h59-0-91" class="i">+// appended to the value name.
</a><a href="#h59-0-92" id="h59-0-92" class="i">+//
</a><a href="#h59-0-93" id="h59-0-93" class="i">+// Anonymous struct fields are usually encoded as if their inner exported
</a><a href="#h59-0-94" id="h59-0-94" class="i">+// fields were fields in the outer struct, subject to the standard Go
</a><a href="#h59-0-95" id="h59-0-95" class="i">+// visibility rules.  An anonymous struct field with a name given in its URL
</a><a href="#h59-0-96" id="h59-0-96" class="i">+// tag is treated as having that name, rather than being anonymous.
</a><a href="#h59-0-97" id="h59-0-97" class="i">+//
</a><a href="#h59-0-98" id="h59-0-98" class="i">+// Non-nil pointer values are encoded as the value pointed to.
</a><a href="#h59-0-99" id="h59-0-99" class="i">+//
</a><a href="#h59-0-100" id="h59-0-100" class="i">+// Nested structs are encoded including parent fields in value names for
</a><a href="#h59-0-101" id="h59-0-101" class="i">+// scoping. e.g:
</a><a href="#h59-0-102" id="h59-0-102" class="i">+//
</a><a href="#h59-0-103" id="h59-0-103" class="i">+// 	&quot;user[name]=acme&amp;user[addr][postcode]=1234&amp;user[addr][city]=SFO&quot;
</a><a href="#h59-0-104" id="h59-0-104" class="i">+//
</a><a href="#h59-0-105" id="h59-0-105" class="i">+// All other values are encoded using their default string representation.
</a><a href="#h59-0-106" id="h59-0-106" class="i">+//
</a><a href="#h59-0-107" id="h59-0-107" class="i">+// Multiple fields that encode to the same URL parameter name will be included
</a><a href="#h59-0-108" id="h59-0-108" class="i">+// as multiple URL values of the same name.
</a><a href="#h59-0-109" id="h59-0-109" class="i">+func Values(v interface{}) (url.Values, error) {
</a><a href="#h59-0-110" id="h59-0-110" class="i">+	values := make(url.Values)
</a><a href="#h59-0-111" id="h59-0-111" class="i">+	val := reflect.ValueOf(v)
</a><a href="#h59-0-112" id="h59-0-112" class="i">+	for val.Kind() == reflect.Ptr {
</a><a href="#h59-0-113" id="h59-0-113" class="i">+		if val.IsNil() {
</a><a href="#h59-0-114" id="h59-0-114" class="i">+			return values, nil
</a><a href="#h59-0-115" id="h59-0-115" class="i">+		}
</a><a href="#h59-0-116" id="h59-0-116" class="i">+		val = val.Elem()
</a><a href="#h59-0-117" id="h59-0-117" class="i">+	}
</a><a href="#h59-0-118" id="h59-0-118" class="i">+
</a><a href="#h59-0-119" id="h59-0-119" class="i">+	if v == nil {
</a><a href="#h59-0-120" id="h59-0-120" class="i">+		return values, nil
</a><a href="#h59-0-121" id="h59-0-121" class="i">+	}
</a><a href="#h59-0-122" id="h59-0-122" class="i">+
</a><a href="#h59-0-123" id="h59-0-123" class="i">+	if val.Kind() != reflect.Struct {
</a><a href="#h59-0-124" id="h59-0-124" class="i">+		return nil, fmt.Errorf(&quot;query: Values() expects struct input. Got %v&quot;, val.Kind())
</a><a href="#h59-0-125" id="h59-0-125" class="i">+	}
</a><a href="#h59-0-126" id="h59-0-126" class="i">+
</a><a href="#h59-0-127" id="h59-0-127" class="i">+	err := reflectValue(values, val, &quot;&quot;)
</a><a href="#h59-0-128" id="h59-0-128" class="i">+	return values, err
</a><a href="#h59-0-129" id="h59-0-129" class="i">+}
</a><a href="#h59-0-130" id="h59-0-130" class="i">+
</a><a href="#h59-0-131" id="h59-0-131" class="i">+// reflectValue populates the values parameter from the struct fields in val.
</a><a href="#h59-0-132" id="h59-0-132" class="i">+// Embedded structs are followed recursively (using the rules defined in the
</a><a href="#h59-0-133" id="h59-0-133" class="i">+// Values function documentation) breadth-first.
</a><a href="#h59-0-134" id="h59-0-134" class="i">+func reflectValue(values url.Values, val reflect.Value, scope string) error {
</a><a href="#h59-0-135" id="h59-0-135" class="i">+	var embedded []reflect.Value
</a><a href="#h59-0-136" id="h59-0-136" class="i">+
</a><a href="#h59-0-137" id="h59-0-137" class="i">+	typ := val.Type()
</a><a href="#h59-0-138" id="h59-0-138" class="i">+	for i := 0; i &lt; typ.NumField(); i++ {
</a><a href="#h59-0-139" id="h59-0-139" class="i">+		sf := typ.Field(i)
</a><a href="#h59-0-140" id="h59-0-140" class="i">+		if sf.PkgPath != &quot;&quot; &amp;&amp; !sf.Anonymous { // unexported
</a><a href="#h59-0-141" id="h59-0-141" class="i">+			continue
</a><a href="#h59-0-142" id="h59-0-142" class="i">+		}
</a><a href="#h59-0-143" id="h59-0-143" class="i">+
</a><a href="#h59-0-144" id="h59-0-144" class="i">+		sv := val.Field(i)
</a><a href="#h59-0-145" id="h59-0-145" class="i">+		tag := sf.Tag.Get(&quot;url&quot;)
</a><a href="#h59-0-146" id="h59-0-146" class="i">+		if tag == &quot;-&quot; {
</a><a href="#h59-0-147" id="h59-0-147" class="i">+			continue
</a><a href="#h59-0-148" id="h59-0-148" class="i">+		}
</a><a href="#h59-0-149" id="h59-0-149" class="i">+		name, opts := parseTag(tag)
</a><a href="#h59-0-150" id="h59-0-150" class="i">+		if name == &quot;&quot; {
</a><a href="#h59-0-151" id="h59-0-151" class="i">+			if sf.Anonymous &amp;&amp; sv.Kind() == reflect.Struct {
</a><a href="#h59-0-152" id="h59-0-152" class="i">+				// save embedded struct for later processing
</a><a href="#h59-0-153" id="h59-0-153" class="i">+				embedded = append(embedded, sv)
</a><a href="#h59-0-154" id="h59-0-154" class="i">+				continue
</a><a href="#h59-0-155" id="h59-0-155" class="i">+			}
</a><a href="#h59-0-156" id="h59-0-156" class="i">+
</a><a href="#h59-0-157" id="h59-0-157" class="i">+			name = sf.Name
</a><a href="#h59-0-158" id="h59-0-158" class="i">+		}
</a><a href="#h59-0-159" id="h59-0-159" class="i">+
</a><a href="#h59-0-160" id="h59-0-160" class="i">+		if scope != &quot;&quot; {
</a><a href="#h59-0-161" id="h59-0-161" class="i">+			name = scope + &quot;[&quot; + name + &quot;]&quot;
</a><a href="#h59-0-162" id="h59-0-162" class="i">+		}
</a><a href="#h59-0-163" id="h59-0-163" class="i">+
</a><a href="#h59-0-164" id="h59-0-164" class="i">+		if opts.Contains(&quot;omitempty&quot;) &amp;&amp; isEmptyValue(sv) {
</a><a href="#h59-0-165" id="h59-0-165" class="i">+			continue
</a><a href="#h59-0-166" id="h59-0-166" class="i">+		}
</a><a href="#h59-0-167" id="h59-0-167" class="i">+
</a><a href="#h59-0-168" id="h59-0-168" class="i">+		if sv.Type().Implements(encoderType) {
</a><a href="#h59-0-169" id="h59-0-169" class="i">+			if !reflect.Indirect(sv).IsValid() {
</a><a href="#h59-0-170" id="h59-0-170" class="i">+				sv = reflect.New(sv.Type().Elem())
</a><a href="#h59-0-171" id="h59-0-171" class="i">+			}
</a><a href="#h59-0-172" id="h59-0-172" class="i">+
</a><a href="#h59-0-173" id="h59-0-173" class="i">+			m := sv.Interface().(Encoder)
</a><a href="#h59-0-174" id="h59-0-174" class="i">+			if err := m.EncodeValues(name, &amp;values); err != nil {
</a><a href="#h59-0-175" id="h59-0-175" class="i">+				return err
</a><a href="#h59-0-176" id="h59-0-176" class="i">+			}
</a><a href="#h59-0-177" id="h59-0-177" class="i">+			continue
</a><a href="#h59-0-178" id="h59-0-178" class="i">+		}
</a><a href="#h59-0-179" id="h59-0-179" class="i">+
</a><a href="#h59-0-180" id="h59-0-180" class="i">+		if sv.Kind() == reflect.Slice || sv.Kind() == reflect.Array {
</a><a href="#h59-0-181" id="h59-0-181" class="i">+			var del byte
</a><a href="#h59-0-182" id="h59-0-182" class="i">+			if opts.Contains(&quot;comma&quot;) {
</a><a href="#h59-0-183" id="h59-0-183" class="i">+				del = &#39;,&#39;
</a><a href="#h59-0-184" id="h59-0-184" class="i">+			} else if opts.Contains(&quot;space&quot;) {
</a><a href="#h59-0-185" id="h59-0-185" class="i">+				del = &#39; &#39;
</a><a href="#h59-0-186" id="h59-0-186" class="i">+			} else if opts.Contains(&quot;brackets&quot;) {
</a><a href="#h59-0-187" id="h59-0-187" class="i">+				name = name + &quot;[]&quot;
</a><a href="#h59-0-188" id="h59-0-188" class="i">+			}
</a><a href="#h59-0-189" id="h59-0-189" class="i">+
</a><a href="#h59-0-190" id="h59-0-190" class="i">+			if del != 0 {
</a><a href="#h59-0-191" id="h59-0-191" class="i">+				s := new(bytes.Buffer)
</a><a href="#h59-0-192" id="h59-0-192" class="i">+				first := true
</a><a href="#h59-0-193" id="h59-0-193" class="i">+				for i := 0; i &lt; sv.Len(); i++ {
</a><a href="#h59-0-194" id="h59-0-194" class="i">+					if first {
</a><a href="#h59-0-195" id="h59-0-195" class="i">+						first = false
</a><a href="#h59-0-196" id="h59-0-196" class="i">+					} else {
</a><a href="#h59-0-197" id="h59-0-197" class="i">+						s.WriteByte(del)
</a><a href="#h59-0-198" id="h59-0-198" class="i">+					}
</a><a href="#h59-0-199" id="h59-0-199" class="i">+					s.WriteString(valueString(sv.Index(i), opts))
</a><a href="#h59-0-200" id="h59-0-200" class="i">+				}
</a><a href="#h59-0-201" id="h59-0-201" class="i">+				values.Add(name, s.String())
</a><a href="#h59-0-202" id="h59-0-202" class="i">+			} else {
</a><a href="#h59-0-203" id="h59-0-203" class="i">+				for i := 0; i &lt; sv.Len(); i++ {
</a><a href="#h59-0-204" id="h59-0-204" class="i">+					values.Add(name, valueString(sv.Index(i), opts))
</a><a href="#h59-0-205" id="h59-0-205" class="i">+				}
</a><a href="#h59-0-206" id="h59-0-206" class="i">+			}
</a><a href="#h59-0-207" id="h59-0-207" class="i">+			continue
</a><a href="#h59-0-208" id="h59-0-208" class="i">+		}
</a><a href="#h59-0-209" id="h59-0-209" class="i">+
</a><a href="#h59-0-210" id="h59-0-210" class="i">+		if sv.Type() == timeType {
</a><a href="#h59-0-211" id="h59-0-211" class="i">+			values.Add(name, valueString(sv, opts))
</a><a href="#h59-0-212" id="h59-0-212" class="i">+			continue
</a><a href="#h59-0-213" id="h59-0-213" class="i">+		}
</a><a href="#h59-0-214" id="h59-0-214" class="i">+
</a><a href="#h59-0-215" id="h59-0-215" class="i">+		for sv.Kind() == reflect.Ptr {
</a><a href="#h59-0-216" id="h59-0-216" class="i">+			if sv.IsNil() {
</a><a href="#h59-0-217" id="h59-0-217" class="i">+				break
</a><a href="#h59-0-218" id="h59-0-218" class="i">+			}
</a><a href="#h59-0-219" id="h59-0-219" class="i">+			sv = sv.Elem()
</a><a href="#h59-0-220" id="h59-0-220" class="i">+		}
</a><a href="#h59-0-221" id="h59-0-221" class="i">+
</a><a href="#h59-0-222" id="h59-0-222" class="i">+		if sv.Kind() == reflect.Struct {
</a><a href="#h59-0-223" id="h59-0-223" class="i">+			reflectValue(values, sv, name)
</a><a href="#h59-0-224" id="h59-0-224" class="i">+			continue
</a><a href="#h59-0-225" id="h59-0-225" class="i">+		}
</a><a href="#h59-0-226" id="h59-0-226" class="i">+
</a><a href="#h59-0-227" id="h59-0-227" class="i">+		values.Add(name, valueString(sv, opts))
</a><a href="#h59-0-228" id="h59-0-228" class="i">+	}
</a><a href="#h59-0-229" id="h59-0-229" class="i">+
</a><a href="#h59-0-230" id="h59-0-230" class="i">+	for _, f := range embedded {
</a><a href="#h59-0-231" id="h59-0-231" class="i">+		if err := reflectValue(values, f, scope); err != nil {
</a><a href="#h59-0-232" id="h59-0-232" class="i">+			return err
</a><a href="#h59-0-233" id="h59-0-233" class="i">+		}
</a><a href="#h59-0-234" id="h59-0-234" class="i">+	}
</a><a href="#h59-0-235" id="h59-0-235" class="i">+
</a><a href="#h59-0-236" id="h59-0-236" class="i">+	return nil
</a><a href="#h59-0-237" id="h59-0-237" class="i">+}
</a><a href="#h59-0-238" id="h59-0-238" class="i">+
</a><a href="#h59-0-239" id="h59-0-239" class="i">+// valueString returns the string representation of a value.
</a><a href="#h59-0-240" id="h59-0-240" class="i">+func valueString(v reflect.Value, opts tagOptions) string {
</a><a href="#h59-0-241" id="h59-0-241" class="i">+	for v.Kind() == reflect.Ptr {
</a><a href="#h59-0-242" id="h59-0-242" class="i">+		if v.IsNil() {
</a><a href="#h59-0-243" id="h59-0-243" class="i">+			return &quot;&quot;
</a><a href="#h59-0-244" id="h59-0-244" class="i">+		}
</a><a href="#h59-0-245" id="h59-0-245" class="i">+		v = v.Elem()
</a><a href="#h59-0-246" id="h59-0-246" class="i">+	}
</a><a href="#h59-0-247" id="h59-0-247" class="i">+
</a><a href="#h59-0-248" id="h59-0-248" class="i">+	if v.Kind() == reflect.Bool &amp;&amp; opts.Contains(&quot;int&quot;) {
</a><a href="#h59-0-249" id="h59-0-249" class="i">+		if v.Bool() {
</a><a href="#h59-0-250" id="h59-0-250" class="i">+			return &quot;1&quot;
</a><a href="#h59-0-251" id="h59-0-251" class="i">+		}
</a><a href="#h59-0-252" id="h59-0-252" class="i">+		return &quot;0&quot;
</a><a href="#h59-0-253" id="h59-0-253" class="i">+	}
</a><a href="#h59-0-254" id="h59-0-254" class="i">+
</a><a href="#h59-0-255" id="h59-0-255" class="i">+	if v.Type() == timeType {
</a><a href="#h59-0-256" id="h59-0-256" class="i">+		t := v.Interface().(time.Time)
</a><a href="#h59-0-257" id="h59-0-257" class="i">+		if opts.Contains(&quot;unix&quot;) {
</a><a href="#h59-0-258" id="h59-0-258" class="i">+			return strconv.FormatInt(t.Unix(), 10)
</a><a href="#h59-0-259" id="h59-0-259" class="i">+		}
</a><a href="#h59-0-260" id="h59-0-260" class="i">+		return t.Format(time.RFC3339)
</a><a href="#h59-0-261" id="h59-0-261" class="i">+	}
</a><a href="#h59-0-262" id="h59-0-262" class="i">+
</a><a href="#h59-0-263" id="h59-0-263" class="i">+	return fmt.Sprint(v.Interface())
</a><a href="#h59-0-264" id="h59-0-264" class="i">+}
</a><a href="#h59-0-265" id="h59-0-265" class="i">+
</a><a href="#h59-0-266" id="h59-0-266" class="i">+// isEmptyValue checks if a value should be considered empty for the purposes
</a><a href="#h59-0-267" id="h59-0-267" class="i">+// of omitting fields with the &quot;omitempty&quot; option.
</a><a href="#h59-0-268" id="h59-0-268" class="i">+func isEmptyValue(v reflect.Value) bool {
</a><a href="#h59-0-269" id="h59-0-269" class="i">+	switch v.Kind() {
</a><a href="#h59-0-270" id="h59-0-270" class="i">+	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
</a><a href="#h59-0-271" id="h59-0-271" class="i">+		return v.Len() == 0
</a><a href="#h59-0-272" id="h59-0-272" class="i">+	case reflect.Bool:
</a><a href="#h59-0-273" id="h59-0-273" class="i">+		return !v.Bool()
</a><a href="#h59-0-274" id="h59-0-274" class="i">+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
</a><a href="#h59-0-275" id="h59-0-275" class="i">+		return v.Int() == 0
</a><a href="#h59-0-276" id="h59-0-276" class="i">+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
</a><a href="#h59-0-277" id="h59-0-277" class="i">+		return v.Uint() == 0
</a><a href="#h59-0-278" id="h59-0-278" class="i">+	case reflect.Float32, reflect.Float64:
</a><a href="#h59-0-279" id="h59-0-279" class="i">+		return v.Float() == 0
</a><a href="#h59-0-280" id="h59-0-280" class="i">+	case reflect.Interface, reflect.Ptr:
</a><a href="#h59-0-281" id="h59-0-281" class="i">+		return v.IsNil()
</a><a href="#h59-0-282" id="h59-0-282" class="i">+	}
</a><a href="#h59-0-283" id="h59-0-283" class="i">+
</a><a href="#h59-0-284" id="h59-0-284" class="i">+	if v.Type() == timeType {
</a><a href="#h59-0-285" id="h59-0-285" class="i">+		return v.Interface().(time.Time).IsZero()
</a><a href="#h59-0-286" id="h59-0-286" class="i">+	}
</a><a href="#h59-0-287" id="h59-0-287" class="i">+
</a><a href="#h59-0-288" id="h59-0-288" class="i">+	return false
</a><a href="#h59-0-289" id="h59-0-289" class="i">+}
</a><a href="#h59-0-290" id="h59-0-290" class="i">+
</a><a href="#h59-0-291" id="h59-0-291" class="i">+// tagOptions is the string following a comma in a struct field&#39;s &quot;url&quot; tag, or
</a><a href="#h59-0-292" id="h59-0-292" class="i">+// the empty string. It does not include the leading comma.
</a><a href="#h59-0-293" id="h59-0-293" class="i">+type tagOptions []string
</a><a href="#h59-0-294" id="h59-0-294" class="i">+
</a><a href="#h59-0-295" id="h59-0-295" class="i">+// parseTag splits a struct field&#39;s url tag into its name and comma-separated
</a><a href="#h59-0-296" id="h59-0-296" class="i">+// options.
</a><a href="#h59-0-297" id="h59-0-297" class="i">+func parseTag(tag string) (string, tagOptions) {
</a><a href="#h59-0-298" id="h59-0-298" class="i">+	s := strings.Split(tag, &quot;,&quot;)
</a><a href="#h59-0-299" id="h59-0-299" class="i">+	return s[0], s[1:]
</a><a href="#h59-0-300" id="h59-0-300" class="i">+}
</a><a href="#h59-0-301" id="h59-0-301" class="i">+
</a><a href="#h59-0-302" id="h59-0-302" class="i">+// Contains checks whether the tagOptions contains the specified option.
</a><a href="#h59-0-303" id="h59-0-303" class="i">+func (o tagOptions) Contains(option string) bool {
</a><a href="#h59-0-304" id="h59-0-304" class="i">+	for _, s := range o {
</a><a href="#h59-0-305" id="h59-0-305" class="i">+		if s == option {
</a><a href="#h59-0-306" id="h59-0-306" class="i">+			return true
</a><a href="#h59-0-307" id="h59-0-307" class="i">+		}
</a><a href="#h59-0-308" id="h59-0-308" class="i">+	}
</a><a href="#h59-0-309" id="h59-0-309" class="i">+	return false
</a><a href="#h59-0-310" id="h59-0-310" class="i">+}
</a><b>diff --git a/<a id="h60" href="../file/vendor/github.com/nelhage/go.cli/LICENSE">vendor/github.com/nelhage/go.cli/LICENSE</a> b/<a href="../file/vendor/github.com/nelhage/go.cli/LICENSE">vendor/github.com/nelhage/go.cli/LICENSE</a></b>
<a href="#h60-0" id="h60-0" class="h">@@ -0,0 +1,26 @@
</a><a href="#h60-0-0" id="h60-0-0" class="i">+Copyright (c) 2013-2014 Nelson Elhage
</a><a href="#h60-0-1" id="h60-0-1" class="i">+All rights reserved.
</a><a href="#h60-0-2" id="h60-0-2" class="i">+
</a><a href="#h60-0-3" id="h60-0-3" class="i">+Redistribution and use in source and binary forms, with or without
</a><a href="#h60-0-4" id="h60-0-4" class="i">+modification, are permitted provided that the following conditions
</a><a href="#h60-0-5" id="h60-0-5" class="i">+are met:
</a><a href="#h60-0-6" id="h60-0-6" class="i">+1. Redistributions of source code must retain the above copyright
</a><a href="#h60-0-7" id="h60-0-7" class="i">+   notice, this list of conditions and the following disclaimer.
</a><a href="#h60-0-8" id="h60-0-8" class="i">+2. Redistributions in binary form must reproduce the above copyright
</a><a href="#h60-0-9" id="h60-0-9" class="i">+   notice, this list of conditions and the following disclaimer in the
</a><a href="#h60-0-10" id="h60-0-10" class="i">+   documentation and/or other materials provided with the distribution.
</a><a href="#h60-0-11" id="h60-0-11" class="i">+3. Neither the name of the University nor the names of its contributors
</a><a href="#h60-0-12" id="h60-0-12" class="i">+   may be used to endorse or promote products derived from this software
</a><a href="#h60-0-13" id="h60-0-13" class="i">+   without specific prior written permission.
</a><a href="#h60-0-14" id="h60-0-14" class="i">+
</a><a href="#h60-0-15" id="h60-0-15" class="i">+THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND
</a><a href="#h60-0-16" id="h60-0-16" class="i">+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</a><a href="#h60-0-17" id="h60-0-17" class="i">+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</a><a href="#h60-0-18" id="h60-0-18" class="i">+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
</a><a href="#h60-0-19" id="h60-0-19" class="i">+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
</a><a href="#h60-0-20" id="h60-0-20" class="i">+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
</a><a href="#h60-0-21" id="h60-0-21" class="i">+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
</a><a href="#h60-0-22" id="h60-0-22" class="i">+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
</a><a href="#h60-0-23" id="h60-0-23" class="i">+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
</a><a href="#h60-0-24" id="h60-0-24" class="i">+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
</a><a href="#h60-0-25" id="h60-0-25" class="i">+SUCH DAMAGE.
</a><b>diff --git a/<a id="h61" href="../file/vendor/github.com/nelhage/go.cli/config/README.md">vendor/github.com/nelhage/go.cli/config/README.md</a> b/<a href="../file/vendor/github.com/nelhage/go.cli/config/README.md">vendor/github.com/nelhage/go.cli/config/README.md</a></b>
<a href="#h61-0" id="h61-0" class="h">@@ -0,0 +1,18 @@
</a><a href="#h61-0-0" id="h61-0-0" class="i">+# go.config -- parse configuration files using go&#39;s &quot;flag&quot; package
</a><a href="#h61-0-1" id="h61-0-1" class="i">+
</a><a href="#h61-0-2" id="h61-0-2" class="i">+command-line options already provide a flexible and powerful way to
</a><a href="#h61-0-3" id="h61-0-3" class="i">+configure many applications, and go&#39;s &quot;flag&quot; package provides an easy
</a><a href="#h61-0-4" id="h61-0-4" class="i">+way to define command-line options and distribute their values into
</a><a href="#h61-0-5" id="h61-0-5" class="i">+arbitrary modules in your program.
</a><a href="#h61-0-6" id="h61-0-6" class="i">+
</a><a href="#h61-0-7" id="h61-0-7" class="i">+go.config builds on that infrastructure to provide a lightweight
</a><a href="#h61-0-8" id="h61-0-8" class="i">+config-file mechanism to read configuration options from a file
</a><a href="#h61-0-9" id="h61-0-9" class="i">+directly into a flag.FlagSet.
</a><a href="#h61-0-10" id="h61-0-10" class="i">+
</a><a href="#h61-0-11" id="h61-0-11" class="i">+Run
</a><a href="#h61-0-12" id="h61-0-12" class="i">+
</a><a href="#h61-0-13" id="h61-0-13" class="i">+```
</a><a href="#h61-0-14" id="h61-0-14" class="i">+godoc github.com/nelhage/go.config
</a><a href="#h61-0-15" id="h61-0-15" class="i">+```
</a><a href="#h61-0-16" id="h61-0-16" class="i">+
</a><a href="#h61-0-17" id="h61-0-17" class="i">+for more information.
</a><b>diff --git a/<a id="h62" href="../file/vendor/github.com/nelhage/go.cli/config/config.go">vendor/github.com/nelhage/go.cli/config/config.go</a> b/<a href="../file/vendor/github.com/nelhage/go.cli/config/config.go">vendor/github.com/nelhage/go.cli/config/config.go</a></b>
<a href="#h62-0" id="h62-0" class="h">@@ -0,0 +1,71 @@
</a><a href="#h62-0-0" id="h62-0-0" class="i">+// Package config provides support for loading config options from a
</a><a href="#h62-0-1" id="h62-0-1" class="i">+// file, leveraging configuration defined using the `flag&#39; package.
</a><a href="#h62-0-2" id="h62-0-2" class="i">+//
</a><a href="#h62-0-3" id="h62-0-3" class="i">+// Config files should consist of lines of the form
</a><a href="#h62-0-4" id="h62-0-4" class="i">+//
</a><a href="#h62-0-5" id="h62-0-5" class="i">+//   &lt;key&gt; = &lt;value&gt;
</a><a href="#h62-0-6" id="h62-0-6" class="i">+//
</a><a href="#h62-0-7" id="h62-0-7" class="i">+// or
</a><a href="#h62-0-8" id="h62-0-8" class="i">+//
</a><a href="#h62-0-9" id="h62-0-9" class="i">+//   # this is a comment
</a><a href="#h62-0-10" id="h62-0-10" class="i">+//
</a><a href="#h62-0-11" id="h62-0-11" class="i">+// Configuration options are loaded by passing in a flag.FlagSet; keys
</a><a href="#h62-0-12" id="h62-0-12" class="i">+//  and values are looked up, parsed, and stored using the
</a><a href="#h62-0-13" id="h62-0-13" class="i">+//  FlagSet. For many applications, you can just pass in
</a><a href="#h62-0-14" id="h62-0-14" class="i">+//  flag.CommandLine to expose your application&#39;s default set of
</a><a href="#h62-0-15" id="h62-0-15" class="i">+//  command-line options as configuration frobs.
</a><a href="#h62-0-16" id="h62-0-16" class="i">+package config
</a><a href="#h62-0-17" id="h62-0-17" class="i">+
</a><a href="#h62-0-18" id="h62-0-18" class="i">+import (
</a><a href="#h62-0-19" id="h62-0-19" class="i">+	&quot;bufio&quot;
</a><a href="#h62-0-20" id="h62-0-20" class="i">+	&quot;flag&quot;
</a><a href="#h62-0-21" id="h62-0-21" class="i">+	&quot;fmt&quot;
</a><a href="#h62-0-22" id="h62-0-22" class="i">+	&quot;io&quot;
</a><a href="#h62-0-23" id="h62-0-23" class="i">+	&quot;os&quot;
</a><a href="#h62-0-24" id="h62-0-24" class="i">+	&quot;strings&quot;
</a><a href="#h62-0-25" id="h62-0-25" class="i">+)
</a><a href="#h62-0-26" id="h62-0-26" class="i">+
</a><a href="#h62-0-27" id="h62-0-27" class="i">+// LoadConfig loads configuration from a dotfile. It looks for
</a><a href="#h62-0-28" id="h62-0-28" class="i">+// $HOME/.basename, and, if it exists, opens it and calls
</a><a href="#h62-0-29" id="h62-0-29" class="i">+// ParseConfig. Returns silently if no such file exists.
</a><a href="#h62-0-30" id="h62-0-30" class="i">+func LoadConfig(flags *flag.FlagSet, basename string) error {
</a><a href="#h62-0-31" id="h62-0-31" class="i">+	path := os.ExpandEnv(fmt.Sprintf(&quot;${HOME}/.%s&quot;, basename))
</a><a href="#h62-0-32" id="h62-0-32" class="i">+	f, err := os.Open(path)
</a><a href="#h62-0-33" id="h62-0-33" class="i">+	if err != nil {
</a><a href="#h62-0-34" id="h62-0-34" class="i">+		if os.IsNotExist(err) {
</a><a href="#h62-0-35" id="h62-0-35" class="i">+			return nil
</a><a href="#h62-0-36" id="h62-0-36" class="i">+		}
</a><a href="#h62-0-37" id="h62-0-37" class="i">+		return err
</a><a href="#h62-0-38" id="h62-0-38" class="i">+	}
</a><a href="#h62-0-39" id="h62-0-39" class="i">+	defer f.Close()
</a><a href="#h62-0-40" id="h62-0-40" class="i">+	return ParseConfig(flags, f)
</a><a href="#h62-0-41" id="h62-0-41" class="i">+}
</a><a href="#h62-0-42" id="h62-0-42" class="i">+
</a><a href="#h62-0-43" id="h62-0-43" class="i">+// ParseConfig parses a config file, using the provided FlagSet to
</a><a href="#h62-0-44" id="h62-0-44" class="i">+// look up, parse, and store values.
</a><a href="#h62-0-45" id="h62-0-45" class="i">+func ParseConfig(flags *flag.FlagSet, f io.Reader) error {
</a><a href="#h62-0-46" id="h62-0-46" class="i">+	scanner := bufio.NewScanner(f)
</a><a href="#h62-0-47" id="h62-0-47" class="i">+	for scanner.Scan() {
</a><a href="#h62-0-48" id="h62-0-48" class="i">+		line := strings.TrimSpace(scanner.Text())
</a><a href="#h62-0-49" id="h62-0-49" class="i">+		if line == &quot;&quot; || strings.HasPrefix(line, &quot;#&quot;) {
</a><a href="#h62-0-50" id="h62-0-50" class="i">+			continue
</a><a href="#h62-0-51" id="h62-0-51" class="i">+		}
</a><a href="#h62-0-52" id="h62-0-52" class="i">+
</a><a href="#h62-0-53" id="h62-0-53" class="i">+		bits := strings.SplitN(line, &quot;=&quot;, 2)
</a><a href="#h62-0-54" id="h62-0-54" class="i">+		if len(bits) != 2 {
</a><a href="#h62-0-55" id="h62-0-55" class="i">+			return fmt.Errorf(&quot;illegal config line: `%s&#39;&quot;, line)
</a><a href="#h62-0-56" id="h62-0-56" class="i">+		}
</a><a href="#h62-0-57" id="h62-0-57" class="i">+
</a><a href="#h62-0-58" id="h62-0-58" class="i">+		key := strings.TrimSpace(bits[0])
</a><a href="#h62-0-59" id="h62-0-59" class="i">+		value := strings.TrimSpace(bits[1])
</a><a href="#h62-0-60" id="h62-0-60" class="i">+
</a><a href="#h62-0-61" id="h62-0-61" class="i">+		if flag := flags.Lookup(key); flag == nil {
</a><a href="#h62-0-62" id="h62-0-62" class="i">+			return fmt.Errorf(&quot;unknown option `%s&#39;&quot;, key)
</a><a href="#h62-0-63" id="h62-0-63" class="i">+		}
</a><a href="#h62-0-64" id="h62-0-64" class="i">+
</a><a href="#h62-0-65" id="h62-0-65" class="i">+		if err := flags.Set(key, value); err != nil {
</a><a href="#h62-0-66" id="h62-0-66" class="i">+			return err
</a><a href="#h62-0-67" id="h62-0-67" class="i">+		}
</a><a href="#h62-0-68" id="h62-0-68" class="i">+	}
</a><a href="#h62-0-69" id="h62-0-69" class="i">+	return nil
</a><a href="#h62-0-70" id="h62-0-70" class="i">+}
</a><b>diff --git a/<a id="h63" href="../file/vendor/golang.org/x/net/LICENSE">vendor/golang.org/x/net/LICENSE</a> b/<a href="../file/vendor/golang.org/x/net/LICENSE">vendor/golang.org/x/net/LICENSE</a></b>
<a href="#h63-0" id="h63-0" class="h">@@ -0,0 +1,27 @@
</a><a href="#h63-0-0" id="h63-0-0" class="i">+Copyright (c) 2009 The Go Authors. All rights reserved.
</a><a href="#h63-0-1" id="h63-0-1" class="i">+
</a><a href="#h63-0-2" id="h63-0-2" class="i">+Redistribution and use in source and binary forms, with or without
</a><a href="#h63-0-3" id="h63-0-3" class="i">+modification, are permitted provided that the following conditions are
</a><a href="#h63-0-4" id="h63-0-4" class="i">+met:
</a><a href="#h63-0-5" id="h63-0-5" class="i">+
</a><a href="#h63-0-6" id="h63-0-6" class="i">+   * Redistributions of source code must retain the above copyright
</a><a href="#h63-0-7" id="h63-0-7" class="i">+notice, this list of conditions and the following disclaimer.
</a><a href="#h63-0-8" id="h63-0-8" class="i">+   * Redistributions in binary form must reproduce the above
</a><a href="#h63-0-9" id="h63-0-9" class="i">+copyright notice, this list of conditions and the following disclaimer
</a><a href="#h63-0-10" id="h63-0-10" class="i">+in the documentation and/or other materials provided with the
</a><a href="#h63-0-11" id="h63-0-11" class="i">+distribution.
</a><a href="#h63-0-12" id="h63-0-12" class="i">+   * Neither the name of Google Inc. nor the names of its
</a><a href="#h63-0-13" id="h63-0-13" class="i">+contributors may be used to endorse or promote products derived from
</a><a href="#h63-0-14" id="h63-0-14" class="i">+this software without specific prior written permission.
</a><a href="#h63-0-15" id="h63-0-15" class="i">+
</a><a href="#h63-0-16" id="h63-0-16" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h63-0-17" id="h63-0-17" class="i">+&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h63-0-18" id="h63-0-18" class="i">+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h63-0-19" id="h63-0-19" class="i">+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h63-0-20" id="h63-0-20" class="i">+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h63-0-21" id="h63-0-21" class="i">+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h63-0-22" id="h63-0-22" class="i">+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h63-0-23" id="h63-0-23" class="i">+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h63-0-24" id="h63-0-24" class="i">+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h63-0-25" id="h63-0-25" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h63-0-26" id="h63-0-26" class="i">+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><b>diff --git a/<a id="h64" href="../file/vendor/golang.org/x/net/PATENTS">vendor/golang.org/x/net/PATENTS</a> b/<a href="../file/vendor/golang.org/x/net/PATENTS">vendor/golang.org/x/net/PATENTS</a></b>
<a href="#h64-0" id="h64-0" class="h">@@ -0,0 +1,22 @@
</a><a href="#h64-0-0" id="h64-0-0" class="i">+Additional IP Rights Grant (Patents)
</a><a href="#h64-0-1" id="h64-0-1" class="i">+
</a><a href="#h64-0-2" id="h64-0-2" class="i">+&quot;This implementation&quot; means the copyrightable works distributed by
</a><a href="#h64-0-3" id="h64-0-3" class="i">+Google as part of the Go project.
</a><a href="#h64-0-4" id="h64-0-4" class="i">+
</a><a href="#h64-0-5" id="h64-0-5" class="i">+Google hereby grants to You a perpetual, worldwide, non-exclusive,
</a><a href="#h64-0-6" id="h64-0-6" class="i">+no-charge, royalty-free, irrevocable (except as stated in this section)
</a><a href="#h64-0-7" id="h64-0-7" class="i">+patent license to make, have made, use, offer to sell, sell, import,
</a><a href="#h64-0-8" id="h64-0-8" class="i">+transfer and otherwise run, modify and propagate the contents of this
</a><a href="#h64-0-9" id="h64-0-9" class="i">+implementation of Go, where such license applies only to those patent
</a><a href="#h64-0-10" id="h64-0-10" class="i">+claims, both currently owned or controlled by Google and acquired in
</a><a href="#h64-0-11" id="h64-0-11" class="i">+the future, licensable by Google that are necessarily infringed by this
</a><a href="#h64-0-12" id="h64-0-12" class="i">+implementation of Go.  This grant does not include claims that would be
</a><a href="#h64-0-13" id="h64-0-13" class="i">+infringed only as a consequence of further modification of this
</a><a href="#h64-0-14" id="h64-0-14" class="i">+implementation.  If you or your agent or exclusive licensee institute or
</a><a href="#h64-0-15" id="h64-0-15" class="i">+order or agree to the institution of patent litigation against any
</a><a href="#h64-0-16" id="h64-0-16" class="i">+entity (including a cross-claim or counterclaim in a lawsuit) alleging
</a><a href="#h64-0-17" id="h64-0-17" class="i">+that this implementation of Go or any code incorporated within this
</a><a href="#h64-0-18" id="h64-0-18" class="i">+implementation of Go constitutes direct or contributory patent
</a><a href="#h64-0-19" id="h64-0-19" class="i">+infringement, or inducement of patent infringement, then any patent
</a><a href="#h64-0-20" id="h64-0-20" class="i">+rights granted to you under this License for this implementation of Go
</a><a href="#h64-0-21" id="h64-0-21" class="i">+shall terminate as of the date such litigation is filed.
</a><b>diff --git a/<a id="h65" href="../file/vendor/golang.org/x/net/context/context.go">vendor/golang.org/x/net/context/context.go</a> b/<a href="../file/vendor/golang.org/x/net/context/context.go">vendor/golang.org/x/net/context/context.go</a></b>
<a href="#h65-0" id="h65-0" class="h">@@ -0,0 +1,156 @@
</a><a href="#h65-0-0" id="h65-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h65-0-1" id="h65-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h65-0-2" id="h65-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h65-0-3" id="h65-0-3" class="i">+
</a><a href="#h65-0-4" id="h65-0-4" class="i">+// Package context defines the Context type, which carries deadlines,
</a><a href="#h65-0-5" id="h65-0-5" class="i">+// cancelation signals, and other request-scoped values across API boundaries
</a><a href="#h65-0-6" id="h65-0-6" class="i">+// and between processes.
</a><a href="#h65-0-7" id="h65-0-7" class="i">+//
</a><a href="#h65-0-8" id="h65-0-8" class="i">+// Incoming requests to a server should create a Context, and outgoing calls to
</a><a href="#h65-0-9" id="h65-0-9" class="i">+// servers should accept a Context.  The chain of function calls between must
</a><a href="#h65-0-10" id="h65-0-10" class="i">+// propagate the Context, optionally replacing it with a modified copy created
</a><a href="#h65-0-11" id="h65-0-11" class="i">+// using WithDeadline, WithTimeout, WithCancel, or WithValue.
</a><a href="#h65-0-12" id="h65-0-12" class="i">+//
</a><a href="#h65-0-13" id="h65-0-13" class="i">+// Programs that use Contexts should follow these rules to keep interfaces
</a><a href="#h65-0-14" id="h65-0-14" class="i">+// consistent across packages and enable static analysis tools to check context
</a><a href="#h65-0-15" id="h65-0-15" class="i">+// propagation:
</a><a href="#h65-0-16" id="h65-0-16" class="i">+//
</a><a href="#h65-0-17" id="h65-0-17" class="i">+// Do not store Contexts inside a struct type; instead, pass a Context
</a><a href="#h65-0-18" id="h65-0-18" class="i">+// explicitly to each function that needs it.  The Context should be the first
</a><a href="#h65-0-19" id="h65-0-19" class="i">+// parameter, typically named ctx:
</a><a href="#h65-0-20" id="h65-0-20" class="i">+//
</a><a href="#h65-0-21" id="h65-0-21" class="i">+// 	func DoSomething(ctx context.Context, arg Arg) error {
</a><a href="#h65-0-22" id="h65-0-22" class="i">+// 		// ... use ctx ...
</a><a href="#h65-0-23" id="h65-0-23" class="i">+// 	}
</a><a href="#h65-0-24" id="h65-0-24" class="i">+//
</a><a href="#h65-0-25" id="h65-0-25" class="i">+// Do not pass a nil Context, even if a function permits it.  Pass context.TODO
</a><a href="#h65-0-26" id="h65-0-26" class="i">+// if you are unsure about which Context to use.
</a><a href="#h65-0-27" id="h65-0-27" class="i">+//
</a><a href="#h65-0-28" id="h65-0-28" class="i">+// Use context Values only for request-scoped data that transits processes and
</a><a href="#h65-0-29" id="h65-0-29" class="i">+// APIs, not for passing optional parameters to functions.
</a><a href="#h65-0-30" id="h65-0-30" class="i">+//
</a><a href="#h65-0-31" id="h65-0-31" class="i">+// The same Context may be passed to functions running in different goroutines;
</a><a href="#h65-0-32" id="h65-0-32" class="i">+// Contexts are safe for simultaneous use by multiple goroutines.
</a><a href="#h65-0-33" id="h65-0-33" class="i">+//
</a><a href="#h65-0-34" id="h65-0-34" class="i">+// See http://blog.golang.org/context for example code for a server that uses
</a><a href="#h65-0-35" id="h65-0-35" class="i">+// Contexts.
</a><a href="#h65-0-36" id="h65-0-36" class="i">+package context // import &quot;golang.org/x/net/context&quot;
</a><a href="#h65-0-37" id="h65-0-37" class="i">+
</a><a href="#h65-0-38" id="h65-0-38" class="i">+import &quot;time&quot;
</a><a href="#h65-0-39" id="h65-0-39" class="i">+
</a><a href="#h65-0-40" id="h65-0-40" class="i">+// A Context carries a deadline, a cancelation signal, and other values across
</a><a href="#h65-0-41" id="h65-0-41" class="i">+// API boundaries.
</a><a href="#h65-0-42" id="h65-0-42" class="i">+//
</a><a href="#h65-0-43" id="h65-0-43" class="i">+// Context&#39;s methods may be called by multiple goroutines simultaneously.
</a><a href="#h65-0-44" id="h65-0-44" class="i">+type Context interface {
</a><a href="#h65-0-45" id="h65-0-45" class="i">+	// Deadline returns the time when work done on behalf of this context
</a><a href="#h65-0-46" id="h65-0-46" class="i">+	// should be canceled.  Deadline returns ok==false when no deadline is
</a><a href="#h65-0-47" id="h65-0-47" class="i">+	// set.  Successive calls to Deadline return the same results.
</a><a href="#h65-0-48" id="h65-0-48" class="i">+	Deadline() (deadline time.Time, ok bool)
</a><a href="#h65-0-49" id="h65-0-49" class="i">+
</a><a href="#h65-0-50" id="h65-0-50" class="i">+	// Done returns a channel that&#39;s closed when work done on behalf of this
</a><a href="#h65-0-51" id="h65-0-51" class="i">+	// context should be canceled.  Done may return nil if this context can
</a><a href="#h65-0-52" id="h65-0-52" class="i">+	// never be canceled.  Successive calls to Done return the same value.
</a><a href="#h65-0-53" id="h65-0-53" class="i">+	//
</a><a href="#h65-0-54" id="h65-0-54" class="i">+	// WithCancel arranges for Done to be closed when cancel is called;
</a><a href="#h65-0-55" id="h65-0-55" class="i">+	// WithDeadline arranges for Done to be closed when the deadline
</a><a href="#h65-0-56" id="h65-0-56" class="i">+	// expires; WithTimeout arranges for Done to be closed when the timeout
</a><a href="#h65-0-57" id="h65-0-57" class="i">+	// elapses.
</a><a href="#h65-0-58" id="h65-0-58" class="i">+	//
</a><a href="#h65-0-59" id="h65-0-59" class="i">+	// Done is provided for use in select statements:
</a><a href="#h65-0-60" id="h65-0-60" class="i">+	//
</a><a href="#h65-0-61" id="h65-0-61" class="i">+	//  // Stream generates values with DoSomething and sends them to out
</a><a href="#h65-0-62" id="h65-0-62" class="i">+	//  // until DoSomething returns an error or ctx.Done is closed.
</a><a href="#h65-0-63" id="h65-0-63" class="i">+	//  func Stream(ctx context.Context, out &lt;-chan Value) error {
</a><a href="#h65-0-64" id="h65-0-64" class="i">+	//  	for {
</a><a href="#h65-0-65" id="h65-0-65" class="i">+	//  		v, err := DoSomething(ctx)
</a><a href="#h65-0-66" id="h65-0-66" class="i">+	//  		if err != nil {
</a><a href="#h65-0-67" id="h65-0-67" class="i">+	//  			return err
</a><a href="#h65-0-68" id="h65-0-68" class="i">+	//  		}
</a><a href="#h65-0-69" id="h65-0-69" class="i">+	//  		select {
</a><a href="#h65-0-70" id="h65-0-70" class="i">+	//  		case &lt;-ctx.Done():
</a><a href="#h65-0-71" id="h65-0-71" class="i">+	//  			return ctx.Err()
</a><a href="#h65-0-72" id="h65-0-72" class="i">+	//  		case out &lt;- v:
</a><a href="#h65-0-73" id="h65-0-73" class="i">+	//  		}
</a><a href="#h65-0-74" id="h65-0-74" class="i">+	//  	}
</a><a href="#h65-0-75" id="h65-0-75" class="i">+	//  }
</a><a href="#h65-0-76" id="h65-0-76" class="i">+	//
</a><a href="#h65-0-77" id="h65-0-77" class="i">+	// See http://blog.golang.org/pipelines for more examples of how to use
</a><a href="#h65-0-78" id="h65-0-78" class="i">+	// a Done channel for cancelation.
</a><a href="#h65-0-79" id="h65-0-79" class="i">+	Done() &lt;-chan struct{}
</a><a href="#h65-0-80" id="h65-0-80" class="i">+
</a><a href="#h65-0-81" id="h65-0-81" class="i">+	// Err returns a non-nil error value after Done is closed.  Err returns
</a><a href="#h65-0-82" id="h65-0-82" class="i">+	// Canceled if the context was canceled or DeadlineExceeded if the
</a><a href="#h65-0-83" id="h65-0-83" class="i">+	// context&#39;s deadline passed.  No other values for Err are defined.
</a><a href="#h65-0-84" id="h65-0-84" class="i">+	// After Done is closed, successive calls to Err return the same value.
</a><a href="#h65-0-85" id="h65-0-85" class="i">+	Err() error
</a><a href="#h65-0-86" id="h65-0-86" class="i">+
</a><a href="#h65-0-87" id="h65-0-87" class="i">+	// Value returns the value associated with this context for key, or nil
</a><a href="#h65-0-88" id="h65-0-88" class="i">+	// if no value is associated with key.  Successive calls to Value with
</a><a href="#h65-0-89" id="h65-0-89" class="i">+	// the same key returns the same result.
</a><a href="#h65-0-90" id="h65-0-90" class="i">+	//
</a><a href="#h65-0-91" id="h65-0-91" class="i">+	// Use context values only for request-scoped data that transits
</a><a href="#h65-0-92" id="h65-0-92" class="i">+	// processes and API boundaries, not for passing optional parameters to
</a><a href="#h65-0-93" id="h65-0-93" class="i">+	// functions.
</a><a href="#h65-0-94" id="h65-0-94" class="i">+	//
</a><a href="#h65-0-95" id="h65-0-95" class="i">+	// A key identifies a specific value in a Context.  Functions that wish
</a><a href="#h65-0-96" id="h65-0-96" class="i">+	// to store values in Context typically allocate a key in a global
</a><a href="#h65-0-97" id="h65-0-97" class="i">+	// variable then use that key as the argument to context.WithValue and
</a><a href="#h65-0-98" id="h65-0-98" class="i">+	// Context.Value.  A key can be any type that supports equality;
</a><a href="#h65-0-99" id="h65-0-99" class="i">+	// packages should define keys as an unexported type to avoid
</a><a href="#h65-0-100" id="h65-0-100" class="i">+	// collisions.
</a><a href="#h65-0-101" id="h65-0-101" class="i">+	//
</a><a href="#h65-0-102" id="h65-0-102" class="i">+	// Packages that define a Context key should provide type-safe accessors
</a><a href="#h65-0-103" id="h65-0-103" class="i">+	// for the values stores using that key:
</a><a href="#h65-0-104" id="h65-0-104" class="i">+	//
</a><a href="#h65-0-105" id="h65-0-105" class="i">+	// 	// Package user defines a User type that&#39;s stored in Contexts.
</a><a href="#h65-0-106" id="h65-0-106" class="i">+	// 	package user
</a><a href="#h65-0-107" id="h65-0-107" class="i">+	//
</a><a href="#h65-0-108" id="h65-0-108" class="i">+	// 	import &quot;golang.org/x/net/context&quot;
</a><a href="#h65-0-109" id="h65-0-109" class="i">+	//
</a><a href="#h65-0-110" id="h65-0-110" class="i">+	// 	// User is the type of value stored in the Contexts.
</a><a href="#h65-0-111" id="h65-0-111" class="i">+	// 	type User struct {...}
</a><a href="#h65-0-112" id="h65-0-112" class="i">+	//
</a><a href="#h65-0-113" id="h65-0-113" class="i">+	// 	// key is an unexported type for keys defined in this package.
</a><a href="#h65-0-114" id="h65-0-114" class="i">+	// 	// This prevents collisions with keys defined in other packages.
</a><a href="#h65-0-115" id="h65-0-115" class="i">+	// 	type key int
</a><a href="#h65-0-116" id="h65-0-116" class="i">+	//
</a><a href="#h65-0-117" id="h65-0-117" class="i">+	// 	// userKey is the key for user.User values in Contexts.  It is
</a><a href="#h65-0-118" id="h65-0-118" class="i">+	// 	// unexported; clients use user.NewContext and user.FromContext
</a><a href="#h65-0-119" id="h65-0-119" class="i">+	// 	// instead of using this key directly.
</a><a href="#h65-0-120" id="h65-0-120" class="i">+	// 	var userKey key = 0
</a><a href="#h65-0-121" id="h65-0-121" class="i">+	//
</a><a href="#h65-0-122" id="h65-0-122" class="i">+	// 	// NewContext returns a new Context that carries value u.
</a><a href="#h65-0-123" id="h65-0-123" class="i">+	// 	func NewContext(ctx context.Context, u *User) context.Context {
</a><a href="#h65-0-124" id="h65-0-124" class="i">+	// 		return context.WithValue(ctx, userKey, u)
</a><a href="#h65-0-125" id="h65-0-125" class="i">+	// 	}
</a><a href="#h65-0-126" id="h65-0-126" class="i">+	//
</a><a href="#h65-0-127" id="h65-0-127" class="i">+	// 	// FromContext returns the User value stored in ctx, if any.
</a><a href="#h65-0-128" id="h65-0-128" class="i">+	// 	func FromContext(ctx context.Context) (*User, bool) {
</a><a href="#h65-0-129" id="h65-0-129" class="i">+	// 		u, ok := ctx.Value(userKey).(*User)
</a><a href="#h65-0-130" id="h65-0-130" class="i">+	// 		return u, ok
</a><a href="#h65-0-131" id="h65-0-131" class="i">+	// 	}
</a><a href="#h65-0-132" id="h65-0-132" class="i">+	Value(key interface{}) interface{}
</a><a href="#h65-0-133" id="h65-0-133" class="i">+}
</a><a href="#h65-0-134" id="h65-0-134" class="i">+
</a><a href="#h65-0-135" id="h65-0-135" class="i">+// Background returns a non-nil, empty Context. It is never canceled, has no
</a><a href="#h65-0-136" id="h65-0-136" class="i">+// values, and has no deadline.  It is typically used by the main function,
</a><a href="#h65-0-137" id="h65-0-137" class="i">+// initialization, and tests, and as the top-level Context for incoming
</a><a href="#h65-0-138" id="h65-0-138" class="i">+// requests.
</a><a href="#h65-0-139" id="h65-0-139" class="i">+func Background() Context {
</a><a href="#h65-0-140" id="h65-0-140" class="i">+	return background
</a><a href="#h65-0-141" id="h65-0-141" class="i">+}
</a><a href="#h65-0-142" id="h65-0-142" class="i">+
</a><a href="#h65-0-143" id="h65-0-143" class="i">+// TODO returns a non-nil, empty Context.  Code should use context.TODO when
</a><a href="#h65-0-144" id="h65-0-144" class="i">+// it&#39;s unclear which Context to use or it is not yet available (because the
</a><a href="#h65-0-145" id="h65-0-145" class="i">+// surrounding function has not yet been extended to accept a Context
</a><a href="#h65-0-146" id="h65-0-146" class="i">+// parameter).  TODO is recognized by static analysis tools that determine
</a><a href="#h65-0-147" id="h65-0-147" class="i">+// whether Contexts are propagated correctly in a program.
</a><a href="#h65-0-148" id="h65-0-148" class="i">+func TODO() Context {
</a><a href="#h65-0-149" id="h65-0-149" class="i">+	return todo
</a><a href="#h65-0-150" id="h65-0-150" class="i">+}
</a><a href="#h65-0-151" id="h65-0-151" class="i">+
</a><a href="#h65-0-152" id="h65-0-152" class="i">+// A CancelFunc tells an operation to abandon its work.
</a><a href="#h65-0-153" id="h65-0-153" class="i">+// A CancelFunc does not wait for the work to stop.
</a><a href="#h65-0-154" id="h65-0-154" class="i">+// After the first call, subsequent calls to a CancelFunc do nothing.
</a><a href="#h65-0-155" id="h65-0-155" class="i">+type CancelFunc func()
</a><b>diff --git a/<a id="h66" href="../file/vendor/golang.org/x/net/context/go17.go">vendor/golang.org/x/net/context/go17.go</a> b/<a href="../file/vendor/golang.org/x/net/context/go17.go">vendor/golang.org/x/net/context/go17.go</a></b>
<a href="#h66-0" id="h66-0" class="h">@@ -0,0 +1,72 @@
</a><a href="#h66-0-0" id="h66-0-0" class="i">+// Copyright 2016 The Go Authors. All rights reserved.
</a><a href="#h66-0-1" id="h66-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h66-0-2" id="h66-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h66-0-3" id="h66-0-3" class="i">+
</a><a href="#h66-0-4" id="h66-0-4" class="i">+// +build go1.7
</a><a href="#h66-0-5" id="h66-0-5" class="i">+
</a><a href="#h66-0-6" id="h66-0-6" class="i">+package context
</a><a href="#h66-0-7" id="h66-0-7" class="i">+
</a><a href="#h66-0-8" id="h66-0-8" class="i">+import (
</a><a href="#h66-0-9" id="h66-0-9" class="i">+	&quot;context&quot; // standard library&#39;s context, as of Go 1.7
</a><a href="#h66-0-10" id="h66-0-10" class="i">+	&quot;time&quot;
</a><a href="#h66-0-11" id="h66-0-11" class="i">+)
</a><a href="#h66-0-12" id="h66-0-12" class="i">+
</a><a href="#h66-0-13" id="h66-0-13" class="i">+var (
</a><a href="#h66-0-14" id="h66-0-14" class="i">+	todo       = context.TODO()
</a><a href="#h66-0-15" id="h66-0-15" class="i">+	background = context.Background()
</a><a href="#h66-0-16" id="h66-0-16" class="i">+)
</a><a href="#h66-0-17" id="h66-0-17" class="i">+
</a><a href="#h66-0-18" id="h66-0-18" class="i">+// Canceled is the error returned by Context.Err when the context is canceled.
</a><a href="#h66-0-19" id="h66-0-19" class="i">+var Canceled = context.Canceled
</a><a href="#h66-0-20" id="h66-0-20" class="i">+
</a><a href="#h66-0-21" id="h66-0-21" class="i">+// DeadlineExceeded is the error returned by Context.Err when the context&#39;s
</a><a href="#h66-0-22" id="h66-0-22" class="i">+// deadline passes.
</a><a href="#h66-0-23" id="h66-0-23" class="i">+var DeadlineExceeded = context.DeadlineExceeded
</a><a href="#h66-0-24" id="h66-0-24" class="i">+
</a><a href="#h66-0-25" id="h66-0-25" class="i">+// WithCancel returns a copy of parent with a new Done channel. The returned
</a><a href="#h66-0-26" id="h66-0-26" class="i">+// context&#39;s Done channel is closed when the returned cancel function is called
</a><a href="#h66-0-27" id="h66-0-27" class="i">+// or when the parent context&#39;s Done channel is closed, whichever happens first.
</a><a href="#h66-0-28" id="h66-0-28" class="i">+//
</a><a href="#h66-0-29" id="h66-0-29" class="i">+// Canceling this context releases resources associated with it, so code should
</a><a href="#h66-0-30" id="h66-0-30" class="i">+// call cancel as soon as the operations running in this Context complete.
</a><a href="#h66-0-31" id="h66-0-31" class="i">+func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
</a><a href="#h66-0-32" id="h66-0-32" class="i">+	ctx, f := context.WithCancel(parent)
</a><a href="#h66-0-33" id="h66-0-33" class="i">+	return ctx, CancelFunc(f)
</a><a href="#h66-0-34" id="h66-0-34" class="i">+}
</a><a href="#h66-0-35" id="h66-0-35" class="i">+
</a><a href="#h66-0-36" id="h66-0-36" class="i">+// WithDeadline returns a copy of the parent context with the deadline adjusted
</a><a href="#h66-0-37" id="h66-0-37" class="i">+// to be no later than d.  If the parent&#39;s deadline is already earlier than d,
</a><a href="#h66-0-38" id="h66-0-38" class="i">+// WithDeadline(parent, d) is semantically equivalent to parent.  The returned
</a><a href="#h66-0-39" id="h66-0-39" class="i">+// context&#39;s Done channel is closed when the deadline expires, when the returned
</a><a href="#h66-0-40" id="h66-0-40" class="i">+// cancel function is called, or when the parent context&#39;s Done channel is
</a><a href="#h66-0-41" id="h66-0-41" class="i">+// closed, whichever happens first.
</a><a href="#h66-0-42" id="h66-0-42" class="i">+//
</a><a href="#h66-0-43" id="h66-0-43" class="i">+// Canceling this context releases resources associated with it, so code should
</a><a href="#h66-0-44" id="h66-0-44" class="i">+// call cancel as soon as the operations running in this Context complete.
</a><a href="#h66-0-45" id="h66-0-45" class="i">+func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
</a><a href="#h66-0-46" id="h66-0-46" class="i">+	ctx, f := context.WithDeadline(parent, deadline)
</a><a href="#h66-0-47" id="h66-0-47" class="i">+	return ctx, CancelFunc(f)
</a><a href="#h66-0-48" id="h66-0-48" class="i">+}
</a><a href="#h66-0-49" id="h66-0-49" class="i">+
</a><a href="#h66-0-50" id="h66-0-50" class="i">+// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
</a><a href="#h66-0-51" id="h66-0-51" class="i">+//
</a><a href="#h66-0-52" id="h66-0-52" class="i">+// Canceling this context releases resources associated with it, so code should
</a><a href="#h66-0-53" id="h66-0-53" class="i">+// call cancel as soon as the operations running in this Context complete:
</a><a href="#h66-0-54" id="h66-0-54" class="i">+//
</a><a href="#h66-0-55" id="h66-0-55" class="i">+// 	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
</a><a href="#h66-0-56" id="h66-0-56" class="i">+// 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
</a><a href="#h66-0-57" id="h66-0-57" class="i">+// 		defer cancel()  // releases resources if slowOperation completes before timeout elapses
</a><a href="#h66-0-58" id="h66-0-58" class="i">+// 		return slowOperation(ctx)
</a><a href="#h66-0-59" id="h66-0-59" class="i">+// 	}
</a><a href="#h66-0-60" id="h66-0-60" class="i">+func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
</a><a href="#h66-0-61" id="h66-0-61" class="i">+	return WithDeadline(parent, time.Now().Add(timeout))
</a><a href="#h66-0-62" id="h66-0-62" class="i">+}
</a><a href="#h66-0-63" id="h66-0-63" class="i">+
</a><a href="#h66-0-64" id="h66-0-64" class="i">+// WithValue returns a copy of parent in which the value associated with key is
</a><a href="#h66-0-65" id="h66-0-65" class="i">+// val.
</a><a href="#h66-0-66" id="h66-0-66" class="i">+//
</a><a href="#h66-0-67" id="h66-0-67" class="i">+// Use context Values only for request-scoped data that transits processes and
</a><a href="#h66-0-68" id="h66-0-68" class="i">+// APIs, not for passing optional parameters to functions.
</a><a href="#h66-0-69" id="h66-0-69" class="i">+func WithValue(parent Context, key interface{}, val interface{}) Context {
</a><a href="#h66-0-70" id="h66-0-70" class="i">+	return context.WithValue(parent, key, val)
</a><a href="#h66-0-71" id="h66-0-71" class="i">+}
</a><b>diff --git a/<a id="h67" href="../file/vendor/golang.org/x/net/context/pre_go17.go">vendor/golang.org/x/net/context/pre_go17.go</a> b/<a href="../file/vendor/golang.org/x/net/context/pre_go17.go">vendor/golang.org/x/net/context/pre_go17.go</a></b>
<a href="#h67-0" id="h67-0" class="h">@@ -0,0 +1,300 @@
</a><a href="#h67-0-0" id="h67-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h67-0-1" id="h67-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h67-0-2" id="h67-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h67-0-3" id="h67-0-3" class="i">+
</a><a href="#h67-0-4" id="h67-0-4" class="i">+// +build !go1.7
</a><a href="#h67-0-5" id="h67-0-5" class="i">+
</a><a href="#h67-0-6" id="h67-0-6" class="i">+package context
</a><a href="#h67-0-7" id="h67-0-7" class="i">+
</a><a href="#h67-0-8" id="h67-0-8" class="i">+import (
</a><a href="#h67-0-9" id="h67-0-9" class="i">+	&quot;errors&quot;
</a><a href="#h67-0-10" id="h67-0-10" class="i">+	&quot;fmt&quot;
</a><a href="#h67-0-11" id="h67-0-11" class="i">+	&quot;sync&quot;
</a><a href="#h67-0-12" id="h67-0-12" class="i">+	&quot;time&quot;
</a><a href="#h67-0-13" id="h67-0-13" class="i">+)
</a><a href="#h67-0-14" id="h67-0-14" class="i">+
</a><a href="#h67-0-15" id="h67-0-15" class="i">+// An emptyCtx is never canceled, has no values, and has no deadline.  It is not
</a><a href="#h67-0-16" id="h67-0-16" class="i">+// struct{}, since vars of this type must have distinct addresses.
</a><a href="#h67-0-17" id="h67-0-17" class="i">+type emptyCtx int
</a><a href="#h67-0-18" id="h67-0-18" class="i">+
</a><a href="#h67-0-19" id="h67-0-19" class="i">+func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
</a><a href="#h67-0-20" id="h67-0-20" class="i">+	return
</a><a href="#h67-0-21" id="h67-0-21" class="i">+}
</a><a href="#h67-0-22" id="h67-0-22" class="i">+
</a><a href="#h67-0-23" id="h67-0-23" class="i">+func (*emptyCtx) Done() &lt;-chan struct{} {
</a><a href="#h67-0-24" id="h67-0-24" class="i">+	return nil
</a><a href="#h67-0-25" id="h67-0-25" class="i">+}
</a><a href="#h67-0-26" id="h67-0-26" class="i">+
</a><a href="#h67-0-27" id="h67-0-27" class="i">+func (*emptyCtx) Err() error {
</a><a href="#h67-0-28" id="h67-0-28" class="i">+	return nil
</a><a href="#h67-0-29" id="h67-0-29" class="i">+}
</a><a href="#h67-0-30" id="h67-0-30" class="i">+
</a><a href="#h67-0-31" id="h67-0-31" class="i">+func (*emptyCtx) Value(key interface{}) interface{} {
</a><a href="#h67-0-32" id="h67-0-32" class="i">+	return nil
</a><a href="#h67-0-33" id="h67-0-33" class="i">+}
</a><a href="#h67-0-34" id="h67-0-34" class="i">+
</a><a href="#h67-0-35" id="h67-0-35" class="i">+func (e *emptyCtx) String() string {
</a><a href="#h67-0-36" id="h67-0-36" class="i">+	switch e {
</a><a href="#h67-0-37" id="h67-0-37" class="i">+	case background:
</a><a href="#h67-0-38" id="h67-0-38" class="i">+		return &quot;context.Background&quot;
</a><a href="#h67-0-39" id="h67-0-39" class="i">+	case todo:
</a><a href="#h67-0-40" id="h67-0-40" class="i">+		return &quot;context.TODO&quot;
</a><a href="#h67-0-41" id="h67-0-41" class="i">+	}
</a><a href="#h67-0-42" id="h67-0-42" class="i">+	return &quot;unknown empty Context&quot;
</a><a href="#h67-0-43" id="h67-0-43" class="i">+}
</a><a href="#h67-0-44" id="h67-0-44" class="i">+
</a><a href="#h67-0-45" id="h67-0-45" class="i">+var (
</a><a href="#h67-0-46" id="h67-0-46" class="i">+	background = new(emptyCtx)
</a><a href="#h67-0-47" id="h67-0-47" class="i">+	todo       = new(emptyCtx)
</a><a href="#h67-0-48" id="h67-0-48" class="i">+)
</a><a href="#h67-0-49" id="h67-0-49" class="i">+
</a><a href="#h67-0-50" id="h67-0-50" class="i">+// Canceled is the error returned by Context.Err when the context is canceled.
</a><a href="#h67-0-51" id="h67-0-51" class="i">+var Canceled = errors.New(&quot;context canceled&quot;)
</a><a href="#h67-0-52" id="h67-0-52" class="i">+
</a><a href="#h67-0-53" id="h67-0-53" class="i">+// DeadlineExceeded is the error returned by Context.Err when the context&#39;s
</a><a href="#h67-0-54" id="h67-0-54" class="i">+// deadline passes.
</a><a href="#h67-0-55" id="h67-0-55" class="i">+var DeadlineExceeded = errors.New(&quot;context deadline exceeded&quot;)
</a><a href="#h67-0-56" id="h67-0-56" class="i">+
</a><a href="#h67-0-57" id="h67-0-57" class="i">+// WithCancel returns a copy of parent with a new Done channel. The returned
</a><a href="#h67-0-58" id="h67-0-58" class="i">+// context&#39;s Done channel is closed when the returned cancel function is called
</a><a href="#h67-0-59" id="h67-0-59" class="i">+// or when the parent context&#39;s Done channel is closed, whichever happens first.
</a><a href="#h67-0-60" id="h67-0-60" class="i">+//
</a><a href="#h67-0-61" id="h67-0-61" class="i">+// Canceling this context releases resources associated with it, so code should
</a><a href="#h67-0-62" id="h67-0-62" class="i">+// call cancel as soon as the operations running in this Context complete.
</a><a href="#h67-0-63" id="h67-0-63" class="i">+func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
</a><a href="#h67-0-64" id="h67-0-64" class="i">+	c := newCancelCtx(parent)
</a><a href="#h67-0-65" id="h67-0-65" class="i">+	propagateCancel(parent, c)
</a><a href="#h67-0-66" id="h67-0-66" class="i">+	return c, func() { c.cancel(true, Canceled) }
</a><a href="#h67-0-67" id="h67-0-67" class="i">+}
</a><a href="#h67-0-68" id="h67-0-68" class="i">+
</a><a href="#h67-0-69" id="h67-0-69" class="i">+// newCancelCtx returns an initialized cancelCtx.
</a><a href="#h67-0-70" id="h67-0-70" class="i">+func newCancelCtx(parent Context) *cancelCtx {
</a><a href="#h67-0-71" id="h67-0-71" class="i">+	return &amp;cancelCtx{
</a><a href="#h67-0-72" id="h67-0-72" class="i">+		Context: parent,
</a><a href="#h67-0-73" id="h67-0-73" class="i">+		done:    make(chan struct{}),
</a><a href="#h67-0-74" id="h67-0-74" class="i">+	}
</a><a href="#h67-0-75" id="h67-0-75" class="i">+}
</a><a href="#h67-0-76" id="h67-0-76" class="i">+
</a><a href="#h67-0-77" id="h67-0-77" class="i">+// propagateCancel arranges for child to be canceled when parent is.
</a><a href="#h67-0-78" id="h67-0-78" class="i">+func propagateCancel(parent Context, child canceler) {
</a><a href="#h67-0-79" id="h67-0-79" class="i">+	if parent.Done() == nil {
</a><a href="#h67-0-80" id="h67-0-80" class="i">+		return // parent is never canceled
</a><a href="#h67-0-81" id="h67-0-81" class="i">+	}
</a><a href="#h67-0-82" id="h67-0-82" class="i">+	if p, ok := parentCancelCtx(parent); ok {
</a><a href="#h67-0-83" id="h67-0-83" class="i">+		p.mu.Lock()
</a><a href="#h67-0-84" id="h67-0-84" class="i">+		if p.err != nil {
</a><a href="#h67-0-85" id="h67-0-85" class="i">+			// parent has already been canceled
</a><a href="#h67-0-86" id="h67-0-86" class="i">+			child.cancel(false, p.err)
</a><a href="#h67-0-87" id="h67-0-87" class="i">+		} else {
</a><a href="#h67-0-88" id="h67-0-88" class="i">+			if p.children == nil {
</a><a href="#h67-0-89" id="h67-0-89" class="i">+				p.children = make(map[canceler]bool)
</a><a href="#h67-0-90" id="h67-0-90" class="i">+			}
</a><a href="#h67-0-91" id="h67-0-91" class="i">+			p.children[child] = true
</a><a href="#h67-0-92" id="h67-0-92" class="i">+		}
</a><a href="#h67-0-93" id="h67-0-93" class="i">+		p.mu.Unlock()
</a><a href="#h67-0-94" id="h67-0-94" class="i">+	} else {
</a><a href="#h67-0-95" id="h67-0-95" class="i">+		go func() {
</a><a href="#h67-0-96" id="h67-0-96" class="i">+			select {
</a><a href="#h67-0-97" id="h67-0-97" class="i">+			case &lt;-parent.Done():
</a><a href="#h67-0-98" id="h67-0-98" class="i">+				child.cancel(false, parent.Err())
</a><a href="#h67-0-99" id="h67-0-99" class="i">+			case &lt;-child.Done():
</a><a href="#h67-0-100" id="h67-0-100" class="i">+			}
</a><a href="#h67-0-101" id="h67-0-101" class="i">+		}()
</a><a href="#h67-0-102" id="h67-0-102" class="i">+	}
</a><a href="#h67-0-103" id="h67-0-103" class="i">+}
</a><a href="#h67-0-104" id="h67-0-104" class="i">+
</a><a href="#h67-0-105" id="h67-0-105" class="i">+// parentCancelCtx follows a chain of parent references until it finds a
</a><a href="#h67-0-106" id="h67-0-106" class="i">+// *cancelCtx.  This function understands how each of the concrete types in this
</a><a href="#h67-0-107" id="h67-0-107" class="i">+// package represents its parent.
</a><a href="#h67-0-108" id="h67-0-108" class="i">+func parentCancelCtx(parent Context) (*cancelCtx, bool) {
</a><a href="#h67-0-109" id="h67-0-109" class="i">+	for {
</a><a href="#h67-0-110" id="h67-0-110" class="i">+		switch c := parent.(type) {
</a><a href="#h67-0-111" id="h67-0-111" class="i">+		case *cancelCtx:
</a><a href="#h67-0-112" id="h67-0-112" class="i">+			return c, true
</a><a href="#h67-0-113" id="h67-0-113" class="i">+		case *timerCtx:
</a><a href="#h67-0-114" id="h67-0-114" class="i">+			return c.cancelCtx, true
</a><a href="#h67-0-115" id="h67-0-115" class="i">+		case *valueCtx:
</a><a href="#h67-0-116" id="h67-0-116" class="i">+			parent = c.Context
</a><a href="#h67-0-117" id="h67-0-117" class="i">+		default:
</a><a href="#h67-0-118" id="h67-0-118" class="i">+			return nil, false
</a><a href="#h67-0-119" id="h67-0-119" class="i">+		}
</a><a href="#h67-0-120" id="h67-0-120" class="i">+	}
</a><a href="#h67-0-121" id="h67-0-121" class="i">+}
</a><a href="#h67-0-122" id="h67-0-122" class="i">+
</a><a href="#h67-0-123" id="h67-0-123" class="i">+// removeChild removes a context from its parent.
</a><a href="#h67-0-124" id="h67-0-124" class="i">+func removeChild(parent Context, child canceler) {
</a><a href="#h67-0-125" id="h67-0-125" class="i">+	p, ok := parentCancelCtx(parent)
</a><a href="#h67-0-126" id="h67-0-126" class="i">+	if !ok {
</a><a href="#h67-0-127" id="h67-0-127" class="i">+		return
</a><a href="#h67-0-128" id="h67-0-128" class="i">+	}
</a><a href="#h67-0-129" id="h67-0-129" class="i">+	p.mu.Lock()
</a><a href="#h67-0-130" id="h67-0-130" class="i">+	if p.children != nil {
</a><a href="#h67-0-131" id="h67-0-131" class="i">+		delete(p.children, child)
</a><a href="#h67-0-132" id="h67-0-132" class="i">+	}
</a><a href="#h67-0-133" id="h67-0-133" class="i">+	p.mu.Unlock()
</a><a href="#h67-0-134" id="h67-0-134" class="i">+}
</a><a href="#h67-0-135" id="h67-0-135" class="i">+
</a><a href="#h67-0-136" id="h67-0-136" class="i">+// A canceler is a context type that can be canceled directly.  The
</a><a href="#h67-0-137" id="h67-0-137" class="i">+// implementations are *cancelCtx and *timerCtx.
</a><a href="#h67-0-138" id="h67-0-138" class="i">+type canceler interface {
</a><a href="#h67-0-139" id="h67-0-139" class="i">+	cancel(removeFromParent bool, err error)
</a><a href="#h67-0-140" id="h67-0-140" class="i">+	Done() &lt;-chan struct{}
</a><a href="#h67-0-141" id="h67-0-141" class="i">+}
</a><a href="#h67-0-142" id="h67-0-142" class="i">+
</a><a href="#h67-0-143" id="h67-0-143" class="i">+// A cancelCtx can be canceled.  When canceled, it also cancels any children
</a><a href="#h67-0-144" id="h67-0-144" class="i">+// that implement canceler.
</a><a href="#h67-0-145" id="h67-0-145" class="i">+type cancelCtx struct {
</a><a href="#h67-0-146" id="h67-0-146" class="i">+	Context
</a><a href="#h67-0-147" id="h67-0-147" class="i">+
</a><a href="#h67-0-148" id="h67-0-148" class="i">+	done chan struct{} // closed by the first cancel call.
</a><a href="#h67-0-149" id="h67-0-149" class="i">+
</a><a href="#h67-0-150" id="h67-0-150" class="i">+	mu       sync.Mutex
</a><a href="#h67-0-151" id="h67-0-151" class="i">+	children map[canceler]bool // set to nil by the first cancel call
</a><a href="#h67-0-152" id="h67-0-152" class="i">+	err      error             // set to non-nil by the first cancel call
</a><a href="#h67-0-153" id="h67-0-153" class="i">+}
</a><a href="#h67-0-154" id="h67-0-154" class="i">+
</a><a href="#h67-0-155" id="h67-0-155" class="i">+func (c *cancelCtx) Done() &lt;-chan struct{} {
</a><a href="#h67-0-156" id="h67-0-156" class="i">+	return c.done
</a><a href="#h67-0-157" id="h67-0-157" class="i">+}
</a><a href="#h67-0-158" id="h67-0-158" class="i">+
</a><a href="#h67-0-159" id="h67-0-159" class="i">+func (c *cancelCtx) Err() error {
</a><a href="#h67-0-160" id="h67-0-160" class="i">+	c.mu.Lock()
</a><a href="#h67-0-161" id="h67-0-161" class="i">+	defer c.mu.Unlock()
</a><a href="#h67-0-162" id="h67-0-162" class="i">+	return c.err
</a><a href="#h67-0-163" id="h67-0-163" class="i">+}
</a><a href="#h67-0-164" id="h67-0-164" class="i">+
</a><a href="#h67-0-165" id="h67-0-165" class="i">+func (c *cancelCtx) String() string {
</a><a href="#h67-0-166" id="h67-0-166" class="i">+	return fmt.Sprintf(&quot;%v.WithCancel&quot;, c.Context)
</a><a href="#h67-0-167" id="h67-0-167" class="i">+}
</a><a href="#h67-0-168" id="h67-0-168" class="i">+
</a><a href="#h67-0-169" id="h67-0-169" class="i">+// cancel closes c.done, cancels each of c&#39;s children, and, if
</a><a href="#h67-0-170" id="h67-0-170" class="i">+// removeFromParent is true, removes c from its parent&#39;s children.
</a><a href="#h67-0-171" id="h67-0-171" class="i">+func (c *cancelCtx) cancel(removeFromParent bool, err error) {
</a><a href="#h67-0-172" id="h67-0-172" class="i">+	if err == nil {
</a><a href="#h67-0-173" id="h67-0-173" class="i">+		panic(&quot;context: internal error: missing cancel error&quot;)
</a><a href="#h67-0-174" id="h67-0-174" class="i">+	}
</a><a href="#h67-0-175" id="h67-0-175" class="i">+	c.mu.Lock()
</a><a href="#h67-0-176" id="h67-0-176" class="i">+	if c.err != nil {
</a><a href="#h67-0-177" id="h67-0-177" class="i">+		c.mu.Unlock()
</a><a href="#h67-0-178" id="h67-0-178" class="i">+		return // already canceled
</a><a href="#h67-0-179" id="h67-0-179" class="i">+	}
</a><a href="#h67-0-180" id="h67-0-180" class="i">+	c.err = err
</a><a href="#h67-0-181" id="h67-0-181" class="i">+	close(c.done)
</a><a href="#h67-0-182" id="h67-0-182" class="i">+	for child := range c.children {
</a><a href="#h67-0-183" id="h67-0-183" class="i">+		// NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.
</a><a href="#h67-0-184" id="h67-0-184" class="i">+		child.cancel(false, err)
</a><a href="#h67-0-185" id="h67-0-185" class="i">+	}
</a><a href="#h67-0-186" id="h67-0-186" class="i">+	c.children = nil
</a><a href="#h67-0-187" id="h67-0-187" class="i">+	c.mu.Unlock()
</a><a href="#h67-0-188" id="h67-0-188" class="i">+
</a><a href="#h67-0-189" id="h67-0-189" class="i">+	if removeFromParent {
</a><a href="#h67-0-190" id="h67-0-190" class="i">+		removeChild(c.Context, c)
</a><a href="#h67-0-191" id="h67-0-191" class="i">+	}
</a><a href="#h67-0-192" id="h67-0-192" class="i">+}
</a><a href="#h67-0-193" id="h67-0-193" class="i">+
</a><a href="#h67-0-194" id="h67-0-194" class="i">+// WithDeadline returns a copy of the parent context with the deadline adjusted
</a><a href="#h67-0-195" id="h67-0-195" class="i">+// to be no later than d.  If the parent&#39;s deadline is already earlier than d,
</a><a href="#h67-0-196" id="h67-0-196" class="i">+// WithDeadline(parent, d) is semantically equivalent to parent.  The returned
</a><a href="#h67-0-197" id="h67-0-197" class="i">+// context&#39;s Done channel is closed when the deadline expires, when the returned
</a><a href="#h67-0-198" id="h67-0-198" class="i">+// cancel function is called, or when the parent context&#39;s Done channel is
</a><a href="#h67-0-199" id="h67-0-199" class="i">+// closed, whichever happens first.
</a><a href="#h67-0-200" id="h67-0-200" class="i">+//
</a><a href="#h67-0-201" id="h67-0-201" class="i">+// Canceling this context releases resources associated with it, so code should
</a><a href="#h67-0-202" id="h67-0-202" class="i">+// call cancel as soon as the operations running in this Context complete.
</a><a href="#h67-0-203" id="h67-0-203" class="i">+func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
</a><a href="#h67-0-204" id="h67-0-204" class="i">+	if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) {
</a><a href="#h67-0-205" id="h67-0-205" class="i">+		// The current deadline is already sooner than the new one.
</a><a href="#h67-0-206" id="h67-0-206" class="i">+		return WithCancel(parent)
</a><a href="#h67-0-207" id="h67-0-207" class="i">+	}
</a><a href="#h67-0-208" id="h67-0-208" class="i">+	c := &amp;timerCtx{
</a><a href="#h67-0-209" id="h67-0-209" class="i">+		cancelCtx: newCancelCtx(parent),
</a><a href="#h67-0-210" id="h67-0-210" class="i">+		deadline:  deadline,
</a><a href="#h67-0-211" id="h67-0-211" class="i">+	}
</a><a href="#h67-0-212" id="h67-0-212" class="i">+	propagateCancel(parent, c)
</a><a href="#h67-0-213" id="h67-0-213" class="i">+	d := deadline.Sub(time.Now())
</a><a href="#h67-0-214" id="h67-0-214" class="i">+	if d &lt;= 0 {
</a><a href="#h67-0-215" id="h67-0-215" class="i">+		c.cancel(true, DeadlineExceeded) // deadline has already passed
</a><a href="#h67-0-216" id="h67-0-216" class="i">+		return c, func() { c.cancel(true, Canceled) }
</a><a href="#h67-0-217" id="h67-0-217" class="i">+	}
</a><a href="#h67-0-218" id="h67-0-218" class="i">+	c.mu.Lock()
</a><a href="#h67-0-219" id="h67-0-219" class="i">+	defer c.mu.Unlock()
</a><a href="#h67-0-220" id="h67-0-220" class="i">+	if c.err == nil {
</a><a href="#h67-0-221" id="h67-0-221" class="i">+		c.timer = time.AfterFunc(d, func() {
</a><a href="#h67-0-222" id="h67-0-222" class="i">+			c.cancel(true, DeadlineExceeded)
</a><a href="#h67-0-223" id="h67-0-223" class="i">+		})
</a><a href="#h67-0-224" id="h67-0-224" class="i">+	}
</a><a href="#h67-0-225" id="h67-0-225" class="i">+	return c, func() { c.cancel(true, Canceled) }
</a><a href="#h67-0-226" id="h67-0-226" class="i">+}
</a><a href="#h67-0-227" id="h67-0-227" class="i">+
</a><a href="#h67-0-228" id="h67-0-228" class="i">+// A timerCtx carries a timer and a deadline.  It embeds a cancelCtx to
</a><a href="#h67-0-229" id="h67-0-229" class="i">+// implement Done and Err.  It implements cancel by stopping its timer then
</a><a href="#h67-0-230" id="h67-0-230" class="i">+// delegating to cancelCtx.cancel.
</a><a href="#h67-0-231" id="h67-0-231" class="i">+type timerCtx struct {
</a><a href="#h67-0-232" id="h67-0-232" class="i">+	*cancelCtx
</a><a href="#h67-0-233" id="h67-0-233" class="i">+	timer *time.Timer // Under cancelCtx.mu.
</a><a href="#h67-0-234" id="h67-0-234" class="i">+
</a><a href="#h67-0-235" id="h67-0-235" class="i">+	deadline time.Time
</a><a href="#h67-0-236" id="h67-0-236" class="i">+}
</a><a href="#h67-0-237" id="h67-0-237" class="i">+
</a><a href="#h67-0-238" id="h67-0-238" class="i">+func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {
</a><a href="#h67-0-239" id="h67-0-239" class="i">+	return c.deadline, true
</a><a href="#h67-0-240" id="h67-0-240" class="i">+}
</a><a href="#h67-0-241" id="h67-0-241" class="i">+
</a><a href="#h67-0-242" id="h67-0-242" class="i">+func (c *timerCtx) String() string {
</a><a href="#h67-0-243" id="h67-0-243" class="i">+	return fmt.Sprintf(&quot;%v.WithDeadline(%s [%s])&quot;, c.cancelCtx.Context, c.deadline, c.deadline.Sub(time.Now()))
</a><a href="#h67-0-244" id="h67-0-244" class="i">+}
</a><a href="#h67-0-245" id="h67-0-245" class="i">+
</a><a href="#h67-0-246" id="h67-0-246" class="i">+func (c *timerCtx) cancel(removeFromParent bool, err error) {
</a><a href="#h67-0-247" id="h67-0-247" class="i">+	c.cancelCtx.cancel(false, err)
</a><a href="#h67-0-248" id="h67-0-248" class="i">+	if removeFromParent {
</a><a href="#h67-0-249" id="h67-0-249" class="i">+		// Remove this timerCtx from its parent cancelCtx&#39;s children.
</a><a href="#h67-0-250" id="h67-0-250" class="i">+		removeChild(c.cancelCtx.Context, c)
</a><a href="#h67-0-251" id="h67-0-251" class="i">+	}
</a><a href="#h67-0-252" id="h67-0-252" class="i">+	c.mu.Lock()
</a><a href="#h67-0-253" id="h67-0-253" class="i">+	if c.timer != nil {
</a><a href="#h67-0-254" id="h67-0-254" class="i">+		c.timer.Stop()
</a><a href="#h67-0-255" id="h67-0-255" class="i">+		c.timer = nil
</a><a href="#h67-0-256" id="h67-0-256" class="i">+	}
</a><a href="#h67-0-257" id="h67-0-257" class="i">+	c.mu.Unlock()
</a><a href="#h67-0-258" id="h67-0-258" class="i">+}
</a><a href="#h67-0-259" id="h67-0-259" class="i">+
</a><a href="#h67-0-260" id="h67-0-260" class="i">+// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
</a><a href="#h67-0-261" id="h67-0-261" class="i">+//
</a><a href="#h67-0-262" id="h67-0-262" class="i">+// Canceling this context releases resources associated with it, so code should
</a><a href="#h67-0-263" id="h67-0-263" class="i">+// call cancel as soon as the operations running in this Context complete:
</a><a href="#h67-0-264" id="h67-0-264" class="i">+//
</a><a href="#h67-0-265" id="h67-0-265" class="i">+// 	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
</a><a href="#h67-0-266" id="h67-0-266" class="i">+// 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
</a><a href="#h67-0-267" id="h67-0-267" class="i">+// 		defer cancel()  // releases resources if slowOperation completes before timeout elapses
</a><a href="#h67-0-268" id="h67-0-268" class="i">+// 		return slowOperation(ctx)
</a><a href="#h67-0-269" id="h67-0-269" class="i">+// 	}
</a><a href="#h67-0-270" id="h67-0-270" class="i">+func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
</a><a href="#h67-0-271" id="h67-0-271" class="i">+	return WithDeadline(parent, time.Now().Add(timeout))
</a><a href="#h67-0-272" id="h67-0-272" class="i">+}
</a><a href="#h67-0-273" id="h67-0-273" class="i">+
</a><a href="#h67-0-274" id="h67-0-274" class="i">+// WithValue returns a copy of parent in which the value associated with key is
</a><a href="#h67-0-275" id="h67-0-275" class="i">+// val.
</a><a href="#h67-0-276" id="h67-0-276" class="i">+//
</a><a href="#h67-0-277" id="h67-0-277" class="i">+// Use context Values only for request-scoped data that transits processes and
</a><a href="#h67-0-278" id="h67-0-278" class="i">+// APIs, not for passing optional parameters to functions.
</a><a href="#h67-0-279" id="h67-0-279" class="i">+func WithValue(parent Context, key interface{}, val interface{}) Context {
</a><a href="#h67-0-280" id="h67-0-280" class="i">+	return &amp;valueCtx{parent, key, val}
</a><a href="#h67-0-281" id="h67-0-281" class="i">+}
</a><a href="#h67-0-282" id="h67-0-282" class="i">+
</a><a href="#h67-0-283" id="h67-0-283" class="i">+// A valueCtx carries a key-value pair.  It implements Value for that key and
</a><a href="#h67-0-284" id="h67-0-284" class="i">+// delegates all other calls to the embedded Context.
</a><a href="#h67-0-285" id="h67-0-285" class="i">+type valueCtx struct {
</a><a href="#h67-0-286" id="h67-0-286" class="i">+	Context
</a><a href="#h67-0-287" id="h67-0-287" class="i">+	key, val interface{}
</a><a href="#h67-0-288" id="h67-0-288" class="i">+}
</a><a href="#h67-0-289" id="h67-0-289" class="i">+
</a><a href="#h67-0-290" id="h67-0-290" class="i">+func (c *valueCtx) String() string {
</a><a href="#h67-0-291" id="h67-0-291" class="i">+	return fmt.Sprintf(&quot;%v.WithValue(%#v, %#v)&quot;, c.Context, c.key, c.val)
</a><a href="#h67-0-292" id="h67-0-292" class="i">+}
</a><a href="#h67-0-293" id="h67-0-293" class="i">+
</a><a href="#h67-0-294" id="h67-0-294" class="i">+func (c *valueCtx) Value(key interface{}) interface{} {
</a><a href="#h67-0-295" id="h67-0-295" class="i">+	if c.key == key {
</a><a href="#h67-0-296" id="h67-0-296" class="i">+		return c.val
</a><a href="#h67-0-297" id="h67-0-297" class="i">+	}
</a><a href="#h67-0-298" id="h67-0-298" class="i">+	return c.Context.Value(key)
</a><a href="#h67-0-299" id="h67-0-299" class="i">+}
</a><b>diff --git a/<a id="h68" href="../file/vendor/golang.org/x/oauth2/AUTHORS">vendor/golang.org/x/oauth2/AUTHORS</a> b/<a href="../file/vendor/golang.org/x/oauth2/AUTHORS">vendor/golang.org/x/oauth2/AUTHORS</a></b>
<a href="#h68-0" id="h68-0" class="h">@@ -0,0 +1,3 @@
</a><a href="#h68-0-0" id="h68-0-0" class="i">+# This source code refers to The Go Authors for copyright purposes.
</a><a href="#h68-0-1" id="h68-0-1" class="i">+# The master list of authors is in the main Go distribution,
</a><a href="#h68-0-2" id="h68-0-2" class="i">+# visible at http://tip.golang.org/AUTHORS.
</a><b>diff --git a/<a id="h69" href="../file/vendor/golang.org/x/oauth2/CONTRIBUTING.md">vendor/golang.org/x/oauth2/CONTRIBUTING.md</a> b/<a href="../file/vendor/golang.org/x/oauth2/CONTRIBUTING.md">vendor/golang.org/x/oauth2/CONTRIBUTING.md</a></b>
<a href="#h69-0" id="h69-0" class="h">@@ -0,0 +1,31 @@
</a><a href="#h69-0-0" id="h69-0-0" class="i">+# Contributing to Go
</a><a href="#h69-0-1" id="h69-0-1" class="i">+
</a><a href="#h69-0-2" id="h69-0-2" class="i">+Go is an open source project.
</a><a href="#h69-0-3" id="h69-0-3" class="i">+
</a><a href="#h69-0-4" id="h69-0-4" class="i">+It is the work of hundreds of contributors. We appreciate your help!
</a><a href="#h69-0-5" id="h69-0-5" class="i">+
</a><a href="#h69-0-6" id="h69-0-6" class="i">+
</a><a href="#h69-0-7" id="h69-0-7" class="i">+## Filing issues
</a><a href="#h69-0-8" id="h69-0-8" class="i">+
</a><a href="#h69-0-9" id="h69-0-9" class="i">+When [filing an issue](https://github.com/golang/oauth2/issues), make sure to answer these five questions:
</a><a href="#h69-0-10" id="h69-0-10" class="i">+
</a><a href="#h69-0-11" id="h69-0-11" class="i">+1. What version of Go are you using (`go version`)?
</a><a href="#h69-0-12" id="h69-0-12" class="i">+2. What operating system and processor architecture are you using?
</a><a href="#h69-0-13" id="h69-0-13" class="i">+3. What did you do?
</a><a href="#h69-0-14" id="h69-0-14" class="i">+4. What did you expect to see?
</a><a href="#h69-0-15" id="h69-0-15" class="i">+5. What did you see instead?
</a><a href="#h69-0-16" id="h69-0-16" class="i">+
</a><a href="#h69-0-17" id="h69-0-17" class="i">+General questions should go to the [golang-nuts mailing list](https://groups.google.com/group/golang-nuts) instead of the issue tracker.
</a><a href="#h69-0-18" id="h69-0-18" class="i">+The gophers there will answer or ask you to file an issue if you&#39;ve tripped over a bug.
</a><a href="#h69-0-19" id="h69-0-19" class="i">+
</a><a href="#h69-0-20" id="h69-0-20" class="i">+## Contributing code
</a><a href="#h69-0-21" id="h69-0-21" class="i">+
</a><a href="#h69-0-22" id="h69-0-22" class="i">+Please read the [Contribution Guidelines](https://golang.org/doc/contribute.html)
</a><a href="#h69-0-23" id="h69-0-23" class="i">+before sending patches.
</a><a href="#h69-0-24" id="h69-0-24" class="i">+
</a><a href="#h69-0-25" id="h69-0-25" class="i">+**We do not accept GitHub pull requests**
</a><a href="#h69-0-26" id="h69-0-26" class="i">+(we use [Gerrit](https://code.google.com/p/gerrit/) instead for code review).
</a><a href="#h69-0-27" id="h69-0-27" class="i">+
</a><a href="#h69-0-28" id="h69-0-28" class="i">+Unless otherwise noted, the Go source files are distributed under
</a><a href="#h69-0-29" id="h69-0-29" class="i">+the BSD-style license found in the LICENSE file.
</a><a href="#h69-0-30" id="h69-0-30" class="i">+
</a><b>diff --git a/<a id="h70" href="../file/vendor/golang.org/x/oauth2/CONTRIBUTORS">vendor/golang.org/x/oauth2/CONTRIBUTORS</a> b/<a href="../file/vendor/golang.org/x/oauth2/CONTRIBUTORS">vendor/golang.org/x/oauth2/CONTRIBUTORS</a></b>
<a href="#h70-0" id="h70-0" class="h">@@ -0,0 +1,3 @@
</a><a href="#h70-0-0" id="h70-0-0" class="i">+# This source code was written by the Go contributors.
</a><a href="#h70-0-1" id="h70-0-1" class="i">+# The master list of contributors is in the main Go distribution,
</a><a href="#h70-0-2" id="h70-0-2" class="i">+# visible at http://tip.golang.org/CONTRIBUTORS.
</a><b>diff --git a/<a id="h71" href="../file/vendor/golang.org/x/oauth2/LICENSE">vendor/golang.org/x/oauth2/LICENSE</a> b/<a href="../file/vendor/golang.org/x/oauth2/LICENSE">vendor/golang.org/x/oauth2/LICENSE</a></b>
<a href="#h71-0" id="h71-0" class="h">@@ -0,0 +1,27 @@
</a><a href="#h71-0-0" id="h71-0-0" class="i">+Copyright (c) 2009 The oauth2 Authors. All rights reserved.
</a><a href="#h71-0-1" id="h71-0-1" class="i">+
</a><a href="#h71-0-2" id="h71-0-2" class="i">+Redistribution and use in source and binary forms, with or without
</a><a href="#h71-0-3" id="h71-0-3" class="i">+modification, are permitted provided that the following conditions are
</a><a href="#h71-0-4" id="h71-0-4" class="i">+met:
</a><a href="#h71-0-5" id="h71-0-5" class="i">+
</a><a href="#h71-0-6" id="h71-0-6" class="i">+   * Redistributions of source code must retain the above copyright
</a><a href="#h71-0-7" id="h71-0-7" class="i">+notice, this list of conditions and the following disclaimer.
</a><a href="#h71-0-8" id="h71-0-8" class="i">+   * Redistributions in binary form must reproduce the above
</a><a href="#h71-0-9" id="h71-0-9" class="i">+copyright notice, this list of conditions and the following disclaimer
</a><a href="#h71-0-10" id="h71-0-10" class="i">+in the documentation and/or other materials provided with the
</a><a href="#h71-0-11" id="h71-0-11" class="i">+distribution.
</a><a href="#h71-0-12" id="h71-0-12" class="i">+   * Neither the name of Google Inc. nor the names of its
</a><a href="#h71-0-13" id="h71-0-13" class="i">+contributors may be used to endorse or promote products derived from
</a><a href="#h71-0-14" id="h71-0-14" class="i">+this software without specific prior written permission.
</a><a href="#h71-0-15" id="h71-0-15" class="i">+
</a><a href="#h71-0-16" id="h71-0-16" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h71-0-17" id="h71-0-17" class="i">+&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h71-0-18" id="h71-0-18" class="i">+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h71-0-19" id="h71-0-19" class="i">+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h71-0-20" id="h71-0-20" class="i">+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h71-0-21" id="h71-0-21" class="i">+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h71-0-22" id="h71-0-22" class="i">+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h71-0-23" id="h71-0-23" class="i">+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h71-0-24" id="h71-0-24" class="i">+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h71-0-25" id="h71-0-25" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h71-0-26" id="h71-0-26" class="i">+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><b>diff --git a/<a id="h72" href="../file/vendor/golang.org/x/oauth2/README.md">vendor/golang.org/x/oauth2/README.md</a> b/<a href="../file/vendor/golang.org/x/oauth2/README.md">vendor/golang.org/x/oauth2/README.md</a></b>
<a href="#h72-0" id="h72-0" class="h">@@ -0,0 +1,64 @@
</a><a href="#h72-0-0" id="h72-0-0" class="i">+# OAuth2 for Go
</a><a href="#h72-0-1" id="h72-0-1" class="i">+
</a><a href="#h72-0-2" id="h72-0-2" class="i">+[![Build Status](https://travis-ci.org/golang/oauth2.svg?branch=master)](https://travis-ci.org/golang/oauth2)
</a><a href="#h72-0-3" id="h72-0-3" class="i">+
</a><a href="#h72-0-4" id="h72-0-4" class="i">+oauth2 package contains a client implementation for OAuth 2.0 spec.
</a><a href="#h72-0-5" id="h72-0-5" class="i">+
</a><a href="#h72-0-6" id="h72-0-6" class="i">+## Installation
</a><a href="#h72-0-7" id="h72-0-7" class="i">+
</a><a href="#h72-0-8" id="h72-0-8" class="i">+~~~~
</a><a href="#h72-0-9" id="h72-0-9" class="i">+go get golang.org/x/oauth2
</a><a href="#h72-0-10" id="h72-0-10" class="i">+~~~~
</a><a href="#h72-0-11" id="h72-0-11" class="i">+
</a><a href="#h72-0-12" id="h72-0-12" class="i">+See godoc for further documentation and examples.
</a><a href="#h72-0-13" id="h72-0-13" class="i">+
</a><a href="#h72-0-14" id="h72-0-14" class="i">+* [godoc.org/golang.org/x/oauth2](http://godoc.org/golang.org/x/oauth2)
</a><a href="#h72-0-15" id="h72-0-15" class="i">+* [godoc.org/golang.org/x/oauth2/google](http://godoc.org/golang.org/x/oauth2/google)
</a><a href="#h72-0-16" id="h72-0-16" class="i">+
</a><a href="#h72-0-17" id="h72-0-17" class="i">+
</a><a href="#h72-0-18" id="h72-0-18" class="i">+## App Engine
</a><a href="#h72-0-19" id="h72-0-19" class="i">+
</a><a href="#h72-0-20" id="h72-0-20" class="i">+In change 96e89be (March 2015) we removed the `oauth2.Context2` type in favor
</a><a href="#h72-0-21" id="h72-0-21" class="i">+of the [`context.Context`](https://golang.org/x/net/context#Context) type from
</a><a href="#h72-0-22" id="h72-0-22" class="i">+the `golang.org/x/net/context` package
</a><a href="#h72-0-23" id="h72-0-23" class="i">+
</a><a href="#h72-0-24" id="h72-0-24" class="i">+This means its no longer possible to use the &quot;Classic App Engine&quot;
</a><a href="#h72-0-25" id="h72-0-25" class="i">+`appengine.Context` type with the `oauth2` package. (You&#39;re using
</a><a href="#h72-0-26" id="h72-0-26" class="i">+Classic App Engine if you import the package `&quot;appengine&quot;`.)
</a><a href="#h72-0-27" id="h72-0-27" class="i">+
</a><a href="#h72-0-28" id="h72-0-28" class="i">+To work around this, you may use the new `&quot;google.golang.org/appengine&quot;`
</a><a href="#h72-0-29" id="h72-0-29" class="i">+package. This package has almost the same API as the `&quot;appengine&quot;` package,
</a><a href="#h72-0-30" id="h72-0-30" class="i">+but it can be fetched with `go get` and used on &quot;Managed VMs&quot; and well as
</a><a href="#h72-0-31" id="h72-0-31" class="i">+Classic App Engine.
</a><a href="#h72-0-32" id="h72-0-32" class="i">+
</a><a href="#h72-0-33" id="h72-0-33" class="i">+See the [new `appengine` package&#39;s readme](https://github.com/golang/appengine#updating-a-go-app-engine-app)
</a><a href="#h72-0-34" id="h72-0-34" class="i">+for information on updating your app.
</a><a href="#h72-0-35" id="h72-0-35" class="i">+
</a><a href="#h72-0-36" id="h72-0-36" class="i">+If you don&#39;t want to update your entire app to use the new App Engine packages,
</a><a href="#h72-0-37" id="h72-0-37" class="i">+you may use both sets of packages in parallel, using only the new packages
</a><a href="#h72-0-38" id="h72-0-38" class="i">+with the `oauth2` package.
</a><a href="#h72-0-39" id="h72-0-39" class="i">+
</a><a href="#h72-0-40" id="h72-0-40" class="i">+	import (
</a><a href="#h72-0-41" id="h72-0-41" class="i">+		&quot;golang.org/x/net/context&quot;
</a><a href="#h72-0-42" id="h72-0-42" class="i">+		&quot;golang.org/x/oauth2&quot;
</a><a href="#h72-0-43" id="h72-0-43" class="i">+		&quot;golang.org/x/oauth2/google&quot;
</a><a href="#h72-0-44" id="h72-0-44" class="i">+		newappengine &quot;google.golang.org/appengine&quot;
</a><a href="#h72-0-45" id="h72-0-45" class="i">+		newurlfetch &quot;google.golang.org/appengine/urlfetch&quot;
</a><a href="#h72-0-46" id="h72-0-46" class="i">+
</a><a href="#h72-0-47" id="h72-0-47" class="i">+		&quot;appengine&quot;
</a><a href="#h72-0-48" id="h72-0-48" class="i">+	)
</a><a href="#h72-0-49" id="h72-0-49" class="i">+
</a><a href="#h72-0-50" id="h72-0-50" class="i">+	func handler(w http.ResponseWriter, r *http.Request) {
</a><a href="#h72-0-51" id="h72-0-51" class="i">+		var c appengine.Context = appengine.NewContext(r)
</a><a href="#h72-0-52" id="h72-0-52" class="i">+		c.Infof(&quot;Logging a message with the old package&quot;)
</a><a href="#h72-0-53" id="h72-0-53" class="i">+
</a><a href="#h72-0-54" id="h72-0-54" class="i">+		var ctx context.Context = newappengine.NewContext(r)
</a><a href="#h72-0-55" id="h72-0-55" class="i">+		client := &amp;http.Client{
</a><a href="#h72-0-56" id="h72-0-56" class="i">+			Transport: &amp;oauth2.Transport{
</a><a href="#h72-0-57" id="h72-0-57" class="i">+				Source: google.AppEngineTokenSource(ctx, &quot;scope&quot;),
</a><a href="#h72-0-58" id="h72-0-58" class="i">+				Base:   &amp;newurlfetch.Transport{Context: ctx},
</a><a href="#h72-0-59" id="h72-0-59" class="i">+			},
</a><a href="#h72-0-60" id="h72-0-60" class="i">+		}
</a><a href="#h72-0-61" id="h72-0-61" class="i">+		client.Get(&quot;...&quot;)
</a><a href="#h72-0-62" id="h72-0-62" class="i">+	}
</a><a href="#h72-0-63" id="h72-0-63" class="i">+
</a><b>diff --git a/<a id="h73" href="../file/vendor/golang.org/x/oauth2/client_appengine.go">vendor/golang.org/x/oauth2/client_appengine.go</a> b/<a href="../file/vendor/golang.org/x/oauth2/client_appengine.go">vendor/golang.org/x/oauth2/client_appengine.go</a></b>
<a href="#h73-0" id="h73-0" class="h">@@ -0,0 +1,25 @@
</a><a href="#h73-0-0" id="h73-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h73-0-1" id="h73-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h73-0-2" id="h73-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h73-0-3" id="h73-0-3" class="i">+
</a><a href="#h73-0-4" id="h73-0-4" class="i">+// +build appengine
</a><a href="#h73-0-5" id="h73-0-5" class="i">+
</a><a href="#h73-0-6" id="h73-0-6" class="i">+// App Engine hooks.
</a><a href="#h73-0-7" id="h73-0-7" class="i">+
</a><a href="#h73-0-8" id="h73-0-8" class="i">+package oauth2
</a><a href="#h73-0-9" id="h73-0-9" class="i">+
</a><a href="#h73-0-10" id="h73-0-10" class="i">+import (
</a><a href="#h73-0-11" id="h73-0-11" class="i">+	&quot;net/http&quot;
</a><a href="#h73-0-12" id="h73-0-12" class="i">+
</a><a href="#h73-0-13" id="h73-0-13" class="i">+	&quot;golang.org/x/net/context&quot;
</a><a href="#h73-0-14" id="h73-0-14" class="i">+	&quot;golang.org/x/oauth2/internal&quot;
</a><a href="#h73-0-15" id="h73-0-15" class="i">+	&quot;google.golang.org/appengine/urlfetch&quot;
</a><a href="#h73-0-16" id="h73-0-16" class="i">+)
</a><a href="#h73-0-17" id="h73-0-17" class="i">+
</a><a href="#h73-0-18" id="h73-0-18" class="i">+func init() {
</a><a href="#h73-0-19" id="h73-0-19" class="i">+	internal.RegisterContextClientFunc(contextClientAppEngine)
</a><a href="#h73-0-20" id="h73-0-20" class="i">+}
</a><a href="#h73-0-21" id="h73-0-21" class="i">+
</a><a href="#h73-0-22" id="h73-0-22" class="i">+func contextClientAppEngine(ctx context.Context) (*http.Client, error) {
</a><a href="#h73-0-23" id="h73-0-23" class="i">+	return urlfetch.Client(ctx), nil
</a><a href="#h73-0-24" id="h73-0-24" class="i">+}
</a><b>diff --git a/<a id="h74" href="../file/vendor/golang.org/x/oauth2/internal/oauth2.go">vendor/golang.org/x/oauth2/internal/oauth2.go</a> b/<a href="../file/vendor/golang.org/x/oauth2/internal/oauth2.go">vendor/golang.org/x/oauth2/internal/oauth2.go</a></b>
<a href="#h74-0" id="h74-0" class="h">@@ -0,0 +1,76 @@
</a><a href="#h74-0-0" id="h74-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h74-0-1" id="h74-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h74-0-2" id="h74-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h74-0-3" id="h74-0-3" class="i">+
</a><a href="#h74-0-4" id="h74-0-4" class="i">+// Package internal contains support packages for oauth2 package.
</a><a href="#h74-0-5" id="h74-0-5" class="i">+package internal
</a><a href="#h74-0-6" id="h74-0-6" class="i">+
</a><a href="#h74-0-7" id="h74-0-7" class="i">+import (
</a><a href="#h74-0-8" id="h74-0-8" class="i">+	&quot;bufio&quot;
</a><a href="#h74-0-9" id="h74-0-9" class="i">+	&quot;crypto/rsa&quot;
</a><a href="#h74-0-10" id="h74-0-10" class="i">+	&quot;crypto/x509&quot;
</a><a href="#h74-0-11" id="h74-0-11" class="i">+	&quot;encoding/pem&quot;
</a><a href="#h74-0-12" id="h74-0-12" class="i">+	&quot;errors&quot;
</a><a href="#h74-0-13" id="h74-0-13" class="i">+	&quot;fmt&quot;
</a><a href="#h74-0-14" id="h74-0-14" class="i">+	&quot;io&quot;
</a><a href="#h74-0-15" id="h74-0-15" class="i">+	&quot;strings&quot;
</a><a href="#h74-0-16" id="h74-0-16" class="i">+)
</a><a href="#h74-0-17" id="h74-0-17" class="i">+
</a><a href="#h74-0-18" id="h74-0-18" class="i">+// ParseKey converts the binary contents of a private key file
</a><a href="#h74-0-19" id="h74-0-19" class="i">+// to an *rsa.PrivateKey. It detects whether the private key is in a
</a><a href="#h74-0-20" id="h74-0-20" class="i">+// PEM container or not. If so, it extracts the the private key
</a><a href="#h74-0-21" id="h74-0-21" class="i">+// from PEM container before conversion. It only supports PEM
</a><a href="#h74-0-22" id="h74-0-22" class="i">+// containers with no passphrase.
</a><a href="#h74-0-23" id="h74-0-23" class="i">+func ParseKey(key []byte) (*rsa.PrivateKey, error) {
</a><a href="#h74-0-24" id="h74-0-24" class="i">+	block, _ := pem.Decode(key)
</a><a href="#h74-0-25" id="h74-0-25" class="i">+	if block != nil {
</a><a href="#h74-0-26" id="h74-0-26" class="i">+		key = block.Bytes
</a><a href="#h74-0-27" id="h74-0-27" class="i">+	}
</a><a href="#h74-0-28" id="h74-0-28" class="i">+	parsedKey, err := x509.ParsePKCS8PrivateKey(key)
</a><a href="#h74-0-29" id="h74-0-29" class="i">+	if err != nil {
</a><a href="#h74-0-30" id="h74-0-30" class="i">+		parsedKey, err = x509.ParsePKCS1PrivateKey(key)
</a><a href="#h74-0-31" id="h74-0-31" class="i">+		if err != nil {
</a><a href="#h74-0-32" id="h74-0-32" class="i">+			return nil, fmt.Errorf(&quot;private key should be a PEM or plain PKSC1 or PKCS8; parse error: %v&quot;, err)
</a><a href="#h74-0-33" id="h74-0-33" class="i">+		}
</a><a href="#h74-0-34" id="h74-0-34" class="i">+	}
</a><a href="#h74-0-35" id="h74-0-35" class="i">+	parsed, ok := parsedKey.(*rsa.PrivateKey)
</a><a href="#h74-0-36" id="h74-0-36" class="i">+	if !ok {
</a><a href="#h74-0-37" id="h74-0-37" class="i">+		return nil, errors.New(&quot;private key is invalid&quot;)
</a><a href="#h74-0-38" id="h74-0-38" class="i">+	}
</a><a href="#h74-0-39" id="h74-0-39" class="i">+	return parsed, nil
</a><a href="#h74-0-40" id="h74-0-40" class="i">+}
</a><a href="#h74-0-41" id="h74-0-41" class="i">+
</a><a href="#h74-0-42" id="h74-0-42" class="i">+func ParseINI(ini io.Reader) (map[string]map[string]string, error) {
</a><a href="#h74-0-43" id="h74-0-43" class="i">+	result := map[string]map[string]string{
</a><a href="#h74-0-44" id="h74-0-44" class="i">+		&quot;&quot;: map[string]string{}, // root section
</a><a href="#h74-0-45" id="h74-0-45" class="i">+	}
</a><a href="#h74-0-46" id="h74-0-46" class="i">+	scanner := bufio.NewScanner(ini)
</a><a href="#h74-0-47" id="h74-0-47" class="i">+	currentSection := &quot;&quot;
</a><a href="#h74-0-48" id="h74-0-48" class="i">+	for scanner.Scan() {
</a><a href="#h74-0-49" id="h74-0-49" class="i">+		line := strings.TrimSpace(scanner.Text())
</a><a href="#h74-0-50" id="h74-0-50" class="i">+		if strings.HasPrefix(line, &quot;;&quot;) {
</a><a href="#h74-0-51" id="h74-0-51" class="i">+			// comment.
</a><a href="#h74-0-52" id="h74-0-52" class="i">+			continue
</a><a href="#h74-0-53" id="h74-0-53" class="i">+		}
</a><a href="#h74-0-54" id="h74-0-54" class="i">+		if strings.HasPrefix(line, &quot;[&quot;) &amp;&amp; strings.HasSuffix(line, &quot;]&quot;) {
</a><a href="#h74-0-55" id="h74-0-55" class="i">+			currentSection = strings.TrimSpace(line[1 : len(line)-1])
</a><a href="#h74-0-56" id="h74-0-56" class="i">+			result[currentSection] = map[string]string{}
</a><a href="#h74-0-57" id="h74-0-57" class="i">+			continue
</a><a href="#h74-0-58" id="h74-0-58" class="i">+		}
</a><a href="#h74-0-59" id="h74-0-59" class="i">+		parts := strings.SplitN(line, &quot;=&quot;, 2)
</a><a href="#h74-0-60" id="h74-0-60" class="i">+		if len(parts) == 2 &amp;&amp; parts[0] != &quot;&quot; {
</a><a href="#h74-0-61" id="h74-0-61" class="i">+			result[currentSection][strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])
</a><a href="#h74-0-62" id="h74-0-62" class="i">+		}
</a><a href="#h74-0-63" id="h74-0-63" class="i">+	}
</a><a href="#h74-0-64" id="h74-0-64" class="i">+	if err := scanner.Err(); err != nil {
</a><a href="#h74-0-65" id="h74-0-65" class="i">+		return nil, fmt.Errorf(&quot;error scanning ini: %v&quot;, err)
</a><a href="#h74-0-66" id="h74-0-66" class="i">+	}
</a><a href="#h74-0-67" id="h74-0-67" class="i">+	return result, nil
</a><a href="#h74-0-68" id="h74-0-68" class="i">+}
</a><a href="#h74-0-69" id="h74-0-69" class="i">+
</a><a href="#h74-0-70" id="h74-0-70" class="i">+func CondVal(v string) []string {
</a><a href="#h74-0-71" id="h74-0-71" class="i">+	if v == &quot;&quot; {
</a><a href="#h74-0-72" id="h74-0-72" class="i">+		return nil
</a><a href="#h74-0-73" id="h74-0-73" class="i">+	}
</a><a href="#h74-0-74" id="h74-0-74" class="i">+	return []string{v}
</a><a href="#h74-0-75" id="h74-0-75" class="i">+}
</a><b>diff --git a/<a id="h75" href="../file/vendor/golang.org/x/oauth2/internal/token.go">vendor/golang.org/x/oauth2/internal/token.go</a> b/<a href="../file/vendor/golang.org/x/oauth2/internal/token.go">vendor/golang.org/x/oauth2/internal/token.go</a></b>
<a href="#h75-0" id="h75-0" class="h">@@ -0,0 +1,225 @@
</a><a href="#h75-0-0" id="h75-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h75-0-1" id="h75-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h75-0-2" id="h75-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h75-0-3" id="h75-0-3" class="i">+
</a><a href="#h75-0-4" id="h75-0-4" class="i">+// Package internal contains support packages for oauth2 package.
</a><a href="#h75-0-5" id="h75-0-5" class="i">+package internal
</a><a href="#h75-0-6" id="h75-0-6" class="i">+
</a><a href="#h75-0-7" id="h75-0-7" class="i">+import (
</a><a href="#h75-0-8" id="h75-0-8" class="i">+	&quot;encoding/json&quot;
</a><a href="#h75-0-9" id="h75-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h75-0-10" id="h75-0-10" class="i">+	&quot;io&quot;
</a><a href="#h75-0-11" id="h75-0-11" class="i">+	&quot;io/ioutil&quot;
</a><a href="#h75-0-12" id="h75-0-12" class="i">+	&quot;mime&quot;
</a><a href="#h75-0-13" id="h75-0-13" class="i">+	&quot;net/http&quot;
</a><a href="#h75-0-14" id="h75-0-14" class="i">+	&quot;net/url&quot;
</a><a href="#h75-0-15" id="h75-0-15" class="i">+	&quot;strconv&quot;
</a><a href="#h75-0-16" id="h75-0-16" class="i">+	&quot;strings&quot;
</a><a href="#h75-0-17" id="h75-0-17" class="i">+	&quot;time&quot;
</a><a href="#h75-0-18" id="h75-0-18" class="i">+
</a><a href="#h75-0-19" id="h75-0-19" class="i">+	&quot;golang.org/x/net/context&quot;
</a><a href="#h75-0-20" id="h75-0-20" class="i">+)
</a><a href="#h75-0-21" id="h75-0-21" class="i">+
</a><a href="#h75-0-22" id="h75-0-22" class="i">+// Token represents the crendentials used to authorize
</a><a href="#h75-0-23" id="h75-0-23" class="i">+// the requests to access protected resources on the OAuth 2.0
</a><a href="#h75-0-24" id="h75-0-24" class="i">+// provider&#39;s backend.
</a><a href="#h75-0-25" id="h75-0-25" class="i">+//
</a><a href="#h75-0-26" id="h75-0-26" class="i">+// This type is a mirror of oauth2.Token and exists to break
</a><a href="#h75-0-27" id="h75-0-27" class="i">+// an otherwise-circular dependency. Other internal packages
</a><a href="#h75-0-28" id="h75-0-28" class="i">+// should convert this Token into an oauth2.Token before use.
</a><a href="#h75-0-29" id="h75-0-29" class="i">+type Token struct {
</a><a href="#h75-0-30" id="h75-0-30" class="i">+	// AccessToken is the token that authorizes and authenticates
</a><a href="#h75-0-31" id="h75-0-31" class="i">+	// the requests.
</a><a href="#h75-0-32" id="h75-0-32" class="i">+	AccessToken string
</a><a href="#h75-0-33" id="h75-0-33" class="i">+
</a><a href="#h75-0-34" id="h75-0-34" class="i">+	// TokenType is the type of token.
</a><a href="#h75-0-35" id="h75-0-35" class="i">+	// The Type method returns either this or &quot;Bearer&quot;, the default.
</a><a href="#h75-0-36" id="h75-0-36" class="i">+	TokenType string
</a><a href="#h75-0-37" id="h75-0-37" class="i">+
</a><a href="#h75-0-38" id="h75-0-38" class="i">+	// RefreshToken is a token that&#39;s used by the application
</a><a href="#h75-0-39" id="h75-0-39" class="i">+	// (as opposed to the user) to refresh the access token
</a><a href="#h75-0-40" id="h75-0-40" class="i">+	// if it expires.
</a><a href="#h75-0-41" id="h75-0-41" class="i">+	RefreshToken string
</a><a href="#h75-0-42" id="h75-0-42" class="i">+
</a><a href="#h75-0-43" id="h75-0-43" class="i">+	// Expiry is the optional expiration time of the access token.
</a><a href="#h75-0-44" id="h75-0-44" class="i">+	//
</a><a href="#h75-0-45" id="h75-0-45" class="i">+	// If zero, TokenSource implementations will reuse the same
</a><a href="#h75-0-46" id="h75-0-46" class="i">+	// token forever and RefreshToken or equivalent
</a><a href="#h75-0-47" id="h75-0-47" class="i">+	// mechanisms for that TokenSource will not be used.
</a><a href="#h75-0-48" id="h75-0-48" class="i">+	Expiry time.Time
</a><a href="#h75-0-49" id="h75-0-49" class="i">+
</a><a href="#h75-0-50" id="h75-0-50" class="i">+	// Raw optionally contains extra metadata from the server
</a><a href="#h75-0-51" id="h75-0-51" class="i">+	// when updating a token.
</a><a href="#h75-0-52" id="h75-0-52" class="i">+	Raw interface{}
</a><a href="#h75-0-53" id="h75-0-53" class="i">+}
</a><a href="#h75-0-54" id="h75-0-54" class="i">+
</a><a href="#h75-0-55" id="h75-0-55" class="i">+// tokenJSON is the struct representing the HTTP response from OAuth2
</a><a href="#h75-0-56" id="h75-0-56" class="i">+// providers returning a token in JSON form.
</a><a href="#h75-0-57" id="h75-0-57" class="i">+type tokenJSON struct {
</a><a href="#h75-0-58" id="h75-0-58" class="i">+	AccessToken  string         `json:&quot;access_token&quot;`
</a><a href="#h75-0-59" id="h75-0-59" class="i">+	TokenType    string         `json:&quot;token_type&quot;`
</a><a href="#h75-0-60" id="h75-0-60" class="i">+	RefreshToken string         `json:&quot;refresh_token&quot;`
</a><a href="#h75-0-61" id="h75-0-61" class="i">+	ExpiresIn    expirationTime `json:&quot;expires_in&quot;` // at least PayPal returns string, while most return number
</a><a href="#h75-0-62" id="h75-0-62" class="i">+	Expires      expirationTime `json:&quot;expires&quot;`    // broken Facebook spelling of expires_in
</a><a href="#h75-0-63" id="h75-0-63" class="i">+}
</a><a href="#h75-0-64" id="h75-0-64" class="i">+
</a><a href="#h75-0-65" id="h75-0-65" class="i">+func (e *tokenJSON) expiry() (t time.Time) {
</a><a href="#h75-0-66" id="h75-0-66" class="i">+	if v := e.ExpiresIn; v != 0 {
</a><a href="#h75-0-67" id="h75-0-67" class="i">+		return time.Now().Add(time.Duration(v) * time.Second)
</a><a href="#h75-0-68" id="h75-0-68" class="i">+	}
</a><a href="#h75-0-69" id="h75-0-69" class="i">+	if v := e.Expires; v != 0 {
</a><a href="#h75-0-70" id="h75-0-70" class="i">+		return time.Now().Add(time.Duration(v) * time.Second)
</a><a href="#h75-0-71" id="h75-0-71" class="i">+	}
</a><a href="#h75-0-72" id="h75-0-72" class="i">+	return
</a><a href="#h75-0-73" id="h75-0-73" class="i">+}
</a><a href="#h75-0-74" id="h75-0-74" class="i">+
</a><a href="#h75-0-75" id="h75-0-75" class="i">+type expirationTime int32
</a><a href="#h75-0-76" id="h75-0-76" class="i">+
</a><a href="#h75-0-77" id="h75-0-77" class="i">+func (e *expirationTime) UnmarshalJSON(b []byte) error {
</a><a href="#h75-0-78" id="h75-0-78" class="i">+	var n json.Number
</a><a href="#h75-0-79" id="h75-0-79" class="i">+	err := json.Unmarshal(b, &amp;n)
</a><a href="#h75-0-80" id="h75-0-80" class="i">+	if err != nil {
</a><a href="#h75-0-81" id="h75-0-81" class="i">+		return err
</a><a href="#h75-0-82" id="h75-0-82" class="i">+	}
</a><a href="#h75-0-83" id="h75-0-83" class="i">+	i, err := n.Int64()
</a><a href="#h75-0-84" id="h75-0-84" class="i">+	if err != nil {
</a><a href="#h75-0-85" id="h75-0-85" class="i">+		return err
</a><a href="#h75-0-86" id="h75-0-86" class="i">+	}
</a><a href="#h75-0-87" id="h75-0-87" class="i">+	*e = expirationTime(i)
</a><a href="#h75-0-88" id="h75-0-88" class="i">+	return nil
</a><a href="#h75-0-89" id="h75-0-89" class="i">+}
</a><a href="#h75-0-90" id="h75-0-90" class="i">+
</a><a href="#h75-0-91" id="h75-0-91" class="i">+var brokenAuthHeaderProviders = []string{
</a><a href="#h75-0-92" id="h75-0-92" class="i">+	&quot;https://accounts.google.com/&quot;,
</a><a href="#h75-0-93" id="h75-0-93" class="i">+	&quot;https://api.dropbox.com/&quot;,
</a><a href="#h75-0-94" id="h75-0-94" class="i">+	&quot;https://api.dropboxapi.com/&quot;,
</a><a href="#h75-0-95" id="h75-0-95" class="i">+	&quot;https://api.instagram.com/&quot;,
</a><a href="#h75-0-96" id="h75-0-96" class="i">+	&quot;https://api.netatmo.net/&quot;,
</a><a href="#h75-0-97" id="h75-0-97" class="i">+	&quot;https://api.odnoklassniki.ru/&quot;,
</a><a href="#h75-0-98" id="h75-0-98" class="i">+	&quot;https://api.pushbullet.com/&quot;,
</a><a href="#h75-0-99" id="h75-0-99" class="i">+	&quot;https://api.soundcloud.com/&quot;,
</a><a href="#h75-0-100" id="h75-0-100" class="i">+	&quot;https://api.twitch.tv/&quot;,
</a><a href="#h75-0-101" id="h75-0-101" class="i">+	&quot;https://app.box.com/&quot;,
</a><a href="#h75-0-102" id="h75-0-102" class="i">+	&quot;https://connect.stripe.com/&quot;,
</a><a href="#h75-0-103" id="h75-0-103" class="i">+	&quot;https://login.microsoftonline.com/&quot;,
</a><a href="#h75-0-104" id="h75-0-104" class="i">+	&quot;https://login.salesforce.com/&quot;,
</a><a href="#h75-0-105" id="h75-0-105" class="i">+	&quot;https://oauth.sandbox.trainingpeaks.com/&quot;,
</a><a href="#h75-0-106" id="h75-0-106" class="i">+	&quot;https://oauth.trainingpeaks.com/&quot;,
</a><a href="#h75-0-107" id="h75-0-107" class="i">+	&quot;https://oauth.vk.com/&quot;,
</a><a href="#h75-0-108" id="h75-0-108" class="i">+	&quot;https://openapi.baidu.com/&quot;,
</a><a href="#h75-0-109" id="h75-0-109" class="i">+	&quot;https://slack.com/&quot;,
</a><a href="#h75-0-110" id="h75-0-110" class="i">+	&quot;https://test-sandbox.auth.corp.google.com&quot;,
</a><a href="#h75-0-111" id="h75-0-111" class="i">+	&quot;https://test.salesforce.com/&quot;,
</a><a href="#h75-0-112" id="h75-0-112" class="i">+	&quot;https://user.gini.net/&quot;,
</a><a href="#h75-0-113" id="h75-0-113" class="i">+	&quot;https://www.douban.com/&quot;,
</a><a href="#h75-0-114" id="h75-0-114" class="i">+	&quot;https://www.googleapis.com/&quot;,
</a><a href="#h75-0-115" id="h75-0-115" class="i">+	&quot;https://www.linkedin.com/&quot;,
</a><a href="#h75-0-116" id="h75-0-116" class="i">+	&quot;https://www.strava.com/oauth/&quot;,
</a><a href="#h75-0-117" id="h75-0-117" class="i">+	&quot;https://www.wunderlist.com/oauth/&quot;,
</a><a href="#h75-0-118" id="h75-0-118" class="i">+	&quot;https://api.patreon.com/&quot;,
</a><a href="#h75-0-119" id="h75-0-119" class="i">+}
</a><a href="#h75-0-120" id="h75-0-120" class="i">+
</a><a href="#h75-0-121" id="h75-0-121" class="i">+func RegisterBrokenAuthHeaderProvider(tokenURL string) {
</a><a href="#h75-0-122" id="h75-0-122" class="i">+	brokenAuthHeaderProviders = append(brokenAuthHeaderProviders, tokenURL)
</a><a href="#h75-0-123" id="h75-0-123" class="i">+}
</a><a href="#h75-0-124" id="h75-0-124" class="i">+
</a><a href="#h75-0-125" id="h75-0-125" class="i">+// providerAuthHeaderWorks reports whether the OAuth2 server identified by the tokenURL
</a><a href="#h75-0-126" id="h75-0-126" class="i">+// implements the OAuth2 spec correctly
</a><a href="#h75-0-127" id="h75-0-127" class="i">+// See https://code.google.com/p/goauth2/issues/detail?id=31 for background.
</a><a href="#h75-0-128" id="h75-0-128" class="i">+// In summary:
</a><a href="#h75-0-129" id="h75-0-129" class="i">+// - Reddit only accepts client secret in the Authorization header
</a><a href="#h75-0-130" id="h75-0-130" class="i">+// - Dropbox accepts either it in URL param or Auth header, but not both.
</a><a href="#h75-0-131" id="h75-0-131" class="i">+// - Google only accepts URL param (not spec compliant?), not Auth header
</a><a href="#h75-0-132" id="h75-0-132" class="i">+// - Stripe only accepts client secret in Auth header with Bearer method, not Basic
</a><a href="#h75-0-133" id="h75-0-133" class="i">+func providerAuthHeaderWorks(tokenURL string) bool {
</a><a href="#h75-0-134" id="h75-0-134" class="i">+	for _, s := range brokenAuthHeaderProviders {
</a><a href="#h75-0-135" id="h75-0-135" class="i">+		if strings.HasPrefix(tokenURL, s) {
</a><a href="#h75-0-136" id="h75-0-136" class="i">+			// Some sites fail to implement the OAuth2 spec fully.
</a><a href="#h75-0-137" id="h75-0-137" class="i">+			return false
</a><a href="#h75-0-138" id="h75-0-138" class="i">+		}
</a><a href="#h75-0-139" id="h75-0-139" class="i">+	}
</a><a href="#h75-0-140" id="h75-0-140" class="i">+
</a><a href="#h75-0-141" id="h75-0-141" class="i">+	// Assume the provider implements the spec properly
</a><a href="#h75-0-142" id="h75-0-142" class="i">+	// otherwise. We can add more exceptions as they&#39;re
</a><a href="#h75-0-143" id="h75-0-143" class="i">+	// discovered. We will _not_ be adding configurable hooks
</a><a href="#h75-0-144" id="h75-0-144" class="i">+	// to this package to let users select server bugs.
</a><a href="#h75-0-145" id="h75-0-145" class="i">+	return true
</a><a href="#h75-0-146" id="h75-0-146" class="i">+}
</a><a href="#h75-0-147" id="h75-0-147" class="i">+
</a><a href="#h75-0-148" id="h75-0-148" class="i">+func RetrieveToken(ctx context.Context, ClientID, ClientSecret, TokenURL string, v url.Values) (*Token, error) {
</a><a href="#h75-0-149" id="h75-0-149" class="i">+	hc, err := ContextClient(ctx)
</a><a href="#h75-0-150" id="h75-0-150" class="i">+	if err != nil {
</a><a href="#h75-0-151" id="h75-0-151" class="i">+		return nil, err
</a><a href="#h75-0-152" id="h75-0-152" class="i">+	}
</a><a href="#h75-0-153" id="h75-0-153" class="i">+	v.Set(&quot;client_id&quot;, ClientID)
</a><a href="#h75-0-154" id="h75-0-154" class="i">+	bustedAuth := !providerAuthHeaderWorks(TokenURL)
</a><a href="#h75-0-155" id="h75-0-155" class="i">+	if bustedAuth &amp;&amp; ClientSecret != &quot;&quot; {
</a><a href="#h75-0-156" id="h75-0-156" class="i">+		v.Set(&quot;client_secret&quot;, ClientSecret)
</a><a href="#h75-0-157" id="h75-0-157" class="i">+	}
</a><a href="#h75-0-158" id="h75-0-158" class="i">+	req, err := http.NewRequest(&quot;POST&quot;, TokenURL, strings.NewReader(v.Encode()))
</a><a href="#h75-0-159" id="h75-0-159" class="i">+	if err != nil {
</a><a href="#h75-0-160" id="h75-0-160" class="i">+		return nil, err
</a><a href="#h75-0-161" id="h75-0-161" class="i">+	}
</a><a href="#h75-0-162" id="h75-0-162" class="i">+	req.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)
</a><a href="#h75-0-163" id="h75-0-163" class="i">+	if !bustedAuth {
</a><a href="#h75-0-164" id="h75-0-164" class="i">+		req.SetBasicAuth(ClientID, ClientSecret)
</a><a href="#h75-0-165" id="h75-0-165" class="i">+	}
</a><a href="#h75-0-166" id="h75-0-166" class="i">+	r, err := hc.Do(req)
</a><a href="#h75-0-167" id="h75-0-167" class="i">+	if err != nil {
</a><a href="#h75-0-168" id="h75-0-168" class="i">+		return nil, err
</a><a href="#h75-0-169" id="h75-0-169" class="i">+	}
</a><a href="#h75-0-170" id="h75-0-170" class="i">+	defer r.Body.Close()
</a><a href="#h75-0-171" id="h75-0-171" class="i">+	body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1&lt;&lt;20))
</a><a href="#h75-0-172" id="h75-0-172" class="i">+	if err != nil {
</a><a href="#h75-0-173" id="h75-0-173" class="i">+		return nil, fmt.Errorf(&quot;oauth2: cannot fetch token: %v&quot;, err)
</a><a href="#h75-0-174" id="h75-0-174" class="i">+	}
</a><a href="#h75-0-175" id="h75-0-175" class="i">+	if code := r.StatusCode; code &lt; 200 || code &gt; 299 {
</a><a href="#h75-0-176" id="h75-0-176" class="i">+		return nil, fmt.Errorf(&quot;oauth2: cannot fetch token: %v\nResponse: %s&quot;, r.Status, body)
</a><a href="#h75-0-177" id="h75-0-177" class="i">+	}
</a><a href="#h75-0-178" id="h75-0-178" class="i">+
</a><a href="#h75-0-179" id="h75-0-179" class="i">+	var token *Token
</a><a href="#h75-0-180" id="h75-0-180" class="i">+	content, _, _ := mime.ParseMediaType(r.Header.Get(&quot;Content-Type&quot;))
</a><a href="#h75-0-181" id="h75-0-181" class="i">+	switch content {
</a><a href="#h75-0-182" id="h75-0-182" class="i">+	case &quot;application/x-www-form-urlencoded&quot;, &quot;text/plain&quot;:
</a><a href="#h75-0-183" id="h75-0-183" class="i">+		vals, err := url.ParseQuery(string(body))
</a><a href="#h75-0-184" id="h75-0-184" class="i">+		if err != nil {
</a><a href="#h75-0-185" id="h75-0-185" class="i">+			return nil, err
</a><a href="#h75-0-186" id="h75-0-186" class="i">+		}
</a><a href="#h75-0-187" id="h75-0-187" class="i">+		token = &amp;Token{
</a><a href="#h75-0-188" id="h75-0-188" class="i">+			AccessToken:  vals.Get(&quot;access_token&quot;),
</a><a href="#h75-0-189" id="h75-0-189" class="i">+			TokenType:    vals.Get(&quot;token_type&quot;),
</a><a href="#h75-0-190" id="h75-0-190" class="i">+			RefreshToken: vals.Get(&quot;refresh_token&quot;),
</a><a href="#h75-0-191" id="h75-0-191" class="i">+			Raw:          vals,
</a><a href="#h75-0-192" id="h75-0-192" class="i">+		}
</a><a href="#h75-0-193" id="h75-0-193" class="i">+		e := vals.Get(&quot;expires_in&quot;)
</a><a href="#h75-0-194" id="h75-0-194" class="i">+		if e == &quot;&quot; {
</a><a href="#h75-0-195" id="h75-0-195" class="i">+			// TODO(jbd): Facebook&#39;s OAuth2 implementation is broken and
</a><a href="#h75-0-196" id="h75-0-196" class="i">+			// returns expires_in field in expires. Remove the fallback to expires,
</a><a href="#h75-0-197" id="h75-0-197" class="i">+			// when Facebook fixes their implementation.
</a><a href="#h75-0-198" id="h75-0-198" class="i">+			e = vals.Get(&quot;expires&quot;)
</a><a href="#h75-0-199" id="h75-0-199" class="i">+		}
</a><a href="#h75-0-200" id="h75-0-200" class="i">+		expires, _ := strconv.Atoi(e)
</a><a href="#h75-0-201" id="h75-0-201" class="i">+		if expires != 0 {
</a><a href="#h75-0-202" id="h75-0-202" class="i">+			token.Expiry = time.Now().Add(time.Duration(expires) * time.Second)
</a><a href="#h75-0-203" id="h75-0-203" class="i">+		}
</a><a href="#h75-0-204" id="h75-0-204" class="i">+	default:
</a><a href="#h75-0-205" id="h75-0-205" class="i">+		var tj tokenJSON
</a><a href="#h75-0-206" id="h75-0-206" class="i">+		if err = json.Unmarshal(body, &amp;tj); err != nil {
</a><a href="#h75-0-207" id="h75-0-207" class="i">+			return nil, err
</a><a href="#h75-0-208" id="h75-0-208" class="i">+		}
</a><a href="#h75-0-209" id="h75-0-209" class="i">+		token = &amp;Token{
</a><a href="#h75-0-210" id="h75-0-210" class="i">+			AccessToken:  tj.AccessToken,
</a><a href="#h75-0-211" id="h75-0-211" class="i">+			TokenType:    tj.TokenType,
</a><a href="#h75-0-212" id="h75-0-212" class="i">+			RefreshToken: tj.RefreshToken,
</a><a href="#h75-0-213" id="h75-0-213" class="i">+			Expiry:       tj.expiry(),
</a><a href="#h75-0-214" id="h75-0-214" class="i">+			Raw:          make(map[string]interface{}),
</a><a href="#h75-0-215" id="h75-0-215" class="i">+		}
</a><a href="#h75-0-216" id="h75-0-216" class="i">+		json.Unmarshal(body, &amp;token.Raw) // no error checks for optional fields
</a><a href="#h75-0-217" id="h75-0-217" class="i">+	}
</a><a href="#h75-0-218" id="h75-0-218" class="i">+	// Don&#39;t overwrite `RefreshToken` with an empty value
</a><a href="#h75-0-219" id="h75-0-219" class="i">+	// if this was a token refreshing request.
</a><a href="#h75-0-220" id="h75-0-220" class="i">+	if token.RefreshToken == &quot;&quot; {
</a><a href="#h75-0-221" id="h75-0-221" class="i">+		token.RefreshToken = v.Get(&quot;refresh_token&quot;)
</a><a href="#h75-0-222" id="h75-0-222" class="i">+	}
</a><a href="#h75-0-223" id="h75-0-223" class="i">+	return token, nil
</a><a href="#h75-0-224" id="h75-0-224" class="i">+}
</a><b>diff --git a/<a id="h76" href="../file/vendor/golang.org/x/oauth2/internal/transport.go">vendor/golang.org/x/oauth2/internal/transport.go</a> b/<a href="../file/vendor/golang.org/x/oauth2/internal/transport.go">vendor/golang.org/x/oauth2/internal/transport.go</a></b>
<a href="#h76-0" id="h76-0" class="h">@@ -0,0 +1,69 @@
</a><a href="#h76-0-0" id="h76-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h76-0-1" id="h76-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h76-0-2" id="h76-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h76-0-3" id="h76-0-3" class="i">+
</a><a href="#h76-0-4" id="h76-0-4" class="i">+// Package internal contains support packages for oauth2 package.
</a><a href="#h76-0-5" id="h76-0-5" class="i">+package internal
</a><a href="#h76-0-6" id="h76-0-6" class="i">+
</a><a href="#h76-0-7" id="h76-0-7" class="i">+import (
</a><a href="#h76-0-8" id="h76-0-8" class="i">+	&quot;net/http&quot;
</a><a href="#h76-0-9" id="h76-0-9" class="i">+
</a><a href="#h76-0-10" id="h76-0-10" class="i">+	&quot;golang.org/x/net/context&quot;
</a><a href="#h76-0-11" id="h76-0-11" class="i">+)
</a><a href="#h76-0-12" id="h76-0-12" class="i">+
</a><a href="#h76-0-13" id="h76-0-13" class="i">+// HTTPClient is the context key to use with golang.org/x/net/context&#39;s
</a><a href="#h76-0-14" id="h76-0-14" class="i">+// WithValue function to associate an *http.Client value with a context.
</a><a href="#h76-0-15" id="h76-0-15" class="i">+var HTTPClient ContextKey
</a><a href="#h76-0-16" id="h76-0-16" class="i">+
</a><a href="#h76-0-17" id="h76-0-17" class="i">+// ContextKey is just an empty struct. It exists so HTTPClient can be
</a><a href="#h76-0-18" id="h76-0-18" class="i">+// an immutable public variable with a unique type. It&#39;s immutable
</a><a href="#h76-0-19" id="h76-0-19" class="i">+// because nobody else can create a ContextKey, being unexported.
</a><a href="#h76-0-20" id="h76-0-20" class="i">+type ContextKey struct{}
</a><a href="#h76-0-21" id="h76-0-21" class="i">+
</a><a href="#h76-0-22" id="h76-0-22" class="i">+// ContextClientFunc is a func which tries to return an *http.Client
</a><a href="#h76-0-23" id="h76-0-23" class="i">+// given a Context value. If it returns an error, the search stops
</a><a href="#h76-0-24" id="h76-0-24" class="i">+// with that error.  If it returns (nil, nil), the search continues
</a><a href="#h76-0-25" id="h76-0-25" class="i">+// down the list of registered funcs.
</a><a href="#h76-0-26" id="h76-0-26" class="i">+type ContextClientFunc func(context.Context) (*http.Client, error)
</a><a href="#h76-0-27" id="h76-0-27" class="i">+
</a><a href="#h76-0-28" id="h76-0-28" class="i">+var contextClientFuncs []ContextClientFunc
</a><a href="#h76-0-29" id="h76-0-29" class="i">+
</a><a href="#h76-0-30" id="h76-0-30" class="i">+func RegisterContextClientFunc(fn ContextClientFunc) {
</a><a href="#h76-0-31" id="h76-0-31" class="i">+	contextClientFuncs = append(contextClientFuncs, fn)
</a><a href="#h76-0-32" id="h76-0-32" class="i">+}
</a><a href="#h76-0-33" id="h76-0-33" class="i">+
</a><a href="#h76-0-34" id="h76-0-34" class="i">+func ContextClient(ctx context.Context) (*http.Client, error) {
</a><a href="#h76-0-35" id="h76-0-35" class="i">+	if ctx != nil {
</a><a href="#h76-0-36" id="h76-0-36" class="i">+		if hc, ok := ctx.Value(HTTPClient).(*http.Client); ok {
</a><a href="#h76-0-37" id="h76-0-37" class="i">+			return hc, nil
</a><a href="#h76-0-38" id="h76-0-38" class="i">+		}
</a><a href="#h76-0-39" id="h76-0-39" class="i">+	}
</a><a href="#h76-0-40" id="h76-0-40" class="i">+	for _, fn := range contextClientFuncs {
</a><a href="#h76-0-41" id="h76-0-41" class="i">+		c, err := fn(ctx)
</a><a href="#h76-0-42" id="h76-0-42" class="i">+		if err != nil {
</a><a href="#h76-0-43" id="h76-0-43" class="i">+			return nil, err
</a><a href="#h76-0-44" id="h76-0-44" class="i">+		}
</a><a href="#h76-0-45" id="h76-0-45" class="i">+		if c != nil {
</a><a href="#h76-0-46" id="h76-0-46" class="i">+			return c, nil
</a><a href="#h76-0-47" id="h76-0-47" class="i">+		}
</a><a href="#h76-0-48" id="h76-0-48" class="i">+	}
</a><a href="#h76-0-49" id="h76-0-49" class="i">+	return http.DefaultClient, nil
</a><a href="#h76-0-50" id="h76-0-50" class="i">+}
</a><a href="#h76-0-51" id="h76-0-51" class="i">+
</a><a href="#h76-0-52" id="h76-0-52" class="i">+func ContextTransport(ctx context.Context) http.RoundTripper {
</a><a href="#h76-0-53" id="h76-0-53" class="i">+	hc, err := ContextClient(ctx)
</a><a href="#h76-0-54" id="h76-0-54" class="i">+	// This is a rare error case (somebody using nil on App Engine).
</a><a href="#h76-0-55" id="h76-0-55" class="i">+	if err != nil {
</a><a href="#h76-0-56" id="h76-0-56" class="i">+		return ErrorTransport{err}
</a><a href="#h76-0-57" id="h76-0-57" class="i">+	}
</a><a href="#h76-0-58" id="h76-0-58" class="i">+	return hc.Transport
</a><a href="#h76-0-59" id="h76-0-59" class="i">+}
</a><a href="#h76-0-60" id="h76-0-60" class="i">+
</a><a href="#h76-0-61" id="h76-0-61" class="i">+// ErrorTransport returns the specified error on RoundTrip.
</a><a href="#h76-0-62" id="h76-0-62" class="i">+// This RoundTripper should be used in rare error cases where
</a><a href="#h76-0-63" id="h76-0-63" class="i">+// error handling can be postponed to response handling time.
</a><a href="#h76-0-64" id="h76-0-64" class="i">+type ErrorTransport struct{ Err error }
</a><a href="#h76-0-65" id="h76-0-65" class="i">+
</a><a href="#h76-0-66" id="h76-0-66" class="i">+func (t ErrorTransport) RoundTrip(*http.Request) (*http.Response, error) {
</a><a href="#h76-0-67" id="h76-0-67" class="i">+	return nil, t.Err
</a><a href="#h76-0-68" id="h76-0-68" class="i">+}
</a><b>diff --git a/<a id="h77" href="../file/vendor/golang.org/x/oauth2/oauth2.go">vendor/golang.org/x/oauth2/oauth2.go</a> b/<a href="../file/vendor/golang.org/x/oauth2/oauth2.go">vendor/golang.org/x/oauth2/oauth2.go</a></b>
<a href="#h77-0" id="h77-0" class="h">@@ -0,0 +1,337 @@
</a><a href="#h77-0-0" id="h77-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h77-0-1" id="h77-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h77-0-2" id="h77-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h77-0-3" id="h77-0-3" class="i">+
</a><a href="#h77-0-4" id="h77-0-4" class="i">+// Package oauth2 provides support for making
</a><a href="#h77-0-5" id="h77-0-5" class="i">+// OAuth2 authorized and authenticated HTTP requests.
</a><a href="#h77-0-6" id="h77-0-6" class="i">+// It can additionally grant authorization with Bearer JWT.
</a><a href="#h77-0-7" id="h77-0-7" class="i">+package oauth2 // import &quot;golang.org/x/oauth2&quot;
</a><a href="#h77-0-8" id="h77-0-8" class="i">+
</a><a href="#h77-0-9" id="h77-0-9" class="i">+import (
</a><a href="#h77-0-10" id="h77-0-10" class="i">+	&quot;bytes&quot;
</a><a href="#h77-0-11" id="h77-0-11" class="i">+	&quot;errors&quot;
</a><a href="#h77-0-12" id="h77-0-12" class="i">+	&quot;net/http&quot;
</a><a href="#h77-0-13" id="h77-0-13" class="i">+	&quot;net/url&quot;
</a><a href="#h77-0-14" id="h77-0-14" class="i">+	&quot;strings&quot;
</a><a href="#h77-0-15" id="h77-0-15" class="i">+	&quot;sync&quot;
</a><a href="#h77-0-16" id="h77-0-16" class="i">+
</a><a href="#h77-0-17" id="h77-0-17" class="i">+	&quot;golang.org/x/net/context&quot;
</a><a href="#h77-0-18" id="h77-0-18" class="i">+	&quot;golang.org/x/oauth2/internal&quot;
</a><a href="#h77-0-19" id="h77-0-19" class="i">+)
</a><a href="#h77-0-20" id="h77-0-20" class="i">+
</a><a href="#h77-0-21" id="h77-0-21" class="i">+// NoContext is the default context you should supply if not using
</a><a href="#h77-0-22" id="h77-0-22" class="i">+// your own context.Context (see https://golang.org/x/net/context).
</a><a href="#h77-0-23" id="h77-0-23" class="i">+var NoContext = context.TODO()
</a><a href="#h77-0-24" id="h77-0-24" class="i">+
</a><a href="#h77-0-25" id="h77-0-25" class="i">+// RegisterBrokenAuthHeaderProvider registers an OAuth2 server
</a><a href="#h77-0-26" id="h77-0-26" class="i">+// identified by the tokenURL prefix as an OAuth2 implementation
</a><a href="#h77-0-27" id="h77-0-27" class="i">+// which doesn&#39;t support the HTTP Basic authentication
</a><a href="#h77-0-28" id="h77-0-28" class="i">+// scheme to authenticate with the authorization server.
</a><a href="#h77-0-29" id="h77-0-29" class="i">+// Once a server is registered, credentials (client_id and client_secret)
</a><a href="#h77-0-30" id="h77-0-30" class="i">+// will be passed as query parameters rather than being present
</a><a href="#h77-0-31" id="h77-0-31" class="i">+// in the Authorization header.
</a><a href="#h77-0-32" id="h77-0-32" class="i">+// See https://code.google.com/p/goauth2/issues/detail?id=31 for background.
</a><a href="#h77-0-33" id="h77-0-33" class="i">+func RegisterBrokenAuthHeaderProvider(tokenURL string) {
</a><a href="#h77-0-34" id="h77-0-34" class="i">+	internal.RegisterBrokenAuthHeaderProvider(tokenURL)
</a><a href="#h77-0-35" id="h77-0-35" class="i">+}
</a><a href="#h77-0-36" id="h77-0-36" class="i">+
</a><a href="#h77-0-37" id="h77-0-37" class="i">+// Config describes a typical 3-legged OAuth2 flow, with both the
</a><a href="#h77-0-38" id="h77-0-38" class="i">+// client application information and the server&#39;s endpoint URLs.
</a><a href="#h77-0-39" id="h77-0-39" class="i">+type Config struct {
</a><a href="#h77-0-40" id="h77-0-40" class="i">+	// ClientID is the application&#39;s ID.
</a><a href="#h77-0-41" id="h77-0-41" class="i">+	ClientID string
</a><a href="#h77-0-42" id="h77-0-42" class="i">+
</a><a href="#h77-0-43" id="h77-0-43" class="i">+	// ClientSecret is the application&#39;s secret.
</a><a href="#h77-0-44" id="h77-0-44" class="i">+	ClientSecret string
</a><a href="#h77-0-45" id="h77-0-45" class="i">+
</a><a href="#h77-0-46" id="h77-0-46" class="i">+	// Endpoint contains the resource server&#39;s token endpoint
</a><a href="#h77-0-47" id="h77-0-47" class="i">+	// URLs. These are constants specific to each server and are
</a><a href="#h77-0-48" id="h77-0-48" class="i">+	// often available via site-specific packages, such as
</a><a href="#h77-0-49" id="h77-0-49" class="i">+	// google.Endpoint or github.Endpoint.
</a><a href="#h77-0-50" id="h77-0-50" class="i">+	Endpoint Endpoint
</a><a href="#h77-0-51" id="h77-0-51" class="i">+
</a><a href="#h77-0-52" id="h77-0-52" class="i">+	// RedirectURL is the URL to redirect users going through
</a><a href="#h77-0-53" id="h77-0-53" class="i">+	// the OAuth flow, after the resource owner&#39;s URLs.
</a><a href="#h77-0-54" id="h77-0-54" class="i">+	RedirectURL string
</a><a href="#h77-0-55" id="h77-0-55" class="i">+
</a><a href="#h77-0-56" id="h77-0-56" class="i">+	// Scope specifies optional requested permissions.
</a><a href="#h77-0-57" id="h77-0-57" class="i">+	Scopes []string
</a><a href="#h77-0-58" id="h77-0-58" class="i">+}
</a><a href="#h77-0-59" id="h77-0-59" class="i">+
</a><a href="#h77-0-60" id="h77-0-60" class="i">+// A TokenSource is anything that can return a token.
</a><a href="#h77-0-61" id="h77-0-61" class="i">+type TokenSource interface {
</a><a href="#h77-0-62" id="h77-0-62" class="i">+	// Token returns a token or an error.
</a><a href="#h77-0-63" id="h77-0-63" class="i">+	// Token must be safe for concurrent use by multiple goroutines.
</a><a href="#h77-0-64" id="h77-0-64" class="i">+	// The returned Token must not be modified.
</a><a href="#h77-0-65" id="h77-0-65" class="i">+	Token() (*Token, error)
</a><a href="#h77-0-66" id="h77-0-66" class="i">+}
</a><a href="#h77-0-67" id="h77-0-67" class="i">+
</a><a href="#h77-0-68" id="h77-0-68" class="i">+// Endpoint contains the OAuth 2.0 provider&#39;s authorization and token
</a><a href="#h77-0-69" id="h77-0-69" class="i">+// endpoint URLs.
</a><a href="#h77-0-70" id="h77-0-70" class="i">+type Endpoint struct {
</a><a href="#h77-0-71" id="h77-0-71" class="i">+	AuthURL  string
</a><a href="#h77-0-72" id="h77-0-72" class="i">+	TokenURL string
</a><a href="#h77-0-73" id="h77-0-73" class="i">+}
</a><a href="#h77-0-74" id="h77-0-74" class="i">+
</a><a href="#h77-0-75" id="h77-0-75" class="i">+var (
</a><a href="#h77-0-76" id="h77-0-76" class="i">+	// AccessTypeOnline and AccessTypeOffline are options passed
</a><a href="#h77-0-77" id="h77-0-77" class="i">+	// to the Options.AuthCodeURL method. They modify the
</a><a href="#h77-0-78" id="h77-0-78" class="i">+	// &quot;access_type&quot; field that gets sent in the URL returned by
</a><a href="#h77-0-79" id="h77-0-79" class="i">+	// AuthCodeURL.
</a><a href="#h77-0-80" id="h77-0-80" class="i">+	//
</a><a href="#h77-0-81" id="h77-0-81" class="i">+	// Online is the default if neither is specified. If your
</a><a href="#h77-0-82" id="h77-0-82" class="i">+	// application needs to refresh access tokens when the user
</a><a href="#h77-0-83" id="h77-0-83" class="i">+	// is not present at the browser, then use offline. This will
</a><a href="#h77-0-84" id="h77-0-84" class="i">+	// result in your application obtaining a refresh token the
</a><a href="#h77-0-85" id="h77-0-85" class="i">+	// first time your application exchanges an authorization
</a><a href="#h77-0-86" id="h77-0-86" class="i">+	// code for a user.
</a><a href="#h77-0-87" id="h77-0-87" class="i">+	AccessTypeOnline  AuthCodeOption = SetAuthURLParam(&quot;access_type&quot;, &quot;online&quot;)
</a><a href="#h77-0-88" id="h77-0-88" class="i">+	AccessTypeOffline AuthCodeOption = SetAuthURLParam(&quot;access_type&quot;, &quot;offline&quot;)
</a><a href="#h77-0-89" id="h77-0-89" class="i">+
</a><a href="#h77-0-90" id="h77-0-90" class="i">+	// ApprovalForce forces the users to view the consent dialog
</a><a href="#h77-0-91" id="h77-0-91" class="i">+	// and confirm the permissions request at the URL returned
</a><a href="#h77-0-92" id="h77-0-92" class="i">+	// from AuthCodeURL, even if they&#39;ve already done so.
</a><a href="#h77-0-93" id="h77-0-93" class="i">+	ApprovalForce AuthCodeOption = SetAuthURLParam(&quot;approval_prompt&quot;, &quot;force&quot;)
</a><a href="#h77-0-94" id="h77-0-94" class="i">+)
</a><a href="#h77-0-95" id="h77-0-95" class="i">+
</a><a href="#h77-0-96" id="h77-0-96" class="i">+// An AuthCodeOption is passed to Config.AuthCodeURL.
</a><a href="#h77-0-97" id="h77-0-97" class="i">+type AuthCodeOption interface {
</a><a href="#h77-0-98" id="h77-0-98" class="i">+	setValue(url.Values)
</a><a href="#h77-0-99" id="h77-0-99" class="i">+}
</a><a href="#h77-0-100" id="h77-0-100" class="i">+
</a><a href="#h77-0-101" id="h77-0-101" class="i">+type setParam struct{ k, v string }
</a><a href="#h77-0-102" id="h77-0-102" class="i">+
</a><a href="#h77-0-103" id="h77-0-103" class="i">+func (p setParam) setValue(m url.Values) { m.Set(p.k, p.v) }
</a><a href="#h77-0-104" id="h77-0-104" class="i">+
</a><a href="#h77-0-105" id="h77-0-105" class="i">+// SetAuthURLParam builds an AuthCodeOption which passes key/value parameters
</a><a href="#h77-0-106" id="h77-0-106" class="i">+// to a provider&#39;s authorization endpoint.
</a><a href="#h77-0-107" id="h77-0-107" class="i">+func SetAuthURLParam(key, value string) AuthCodeOption {
</a><a href="#h77-0-108" id="h77-0-108" class="i">+	return setParam{key, value}
</a><a href="#h77-0-109" id="h77-0-109" class="i">+}
</a><a href="#h77-0-110" id="h77-0-110" class="i">+
</a><a href="#h77-0-111" id="h77-0-111" class="i">+// AuthCodeURL returns a URL to OAuth 2.0 provider&#39;s consent page
</a><a href="#h77-0-112" id="h77-0-112" class="i">+// that asks for permissions for the required scopes explicitly.
</a><a href="#h77-0-113" id="h77-0-113" class="i">+//
</a><a href="#h77-0-114" id="h77-0-114" class="i">+// State is a token to protect the user from CSRF attacks. You must
</a><a href="#h77-0-115" id="h77-0-115" class="i">+// always provide a non-zero string and validate that it matches the
</a><a href="#h77-0-116" id="h77-0-116" class="i">+// the state query parameter on your redirect callback.
</a><a href="#h77-0-117" id="h77-0-117" class="i">+// See http://tools.ietf.org/html/rfc6749#section-10.12 for more info.
</a><a href="#h77-0-118" id="h77-0-118" class="i">+//
</a><a href="#h77-0-119" id="h77-0-119" class="i">+// Opts may include AccessTypeOnline or AccessTypeOffline, as well
</a><a href="#h77-0-120" id="h77-0-120" class="i">+// as ApprovalForce.
</a><a href="#h77-0-121" id="h77-0-121" class="i">+func (c *Config) AuthCodeURL(state string, opts ...AuthCodeOption) string {
</a><a href="#h77-0-122" id="h77-0-122" class="i">+	var buf bytes.Buffer
</a><a href="#h77-0-123" id="h77-0-123" class="i">+	buf.WriteString(c.Endpoint.AuthURL)
</a><a href="#h77-0-124" id="h77-0-124" class="i">+	v := url.Values{
</a><a href="#h77-0-125" id="h77-0-125" class="i">+		&quot;response_type&quot;: {&quot;code&quot;},
</a><a href="#h77-0-126" id="h77-0-126" class="i">+		&quot;client_id&quot;:     {c.ClientID},
</a><a href="#h77-0-127" id="h77-0-127" class="i">+		&quot;redirect_uri&quot;:  internal.CondVal(c.RedirectURL),
</a><a href="#h77-0-128" id="h77-0-128" class="i">+		&quot;scope&quot;:         internal.CondVal(strings.Join(c.Scopes, &quot; &quot;)),
</a><a href="#h77-0-129" id="h77-0-129" class="i">+		&quot;state&quot;:         internal.CondVal(state),
</a><a href="#h77-0-130" id="h77-0-130" class="i">+	}
</a><a href="#h77-0-131" id="h77-0-131" class="i">+	for _, opt := range opts {
</a><a href="#h77-0-132" id="h77-0-132" class="i">+		opt.setValue(v)
</a><a href="#h77-0-133" id="h77-0-133" class="i">+	}
</a><a href="#h77-0-134" id="h77-0-134" class="i">+	if strings.Contains(c.Endpoint.AuthURL, &quot;?&quot;) {
</a><a href="#h77-0-135" id="h77-0-135" class="i">+		buf.WriteByte(&#39;&amp;&#39;)
</a><a href="#h77-0-136" id="h77-0-136" class="i">+	} else {
</a><a href="#h77-0-137" id="h77-0-137" class="i">+		buf.WriteByte(&#39;?&#39;)
</a><a href="#h77-0-138" id="h77-0-138" class="i">+	}
</a><a href="#h77-0-139" id="h77-0-139" class="i">+	buf.WriteString(v.Encode())
</a><a href="#h77-0-140" id="h77-0-140" class="i">+	return buf.String()
</a><a href="#h77-0-141" id="h77-0-141" class="i">+}
</a><a href="#h77-0-142" id="h77-0-142" class="i">+
</a><a href="#h77-0-143" id="h77-0-143" class="i">+// PasswordCredentialsToken converts a resource owner username and password
</a><a href="#h77-0-144" id="h77-0-144" class="i">+// pair into a token.
</a><a href="#h77-0-145" id="h77-0-145" class="i">+//
</a><a href="#h77-0-146" id="h77-0-146" class="i">+// Per the RFC, this grant type should only be used &quot;when there is a high
</a><a href="#h77-0-147" id="h77-0-147" class="i">+// degree of trust between the resource owner and the client (e.g., the client
</a><a href="#h77-0-148" id="h77-0-148" class="i">+// is part of the device operating system or a highly privileged application),
</a><a href="#h77-0-149" id="h77-0-149" class="i">+// and when other authorization grant types are not available.&quot;
</a><a href="#h77-0-150" id="h77-0-150" class="i">+// See https://tools.ietf.org/html/rfc6749#section-4.3 for more info.
</a><a href="#h77-0-151" id="h77-0-151" class="i">+//
</a><a href="#h77-0-152" id="h77-0-152" class="i">+// The HTTP client to use is derived from the context.
</a><a href="#h77-0-153" id="h77-0-153" class="i">+// If nil, http.DefaultClient is used.
</a><a href="#h77-0-154" id="h77-0-154" class="i">+func (c *Config) PasswordCredentialsToken(ctx context.Context, username, password string) (*Token, error) {
</a><a href="#h77-0-155" id="h77-0-155" class="i">+	return retrieveToken(ctx, c, url.Values{
</a><a href="#h77-0-156" id="h77-0-156" class="i">+		&quot;grant_type&quot;: {&quot;password&quot;},
</a><a href="#h77-0-157" id="h77-0-157" class="i">+		&quot;username&quot;:   {username},
</a><a href="#h77-0-158" id="h77-0-158" class="i">+		&quot;password&quot;:   {password},
</a><a href="#h77-0-159" id="h77-0-159" class="i">+		&quot;scope&quot;:      internal.CondVal(strings.Join(c.Scopes, &quot; &quot;)),
</a><a href="#h77-0-160" id="h77-0-160" class="i">+	})
</a><a href="#h77-0-161" id="h77-0-161" class="i">+}
</a><a href="#h77-0-162" id="h77-0-162" class="i">+
</a><a href="#h77-0-163" id="h77-0-163" class="i">+// Exchange converts an authorization code into a token.
</a><a href="#h77-0-164" id="h77-0-164" class="i">+//
</a><a href="#h77-0-165" id="h77-0-165" class="i">+// It is used after a resource provider redirects the user back
</a><a href="#h77-0-166" id="h77-0-166" class="i">+// to the Redirect URI (the URL obtained from AuthCodeURL).
</a><a href="#h77-0-167" id="h77-0-167" class="i">+//
</a><a href="#h77-0-168" id="h77-0-168" class="i">+// The HTTP client to use is derived from the context.
</a><a href="#h77-0-169" id="h77-0-169" class="i">+// If a client is not provided via the context, http.DefaultClient is used.
</a><a href="#h77-0-170" id="h77-0-170" class="i">+//
</a><a href="#h77-0-171" id="h77-0-171" class="i">+// The code will be in the *http.Request.FormValue(&quot;code&quot;). Before
</a><a href="#h77-0-172" id="h77-0-172" class="i">+// calling Exchange, be sure to validate FormValue(&quot;state&quot;).
</a><a href="#h77-0-173" id="h77-0-173" class="i">+func (c *Config) Exchange(ctx context.Context, code string) (*Token, error) {
</a><a href="#h77-0-174" id="h77-0-174" class="i">+	return retrieveToken(ctx, c, url.Values{
</a><a href="#h77-0-175" id="h77-0-175" class="i">+		&quot;grant_type&quot;:   {&quot;authorization_code&quot;},
</a><a href="#h77-0-176" id="h77-0-176" class="i">+		&quot;code&quot;:         {code},
</a><a href="#h77-0-177" id="h77-0-177" class="i">+		&quot;redirect_uri&quot;: internal.CondVal(c.RedirectURL),
</a><a href="#h77-0-178" id="h77-0-178" class="i">+		&quot;scope&quot;:        internal.CondVal(strings.Join(c.Scopes, &quot; &quot;)),
</a><a href="#h77-0-179" id="h77-0-179" class="i">+	})
</a><a href="#h77-0-180" id="h77-0-180" class="i">+}
</a><a href="#h77-0-181" id="h77-0-181" class="i">+
</a><a href="#h77-0-182" id="h77-0-182" class="i">+// Client returns an HTTP client using the provided token.
</a><a href="#h77-0-183" id="h77-0-183" class="i">+// The token will auto-refresh as necessary. The underlying
</a><a href="#h77-0-184" id="h77-0-184" class="i">+// HTTP transport will be obtained using the provided context.
</a><a href="#h77-0-185" id="h77-0-185" class="i">+// The returned client and its Transport should not be modified.
</a><a href="#h77-0-186" id="h77-0-186" class="i">+func (c *Config) Client(ctx context.Context, t *Token) *http.Client {
</a><a href="#h77-0-187" id="h77-0-187" class="i">+	return NewClient(ctx, c.TokenSource(ctx, t))
</a><a href="#h77-0-188" id="h77-0-188" class="i">+}
</a><a href="#h77-0-189" id="h77-0-189" class="i">+
</a><a href="#h77-0-190" id="h77-0-190" class="i">+// TokenSource returns a TokenSource that returns t until t expires,
</a><a href="#h77-0-191" id="h77-0-191" class="i">+// automatically refreshing it as necessary using the provided context.
</a><a href="#h77-0-192" id="h77-0-192" class="i">+//
</a><a href="#h77-0-193" id="h77-0-193" class="i">+// Most users will use Config.Client instead.
</a><a href="#h77-0-194" id="h77-0-194" class="i">+func (c *Config) TokenSource(ctx context.Context, t *Token) TokenSource {
</a><a href="#h77-0-195" id="h77-0-195" class="i">+	tkr := &amp;tokenRefresher{
</a><a href="#h77-0-196" id="h77-0-196" class="i">+		ctx:  ctx,
</a><a href="#h77-0-197" id="h77-0-197" class="i">+		conf: c,
</a><a href="#h77-0-198" id="h77-0-198" class="i">+	}
</a><a href="#h77-0-199" id="h77-0-199" class="i">+	if t != nil {
</a><a href="#h77-0-200" id="h77-0-200" class="i">+		tkr.refreshToken = t.RefreshToken
</a><a href="#h77-0-201" id="h77-0-201" class="i">+	}
</a><a href="#h77-0-202" id="h77-0-202" class="i">+	return &amp;reuseTokenSource{
</a><a href="#h77-0-203" id="h77-0-203" class="i">+		t:   t,
</a><a href="#h77-0-204" id="h77-0-204" class="i">+		new: tkr,
</a><a href="#h77-0-205" id="h77-0-205" class="i">+	}
</a><a href="#h77-0-206" id="h77-0-206" class="i">+}
</a><a href="#h77-0-207" id="h77-0-207" class="i">+
</a><a href="#h77-0-208" id="h77-0-208" class="i">+// tokenRefresher is a TokenSource that makes &quot;grant_type&quot;==&quot;refresh_token&quot;
</a><a href="#h77-0-209" id="h77-0-209" class="i">+// HTTP requests to renew a token using a RefreshToken.
</a><a href="#h77-0-210" id="h77-0-210" class="i">+type tokenRefresher struct {
</a><a href="#h77-0-211" id="h77-0-211" class="i">+	ctx          context.Context // used to get HTTP requests
</a><a href="#h77-0-212" id="h77-0-212" class="i">+	conf         *Config
</a><a href="#h77-0-213" id="h77-0-213" class="i">+	refreshToken string
</a><a href="#h77-0-214" id="h77-0-214" class="i">+}
</a><a href="#h77-0-215" id="h77-0-215" class="i">+
</a><a href="#h77-0-216" id="h77-0-216" class="i">+// WARNING: Token is not safe for concurrent access, as it
</a><a href="#h77-0-217" id="h77-0-217" class="i">+// updates the tokenRefresher&#39;s refreshToken field.
</a><a href="#h77-0-218" id="h77-0-218" class="i">+// Within this package, it is used by reuseTokenSource which
</a><a href="#h77-0-219" id="h77-0-219" class="i">+// synchronizes calls to this method with its own mutex.
</a><a href="#h77-0-220" id="h77-0-220" class="i">+func (tf *tokenRefresher) Token() (*Token, error) {
</a><a href="#h77-0-221" id="h77-0-221" class="i">+	if tf.refreshToken == &quot;&quot; {
</a><a href="#h77-0-222" id="h77-0-222" class="i">+		return nil, errors.New(&quot;oauth2: token expired and refresh token is not set&quot;)
</a><a href="#h77-0-223" id="h77-0-223" class="i">+	}
</a><a href="#h77-0-224" id="h77-0-224" class="i">+
</a><a href="#h77-0-225" id="h77-0-225" class="i">+	tk, err := retrieveToken(tf.ctx, tf.conf, url.Values{
</a><a href="#h77-0-226" id="h77-0-226" class="i">+		&quot;grant_type&quot;:    {&quot;refresh_token&quot;},
</a><a href="#h77-0-227" id="h77-0-227" class="i">+		&quot;refresh_token&quot;: {tf.refreshToken},
</a><a href="#h77-0-228" id="h77-0-228" class="i">+	})
</a><a href="#h77-0-229" id="h77-0-229" class="i">+
</a><a href="#h77-0-230" id="h77-0-230" class="i">+	if err != nil {
</a><a href="#h77-0-231" id="h77-0-231" class="i">+		return nil, err
</a><a href="#h77-0-232" id="h77-0-232" class="i">+	}
</a><a href="#h77-0-233" id="h77-0-233" class="i">+	if tf.refreshToken != tk.RefreshToken {
</a><a href="#h77-0-234" id="h77-0-234" class="i">+		tf.refreshToken = tk.RefreshToken
</a><a href="#h77-0-235" id="h77-0-235" class="i">+	}
</a><a href="#h77-0-236" id="h77-0-236" class="i">+	return tk, err
</a><a href="#h77-0-237" id="h77-0-237" class="i">+}
</a><a href="#h77-0-238" id="h77-0-238" class="i">+
</a><a href="#h77-0-239" id="h77-0-239" class="i">+// reuseTokenSource is a TokenSource that holds a single token in memory
</a><a href="#h77-0-240" id="h77-0-240" class="i">+// and validates its expiry before each call to retrieve it with
</a><a href="#h77-0-241" id="h77-0-241" class="i">+// Token. If it&#39;s expired, it will be auto-refreshed using the
</a><a href="#h77-0-242" id="h77-0-242" class="i">+// new TokenSource.
</a><a href="#h77-0-243" id="h77-0-243" class="i">+type reuseTokenSource struct {
</a><a href="#h77-0-244" id="h77-0-244" class="i">+	new TokenSource // called when t is expired.
</a><a href="#h77-0-245" id="h77-0-245" class="i">+
</a><a href="#h77-0-246" id="h77-0-246" class="i">+	mu sync.Mutex // guards t
</a><a href="#h77-0-247" id="h77-0-247" class="i">+	t  *Token
</a><a href="#h77-0-248" id="h77-0-248" class="i">+}
</a><a href="#h77-0-249" id="h77-0-249" class="i">+
</a><a href="#h77-0-250" id="h77-0-250" class="i">+// Token returns the current token if it&#39;s still valid, else will
</a><a href="#h77-0-251" id="h77-0-251" class="i">+// refresh the current token (using r.Context for HTTP client
</a><a href="#h77-0-252" id="h77-0-252" class="i">+// information) and return the new one.
</a><a href="#h77-0-253" id="h77-0-253" class="i">+func (s *reuseTokenSource) Token() (*Token, error) {
</a><a href="#h77-0-254" id="h77-0-254" class="i">+	s.mu.Lock()
</a><a href="#h77-0-255" id="h77-0-255" class="i">+	defer s.mu.Unlock()
</a><a href="#h77-0-256" id="h77-0-256" class="i">+	if s.t.Valid() {
</a><a href="#h77-0-257" id="h77-0-257" class="i">+		return s.t, nil
</a><a href="#h77-0-258" id="h77-0-258" class="i">+	}
</a><a href="#h77-0-259" id="h77-0-259" class="i">+	t, err := s.new.Token()
</a><a href="#h77-0-260" id="h77-0-260" class="i">+	if err != nil {
</a><a href="#h77-0-261" id="h77-0-261" class="i">+		return nil, err
</a><a href="#h77-0-262" id="h77-0-262" class="i">+	}
</a><a href="#h77-0-263" id="h77-0-263" class="i">+	s.t = t
</a><a href="#h77-0-264" id="h77-0-264" class="i">+	return t, nil
</a><a href="#h77-0-265" id="h77-0-265" class="i">+}
</a><a href="#h77-0-266" id="h77-0-266" class="i">+
</a><a href="#h77-0-267" id="h77-0-267" class="i">+// StaticTokenSource returns a TokenSource that always returns the same token.
</a><a href="#h77-0-268" id="h77-0-268" class="i">+// Because the provided token t is never refreshed, StaticTokenSource is only
</a><a href="#h77-0-269" id="h77-0-269" class="i">+// useful for tokens that never expire.
</a><a href="#h77-0-270" id="h77-0-270" class="i">+func StaticTokenSource(t *Token) TokenSource {
</a><a href="#h77-0-271" id="h77-0-271" class="i">+	return staticTokenSource{t}
</a><a href="#h77-0-272" id="h77-0-272" class="i">+}
</a><a href="#h77-0-273" id="h77-0-273" class="i">+
</a><a href="#h77-0-274" id="h77-0-274" class="i">+// staticTokenSource is a TokenSource that always returns the same Token.
</a><a href="#h77-0-275" id="h77-0-275" class="i">+type staticTokenSource struct {
</a><a href="#h77-0-276" id="h77-0-276" class="i">+	t *Token
</a><a href="#h77-0-277" id="h77-0-277" class="i">+}
</a><a href="#h77-0-278" id="h77-0-278" class="i">+
</a><a href="#h77-0-279" id="h77-0-279" class="i">+func (s staticTokenSource) Token() (*Token, error) {
</a><a href="#h77-0-280" id="h77-0-280" class="i">+	return s.t, nil
</a><a href="#h77-0-281" id="h77-0-281" class="i">+}
</a><a href="#h77-0-282" id="h77-0-282" class="i">+
</a><a href="#h77-0-283" id="h77-0-283" class="i">+// HTTPClient is the context key to use with golang.org/x/net/context&#39;s
</a><a href="#h77-0-284" id="h77-0-284" class="i">+// WithValue function to associate an *http.Client value with a context.
</a><a href="#h77-0-285" id="h77-0-285" class="i">+var HTTPClient internal.ContextKey
</a><a href="#h77-0-286" id="h77-0-286" class="i">+
</a><a href="#h77-0-287" id="h77-0-287" class="i">+// NewClient creates an *http.Client from a Context and TokenSource.
</a><a href="#h77-0-288" id="h77-0-288" class="i">+// The returned client is not valid beyond the lifetime of the context.
</a><a href="#h77-0-289" id="h77-0-289" class="i">+//
</a><a href="#h77-0-290" id="h77-0-290" class="i">+// As a special case, if src is nil, a non-OAuth2 client is returned
</a><a href="#h77-0-291" id="h77-0-291" class="i">+// using the provided context. This exists to support related OAuth2
</a><a href="#h77-0-292" id="h77-0-292" class="i">+// packages.
</a><a href="#h77-0-293" id="h77-0-293" class="i">+func NewClient(ctx context.Context, src TokenSource) *http.Client {
</a><a href="#h77-0-294" id="h77-0-294" class="i">+	if src == nil {
</a><a href="#h77-0-295" id="h77-0-295" class="i">+		c, err := internal.ContextClient(ctx)
</a><a href="#h77-0-296" id="h77-0-296" class="i">+		if err != nil {
</a><a href="#h77-0-297" id="h77-0-297" class="i">+			return &amp;http.Client{Transport: internal.ErrorTransport{err}}
</a><a href="#h77-0-298" id="h77-0-298" class="i">+		}
</a><a href="#h77-0-299" id="h77-0-299" class="i">+		return c
</a><a href="#h77-0-300" id="h77-0-300" class="i">+	}
</a><a href="#h77-0-301" id="h77-0-301" class="i">+	return &amp;http.Client{
</a><a href="#h77-0-302" id="h77-0-302" class="i">+		Transport: &amp;Transport{
</a><a href="#h77-0-303" id="h77-0-303" class="i">+			Base:   internal.ContextTransport(ctx),
</a><a href="#h77-0-304" id="h77-0-304" class="i">+			Source: ReuseTokenSource(nil, src),
</a><a href="#h77-0-305" id="h77-0-305" class="i">+		},
</a><a href="#h77-0-306" id="h77-0-306" class="i">+	}
</a><a href="#h77-0-307" id="h77-0-307" class="i">+}
</a><a href="#h77-0-308" id="h77-0-308" class="i">+
</a><a href="#h77-0-309" id="h77-0-309" class="i">+// ReuseTokenSource returns a TokenSource which repeatedly returns the
</a><a href="#h77-0-310" id="h77-0-310" class="i">+// same token as long as it&#39;s valid, starting with t.
</a><a href="#h77-0-311" id="h77-0-311" class="i">+// When its cached token is invalid, a new token is obtained from src.
</a><a href="#h77-0-312" id="h77-0-312" class="i">+//
</a><a href="#h77-0-313" id="h77-0-313" class="i">+// ReuseTokenSource is typically used to reuse tokens from a cache
</a><a href="#h77-0-314" id="h77-0-314" class="i">+// (such as a file on disk) between runs of a program, rather than
</a><a href="#h77-0-315" id="h77-0-315" class="i">+// obtaining new tokens unnecessarily.
</a><a href="#h77-0-316" id="h77-0-316" class="i">+//
</a><a href="#h77-0-317" id="h77-0-317" class="i">+// The initial token t may be nil, in which case the TokenSource is
</a><a href="#h77-0-318" id="h77-0-318" class="i">+// wrapped in a caching version if it isn&#39;t one already. This also
</a><a href="#h77-0-319" id="h77-0-319" class="i">+// means it&#39;s always safe to wrap ReuseTokenSource around any other
</a><a href="#h77-0-320" id="h77-0-320" class="i">+// TokenSource without adverse effects.
</a><a href="#h77-0-321" id="h77-0-321" class="i">+func ReuseTokenSource(t *Token, src TokenSource) TokenSource {
</a><a href="#h77-0-322" id="h77-0-322" class="i">+	// Don&#39;t wrap a reuseTokenSource in itself. That would work,
</a><a href="#h77-0-323" id="h77-0-323" class="i">+	// but cause an unnecessary number of mutex operations.
</a><a href="#h77-0-324" id="h77-0-324" class="i">+	// Just build the equivalent one.
</a><a href="#h77-0-325" id="h77-0-325" class="i">+	if rt, ok := src.(*reuseTokenSource); ok {
</a><a href="#h77-0-326" id="h77-0-326" class="i">+		if t == nil {
</a><a href="#h77-0-327" id="h77-0-327" class="i">+			// Just use it directly.
</a><a href="#h77-0-328" id="h77-0-328" class="i">+			return rt
</a><a href="#h77-0-329" id="h77-0-329" class="i">+		}
</a><a href="#h77-0-330" id="h77-0-330" class="i">+		src = rt.new
</a><a href="#h77-0-331" id="h77-0-331" class="i">+	}
</a><a href="#h77-0-332" id="h77-0-332" class="i">+	return &amp;reuseTokenSource{
</a><a href="#h77-0-333" id="h77-0-333" class="i">+		t:   t,
</a><a href="#h77-0-334" id="h77-0-334" class="i">+		new: src,
</a><a href="#h77-0-335" id="h77-0-335" class="i">+	}
</a><a href="#h77-0-336" id="h77-0-336" class="i">+}
</a><b>diff --git a/<a id="h78" href="../file/vendor/golang.org/x/oauth2/token.go">vendor/golang.org/x/oauth2/token.go</a> b/<a href="../file/vendor/golang.org/x/oauth2/token.go">vendor/golang.org/x/oauth2/token.go</a></b>
<a href="#h78-0" id="h78-0" class="h">@@ -0,0 +1,158 @@
</a><a href="#h78-0-0" id="h78-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h78-0-1" id="h78-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h78-0-2" id="h78-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h78-0-3" id="h78-0-3" class="i">+
</a><a href="#h78-0-4" id="h78-0-4" class="i">+package oauth2
</a><a href="#h78-0-5" id="h78-0-5" class="i">+
</a><a href="#h78-0-6" id="h78-0-6" class="i">+import (
</a><a href="#h78-0-7" id="h78-0-7" class="i">+	&quot;net/http&quot;
</a><a href="#h78-0-8" id="h78-0-8" class="i">+	&quot;net/url&quot;
</a><a href="#h78-0-9" id="h78-0-9" class="i">+	&quot;strconv&quot;
</a><a href="#h78-0-10" id="h78-0-10" class="i">+	&quot;strings&quot;
</a><a href="#h78-0-11" id="h78-0-11" class="i">+	&quot;time&quot;
</a><a href="#h78-0-12" id="h78-0-12" class="i">+
</a><a href="#h78-0-13" id="h78-0-13" class="i">+	&quot;golang.org/x/net/context&quot;
</a><a href="#h78-0-14" id="h78-0-14" class="i">+	&quot;golang.org/x/oauth2/internal&quot;
</a><a href="#h78-0-15" id="h78-0-15" class="i">+)
</a><a href="#h78-0-16" id="h78-0-16" class="i">+
</a><a href="#h78-0-17" id="h78-0-17" class="i">+// expiryDelta determines how earlier a token should be considered
</a><a href="#h78-0-18" id="h78-0-18" class="i">+// expired than its actual expiration time. It is used to avoid late
</a><a href="#h78-0-19" id="h78-0-19" class="i">+// expirations due to client-server time mismatches.
</a><a href="#h78-0-20" id="h78-0-20" class="i">+const expiryDelta = 10 * time.Second
</a><a href="#h78-0-21" id="h78-0-21" class="i">+
</a><a href="#h78-0-22" id="h78-0-22" class="i">+// Token represents the crendentials used to authorize
</a><a href="#h78-0-23" id="h78-0-23" class="i">+// the requests to access protected resources on the OAuth 2.0
</a><a href="#h78-0-24" id="h78-0-24" class="i">+// provider&#39;s backend.
</a><a href="#h78-0-25" id="h78-0-25" class="i">+//
</a><a href="#h78-0-26" id="h78-0-26" class="i">+// Most users of this package should not access fields of Token
</a><a href="#h78-0-27" id="h78-0-27" class="i">+// directly. They&#39;re exported mostly for use by related packages
</a><a href="#h78-0-28" id="h78-0-28" class="i">+// implementing derivative OAuth2 flows.
</a><a href="#h78-0-29" id="h78-0-29" class="i">+type Token struct {
</a><a href="#h78-0-30" id="h78-0-30" class="i">+	// AccessToken is the token that authorizes and authenticates
</a><a href="#h78-0-31" id="h78-0-31" class="i">+	// the requests.
</a><a href="#h78-0-32" id="h78-0-32" class="i">+	AccessToken string `json:&quot;access_token&quot;`
</a><a href="#h78-0-33" id="h78-0-33" class="i">+
</a><a href="#h78-0-34" id="h78-0-34" class="i">+	// TokenType is the type of token.
</a><a href="#h78-0-35" id="h78-0-35" class="i">+	// The Type method returns either this or &quot;Bearer&quot;, the default.
</a><a href="#h78-0-36" id="h78-0-36" class="i">+	TokenType string `json:&quot;token_type,omitempty&quot;`
</a><a href="#h78-0-37" id="h78-0-37" class="i">+
</a><a href="#h78-0-38" id="h78-0-38" class="i">+	// RefreshToken is a token that&#39;s used by the application
</a><a href="#h78-0-39" id="h78-0-39" class="i">+	// (as opposed to the user) to refresh the access token
</a><a href="#h78-0-40" id="h78-0-40" class="i">+	// if it expires.
</a><a href="#h78-0-41" id="h78-0-41" class="i">+	RefreshToken string `json:&quot;refresh_token,omitempty&quot;`
</a><a href="#h78-0-42" id="h78-0-42" class="i">+
</a><a href="#h78-0-43" id="h78-0-43" class="i">+	// Expiry is the optional expiration time of the access token.
</a><a href="#h78-0-44" id="h78-0-44" class="i">+	//
</a><a href="#h78-0-45" id="h78-0-45" class="i">+	// If zero, TokenSource implementations will reuse the same
</a><a href="#h78-0-46" id="h78-0-46" class="i">+	// token forever and RefreshToken or equivalent
</a><a href="#h78-0-47" id="h78-0-47" class="i">+	// mechanisms for that TokenSource will not be used.
</a><a href="#h78-0-48" id="h78-0-48" class="i">+	Expiry time.Time `json:&quot;expiry,omitempty&quot;`
</a><a href="#h78-0-49" id="h78-0-49" class="i">+
</a><a href="#h78-0-50" id="h78-0-50" class="i">+	// raw optionally contains extra metadata from the server
</a><a href="#h78-0-51" id="h78-0-51" class="i">+	// when updating a token.
</a><a href="#h78-0-52" id="h78-0-52" class="i">+	raw interface{}
</a><a href="#h78-0-53" id="h78-0-53" class="i">+}
</a><a href="#h78-0-54" id="h78-0-54" class="i">+
</a><a href="#h78-0-55" id="h78-0-55" class="i">+// Type returns t.TokenType if non-empty, else &quot;Bearer&quot;.
</a><a href="#h78-0-56" id="h78-0-56" class="i">+func (t *Token) Type() string {
</a><a href="#h78-0-57" id="h78-0-57" class="i">+	if strings.EqualFold(t.TokenType, &quot;bearer&quot;) {
</a><a href="#h78-0-58" id="h78-0-58" class="i">+		return &quot;Bearer&quot;
</a><a href="#h78-0-59" id="h78-0-59" class="i">+	}
</a><a href="#h78-0-60" id="h78-0-60" class="i">+	if strings.EqualFold(t.TokenType, &quot;mac&quot;) {
</a><a href="#h78-0-61" id="h78-0-61" class="i">+		return &quot;MAC&quot;
</a><a href="#h78-0-62" id="h78-0-62" class="i">+	}
</a><a href="#h78-0-63" id="h78-0-63" class="i">+	if strings.EqualFold(t.TokenType, &quot;basic&quot;) {
</a><a href="#h78-0-64" id="h78-0-64" class="i">+		return &quot;Basic&quot;
</a><a href="#h78-0-65" id="h78-0-65" class="i">+	}
</a><a href="#h78-0-66" id="h78-0-66" class="i">+	if t.TokenType != &quot;&quot; {
</a><a href="#h78-0-67" id="h78-0-67" class="i">+		return t.TokenType
</a><a href="#h78-0-68" id="h78-0-68" class="i">+	}
</a><a href="#h78-0-69" id="h78-0-69" class="i">+	return &quot;Bearer&quot;
</a><a href="#h78-0-70" id="h78-0-70" class="i">+}
</a><a href="#h78-0-71" id="h78-0-71" class="i">+
</a><a href="#h78-0-72" id="h78-0-72" class="i">+// SetAuthHeader sets the Authorization header to r using the access
</a><a href="#h78-0-73" id="h78-0-73" class="i">+// token in t.
</a><a href="#h78-0-74" id="h78-0-74" class="i">+//
</a><a href="#h78-0-75" id="h78-0-75" class="i">+// This method is unnecessary when using Transport or an HTTP Client
</a><a href="#h78-0-76" id="h78-0-76" class="i">+// returned by this package.
</a><a href="#h78-0-77" id="h78-0-77" class="i">+func (t *Token) SetAuthHeader(r *http.Request) {
</a><a href="#h78-0-78" id="h78-0-78" class="i">+	r.Header.Set(&quot;Authorization&quot;, t.Type()+&quot; &quot;+t.AccessToken)
</a><a href="#h78-0-79" id="h78-0-79" class="i">+}
</a><a href="#h78-0-80" id="h78-0-80" class="i">+
</a><a href="#h78-0-81" id="h78-0-81" class="i">+// WithExtra returns a new Token that&#39;s a clone of t, but using the
</a><a href="#h78-0-82" id="h78-0-82" class="i">+// provided raw extra map. This is only intended for use by packages
</a><a href="#h78-0-83" id="h78-0-83" class="i">+// implementing derivative OAuth2 flows.
</a><a href="#h78-0-84" id="h78-0-84" class="i">+func (t *Token) WithExtra(extra interface{}) *Token {
</a><a href="#h78-0-85" id="h78-0-85" class="i">+	t2 := new(Token)
</a><a href="#h78-0-86" id="h78-0-86" class="i">+	*t2 = *t
</a><a href="#h78-0-87" id="h78-0-87" class="i">+	t2.raw = extra
</a><a href="#h78-0-88" id="h78-0-88" class="i">+	return t2
</a><a href="#h78-0-89" id="h78-0-89" class="i">+}
</a><a href="#h78-0-90" id="h78-0-90" class="i">+
</a><a href="#h78-0-91" id="h78-0-91" class="i">+// Extra returns an extra field.
</a><a href="#h78-0-92" id="h78-0-92" class="i">+// Extra fields are key-value pairs returned by the server as a
</a><a href="#h78-0-93" id="h78-0-93" class="i">+// part of the token retrieval response.
</a><a href="#h78-0-94" id="h78-0-94" class="i">+func (t *Token) Extra(key string) interface{} {
</a><a href="#h78-0-95" id="h78-0-95" class="i">+	if raw, ok := t.raw.(map[string]interface{}); ok {
</a><a href="#h78-0-96" id="h78-0-96" class="i">+		return raw[key]
</a><a href="#h78-0-97" id="h78-0-97" class="i">+	}
</a><a href="#h78-0-98" id="h78-0-98" class="i">+
</a><a href="#h78-0-99" id="h78-0-99" class="i">+	vals, ok := t.raw.(url.Values)
</a><a href="#h78-0-100" id="h78-0-100" class="i">+	if !ok {
</a><a href="#h78-0-101" id="h78-0-101" class="i">+		return nil
</a><a href="#h78-0-102" id="h78-0-102" class="i">+	}
</a><a href="#h78-0-103" id="h78-0-103" class="i">+
</a><a href="#h78-0-104" id="h78-0-104" class="i">+	v := vals.Get(key)
</a><a href="#h78-0-105" id="h78-0-105" class="i">+	switch s := strings.TrimSpace(v); strings.Count(s, &quot;.&quot;) {
</a><a href="#h78-0-106" id="h78-0-106" class="i">+	case 0: // Contains no &quot;.&quot;; try to parse as int
</a><a href="#h78-0-107" id="h78-0-107" class="i">+		if i, err := strconv.ParseInt(s, 10, 64); err == nil {
</a><a href="#h78-0-108" id="h78-0-108" class="i">+			return i
</a><a href="#h78-0-109" id="h78-0-109" class="i">+		}
</a><a href="#h78-0-110" id="h78-0-110" class="i">+	case 1: // Contains a single &quot;.&quot;; try to parse as float
</a><a href="#h78-0-111" id="h78-0-111" class="i">+		if f, err := strconv.ParseFloat(s, 64); err == nil {
</a><a href="#h78-0-112" id="h78-0-112" class="i">+			return f
</a><a href="#h78-0-113" id="h78-0-113" class="i">+		}
</a><a href="#h78-0-114" id="h78-0-114" class="i">+	}
</a><a href="#h78-0-115" id="h78-0-115" class="i">+
</a><a href="#h78-0-116" id="h78-0-116" class="i">+	return v
</a><a href="#h78-0-117" id="h78-0-117" class="i">+}
</a><a href="#h78-0-118" id="h78-0-118" class="i">+
</a><a href="#h78-0-119" id="h78-0-119" class="i">+// expired reports whether the token is expired.
</a><a href="#h78-0-120" id="h78-0-120" class="i">+// t must be non-nil.
</a><a href="#h78-0-121" id="h78-0-121" class="i">+func (t *Token) expired() bool {
</a><a href="#h78-0-122" id="h78-0-122" class="i">+	if t.Expiry.IsZero() {
</a><a href="#h78-0-123" id="h78-0-123" class="i">+		return false
</a><a href="#h78-0-124" id="h78-0-124" class="i">+	}
</a><a href="#h78-0-125" id="h78-0-125" class="i">+	return t.Expiry.Add(-expiryDelta).Before(time.Now())
</a><a href="#h78-0-126" id="h78-0-126" class="i">+}
</a><a href="#h78-0-127" id="h78-0-127" class="i">+
</a><a href="#h78-0-128" id="h78-0-128" class="i">+// Valid reports whether t is non-nil, has an AccessToken, and is not expired.
</a><a href="#h78-0-129" id="h78-0-129" class="i">+func (t *Token) Valid() bool {
</a><a href="#h78-0-130" id="h78-0-130" class="i">+	return t != nil &amp;&amp; t.AccessToken != &quot;&quot; &amp;&amp; !t.expired()
</a><a href="#h78-0-131" id="h78-0-131" class="i">+}
</a><a href="#h78-0-132" id="h78-0-132" class="i">+
</a><a href="#h78-0-133" id="h78-0-133" class="i">+// tokenFromInternal maps an *internal.Token struct into
</a><a href="#h78-0-134" id="h78-0-134" class="i">+// a *Token struct.
</a><a href="#h78-0-135" id="h78-0-135" class="i">+func tokenFromInternal(t *internal.Token) *Token {
</a><a href="#h78-0-136" id="h78-0-136" class="i">+	if t == nil {
</a><a href="#h78-0-137" id="h78-0-137" class="i">+		return nil
</a><a href="#h78-0-138" id="h78-0-138" class="i">+	}
</a><a href="#h78-0-139" id="h78-0-139" class="i">+	return &amp;Token{
</a><a href="#h78-0-140" id="h78-0-140" class="i">+		AccessToken:  t.AccessToken,
</a><a href="#h78-0-141" id="h78-0-141" class="i">+		TokenType:    t.TokenType,
</a><a href="#h78-0-142" id="h78-0-142" class="i">+		RefreshToken: t.RefreshToken,
</a><a href="#h78-0-143" id="h78-0-143" class="i">+		Expiry:       t.Expiry,
</a><a href="#h78-0-144" id="h78-0-144" class="i">+		raw:          t.Raw,
</a><a href="#h78-0-145" id="h78-0-145" class="i">+	}
</a><a href="#h78-0-146" id="h78-0-146" class="i">+}
</a><a href="#h78-0-147" id="h78-0-147" class="i">+
</a><a href="#h78-0-148" id="h78-0-148" class="i">+// retrieveToken takes a *Config and uses that to retrieve an *internal.Token.
</a><a href="#h78-0-149" id="h78-0-149" class="i">+// This token is then mapped from *internal.Token into an *oauth2.Token which is returned along
</a><a href="#h78-0-150" id="h78-0-150" class="i">+// with an error..
</a><a href="#h78-0-151" id="h78-0-151" class="i">+func retrieveToken(ctx context.Context, c *Config, v url.Values) (*Token, error) {
</a><a href="#h78-0-152" id="h78-0-152" class="i">+	tk, err := internal.RetrieveToken(ctx, c.ClientID, c.ClientSecret, c.Endpoint.TokenURL, v)
</a><a href="#h78-0-153" id="h78-0-153" class="i">+	if err != nil {
</a><a href="#h78-0-154" id="h78-0-154" class="i">+		return nil, err
</a><a href="#h78-0-155" id="h78-0-155" class="i">+	}
</a><a href="#h78-0-156" id="h78-0-156" class="i">+	return tokenFromInternal(tk), nil
</a><a href="#h78-0-157" id="h78-0-157" class="i">+}
</a><b>diff --git a/<a id="h79" href="../file/vendor/golang.org/x/oauth2/transport.go">vendor/golang.org/x/oauth2/transport.go</a> b/<a href="../file/vendor/golang.org/x/oauth2/transport.go">vendor/golang.org/x/oauth2/transport.go</a></b>
<a href="#h79-0" id="h79-0" class="h">@@ -0,0 +1,132 @@
</a><a href="#h79-0-0" id="h79-0-0" class="i">+// Copyright 2014 The Go Authors. All rights reserved.
</a><a href="#h79-0-1" id="h79-0-1" class="i">+// Use of this source code is governed by a BSD-style
</a><a href="#h79-0-2" id="h79-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h79-0-3" id="h79-0-3" class="i">+
</a><a href="#h79-0-4" id="h79-0-4" class="i">+package oauth2
</a><a href="#h79-0-5" id="h79-0-5" class="i">+
</a><a href="#h79-0-6" id="h79-0-6" class="i">+import (
</a><a href="#h79-0-7" id="h79-0-7" class="i">+	&quot;errors&quot;
</a><a href="#h79-0-8" id="h79-0-8" class="i">+	&quot;io&quot;
</a><a href="#h79-0-9" id="h79-0-9" class="i">+	&quot;net/http&quot;
</a><a href="#h79-0-10" id="h79-0-10" class="i">+	&quot;sync&quot;
</a><a href="#h79-0-11" id="h79-0-11" class="i">+)
</a><a href="#h79-0-12" id="h79-0-12" class="i">+
</a><a href="#h79-0-13" id="h79-0-13" class="i">+// Transport is an http.RoundTripper that makes OAuth 2.0 HTTP requests,
</a><a href="#h79-0-14" id="h79-0-14" class="i">+// wrapping a base RoundTripper and adding an Authorization header
</a><a href="#h79-0-15" id="h79-0-15" class="i">+// with a token from the supplied Sources.
</a><a href="#h79-0-16" id="h79-0-16" class="i">+//
</a><a href="#h79-0-17" id="h79-0-17" class="i">+// Transport is a low-level mechanism. Most code will use the
</a><a href="#h79-0-18" id="h79-0-18" class="i">+// higher-level Config.Client method instead.
</a><a href="#h79-0-19" id="h79-0-19" class="i">+type Transport struct {
</a><a href="#h79-0-20" id="h79-0-20" class="i">+	// Source supplies the token to add to outgoing requests&#39;
</a><a href="#h79-0-21" id="h79-0-21" class="i">+	// Authorization headers.
</a><a href="#h79-0-22" id="h79-0-22" class="i">+	Source TokenSource
</a><a href="#h79-0-23" id="h79-0-23" class="i">+
</a><a href="#h79-0-24" id="h79-0-24" class="i">+	// Base is the base RoundTripper used to make HTTP requests.
</a><a href="#h79-0-25" id="h79-0-25" class="i">+	// If nil, http.DefaultTransport is used.
</a><a href="#h79-0-26" id="h79-0-26" class="i">+	Base http.RoundTripper
</a><a href="#h79-0-27" id="h79-0-27" class="i">+
</a><a href="#h79-0-28" id="h79-0-28" class="i">+	mu     sync.Mutex                      // guards modReq
</a><a href="#h79-0-29" id="h79-0-29" class="i">+	modReq map[*http.Request]*http.Request // original -&gt; modified
</a><a href="#h79-0-30" id="h79-0-30" class="i">+}
</a><a href="#h79-0-31" id="h79-0-31" class="i">+
</a><a href="#h79-0-32" id="h79-0-32" class="i">+// RoundTrip authorizes and authenticates the request with an
</a><a href="#h79-0-33" id="h79-0-33" class="i">+// access token. If no token exists or token is expired,
</a><a href="#h79-0-34" id="h79-0-34" class="i">+// tries to refresh/fetch a new token.
</a><a href="#h79-0-35" id="h79-0-35" class="i">+func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
</a><a href="#h79-0-36" id="h79-0-36" class="i">+	if t.Source == nil {
</a><a href="#h79-0-37" id="h79-0-37" class="i">+		return nil, errors.New(&quot;oauth2: Transport&#39;s Source is nil&quot;)
</a><a href="#h79-0-38" id="h79-0-38" class="i">+	}
</a><a href="#h79-0-39" id="h79-0-39" class="i">+	token, err := t.Source.Token()
</a><a href="#h79-0-40" id="h79-0-40" class="i">+	if err != nil {
</a><a href="#h79-0-41" id="h79-0-41" class="i">+		return nil, err
</a><a href="#h79-0-42" id="h79-0-42" class="i">+	}
</a><a href="#h79-0-43" id="h79-0-43" class="i">+
</a><a href="#h79-0-44" id="h79-0-44" class="i">+	req2 := cloneRequest(req) // per RoundTripper contract
</a><a href="#h79-0-45" id="h79-0-45" class="i">+	token.SetAuthHeader(req2)
</a><a href="#h79-0-46" id="h79-0-46" class="i">+	t.setModReq(req, req2)
</a><a href="#h79-0-47" id="h79-0-47" class="i">+	res, err := t.base().RoundTrip(req2)
</a><a href="#h79-0-48" id="h79-0-48" class="i">+	if err != nil {
</a><a href="#h79-0-49" id="h79-0-49" class="i">+		t.setModReq(req, nil)
</a><a href="#h79-0-50" id="h79-0-50" class="i">+		return nil, err
</a><a href="#h79-0-51" id="h79-0-51" class="i">+	}
</a><a href="#h79-0-52" id="h79-0-52" class="i">+	res.Body = &amp;onEOFReader{
</a><a href="#h79-0-53" id="h79-0-53" class="i">+		rc: res.Body,
</a><a href="#h79-0-54" id="h79-0-54" class="i">+		fn: func() { t.setModReq(req, nil) },
</a><a href="#h79-0-55" id="h79-0-55" class="i">+	}
</a><a href="#h79-0-56" id="h79-0-56" class="i">+	return res, nil
</a><a href="#h79-0-57" id="h79-0-57" class="i">+}
</a><a href="#h79-0-58" id="h79-0-58" class="i">+
</a><a href="#h79-0-59" id="h79-0-59" class="i">+// CancelRequest cancels an in-flight request by closing its connection.
</a><a href="#h79-0-60" id="h79-0-60" class="i">+func (t *Transport) CancelRequest(req *http.Request) {
</a><a href="#h79-0-61" id="h79-0-61" class="i">+	type canceler interface {
</a><a href="#h79-0-62" id="h79-0-62" class="i">+		CancelRequest(*http.Request)
</a><a href="#h79-0-63" id="h79-0-63" class="i">+	}
</a><a href="#h79-0-64" id="h79-0-64" class="i">+	if cr, ok := t.base().(canceler); ok {
</a><a href="#h79-0-65" id="h79-0-65" class="i">+		t.mu.Lock()
</a><a href="#h79-0-66" id="h79-0-66" class="i">+		modReq := t.modReq[req]
</a><a href="#h79-0-67" id="h79-0-67" class="i">+		delete(t.modReq, req)
</a><a href="#h79-0-68" id="h79-0-68" class="i">+		t.mu.Unlock()
</a><a href="#h79-0-69" id="h79-0-69" class="i">+		cr.CancelRequest(modReq)
</a><a href="#h79-0-70" id="h79-0-70" class="i">+	}
</a><a href="#h79-0-71" id="h79-0-71" class="i">+}
</a><a href="#h79-0-72" id="h79-0-72" class="i">+
</a><a href="#h79-0-73" id="h79-0-73" class="i">+func (t *Transport) base() http.RoundTripper {
</a><a href="#h79-0-74" id="h79-0-74" class="i">+	if t.Base != nil {
</a><a href="#h79-0-75" id="h79-0-75" class="i">+		return t.Base
</a><a href="#h79-0-76" id="h79-0-76" class="i">+	}
</a><a href="#h79-0-77" id="h79-0-77" class="i">+	return http.DefaultTransport
</a><a href="#h79-0-78" id="h79-0-78" class="i">+}
</a><a href="#h79-0-79" id="h79-0-79" class="i">+
</a><a href="#h79-0-80" id="h79-0-80" class="i">+func (t *Transport) setModReq(orig, mod *http.Request) {
</a><a href="#h79-0-81" id="h79-0-81" class="i">+	t.mu.Lock()
</a><a href="#h79-0-82" id="h79-0-82" class="i">+	defer t.mu.Unlock()
</a><a href="#h79-0-83" id="h79-0-83" class="i">+	if t.modReq == nil {
</a><a href="#h79-0-84" id="h79-0-84" class="i">+		t.modReq = make(map[*http.Request]*http.Request)
</a><a href="#h79-0-85" id="h79-0-85" class="i">+	}
</a><a href="#h79-0-86" id="h79-0-86" class="i">+	if mod == nil {
</a><a href="#h79-0-87" id="h79-0-87" class="i">+		delete(t.modReq, orig)
</a><a href="#h79-0-88" id="h79-0-88" class="i">+	} else {
</a><a href="#h79-0-89" id="h79-0-89" class="i">+		t.modReq[orig] = mod
</a><a href="#h79-0-90" id="h79-0-90" class="i">+	}
</a><a href="#h79-0-91" id="h79-0-91" class="i">+}
</a><a href="#h79-0-92" id="h79-0-92" class="i">+
</a><a href="#h79-0-93" id="h79-0-93" class="i">+// cloneRequest returns a clone of the provided *http.Request.
</a><a href="#h79-0-94" id="h79-0-94" class="i">+// The clone is a shallow copy of the struct and its Header map.
</a><a href="#h79-0-95" id="h79-0-95" class="i">+func cloneRequest(r *http.Request) *http.Request {
</a><a href="#h79-0-96" id="h79-0-96" class="i">+	// shallow copy of the struct
</a><a href="#h79-0-97" id="h79-0-97" class="i">+	r2 := new(http.Request)
</a><a href="#h79-0-98" id="h79-0-98" class="i">+	*r2 = *r
</a><a href="#h79-0-99" id="h79-0-99" class="i">+	// deep copy of the Header
</a><a href="#h79-0-100" id="h79-0-100" class="i">+	r2.Header = make(http.Header, len(r.Header))
</a><a href="#h79-0-101" id="h79-0-101" class="i">+	for k, s := range r.Header {
</a><a href="#h79-0-102" id="h79-0-102" class="i">+		r2.Header[k] = append([]string(nil), s...)
</a><a href="#h79-0-103" id="h79-0-103" class="i">+	}
</a><a href="#h79-0-104" id="h79-0-104" class="i">+	return r2
</a><a href="#h79-0-105" id="h79-0-105" class="i">+}
</a><a href="#h79-0-106" id="h79-0-106" class="i">+
</a><a href="#h79-0-107" id="h79-0-107" class="i">+type onEOFReader struct {
</a><a href="#h79-0-108" id="h79-0-108" class="i">+	rc io.ReadCloser
</a><a href="#h79-0-109" id="h79-0-109" class="i">+	fn func()
</a><a href="#h79-0-110" id="h79-0-110" class="i">+}
</a><a href="#h79-0-111" id="h79-0-111" class="i">+
</a><a href="#h79-0-112" id="h79-0-112" class="i">+func (r *onEOFReader) Read(p []byte) (n int, err error) {
</a><a href="#h79-0-113" id="h79-0-113" class="i">+	n, err = r.rc.Read(p)
</a><a href="#h79-0-114" id="h79-0-114" class="i">+	if err == io.EOF {
</a><a href="#h79-0-115" id="h79-0-115" class="i">+		r.runFunc()
</a><a href="#h79-0-116" id="h79-0-116" class="i">+	}
</a><a href="#h79-0-117" id="h79-0-117" class="i">+	return
</a><a href="#h79-0-118" id="h79-0-118" class="i">+}
</a><a href="#h79-0-119" id="h79-0-119" class="i">+
</a><a href="#h79-0-120" id="h79-0-120" class="i">+func (r *onEOFReader) Close() error {
</a><a href="#h79-0-121" id="h79-0-121" class="i">+	err := r.rc.Close()
</a><a href="#h79-0-122" id="h79-0-122" class="i">+	r.runFunc()
</a><a href="#h79-0-123" id="h79-0-123" class="i">+	return err
</a><a href="#h79-0-124" id="h79-0-124" class="i">+}
</a><a href="#h79-0-125" id="h79-0-125" class="i">+
</a><a href="#h79-0-126" id="h79-0-126" class="i">+func (r *onEOFReader) runFunc() {
</a><a href="#h79-0-127" id="h79-0-127" class="i">+	if fn := r.fn; fn != nil {
</a><a href="#h79-0-128" id="h79-0-128" class="i">+		fn()
</a><a href="#h79-0-129" id="h79-0-129" class="i">+		r.fn = nil
</a><a href="#h79-0-130" id="h79-0-130" class="i">+	}
</a><a href="#h79-0-131" id="h79-0-131" class="i">+}
</a><b>diff --git a/<a id="h80" href="../file/vendor/gopkg.in/check.v1/LICENSE">vendor/gopkg.in/check.v1/LICENSE</a> b/<a href="../file/vendor/gopkg.in/check.v1/LICENSE">vendor/gopkg.in/check.v1/LICENSE</a></b>
<a href="#h80-0" id="h80-0" class="h">@@ -0,0 +1,25 @@
</a><a href="#h80-0-0" id="h80-0-0" class="i">+Gocheck - A rich testing framework for Go
</a><a href="#h80-0-1" id="h80-0-1" class="i">+ 
</a><a href="#h80-0-2" id="h80-0-2" class="i">+Copyright (c) 2010-2013 Gustavo Niemeyer &lt;gustavo@niemeyer.net&gt;
</a><a href="#h80-0-3" id="h80-0-3" class="i">+
</a><a href="#h80-0-4" id="h80-0-4" class="i">+All rights reserved.
</a><a href="#h80-0-5" id="h80-0-5" class="i">+
</a><a href="#h80-0-6" id="h80-0-6" class="i">+Redistribution and use in source and binary forms, with or without
</a><a href="#h80-0-7" id="h80-0-7" class="i">+modification, are permitted provided that the following conditions are met: 
</a><a href="#h80-0-8" id="h80-0-8" class="i">+
</a><a href="#h80-0-9" id="h80-0-9" class="i">+1. Redistributions of source code must retain the above copyright notice, this
</a><a href="#h80-0-10" id="h80-0-10" class="i">+   list of conditions and the following disclaimer. 
</a><a href="#h80-0-11" id="h80-0-11" class="i">+2. Redistributions in binary form must reproduce the above copyright notice,
</a><a href="#h80-0-12" id="h80-0-12" class="i">+   this list of conditions and the following disclaimer in the documentation
</a><a href="#h80-0-13" id="h80-0-13" class="i">+   and/or other materials provided with the distribution. 
</a><a href="#h80-0-14" id="h80-0-14" class="i">+
</a><a href="#h80-0-15" id="h80-0-15" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</a><a href="#h80-0-16" id="h80-0-16" class="i">+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
</a><a href="#h80-0-17" id="h80-0-17" class="i">+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
</a><a href="#h80-0-18" id="h80-0-18" class="i">+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
</a><a href="#h80-0-19" id="h80-0-19" class="i">+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
</a><a href="#h80-0-20" id="h80-0-20" class="i">+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
</a><a href="#h80-0-21" id="h80-0-21" class="i">+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
</a><a href="#h80-0-22" id="h80-0-22" class="i">+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h80-0-23" id="h80-0-23" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
</a><a href="#h80-0-24" id="h80-0-24" class="i">+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><b>diff --git a/<a id="h81" href="../file/vendor/gopkg.in/check.v1/README.md">vendor/gopkg.in/check.v1/README.md</a> b/<a href="../file/vendor/gopkg.in/check.v1/README.md">vendor/gopkg.in/check.v1/README.md</a></b>
<a href="#h81-0" id="h81-0" class="h">@@ -0,0 +1,20 @@
</a><a href="#h81-0-0" id="h81-0-0" class="i">+Instructions
</a><a href="#h81-0-1" id="h81-0-1" class="i">+============
</a><a href="#h81-0-2" id="h81-0-2" class="i">+
</a><a href="#h81-0-3" id="h81-0-3" class="i">+Install the package with:
</a><a href="#h81-0-4" id="h81-0-4" class="i">+
</a><a href="#h81-0-5" id="h81-0-5" class="i">+    go get gopkg.in/check.v1
</a><a href="#h81-0-6" id="h81-0-6" class="i">+    
</a><a href="#h81-0-7" id="h81-0-7" class="i">+Import it with:
</a><a href="#h81-0-8" id="h81-0-8" class="i">+
</a><a href="#h81-0-9" id="h81-0-9" class="i">+    import &quot;gopkg.in/check.v1&quot;
</a><a href="#h81-0-10" id="h81-0-10" class="i">+
</a><a href="#h81-0-11" id="h81-0-11" class="i">+and use _check_ as the package name inside the code.
</a><a href="#h81-0-12" id="h81-0-12" class="i">+
</a><a href="#h81-0-13" id="h81-0-13" class="i">+For more details, visit the project page:
</a><a href="#h81-0-14" id="h81-0-14" class="i">+
</a><a href="#h81-0-15" id="h81-0-15" class="i">+* http://labix.org/gocheck
</a><a href="#h81-0-16" id="h81-0-16" class="i">+
</a><a href="#h81-0-17" id="h81-0-17" class="i">+and the API documentation:
</a><a href="#h81-0-18" id="h81-0-18" class="i">+
</a><a href="#h81-0-19" id="h81-0-19" class="i">+* https://gopkg.in/check.v1
</a><b>diff --git a/<a id="h82" href="../file/vendor/gopkg.in/check.v1/TODO">vendor/gopkg.in/check.v1/TODO</a> b/<a href="../file/vendor/gopkg.in/check.v1/TODO">vendor/gopkg.in/check.v1/TODO</a></b>
<a href="#h82-0" id="h82-0" class="h">@@ -0,0 +1,2 @@
</a><a href="#h82-0-0" id="h82-0-0" class="i">+- Assert(slice, Contains, item)
</a><a href="#h82-0-1" id="h82-0-1" class="i">+- Parallel test support
</a><b>diff --git a/<a id="h83" href="../file/vendor/gopkg.in/check.v1/benchmark.go">vendor/gopkg.in/check.v1/benchmark.go</a> b/<a href="../file/vendor/gopkg.in/check.v1/benchmark.go">vendor/gopkg.in/check.v1/benchmark.go</a></b>
<a href="#h83-0" id="h83-0" class="h">@@ -0,0 +1,187 @@
</a><a href="#h83-0-0" id="h83-0-0" class="i">+// Copyright (c) 2012 The Go Authors. All rights reserved.
</a><a href="#h83-0-1" id="h83-0-1" class="i">+// 
</a><a href="#h83-0-2" id="h83-0-2" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h83-0-3" id="h83-0-3" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h83-0-4" id="h83-0-4" class="i">+// met:
</a><a href="#h83-0-5" id="h83-0-5" class="i">+// 
</a><a href="#h83-0-6" id="h83-0-6" class="i">+//    * Redistributions of source code must retain the above copyright
</a><a href="#h83-0-7" id="h83-0-7" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h83-0-8" id="h83-0-8" class="i">+//    * Redistributions in binary form must reproduce the above
</a><a href="#h83-0-9" id="h83-0-9" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h83-0-10" id="h83-0-10" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h83-0-11" id="h83-0-11" class="i">+// distribution.
</a><a href="#h83-0-12" id="h83-0-12" class="i">+//    * Neither the name of Google Inc. nor the names of its
</a><a href="#h83-0-13" id="h83-0-13" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h83-0-14" id="h83-0-14" class="i">+// this software without specific prior written permission.
</a><a href="#h83-0-15" id="h83-0-15" class="i">+// 
</a><a href="#h83-0-16" id="h83-0-16" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h83-0-17" id="h83-0-17" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h83-0-18" id="h83-0-18" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h83-0-19" id="h83-0-19" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h83-0-20" id="h83-0-20" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h83-0-21" id="h83-0-21" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h83-0-22" id="h83-0-22" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h83-0-23" id="h83-0-23" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h83-0-24" id="h83-0-24" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h83-0-25" id="h83-0-25" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h83-0-26" id="h83-0-26" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h83-0-27" id="h83-0-27" class="i">+
</a><a href="#h83-0-28" id="h83-0-28" class="i">+package check
</a><a href="#h83-0-29" id="h83-0-29" class="i">+
</a><a href="#h83-0-30" id="h83-0-30" class="i">+import (
</a><a href="#h83-0-31" id="h83-0-31" class="i">+	&quot;fmt&quot;
</a><a href="#h83-0-32" id="h83-0-32" class="i">+	&quot;runtime&quot;
</a><a href="#h83-0-33" id="h83-0-33" class="i">+	&quot;time&quot;
</a><a href="#h83-0-34" id="h83-0-34" class="i">+)
</a><a href="#h83-0-35" id="h83-0-35" class="i">+
</a><a href="#h83-0-36" id="h83-0-36" class="i">+var memStats runtime.MemStats
</a><a href="#h83-0-37" id="h83-0-37" class="i">+
</a><a href="#h83-0-38" id="h83-0-38" class="i">+// testingB is a type passed to Benchmark functions to manage benchmark
</a><a href="#h83-0-39" id="h83-0-39" class="i">+// timing and to specify the number of iterations to run.
</a><a href="#h83-0-40" id="h83-0-40" class="i">+type timer struct {
</a><a href="#h83-0-41" id="h83-0-41" class="i">+	start     time.Time // Time test or benchmark started
</a><a href="#h83-0-42" id="h83-0-42" class="i">+	duration  time.Duration
</a><a href="#h83-0-43" id="h83-0-43" class="i">+	N         int
</a><a href="#h83-0-44" id="h83-0-44" class="i">+	bytes     int64
</a><a href="#h83-0-45" id="h83-0-45" class="i">+	timerOn   bool
</a><a href="#h83-0-46" id="h83-0-46" class="i">+	benchTime time.Duration
</a><a href="#h83-0-47" id="h83-0-47" class="i">+	// The initial states of memStats.Mallocs and memStats.TotalAlloc.
</a><a href="#h83-0-48" id="h83-0-48" class="i">+	startAllocs uint64
</a><a href="#h83-0-49" id="h83-0-49" class="i">+	startBytes  uint64
</a><a href="#h83-0-50" id="h83-0-50" class="i">+	// The net total of this test after being run.
</a><a href="#h83-0-51" id="h83-0-51" class="i">+	netAllocs uint64
</a><a href="#h83-0-52" id="h83-0-52" class="i">+	netBytes  uint64
</a><a href="#h83-0-53" id="h83-0-53" class="i">+}
</a><a href="#h83-0-54" id="h83-0-54" class="i">+
</a><a href="#h83-0-55" id="h83-0-55" class="i">+// StartTimer starts timing a test. This function is called automatically
</a><a href="#h83-0-56" id="h83-0-56" class="i">+// before a benchmark starts, but it can also used to resume timing after
</a><a href="#h83-0-57" id="h83-0-57" class="i">+// a call to StopTimer.
</a><a href="#h83-0-58" id="h83-0-58" class="i">+func (c *C) StartTimer() {
</a><a href="#h83-0-59" id="h83-0-59" class="i">+	if !c.timerOn {
</a><a href="#h83-0-60" id="h83-0-60" class="i">+		c.start = time.Now()
</a><a href="#h83-0-61" id="h83-0-61" class="i">+		c.timerOn = true
</a><a href="#h83-0-62" id="h83-0-62" class="i">+
</a><a href="#h83-0-63" id="h83-0-63" class="i">+		runtime.ReadMemStats(&amp;memStats)
</a><a href="#h83-0-64" id="h83-0-64" class="i">+		c.startAllocs = memStats.Mallocs
</a><a href="#h83-0-65" id="h83-0-65" class="i">+		c.startBytes = memStats.TotalAlloc
</a><a href="#h83-0-66" id="h83-0-66" class="i">+	}
</a><a href="#h83-0-67" id="h83-0-67" class="i">+}
</a><a href="#h83-0-68" id="h83-0-68" class="i">+
</a><a href="#h83-0-69" id="h83-0-69" class="i">+// StopTimer stops timing a test. This can be used to pause the timer
</a><a href="#h83-0-70" id="h83-0-70" class="i">+// while performing complex initialization that you don&#39;t
</a><a href="#h83-0-71" id="h83-0-71" class="i">+// want to measure.
</a><a href="#h83-0-72" id="h83-0-72" class="i">+func (c *C) StopTimer() {
</a><a href="#h83-0-73" id="h83-0-73" class="i">+	if c.timerOn {
</a><a href="#h83-0-74" id="h83-0-74" class="i">+		c.duration += time.Now().Sub(c.start)
</a><a href="#h83-0-75" id="h83-0-75" class="i">+		c.timerOn = false
</a><a href="#h83-0-76" id="h83-0-76" class="i">+		runtime.ReadMemStats(&amp;memStats)
</a><a href="#h83-0-77" id="h83-0-77" class="i">+		c.netAllocs += memStats.Mallocs - c.startAllocs
</a><a href="#h83-0-78" id="h83-0-78" class="i">+		c.netBytes += memStats.TotalAlloc - c.startBytes
</a><a href="#h83-0-79" id="h83-0-79" class="i">+	}
</a><a href="#h83-0-80" id="h83-0-80" class="i">+}
</a><a href="#h83-0-81" id="h83-0-81" class="i">+
</a><a href="#h83-0-82" id="h83-0-82" class="i">+// ResetTimer sets the elapsed benchmark time to zero.
</a><a href="#h83-0-83" id="h83-0-83" class="i">+// It does not affect whether the timer is running.
</a><a href="#h83-0-84" id="h83-0-84" class="i">+func (c *C) ResetTimer() {
</a><a href="#h83-0-85" id="h83-0-85" class="i">+	if c.timerOn {
</a><a href="#h83-0-86" id="h83-0-86" class="i">+		c.start = time.Now()
</a><a href="#h83-0-87" id="h83-0-87" class="i">+		runtime.ReadMemStats(&amp;memStats)
</a><a href="#h83-0-88" id="h83-0-88" class="i">+		c.startAllocs = memStats.Mallocs
</a><a href="#h83-0-89" id="h83-0-89" class="i">+		c.startBytes = memStats.TotalAlloc
</a><a href="#h83-0-90" id="h83-0-90" class="i">+	}
</a><a href="#h83-0-91" id="h83-0-91" class="i">+	c.duration = 0
</a><a href="#h83-0-92" id="h83-0-92" class="i">+	c.netAllocs = 0
</a><a href="#h83-0-93" id="h83-0-93" class="i">+	c.netBytes = 0
</a><a href="#h83-0-94" id="h83-0-94" class="i">+}
</a><a href="#h83-0-95" id="h83-0-95" class="i">+
</a><a href="#h83-0-96" id="h83-0-96" class="i">+// SetBytes informs the number of bytes that the benchmark processes
</a><a href="#h83-0-97" id="h83-0-97" class="i">+// on each iteration. If this is called in a benchmark it will also
</a><a href="#h83-0-98" id="h83-0-98" class="i">+// report MB/s.
</a><a href="#h83-0-99" id="h83-0-99" class="i">+func (c *C) SetBytes(n int64) {
</a><a href="#h83-0-100" id="h83-0-100" class="i">+	c.bytes = n
</a><a href="#h83-0-101" id="h83-0-101" class="i">+}
</a><a href="#h83-0-102" id="h83-0-102" class="i">+
</a><a href="#h83-0-103" id="h83-0-103" class="i">+func (c *C) nsPerOp() int64 {
</a><a href="#h83-0-104" id="h83-0-104" class="i">+	if c.N &lt;= 0 {
</a><a href="#h83-0-105" id="h83-0-105" class="i">+		return 0
</a><a href="#h83-0-106" id="h83-0-106" class="i">+	}
</a><a href="#h83-0-107" id="h83-0-107" class="i">+	return c.duration.Nanoseconds() / int64(c.N)
</a><a href="#h83-0-108" id="h83-0-108" class="i">+}
</a><a href="#h83-0-109" id="h83-0-109" class="i">+
</a><a href="#h83-0-110" id="h83-0-110" class="i">+func (c *C) mbPerSec() float64 {
</a><a href="#h83-0-111" id="h83-0-111" class="i">+	if c.bytes &lt;= 0 || c.duration &lt;= 0 || c.N &lt;= 0 {
</a><a href="#h83-0-112" id="h83-0-112" class="i">+		return 0
</a><a href="#h83-0-113" id="h83-0-113" class="i">+	}
</a><a href="#h83-0-114" id="h83-0-114" class="i">+	return (float64(c.bytes) * float64(c.N) / 1e6) / c.duration.Seconds()
</a><a href="#h83-0-115" id="h83-0-115" class="i">+}
</a><a href="#h83-0-116" id="h83-0-116" class="i">+
</a><a href="#h83-0-117" id="h83-0-117" class="i">+func (c *C) timerString() string {
</a><a href="#h83-0-118" id="h83-0-118" class="i">+	if c.N &lt;= 0 {
</a><a href="#h83-0-119" id="h83-0-119" class="i">+		return fmt.Sprintf(&quot;%3.3fs&quot;, float64(c.duration.Nanoseconds())/1e9)
</a><a href="#h83-0-120" id="h83-0-120" class="i">+	}
</a><a href="#h83-0-121" id="h83-0-121" class="i">+	mbs := c.mbPerSec()
</a><a href="#h83-0-122" id="h83-0-122" class="i">+	mb := &quot;&quot;
</a><a href="#h83-0-123" id="h83-0-123" class="i">+	if mbs != 0 {
</a><a href="#h83-0-124" id="h83-0-124" class="i">+		mb = fmt.Sprintf(&quot;\t%7.2f MB/s&quot;, mbs)
</a><a href="#h83-0-125" id="h83-0-125" class="i">+	}
</a><a href="#h83-0-126" id="h83-0-126" class="i">+	nsop := c.nsPerOp()
</a><a href="#h83-0-127" id="h83-0-127" class="i">+	ns := fmt.Sprintf(&quot;%10d ns/op&quot;, nsop)
</a><a href="#h83-0-128" id="h83-0-128" class="i">+	if c.N &gt; 0 &amp;&amp; nsop &lt; 100 {
</a><a href="#h83-0-129" id="h83-0-129" class="i">+		// The format specifiers here make sure that
</a><a href="#h83-0-130" id="h83-0-130" class="i">+		// the ones digits line up for all three possible formats.
</a><a href="#h83-0-131" id="h83-0-131" class="i">+		if nsop &lt; 10 {
</a><a href="#h83-0-132" id="h83-0-132" class="i">+			ns = fmt.Sprintf(&quot;%13.2f ns/op&quot;, float64(c.duration.Nanoseconds())/float64(c.N))
</a><a href="#h83-0-133" id="h83-0-133" class="i">+		} else {
</a><a href="#h83-0-134" id="h83-0-134" class="i">+			ns = fmt.Sprintf(&quot;%12.1f ns/op&quot;, float64(c.duration.Nanoseconds())/float64(c.N))
</a><a href="#h83-0-135" id="h83-0-135" class="i">+		}
</a><a href="#h83-0-136" id="h83-0-136" class="i">+	}
</a><a href="#h83-0-137" id="h83-0-137" class="i">+	memStats := &quot;&quot;
</a><a href="#h83-0-138" id="h83-0-138" class="i">+	if c.benchMem {
</a><a href="#h83-0-139" id="h83-0-139" class="i">+		allocedBytes := fmt.Sprintf(&quot;%8d B/op&quot;, int64(c.netBytes)/int64(c.N))
</a><a href="#h83-0-140" id="h83-0-140" class="i">+		allocs := fmt.Sprintf(&quot;%8d allocs/op&quot;, int64(c.netAllocs)/int64(c.N))
</a><a href="#h83-0-141" id="h83-0-141" class="i">+		memStats = fmt.Sprintf(&quot;\t%s\t%s&quot;, allocedBytes, allocs)
</a><a href="#h83-0-142" id="h83-0-142" class="i">+	}
</a><a href="#h83-0-143" id="h83-0-143" class="i">+	return fmt.Sprintf(&quot;%8d\t%s%s%s&quot;, c.N, ns, mb, memStats)
</a><a href="#h83-0-144" id="h83-0-144" class="i">+}
</a><a href="#h83-0-145" id="h83-0-145" class="i">+
</a><a href="#h83-0-146" id="h83-0-146" class="i">+func min(x, y int) int {
</a><a href="#h83-0-147" id="h83-0-147" class="i">+	if x &gt; y {
</a><a href="#h83-0-148" id="h83-0-148" class="i">+		return y
</a><a href="#h83-0-149" id="h83-0-149" class="i">+	}
</a><a href="#h83-0-150" id="h83-0-150" class="i">+	return x
</a><a href="#h83-0-151" id="h83-0-151" class="i">+}
</a><a href="#h83-0-152" id="h83-0-152" class="i">+
</a><a href="#h83-0-153" id="h83-0-153" class="i">+func max(x, y int) int {
</a><a href="#h83-0-154" id="h83-0-154" class="i">+	if x &lt; y {
</a><a href="#h83-0-155" id="h83-0-155" class="i">+		return y
</a><a href="#h83-0-156" id="h83-0-156" class="i">+	}
</a><a href="#h83-0-157" id="h83-0-157" class="i">+	return x
</a><a href="#h83-0-158" id="h83-0-158" class="i">+}
</a><a href="#h83-0-159" id="h83-0-159" class="i">+
</a><a href="#h83-0-160" id="h83-0-160" class="i">+// roundDown10 rounds a number down to the nearest power of 10.
</a><a href="#h83-0-161" id="h83-0-161" class="i">+func roundDown10(n int) int {
</a><a href="#h83-0-162" id="h83-0-162" class="i">+	var tens = 0
</a><a href="#h83-0-163" id="h83-0-163" class="i">+	// tens = floor(log_10(n))
</a><a href="#h83-0-164" id="h83-0-164" class="i">+	for n &gt; 10 {
</a><a href="#h83-0-165" id="h83-0-165" class="i">+		n = n / 10
</a><a href="#h83-0-166" id="h83-0-166" class="i">+		tens++
</a><a href="#h83-0-167" id="h83-0-167" class="i">+	}
</a><a href="#h83-0-168" id="h83-0-168" class="i">+	// result = 10^tens
</a><a href="#h83-0-169" id="h83-0-169" class="i">+	result := 1
</a><a href="#h83-0-170" id="h83-0-170" class="i">+	for i := 0; i &lt; tens; i++ {
</a><a href="#h83-0-171" id="h83-0-171" class="i">+		result *= 10
</a><a href="#h83-0-172" id="h83-0-172" class="i">+	}
</a><a href="#h83-0-173" id="h83-0-173" class="i">+	return result
</a><a href="#h83-0-174" id="h83-0-174" class="i">+}
</a><a href="#h83-0-175" id="h83-0-175" class="i">+
</a><a href="#h83-0-176" id="h83-0-176" class="i">+// roundUp rounds x up to a number of the form [1eX, 2eX, 5eX].
</a><a href="#h83-0-177" id="h83-0-177" class="i">+func roundUp(n int) int {
</a><a href="#h83-0-178" id="h83-0-178" class="i">+	base := roundDown10(n)
</a><a href="#h83-0-179" id="h83-0-179" class="i">+	if n &lt; (2 * base) {
</a><a href="#h83-0-180" id="h83-0-180" class="i">+		return 2 * base
</a><a href="#h83-0-181" id="h83-0-181" class="i">+	}
</a><a href="#h83-0-182" id="h83-0-182" class="i">+	if n &lt; (5 * base) {
</a><a href="#h83-0-183" id="h83-0-183" class="i">+		return 5 * base
</a><a href="#h83-0-184" id="h83-0-184" class="i">+	}
</a><a href="#h83-0-185" id="h83-0-185" class="i">+	return 10 * base
</a><a href="#h83-0-186" id="h83-0-186" class="i">+}
</a><b>diff --git a/<a id="h84" href="../file/vendor/gopkg.in/check.v1/check.go">vendor/gopkg.in/check.v1/check.go</a> b/<a href="../file/vendor/gopkg.in/check.v1/check.go">vendor/gopkg.in/check.v1/check.go</a></b>
<a href="#h84-0" id="h84-0" class="h">@@ -0,0 +1,873 @@
</a><a href="#h84-0-0" id="h84-0-0" class="i">+// Package check is a rich testing extension for Go&#39;s testing package.
</a><a href="#h84-0-1" id="h84-0-1" class="i">+//
</a><a href="#h84-0-2" id="h84-0-2" class="i">+// For details about the project, see:
</a><a href="#h84-0-3" id="h84-0-3" class="i">+//
</a><a href="#h84-0-4" id="h84-0-4" class="i">+//     http://labix.org/gocheck
</a><a href="#h84-0-5" id="h84-0-5" class="i">+//
</a><a href="#h84-0-6" id="h84-0-6" class="i">+package check
</a><a href="#h84-0-7" id="h84-0-7" class="i">+
</a><a href="#h84-0-8" id="h84-0-8" class="i">+import (
</a><a href="#h84-0-9" id="h84-0-9" class="i">+	&quot;bytes&quot;
</a><a href="#h84-0-10" id="h84-0-10" class="i">+	&quot;errors&quot;
</a><a href="#h84-0-11" id="h84-0-11" class="i">+	&quot;fmt&quot;
</a><a href="#h84-0-12" id="h84-0-12" class="i">+	&quot;io&quot;
</a><a href="#h84-0-13" id="h84-0-13" class="i">+	&quot;math/rand&quot;
</a><a href="#h84-0-14" id="h84-0-14" class="i">+	&quot;os&quot;
</a><a href="#h84-0-15" id="h84-0-15" class="i">+	&quot;path&quot;
</a><a href="#h84-0-16" id="h84-0-16" class="i">+	&quot;path/filepath&quot;
</a><a href="#h84-0-17" id="h84-0-17" class="i">+	&quot;reflect&quot;
</a><a href="#h84-0-18" id="h84-0-18" class="i">+	&quot;regexp&quot;
</a><a href="#h84-0-19" id="h84-0-19" class="i">+	&quot;runtime&quot;
</a><a href="#h84-0-20" id="h84-0-20" class="i">+	&quot;strconv&quot;
</a><a href="#h84-0-21" id="h84-0-21" class="i">+	&quot;strings&quot;
</a><a href="#h84-0-22" id="h84-0-22" class="i">+	&quot;sync&quot;
</a><a href="#h84-0-23" id="h84-0-23" class="i">+	&quot;sync/atomic&quot;
</a><a href="#h84-0-24" id="h84-0-24" class="i">+	&quot;time&quot;
</a><a href="#h84-0-25" id="h84-0-25" class="i">+)
</a><a href="#h84-0-26" id="h84-0-26" class="i">+
</a><a href="#h84-0-27" id="h84-0-27" class="i">+// -----------------------------------------------------------------------
</a><a href="#h84-0-28" id="h84-0-28" class="i">+// Internal type which deals with suite method calling.
</a><a href="#h84-0-29" id="h84-0-29" class="i">+
</a><a href="#h84-0-30" id="h84-0-30" class="i">+const (
</a><a href="#h84-0-31" id="h84-0-31" class="i">+	fixtureKd = iota
</a><a href="#h84-0-32" id="h84-0-32" class="i">+	testKd
</a><a href="#h84-0-33" id="h84-0-33" class="i">+)
</a><a href="#h84-0-34" id="h84-0-34" class="i">+
</a><a href="#h84-0-35" id="h84-0-35" class="i">+type funcKind int
</a><a href="#h84-0-36" id="h84-0-36" class="i">+
</a><a href="#h84-0-37" id="h84-0-37" class="i">+const (
</a><a href="#h84-0-38" id="h84-0-38" class="i">+	succeededSt = iota
</a><a href="#h84-0-39" id="h84-0-39" class="i">+	failedSt
</a><a href="#h84-0-40" id="h84-0-40" class="i">+	skippedSt
</a><a href="#h84-0-41" id="h84-0-41" class="i">+	panickedSt
</a><a href="#h84-0-42" id="h84-0-42" class="i">+	fixturePanickedSt
</a><a href="#h84-0-43" id="h84-0-43" class="i">+	missedSt
</a><a href="#h84-0-44" id="h84-0-44" class="i">+)
</a><a href="#h84-0-45" id="h84-0-45" class="i">+
</a><a href="#h84-0-46" id="h84-0-46" class="i">+type funcStatus uint32
</a><a href="#h84-0-47" id="h84-0-47" class="i">+
</a><a href="#h84-0-48" id="h84-0-48" class="i">+// A method value can&#39;t reach its own Method structure.
</a><a href="#h84-0-49" id="h84-0-49" class="i">+type methodType struct {
</a><a href="#h84-0-50" id="h84-0-50" class="i">+	reflect.Value
</a><a href="#h84-0-51" id="h84-0-51" class="i">+	Info reflect.Method
</a><a href="#h84-0-52" id="h84-0-52" class="i">+}
</a><a href="#h84-0-53" id="h84-0-53" class="i">+
</a><a href="#h84-0-54" id="h84-0-54" class="i">+func newMethod(receiver reflect.Value, i int) *methodType {
</a><a href="#h84-0-55" id="h84-0-55" class="i">+	return &amp;methodType{receiver.Method(i), receiver.Type().Method(i)}
</a><a href="#h84-0-56" id="h84-0-56" class="i">+}
</a><a href="#h84-0-57" id="h84-0-57" class="i">+
</a><a href="#h84-0-58" id="h84-0-58" class="i">+func (method *methodType) PC() uintptr {
</a><a href="#h84-0-59" id="h84-0-59" class="i">+	return method.Info.Func.Pointer()
</a><a href="#h84-0-60" id="h84-0-60" class="i">+}
</a><a href="#h84-0-61" id="h84-0-61" class="i">+
</a><a href="#h84-0-62" id="h84-0-62" class="i">+func (method *methodType) suiteName() string {
</a><a href="#h84-0-63" id="h84-0-63" class="i">+	t := method.Info.Type.In(0)
</a><a href="#h84-0-64" id="h84-0-64" class="i">+	if t.Kind() == reflect.Ptr {
</a><a href="#h84-0-65" id="h84-0-65" class="i">+		t = t.Elem()
</a><a href="#h84-0-66" id="h84-0-66" class="i">+	}
</a><a href="#h84-0-67" id="h84-0-67" class="i">+	return t.Name()
</a><a href="#h84-0-68" id="h84-0-68" class="i">+}
</a><a href="#h84-0-69" id="h84-0-69" class="i">+
</a><a href="#h84-0-70" id="h84-0-70" class="i">+func (method *methodType) String() string {
</a><a href="#h84-0-71" id="h84-0-71" class="i">+	return method.suiteName() + &quot;.&quot; + method.Info.Name
</a><a href="#h84-0-72" id="h84-0-72" class="i">+}
</a><a href="#h84-0-73" id="h84-0-73" class="i">+
</a><a href="#h84-0-74" id="h84-0-74" class="i">+func (method *methodType) matches(re *regexp.Regexp) bool {
</a><a href="#h84-0-75" id="h84-0-75" class="i">+	return (re.MatchString(method.Info.Name) ||
</a><a href="#h84-0-76" id="h84-0-76" class="i">+		re.MatchString(method.suiteName()) ||
</a><a href="#h84-0-77" id="h84-0-77" class="i">+		re.MatchString(method.String()))
</a><a href="#h84-0-78" id="h84-0-78" class="i">+}
</a><a href="#h84-0-79" id="h84-0-79" class="i">+
</a><a href="#h84-0-80" id="h84-0-80" class="i">+type C struct {
</a><a href="#h84-0-81" id="h84-0-81" class="i">+	method    *methodType
</a><a href="#h84-0-82" id="h84-0-82" class="i">+	kind      funcKind
</a><a href="#h84-0-83" id="h84-0-83" class="i">+	testName  string
</a><a href="#h84-0-84" id="h84-0-84" class="i">+	_status   funcStatus
</a><a href="#h84-0-85" id="h84-0-85" class="i">+	logb      *logger
</a><a href="#h84-0-86" id="h84-0-86" class="i">+	logw      io.Writer
</a><a href="#h84-0-87" id="h84-0-87" class="i">+	done      chan *C
</a><a href="#h84-0-88" id="h84-0-88" class="i">+	reason    string
</a><a href="#h84-0-89" id="h84-0-89" class="i">+	mustFail  bool
</a><a href="#h84-0-90" id="h84-0-90" class="i">+	tempDir   *tempDir
</a><a href="#h84-0-91" id="h84-0-91" class="i">+	benchMem  bool
</a><a href="#h84-0-92" id="h84-0-92" class="i">+	startTime time.Time
</a><a href="#h84-0-93" id="h84-0-93" class="i">+	timer
</a><a href="#h84-0-94" id="h84-0-94" class="i">+}
</a><a href="#h84-0-95" id="h84-0-95" class="i">+
</a><a href="#h84-0-96" id="h84-0-96" class="i">+func (c *C) status() funcStatus {
</a><a href="#h84-0-97" id="h84-0-97" class="i">+	return funcStatus(atomic.LoadUint32((*uint32)(&amp;c._status)))
</a><a href="#h84-0-98" id="h84-0-98" class="i">+}
</a><a href="#h84-0-99" id="h84-0-99" class="i">+
</a><a href="#h84-0-100" id="h84-0-100" class="i">+func (c *C) setStatus(s funcStatus) {
</a><a href="#h84-0-101" id="h84-0-101" class="i">+	atomic.StoreUint32((*uint32)(&amp;c._status), uint32(s))
</a><a href="#h84-0-102" id="h84-0-102" class="i">+}
</a><a href="#h84-0-103" id="h84-0-103" class="i">+
</a><a href="#h84-0-104" id="h84-0-104" class="i">+func (c *C) stopNow() {
</a><a href="#h84-0-105" id="h84-0-105" class="i">+	runtime.Goexit()
</a><a href="#h84-0-106" id="h84-0-106" class="i">+}
</a><a href="#h84-0-107" id="h84-0-107" class="i">+
</a><a href="#h84-0-108" id="h84-0-108" class="i">+// logger is a concurrency safe byte.Buffer
</a><a href="#h84-0-109" id="h84-0-109" class="i">+type logger struct {
</a><a href="#h84-0-110" id="h84-0-110" class="i">+	sync.Mutex
</a><a href="#h84-0-111" id="h84-0-111" class="i">+	writer bytes.Buffer
</a><a href="#h84-0-112" id="h84-0-112" class="i">+}
</a><a href="#h84-0-113" id="h84-0-113" class="i">+
</a><a href="#h84-0-114" id="h84-0-114" class="i">+func (l *logger) Write(buf []byte) (int, error) {
</a><a href="#h84-0-115" id="h84-0-115" class="i">+	l.Lock()
</a><a href="#h84-0-116" id="h84-0-116" class="i">+	defer l.Unlock()
</a><a href="#h84-0-117" id="h84-0-117" class="i">+	return l.writer.Write(buf)
</a><a href="#h84-0-118" id="h84-0-118" class="i">+}
</a><a href="#h84-0-119" id="h84-0-119" class="i">+
</a><a href="#h84-0-120" id="h84-0-120" class="i">+func (l *logger) WriteTo(w io.Writer) (int64, error) {
</a><a href="#h84-0-121" id="h84-0-121" class="i">+	l.Lock()
</a><a href="#h84-0-122" id="h84-0-122" class="i">+	defer l.Unlock()
</a><a href="#h84-0-123" id="h84-0-123" class="i">+	return l.writer.WriteTo(w)
</a><a href="#h84-0-124" id="h84-0-124" class="i">+}
</a><a href="#h84-0-125" id="h84-0-125" class="i">+
</a><a href="#h84-0-126" id="h84-0-126" class="i">+func (l *logger) String() string {
</a><a href="#h84-0-127" id="h84-0-127" class="i">+	l.Lock()
</a><a href="#h84-0-128" id="h84-0-128" class="i">+	defer l.Unlock()
</a><a href="#h84-0-129" id="h84-0-129" class="i">+	return l.writer.String()
</a><a href="#h84-0-130" id="h84-0-130" class="i">+}
</a><a href="#h84-0-131" id="h84-0-131" class="i">+
</a><a href="#h84-0-132" id="h84-0-132" class="i">+// -----------------------------------------------------------------------
</a><a href="#h84-0-133" id="h84-0-133" class="i">+// Handling of temporary files and directories.
</a><a href="#h84-0-134" id="h84-0-134" class="i">+
</a><a href="#h84-0-135" id="h84-0-135" class="i">+type tempDir struct {
</a><a href="#h84-0-136" id="h84-0-136" class="i">+	sync.Mutex
</a><a href="#h84-0-137" id="h84-0-137" class="i">+	path    string
</a><a href="#h84-0-138" id="h84-0-138" class="i">+	counter int
</a><a href="#h84-0-139" id="h84-0-139" class="i">+}
</a><a href="#h84-0-140" id="h84-0-140" class="i">+
</a><a href="#h84-0-141" id="h84-0-141" class="i">+func (td *tempDir) newPath() string {
</a><a href="#h84-0-142" id="h84-0-142" class="i">+	td.Lock()
</a><a href="#h84-0-143" id="h84-0-143" class="i">+	defer td.Unlock()
</a><a href="#h84-0-144" id="h84-0-144" class="i">+	if td.path == &quot;&quot; {
</a><a href="#h84-0-145" id="h84-0-145" class="i">+		var err error
</a><a href="#h84-0-146" id="h84-0-146" class="i">+		for i := 0; i != 100; i++ {
</a><a href="#h84-0-147" id="h84-0-147" class="i">+			path := fmt.Sprintf(&quot;%s%ccheck-%d&quot;, os.TempDir(), os.PathSeparator, rand.Int())
</a><a href="#h84-0-148" id="h84-0-148" class="i">+			if err = os.Mkdir(path, 0700); err == nil {
</a><a href="#h84-0-149" id="h84-0-149" class="i">+				td.path = path
</a><a href="#h84-0-150" id="h84-0-150" class="i">+				break
</a><a href="#h84-0-151" id="h84-0-151" class="i">+			}
</a><a href="#h84-0-152" id="h84-0-152" class="i">+		}
</a><a href="#h84-0-153" id="h84-0-153" class="i">+		if td.path == &quot;&quot; {
</a><a href="#h84-0-154" id="h84-0-154" class="i">+			panic(&quot;Couldn&#39;t create temporary directory: &quot; + err.Error())
</a><a href="#h84-0-155" id="h84-0-155" class="i">+		}
</a><a href="#h84-0-156" id="h84-0-156" class="i">+	}
</a><a href="#h84-0-157" id="h84-0-157" class="i">+	result := filepath.Join(td.path, strconv.Itoa(td.counter))
</a><a href="#h84-0-158" id="h84-0-158" class="i">+	td.counter += 1
</a><a href="#h84-0-159" id="h84-0-159" class="i">+	return result
</a><a href="#h84-0-160" id="h84-0-160" class="i">+}
</a><a href="#h84-0-161" id="h84-0-161" class="i">+
</a><a href="#h84-0-162" id="h84-0-162" class="i">+func (td *tempDir) removeAll() {
</a><a href="#h84-0-163" id="h84-0-163" class="i">+	td.Lock()
</a><a href="#h84-0-164" id="h84-0-164" class="i">+	defer td.Unlock()
</a><a href="#h84-0-165" id="h84-0-165" class="i">+	if td.path != &quot;&quot; {
</a><a href="#h84-0-166" id="h84-0-166" class="i">+		err := os.RemoveAll(td.path)
</a><a href="#h84-0-167" id="h84-0-167" class="i">+		if err != nil {
</a><a href="#h84-0-168" id="h84-0-168" class="i">+			fmt.Fprintf(os.Stderr, &quot;WARNING: Error cleaning up temporaries: &quot;+err.Error())
</a><a href="#h84-0-169" id="h84-0-169" class="i">+		}
</a><a href="#h84-0-170" id="h84-0-170" class="i">+	}
</a><a href="#h84-0-171" id="h84-0-171" class="i">+}
</a><a href="#h84-0-172" id="h84-0-172" class="i">+
</a><a href="#h84-0-173" id="h84-0-173" class="i">+// Create a new temporary directory which is automatically removed after
</a><a href="#h84-0-174" id="h84-0-174" class="i">+// the suite finishes running.
</a><a href="#h84-0-175" id="h84-0-175" class="i">+func (c *C) MkDir() string {
</a><a href="#h84-0-176" id="h84-0-176" class="i">+	path := c.tempDir.newPath()
</a><a href="#h84-0-177" id="h84-0-177" class="i">+	if err := os.Mkdir(path, 0700); err != nil {
</a><a href="#h84-0-178" id="h84-0-178" class="i">+		panic(fmt.Sprintf(&quot;Couldn&#39;t create temporary directory %s: %s&quot;, path, err.Error()))
</a><a href="#h84-0-179" id="h84-0-179" class="i">+	}
</a><a href="#h84-0-180" id="h84-0-180" class="i">+	return path
</a><a href="#h84-0-181" id="h84-0-181" class="i">+}
</a><a href="#h84-0-182" id="h84-0-182" class="i">+
</a><a href="#h84-0-183" id="h84-0-183" class="i">+// -----------------------------------------------------------------------
</a><a href="#h84-0-184" id="h84-0-184" class="i">+// Low-level logging functions.
</a><a href="#h84-0-185" id="h84-0-185" class="i">+
</a><a href="#h84-0-186" id="h84-0-186" class="i">+func (c *C) log(args ...interface{}) {
</a><a href="#h84-0-187" id="h84-0-187" class="i">+	c.writeLog([]byte(fmt.Sprint(args...) + &quot;\n&quot;))
</a><a href="#h84-0-188" id="h84-0-188" class="i">+}
</a><a href="#h84-0-189" id="h84-0-189" class="i">+
</a><a href="#h84-0-190" id="h84-0-190" class="i">+func (c *C) logf(format string, args ...interface{}) {
</a><a href="#h84-0-191" id="h84-0-191" class="i">+	c.writeLog([]byte(fmt.Sprintf(format+&quot;\n&quot;, args...)))
</a><a href="#h84-0-192" id="h84-0-192" class="i">+}
</a><a href="#h84-0-193" id="h84-0-193" class="i">+
</a><a href="#h84-0-194" id="h84-0-194" class="i">+func (c *C) logNewLine() {
</a><a href="#h84-0-195" id="h84-0-195" class="i">+	c.writeLog([]byte{&#39;\n&#39;})
</a><a href="#h84-0-196" id="h84-0-196" class="i">+}
</a><a href="#h84-0-197" id="h84-0-197" class="i">+
</a><a href="#h84-0-198" id="h84-0-198" class="i">+func (c *C) writeLog(buf []byte) {
</a><a href="#h84-0-199" id="h84-0-199" class="i">+	c.logb.Write(buf)
</a><a href="#h84-0-200" id="h84-0-200" class="i">+	if c.logw != nil {
</a><a href="#h84-0-201" id="h84-0-201" class="i">+		c.logw.Write(buf)
</a><a href="#h84-0-202" id="h84-0-202" class="i">+	}
</a><a href="#h84-0-203" id="h84-0-203" class="i">+}
</a><a href="#h84-0-204" id="h84-0-204" class="i">+
</a><a href="#h84-0-205" id="h84-0-205" class="i">+func hasStringOrError(x interface{}) (ok bool) {
</a><a href="#h84-0-206" id="h84-0-206" class="i">+	_, ok = x.(fmt.Stringer)
</a><a href="#h84-0-207" id="h84-0-207" class="i">+	if ok {
</a><a href="#h84-0-208" id="h84-0-208" class="i">+		return
</a><a href="#h84-0-209" id="h84-0-209" class="i">+	}
</a><a href="#h84-0-210" id="h84-0-210" class="i">+	_, ok = x.(error)
</a><a href="#h84-0-211" id="h84-0-211" class="i">+	return
</a><a href="#h84-0-212" id="h84-0-212" class="i">+}
</a><a href="#h84-0-213" id="h84-0-213" class="i">+
</a><a href="#h84-0-214" id="h84-0-214" class="i">+func (c *C) logValue(label string, value interface{}) {
</a><a href="#h84-0-215" id="h84-0-215" class="i">+	if label == &quot;&quot; {
</a><a href="#h84-0-216" id="h84-0-216" class="i">+		if hasStringOrError(value) {
</a><a href="#h84-0-217" id="h84-0-217" class="i">+			c.logf(&quot;... %#v (%q)&quot;, value, value)
</a><a href="#h84-0-218" id="h84-0-218" class="i">+		} else {
</a><a href="#h84-0-219" id="h84-0-219" class="i">+			c.logf(&quot;... %#v&quot;, value)
</a><a href="#h84-0-220" id="h84-0-220" class="i">+		}
</a><a href="#h84-0-221" id="h84-0-221" class="i">+	} else if value == nil {
</a><a href="#h84-0-222" id="h84-0-222" class="i">+		c.logf(&quot;... %s = nil&quot;, label)
</a><a href="#h84-0-223" id="h84-0-223" class="i">+	} else {
</a><a href="#h84-0-224" id="h84-0-224" class="i">+		if hasStringOrError(value) {
</a><a href="#h84-0-225" id="h84-0-225" class="i">+			fv := fmt.Sprintf(&quot;%#v&quot;, value)
</a><a href="#h84-0-226" id="h84-0-226" class="i">+			qv := fmt.Sprintf(&quot;%q&quot;, value)
</a><a href="#h84-0-227" id="h84-0-227" class="i">+			if fv != qv {
</a><a href="#h84-0-228" id="h84-0-228" class="i">+				c.logf(&quot;... %s %s = %s (%s)&quot;, label, reflect.TypeOf(value), fv, qv)
</a><a href="#h84-0-229" id="h84-0-229" class="i">+				return
</a><a href="#h84-0-230" id="h84-0-230" class="i">+			}
</a><a href="#h84-0-231" id="h84-0-231" class="i">+		}
</a><a href="#h84-0-232" id="h84-0-232" class="i">+		if s, ok := value.(string); ok &amp;&amp; isMultiLine(s) {
</a><a href="#h84-0-233" id="h84-0-233" class="i">+			c.logf(`... %s %s = &quot;&quot; +`, label, reflect.TypeOf(value))
</a><a href="#h84-0-234" id="h84-0-234" class="i">+			c.logMultiLine(s)
</a><a href="#h84-0-235" id="h84-0-235" class="i">+		} else {
</a><a href="#h84-0-236" id="h84-0-236" class="i">+			c.logf(&quot;... %s %s = %#v&quot;, label, reflect.TypeOf(value), value)
</a><a href="#h84-0-237" id="h84-0-237" class="i">+		}
</a><a href="#h84-0-238" id="h84-0-238" class="i">+	}
</a><a href="#h84-0-239" id="h84-0-239" class="i">+}
</a><a href="#h84-0-240" id="h84-0-240" class="i">+
</a><a href="#h84-0-241" id="h84-0-241" class="i">+func (c *C) logMultiLine(s string) {
</a><a href="#h84-0-242" id="h84-0-242" class="i">+	b := make([]byte, 0, len(s)*2)
</a><a href="#h84-0-243" id="h84-0-243" class="i">+	i := 0
</a><a href="#h84-0-244" id="h84-0-244" class="i">+	n := len(s)
</a><a href="#h84-0-245" id="h84-0-245" class="i">+	for i &lt; n {
</a><a href="#h84-0-246" id="h84-0-246" class="i">+		j := i + 1
</a><a href="#h84-0-247" id="h84-0-247" class="i">+		for j &lt; n &amp;&amp; s[j-1] != &#39;\n&#39; {
</a><a href="#h84-0-248" id="h84-0-248" class="i">+			j++
</a><a href="#h84-0-249" id="h84-0-249" class="i">+		}
</a><a href="#h84-0-250" id="h84-0-250" class="i">+		b = append(b, &quot;...     &quot;...)
</a><a href="#h84-0-251" id="h84-0-251" class="i">+		b = strconv.AppendQuote(b, s[i:j])
</a><a href="#h84-0-252" id="h84-0-252" class="i">+		if j &lt; n {
</a><a href="#h84-0-253" id="h84-0-253" class="i">+			b = append(b, &quot; +&quot;...)
</a><a href="#h84-0-254" id="h84-0-254" class="i">+		}
</a><a href="#h84-0-255" id="h84-0-255" class="i">+		b = append(b, &#39;\n&#39;)
</a><a href="#h84-0-256" id="h84-0-256" class="i">+		i = j
</a><a href="#h84-0-257" id="h84-0-257" class="i">+	}
</a><a href="#h84-0-258" id="h84-0-258" class="i">+	c.writeLog(b)
</a><a href="#h84-0-259" id="h84-0-259" class="i">+}
</a><a href="#h84-0-260" id="h84-0-260" class="i">+
</a><a href="#h84-0-261" id="h84-0-261" class="i">+func isMultiLine(s string) bool {
</a><a href="#h84-0-262" id="h84-0-262" class="i">+	for i := 0; i+1 &lt; len(s); i++ {
</a><a href="#h84-0-263" id="h84-0-263" class="i">+		if s[i] == &#39;\n&#39; {
</a><a href="#h84-0-264" id="h84-0-264" class="i">+			return true
</a><a href="#h84-0-265" id="h84-0-265" class="i">+		}
</a><a href="#h84-0-266" id="h84-0-266" class="i">+	}
</a><a href="#h84-0-267" id="h84-0-267" class="i">+	return false
</a><a href="#h84-0-268" id="h84-0-268" class="i">+}
</a><a href="#h84-0-269" id="h84-0-269" class="i">+
</a><a href="#h84-0-270" id="h84-0-270" class="i">+func (c *C) logString(issue string) {
</a><a href="#h84-0-271" id="h84-0-271" class="i">+	c.log(&quot;... &quot;, issue)
</a><a href="#h84-0-272" id="h84-0-272" class="i">+}
</a><a href="#h84-0-273" id="h84-0-273" class="i">+
</a><a href="#h84-0-274" id="h84-0-274" class="i">+func (c *C) logCaller(skip int) {
</a><a href="#h84-0-275" id="h84-0-275" class="i">+	// This is a bit heavier than it ought to be.
</a><a href="#h84-0-276" id="h84-0-276" class="i">+	skip += 1 // Our own frame.
</a><a href="#h84-0-277" id="h84-0-277" class="i">+	pc, callerFile, callerLine, ok := runtime.Caller(skip)
</a><a href="#h84-0-278" id="h84-0-278" class="i">+	if !ok {
</a><a href="#h84-0-279" id="h84-0-279" class="i">+		return
</a><a href="#h84-0-280" id="h84-0-280" class="i">+	}
</a><a href="#h84-0-281" id="h84-0-281" class="i">+	var testFile string
</a><a href="#h84-0-282" id="h84-0-282" class="i">+	var testLine int
</a><a href="#h84-0-283" id="h84-0-283" class="i">+	testFunc := runtime.FuncForPC(c.method.PC())
</a><a href="#h84-0-284" id="h84-0-284" class="i">+	if runtime.FuncForPC(pc) != testFunc {
</a><a href="#h84-0-285" id="h84-0-285" class="i">+		for {
</a><a href="#h84-0-286" id="h84-0-286" class="i">+			skip += 1
</a><a href="#h84-0-287" id="h84-0-287" class="i">+			if pc, file, line, ok := runtime.Caller(skip); ok {
</a><a href="#h84-0-288" id="h84-0-288" class="i">+				// Note that the test line may be different on
</a><a href="#h84-0-289" id="h84-0-289" class="i">+				// distinct calls for the same test.  Showing
</a><a href="#h84-0-290" id="h84-0-290" class="i">+				// the &quot;internal&quot; line is helpful when debugging.
</a><a href="#h84-0-291" id="h84-0-291" class="i">+				if runtime.FuncForPC(pc) == testFunc {
</a><a href="#h84-0-292" id="h84-0-292" class="i">+					testFile, testLine = file, line
</a><a href="#h84-0-293" id="h84-0-293" class="i">+					break
</a><a href="#h84-0-294" id="h84-0-294" class="i">+				}
</a><a href="#h84-0-295" id="h84-0-295" class="i">+			} else {
</a><a href="#h84-0-296" id="h84-0-296" class="i">+				break
</a><a href="#h84-0-297" id="h84-0-297" class="i">+			}
</a><a href="#h84-0-298" id="h84-0-298" class="i">+		}
</a><a href="#h84-0-299" id="h84-0-299" class="i">+	}
</a><a href="#h84-0-300" id="h84-0-300" class="i">+	if testFile != &quot;&quot; &amp;&amp; (testFile != callerFile || testLine != callerLine) {
</a><a href="#h84-0-301" id="h84-0-301" class="i">+		c.logCode(testFile, testLine)
</a><a href="#h84-0-302" id="h84-0-302" class="i">+	}
</a><a href="#h84-0-303" id="h84-0-303" class="i">+	c.logCode(callerFile, callerLine)
</a><a href="#h84-0-304" id="h84-0-304" class="i">+}
</a><a href="#h84-0-305" id="h84-0-305" class="i">+
</a><a href="#h84-0-306" id="h84-0-306" class="i">+func (c *C) logCode(path string, line int) {
</a><a href="#h84-0-307" id="h84-0-307" class="i">+	c.logf(&quot;%s:%d:&quot;, nicePath(path), line)
</a><a href="#h84-0-308" id="h84-0-308" class="i">+	code, err := printLine(path, line)
</a><a href="#h84-0-309" id="h84-0-309" class="i">+	if code == &quot;&quot; {
</a><a href="#h84-0-310" id="h84-0-310" class="i">+		code = &quot;...&quot; // XXX Open the file and take the raw line.
</a><a href="#h84-0-311" id="h84-0-311" class="i">+		if err != nil {
</a><a href="#h84-0-312" id="h84-0-312" class="i">+			code += err.Error()
</a><a href="#h84-0-313" id="h84-0-313" class="i">+		}
</a><a href="#h84-0-314" id="h84-0-314" class="i">+	}
</a><a href="#h84-0-315" id="h84-0-315" class="i">+	c.log(indent(code, &quot;    &quot;))
</a><a href="#h84-0-316" id="h84-0-316" class="i">+}
</a><a href="#h84-0-317" id="h84-0-317" class="i">+
</a><a href="#h84-0-318" id="h84-0-318" class="i">+var valueGo = filepath.Join(&quot;reflect&quot;, &quot;value.go&quot;)
</a><a href="#h84-0-319" id="h84-0-319" class="i">+var asmGo = filepath.Join(&quot;runtime&quot;, &quot;asm_&quot;)
</a><a href="#h84-0-320" id="h84-0-320" class="i">+
</a><a href="#h84-0-321" id="h84-0-321" class="i">+func (c *C) logPanic(skip int, value interface{}) {
</a><a href="#h84-0-322" id="h84-0-322" class="i">+	skip++ // Our own frame.
</a><a href="#h84-0-323" id="h84-0-323" class="i">+	initialSkip := skip
</a><a href="#h84-0-324" id="h84-0-324" class="i">+	for ; ; skip++ {
</a><a href="#h84-0-325" id="h84-0-325" class="i">+		if pc, file, line, ok := runtime.Caller(skip); ok {
</a><a href="#h84-0-326" id="h84-0-326" class="i">+			if skip == initialSkip {
</a><a href="#h84-0-327" id="h84-0-327" class="i">+				c.logf(&quot;... Panic: %s (PC=0x%X)\n&quot;, value, pc)
</a><a href="#h84-0-328" id="h84-0-328" class="i">+			}
</a><a href="#h84-0-329" id="h84-0-329" class="i">+			name := niceFuncName(pc)
</a><a href="#h84-0-330" id="h84-0-330" class="i">+			path := nicePath(file)
</a><a href="#h84-0-331" id="h84-0-331" class="i">+			if strings.Contains(path, &quot;/gopkg.in/check.v&quot;) {
</a><a href="#h84-0-332" id="h84-0-332" class="i">+				continue
</a><a href="#h84-0-333" id="h84-0-333" class="i">+			}
</a><a href="#h84-0-334" id="h84-0-334" class="i">+			if name == &quot;Value.call&quot; &amp;&amp; strings.HasSuffix(path, valueGo) {
</a><a href="#h84-0-335" id="h84-0-335" class="i">+				continue
</a><a href="#h84-0-336" id="h84-0-336" class="i">+			}
</a><a href="#h84-0-337" id="h84-0-337" class="i">+			if (name == &quot;call16&quot; || name == &quot;call32&quot;) &amp;&amp; strings.Contains(path, asmGo) {
</a><a href="#h84-0-338" id="h84-0-338" class="i">+				continue
</a><a href="#h84-0-339" id="h84-0-339" class="i">+			}
</a><a href="#h84-0-340" id="h84-0-340" class="i">+			c.logf(&quot;%s:%d\n  in %s&quot;, nicePath(file), line, name)
</a><a href="#h84-0-341" id="h84-0-341" class="i">+		} else {
</a><a href="#h84-0-342" id="h84-0-342" class="i">+			break
</a><a href="#h84-0-343" id="h84-0-343" class="i">+		}
</a><a href="#h84-0-344" id="h84-0-344" class="i">+	}
</a><a href="#h84-0-345" id="h84-0-345" class="i">+}
</a><a href="#h84-0-346" id="h84-0-346" class="i">+
</a><a href="#h84-0-347" id="h84-0-347" class="i">+func (c *C) logSoftPanic(issue string) {
</a><a href="#h84-0-348" id="h84-0-348" class="i">+	c.log(&quot;... Panic: &quot;, issue)
</a><a href="#h84-0-349" id="h84-0-349" class="i">+}
</a><a href="#h84-0-350" id="h84-0-350" class="i">+
</a><a href="#h84-0-351" id="h84-0-351" class="i">+func (c *C) logArgPanic(method *methodType, expectedType string) {
</a><a href="#h84-0-352" id="h84-0-352" class="i">+	c.logf(&quot;... Panic: %s argument should be %s&quot;,
</a><a href="#h84-0-353" id="h84-0-353" class="i">+		niceFuncName(method.PC()), expectedType)
</a><a href="#h84-0-354" id="h84-0-354" class="i">+}
</a><a href="#h84-0-355" id="h84-0-355" class="i">+
</a><a href="#h84-0-356" id="h84-0-356" class="i">+// -----------------------------------------------------------------------
</a><a href="#h84-0-357" id="h84-0-357" class="i">+// Some simple formatting helpers.
</a><a href="#h84-0-358" id="h84-0-358" class="i">+
</a><a href="#h84-0-359" id="h84-0-359" class="i">+var initWD, initWDErr = os.Getwd()
</a><a href="#h84-0-360" id="h84-0-360" class="i">+
</a><a href="#h84-0-361" id="h84-0-361" class="i">+func init() {
</a><a href="#h84-0-362" id="h84-0-362" class="i">+	if initWDErr == nil {
</a><a href="#h84-0-363" id="h84-0-363" class="i">+		initWD = strings.Replace(initWD, &quot;\\&quot;, &quot;/&quot;, -1) + &quot;/&quot;
</a><a href="#h84-0-364" id="h84-0-364" class="i">+	}
</a><a href="#h84-0-365" id="h84-0-365" class="i">+}
</a><a href="#h84-0-366" id="h84-0-366" class="i">+
</a><a href="#h84-0-367" id="h84-0-367" class="i">+func nicePath(path string) string {
</a><a href="#h84-0-368" id="h84-0-368" class="i">+	if initWDErr == nil {
</a><a href="#h84-0-369" id="h84-0-369" class="i">+		if strings.HasPrefix(path, initWD) {
</a><a href="#h84-0-370" id="h84-0-370" class="i">+			return path[len(initWD):]
</a><a href="#h84-0-371" id="h84-0-371" class="i">+		}
</a><a href="#h84-0-372" id="h84-0-372" class="i">+	}
</a><a href="#h84-0-373" id="h84-0-373" class="i">+	return path
</a><a href="#h84-0-374" id="h84-0-374" class="i">+}
</a><a href="#h84-0-375" id="h84-0-375" class="i">+
</a><a href="#h84-0-376" id="h84-0-376" class="i">+func niceFuncPath(pc uintptr) string {
</a><a href="#h84-0-377" id="h84-0-377" class="i">+	function := runtime.FuncForPC(pc)
</a><a href="#h84-0-378" id="h84-0-378" class="i">+	if function != nil {
</a><a href="#h84-0-379" id="h84-0-379" class="i">+		filename, line := function.FileLine(pc)
</a><a href="#h84-0-380" id="h84-0-380" class="i">+		return fmt.Sprintf(&quot;%s:%d&quot;, nicePath(filename), line)
</a><a href="#h84-0-381" id="h84-0-381" class="i">+	}
</a><a href="#h84-0-382" id="h84-0-382" class="i">+	return &quot;&lt;unknown path&gt;&quot;
</a><a href="#h84-0-383" id="h84-0-383" class="i">+}
</a><a href="#h84-0-384" id="h84-0-384" class="i">+
</a><a href="#h84-0-385" id="h84-0-385" class="i">+func niceFuncName(pc uintptr) string {
</a><a href="#h84-0-386" id="h84-0-386" class="i">+	function := runtime.FuncForPC(pc)
</a><a href="#h84-0-387" id="h84-0-387" class="i">+	if function != nil {
</a><a href="#h84-0-388" id="h84-0-388" class="i">+		name := path.Base(function.Name())
</a><a href="#h84-0-389" id="h84-0-389" class="i">+		if i := strings.Index(name, &quot;.&quot;); i &gt; 0 {
</a><a href="#h84-0-390" id="h84-0-390" class="i">+			name = name[i+1:]
</a><a href="#h84-0-391" id="h84-0-391" class="i">+		}
</a><a href="#h84-0-392" id="h84-0-392" class="i">+		if strings.HasPrefix(name, &quot;(*&quot;) {
</a><a href="#h84-0-393" id="h84-0-393" class="i">+			if i := strings.Index(name, &quot;)&quot;); i &gt; 0 {
</a><a href="#h84-0-394" id="h84-0-394" class="i">+				name = name[2:i] + name[i+1:]
</a><a href="#h84-0-395" id="h84-0-395" class="i">+			}
</a><a href="#h84-0-396" id="h84-0-396" class="i">+		}
</a><a href="#h84-0-397" id="h84-0-397" class="i">+		if i := strings.LastIndex(name, &quot;.*&quot;); i != -1 {
</a><a href="#h84-0-398" id="h84-0-398" class="i">+			name = name[:i] + &quot;.&quot; + name[i+2:]
</a><a href="#h84-0-399" id="h84-0-399" class="i">+		}
</a><a href="#h84-0-400" id="h84-0-400" class="i">+		if i := strings.LastIndex(name, &quot;&quot;); i != -1 {
</a><a href="#h84-0-401" id="h84-0-401" class="i">+			name = name[:i] + &quot;.&quot; + name[i+2:]
</a><a href="#h84-0-402" id="h84-0-402" class="i">+		}
</a><a href="#h84-0-403" id="h84-0-403" class="i">+		return name
</a><a href="#h84-0-404" id="h84-0-404" class="i">+	}
</a><a href="#h84-0-405" id="h84-0-405" class="i">+	return &quot;&lt;unknown function&gt;&quot;
</a><a href="#h84-0-406" id="h84-0-406" class="i">+}
</a><a href="#h84-0-407" id="h84-0-407" class="i">+
</a><a href="#h84-0-408" id="h84-0-408" class="i">+// -----------------------------------------------------------------------
</a><a href="#h84-0-409" id="h84-0-409" class="i">+// Result tracker to aggregate call results.
</a><a href="#h84-0-410" id="h84-0-410" class="i">+
</a><a href="#h84-0-411" id="h84-0-411" class="i">+type Result struct {
</a><a href="#h84-0-412" id="h84-0-412" class="i">+	Succeeded        int
</a><a href="#h84-0-413" id="h84-0-413" class="i">+	Failed           int
</a><a href="#h84-0-414" id="h84-0-414" class="i">+	Skipped          int
</a><a href="#h84-0-415" id="h84-0-415" class="i">+	Panicked         int
</a><a href="#h84-0-416" id="h84-0-416" class="i">+	FixturePanicked  int
</a><a href="#h84-0-417" id="h84-0-417" class="i">+	ExpectedFailures int
</a><a href="#h84-0-418" id="h84-0-418" class="i">+	Missed           int    // Not even tried to run, related to a panic in the fixture.
</a><a href="#h84-0-419" id="h84-0-419" class="i">+	RunError         error  // Houston, we&#39;ve got a problem.
</a><a href="#h84-0-420" id="h84-0-420" class="i">+	WorkDir          string // If KeepWorkDir is true
</a><a href="#h84-0-421" id="h84-0-421" class="i">+}
</a><a href="#h84-0-422" id="h84-0-422" class="i">+
</a><a href="#h84-0-423" id="h84-0-423" class="i">+type resultTracker struct {
</a><a href="#h84-0-424" id="h84-0-424" class="i">+	result          Result
</a><a href="#h84-0-425" id="h84-0-425" class="i">+	_lastWasProblem bool
</a><a href="#h84-0-426" id="h84-0-426" class="i">+	_waiting        int
</a><a href="#h84-0-427" id="h84-0-427" class="i">+	_missed         int
</a><a href="#h84-0-428" id="h84-0-428" class="i">+	_expectChan     chan *C
</a><a href="#h84-0-429" id="h84-0-429" class="i">+	_doneChan       chan *C
</a><a href="#h84-0-430" id="h84-0-430" class="i">+	_stopChan       chan bool
</a><a href="#h84-0-431" id="h84-0-431" class="i">+}
</a><a href="#h84-0-432" id="h84-0-432" class="i">+
</a><a href="#h84-0-433" id="h84-0-433" class="i">+func newResultTracker() *resultTracker {
</a><a href="#h84-0-434" id="h84-0-434" class="i">+	return &amp;resultTracker{_expectChan: make(chan *C), // Synchronous
</a><a href="#h84-0-435" id="h84-0-435" class="i">+		_doneChan: make(chan *C, 32), // Asynchronous
</a><a href="#h84-0-436" id="h84-0-436" class="i">+		_stopChan: make(chan bool)}   // Synchronous
</a><a href="#h84-0-437" id="h84-0-437" class="i">+}
</a><a href="#h84-0-438" id="h84-0-438" class="i">+
</a><a href="#h84-0-439" id="h84-0-439" class="i">+func (tracker *resultTracker) start() {
</a><a href="#h84-0-440" id="h84-0-440" class="i">+	go tracker._loopRoutine()
</a><a href="#h84-0-441" id="h84-0-441" class="i">+}
</a><a href="#h84-0-442" id="h84-0-442" class="i">+
</a><a href="#h84-0-443" id="h84-0-443" class="i">+func (tracker *resultTracker) waitAndStop() {
</a><a href="#h84-0-444" id="h84-0-444" class="i">+	&lt;-tracker._stopChan
</a><a href="#h84-0-445" id="h84-0-445" class="i">+}
</a><a href="#h84-0-446" id="h84-0-446" class="i">+
</a><a href="#h84-0-447" id="h84-0-447" class="i">+func (tracker *resultTracker) expectCall(c *C) {
</a><a href="#h84-0-448" id="h84-0-448" class="i">+	tracker._expectChan &lt;- c
</a><a href="#h84-0-449" id="h84-0-449" class="i">+}
</a><a href="#h84-0-450" id="h84-0-450" class="i">+
</a><a href="#h84-0-451" id="h84-0-451" class="i">+func (tracker *resultTracker) callDone(c *C) {
</a><a href="#h84-0-452" id="h84-0-452" class="i">+	tracker._doneChan &lt;- c
</a><a href="#h84-0-453" id="h84-0-453" class="i">+}
</a><a href="#h84-0-454" id="h84-0-454" class="i">+
</a><a href="#h84-0-455" id="h84-0-455" class="i">+func (tracker *resultTracker) _loopRoutine() {
</a><a href="#h84-0-456" id="h84-0-456" class="i">+	for {
</a><a href="#h84-0-457" id="h84-0-457" class="i">+		var c *C
</a><a href="#h84-0-458" id="h84-0-458" class="i">+		if tracker._waiting &gt; 0 {
</a><a href="#h84-0-459" id="h84-0-459" class="i">+			// Calls still running. Can&#39;t stop.
</a><a href="#h84-0-460" id="h84-0-460" class="i">+			select {
</a><a href="#h84-0-461" id="h84-0-461" class="i">+			// XXX Reindent this (not now to make diff clear)
</a><a href="#h84-0-462" id="h84-0-462" class="i">+			case c = &lt;-tracker._expectChan:
</a><a href="#h84-0-463" id="h84-0-463" class="i">+				tracker._waiting += 1
</a><a href="#h84-0-464" id="h84-0-464" class="i">+			case c = &lt;-tracker._doneChan:
</a><a href="#h84-0-465" id="h84-0-465" class="i">+				tracker._waiting -= 1
</a><a href="#h84-0-466" id="h84-0-466" class="i">+				switch c.status() {
</a><a href="#h84-0-467" id="h84-0-467" class="i">+				case succeededSt:
</a><a href="#h84-0-468" id="h84-0-468" class="i">+					if c.kind == testKd {
</a><a href="#h84-0-469" id="h84-0-469" class="i">+						if c.mustFail {
</a><a href="#h84-0-470" id="h84-0-470" class="i">+							tracker.result.ExpectedFailures++
</a><a href="#h84-0-471" id="h84-0-471" class="i">+						} else {
</a><a href="#h84-0-472" id="h84-0-472" class="i">+							tracker.result.Succeeded++
</a><a href="#h84-0-473" id="h84-0-473" class="i">+						}
</a><a href="#h84-0-474" id="h84-0-474" class="i">+					}
</a><a href="#h84-0-475" id="h84-0-475" class="i">+				case failedSt:
</a><a href="#h84-0-476" id="h84-0-476" class="i">+					tracker.result.Failed++
</a><a href="#h84-0-477" id="h84-0-477" class="i">+				case panickedSt:
</a><a href="#h84-0-478" id="h84-0-478" class="i">+					if c.kind == fixtureKd {
</a><a href="#h84-0-479" id="h84-0-479" class="i">+						tracker.result.FixturePanicked++
</a><a href="#h84-0-480" id="h84-0-480" class="i">+					} else {
</a><a href="#h84-0-481" id="h84-0-481" class="i">+						tracker.result.Panicked++
</a><a href="#h84-0-482" id="h84-0-482" class="i">+					}
</a><a href="#h84-0-483" id="h84-0-483" class="i">+				case fixturePanickedSt:
</a><a href="#h84-0-484" id="h84-0-484" class="i">+					// Track it as missed, since the panic
</a><a href="#h84-0-485" id="h84-0-485" class="i">+					// was on the fixture, not on the test.
</a><a href="#h84-0-486" id="h84-0-486" class="i">+					tracker.result.Missed++
</a><a href="#h84-0-487" id="h84-0-487" class="i">+				case missedSt:
</a><a href="#h84-0-488" id="h84-0-488" class="i">+					tracker.result.Missed++
</a><a href="#h84-0-489" id="h84-0-489" class="i">+				case skippedSt:
</a><a href="#h84-0-490" id="h84-0-490" class="i">+					if c.kind == testKd {
</a><a href="#h84-0-491" id="h84-0-491" class="i">+						tracker.result.Skipped++
</a><a href="#h84-0-492" id="h84-0-492" class="i">+					}
</a><a href="#h84-0-493" id="h84-0-493" class="i">+				}
</a><a href="#h84-0-494" id="h84-0-494" class="i">+			}
</a><a href="#h84-0-495" id="h84-0-495" class="i">+		} else {
</a><a href="#h84-0-496" id="h84-0-496" class="i">+			// No calls.  Can stop, but no done calls here.
</a><a href="#h84-0-497" id="h84-0-497" class="i">+			select {
</a><a href="#h84-0-498" id="h84-0-498" class="i">+			case tracker._stopChan &lt;- true:
</a><a href="#h84-0-499" id="h84-0-499" class="i">+				return
</a><a href="#h84-0-500" id="h84-0-500" class="i">+			case c = &lt;-tracker._expectChan:
</a><a href="#h84-0-501" id="h84-0-501" class="i">+				tracker._waiting += 1
</a><a href="#h84-0-502" id="h84-0-502" class="i">+			case c = &lt;-tracker._doneChan:
</a><a href="#h84-0-503" id="h84-0-503" class="i">+				panic(&quot;Tracker got an unexpected done call.&quot;)
</a><a href="#h84-0-504" id="h84-0-504" class="i">+			}
</a><a href="#h84-0-505" id="h84-0-505" class="i">+		}
</a><a href="#h84-0-506" id="h84-0-506" class="i">+	}
</a><a href="#h84-0-507" id="h84-0-507" class="i">+}
</a><a href="#h84-0-508" id="h84-0-508" class="i">+
</a><a href="#h84-0-509" id="h84-0-509" class="i">+// -----------------------------------------------------------------------
</a><a href="#h84-0-510" id="h84-0-510" class="i">+// The underlying suite runner.
</a><a href="#h84-0-511" id="h84-0-511" class="i">+
</a><a href="#h84-0-512" id="h84-0-512" class="i">+type suiteRunner struct {
</a><a href="#h84-0-513" id="h84-0-513" class="i">+	suite                     interface{}
</a><a href="#h84-0-514" id="h84-0-514" class="i">+	setUpSuite, tearDownSuite *methodType
</a><a href="#h84-0-515" id="h84-0-515" class="i">+	setUpTest, tearDownTest   *methodType
</a><a href="#h84-0-516" id="h84-0-516" class="i">+	tests                     []*methodType
</a><a href="#h84-0-517" id="h84-0-517" class="i">+	tracker                   *resultTracker
</a><a href="#h84-0-518" id="h84-0-518" class="i">+	tempDir                   *tempDir
</a><a href="#h84-0-519" id="h84-0-519" class="i">+	keepDir                   bool
</a><a href="#h84-0-520" id="h84-0-520" class="i">+	output                    *outputWriter
</a><a href="#h84-0-521" id="h84-0-521" class="i">+	reportedProblemLast       bool
</a><a href="#h84-0-522" id="h84-0-522" class="i">+	benchTime                 time.Duration
</a><a href="#h84-0-523" id="h84-0-523" class="i">+	benchMem                  bool
</a><a href="#h84-0-524" id="h84-0-524" class="i">+}
</a><a href="#h84-0-525" id="h84-0-525" class="i">+
</a><a href="#h84-0-526" id="h84-0-526" class="i">+type RunConf struct {
</a><a href="#h84-0-527" id="h84-0-527" class="i">+	Output        io.Writer
</a><a href="#h84-0-528" id="h84-0-528" class="i">+	Stream        bool
</a><a href="#h84-0-529" id="h84-0-529" class="i">+	Verbose       bool
</a><a href="#h84-0-530" id="h84-0-530" class="i">+	Filter        string
</a><a href="#h84-0-531" id="h84-0-531" class="i">+	Benchmark     bool
</a><a href="#h84-0-532" id="h84-0-532" class="i">+	BenchmarkTime time.Duration // Defaults to 1 second
</a><a href="#h84-0-533" id="h84-0-533" class="i">+	BenchmarkMem  bool
</a><a href="#h84-0-534" id="h84-0-534" class="i">+	KeepWorkDir   bool
</a><a href="#h84-0-535" id="h84-0-535" class="i">+}
</a><a href="#h84-0-536" id="h84-0-536" class="i">+
</a><a href="#h84-0-537" id="h84-0-537" class="i">+// Create a new suiteRunner able to run all methods in the given suite.
</a><a href="#h84-0-538" id="h84-0-538" class="i">+func newSuiteRunner(suite interface{}, runConf *RunConf) *suiteRunner {
</a><a href="#h84-0-539" id="h84-0-539" class="i">+	var conf RunConf
</a><a href="#h84-0-540" id="h84-0-540" class="i">+	if runConf != nil {
</a><a href="#h84-0-541" id="h84-0-541" class="i">+		conf = *runConf
</a><a href="#h84-0-542" id="h84-0-542" class="i">+	}
</a><a href="#h84-0-543" id="h84-0-543" class="i">+	if conf.Output == nil {
</a><a href="#h84-0-544" id="h84-0-544" class="i">+		conf.Output = os.Stdout
</a><a href="#h84-0-545" id="h84-0-545" class="i">+	}
</a><a href="#h84-0-546" id="h84-0-546" class="i">+	if conf.Benchmark {
</a><a href="#h84-0-547" id="h84-0-547" class="i">+		conf.Verbose = true
</a><a href="#h84-0-548" id="h84-0-548" class="i">+	}
</a><a href="#h84-0-549" id="h84-0-549" class="i">+
</a><a href="#h84-0-550" id="h84-0-550" class="i">+	suiteType := reflect.TypeOf(suite)
</a><a href="#h84-0-551" id="h84-0-551" class="i">+	suiteNumMethods := suiteType.NumMethod()
</a><a href="#h84-0-552" id="h84-0-552" class="i">+	suiteValue := reflect.ValueOf(suite)
</a><a href="#h84-0-553" id="h84-0-553" class="i">+
</a><a href="#h84-0-554" id="h84-0-554" class="i">+	runner := &amp;suiteRunner{
</a><a href="#h84-0-555" id="h84-0-555" class="i">+		suite:     suite,
</a><a href="#h84-0-556" id="h84-0-556" class="i">+		output:    newOutputWriter(conf.Output, conf.Stream, conf.Verbose),
</a><a href="#h84-0-557" id="h84-0-557" class="i">+		tracker:   newResultTracker(),
</a><a href="#h84-0-558" id="h84-0-558" class="i">+		benchTime: conf.BenchmarkTime,
</a><a href="#h84-0-559" id="h84-0-559" class="i">+		benchMem:  conf.BenchmarkMem,
</a><a href="#h84-0-560" id="h84-0-560" class="i">+		tempDir:   &amp;tempDir{},
</a><a href="#h84-0-561" id="h84-0-561" class="i">+		keepDir:   conf.KeepWorkDir,
</a><a href="#h84-0-562" id="h84-0-562" class="i">+		tests:     make([]*methodType, 0, suiteNumMethods),
</a><a href="#h84-0-563" id="h84-0-563" class="i">+	}
</a><a href="#h84-0-564" id="h84-0-564" class="i">+	if runner.benchTime == 0 {
</a><a href="#h84-0-565" id="h84-0-565" class="i">+		runner.benchTime = 1 * time.Second
</a><a href="#h84-0-566" id="h84-0-566" class="i">+	}
</a><a href="#h84-0-567" id="h84-0-567" class="i">+
</a><a href="#h84-0-568" id="h84-0-568" class="i">+	var filterRegexp *regexp.Regexp
</a><a href="#h84-0-569" id="h84-0-569" class="i">+	if conf.Filter != &quot;&quot; {
</a><a href="#h84-0-570" id="h84-0-570" class="i">+		if regexp, err := regexp.Compile(conf.Filter); err != nil {
</a><a href="#h84-0-571" id="h84-0-571" class="i">+			msg := &quot;Bad filter expression: &quot; + err.Error()
</a><a href="#h84-0-572" id="h84-0-572" class="i">+			runner.tracker.result.RunError = errors.New(msg)
</a><a href="#h84-0-573" id="h84-0-573" class="i">+			return runner
</a><a href="#h84-0-574" id="h84-0-574" class="i">+		} else {
</a><a href="#h84-0-575" id="h84-0-575" class="i">+			filterRegexp = regexp
</a><a href="#h84-0-576" id="h84-0-576" class="i">+		}
</a><a href="#h84-0-577" id="h84-0-577" class="i">+	}
</a><a href="#h84-0-578" id="h84-0-578" class="i">+
</a><a href="#h84-0-579" id="h84-0-579" class="i">+	for i := 0; i != suiteNumMethods; i++ {
</a><a href="#h84-0-580" id="h84-0-580" class="i">+		method := newMethod(suiteValue, i)
</a><a href="#h84-0-581" id="h84-0-581" class="i">+		switch method.Info.Name {
</a><a href="#h84-0-582" id="h84-0-582" class="i">+		case &quot;SetUpSuite&quot;:
</a><a href="#h84-0-583" id="h84-0-583" class="i">+			runner.setUpSuite = method
</a><a href="#h84-0-584" id="h84-0-584" class="i">+		case &quot;TearDownSuite&quot;:
</a><a href="#h84-0-585" id="h84-0-585" class="i">+			runner.tearDownSuite = method
</a><a href="#h84-0-586" id="h84-0-586" class="i">+		case &quot;SetUpTest&quot;:
</a><a href="#h84-0-587" id="h84-0-587" class="i">+			runner.setUpTest = method
</a><a href="#h84-0-588" id="h84-0-588" class="i">+		case &quot;TearDownTest&quot;:
</a><a href="#h84-0-589" id="h84-0-589" class="i">+			runner.tearDownTest = method
</a><a href="#h84-0-590" id="h84-0-590" class="i">+		default:
</a><a href="#h84-0-591" id="h84-0-591" class="i">+			prefix := &quot;Test&quot;
</a><a href="#h84-0-592" id="h84-0-592" class="i">+			if conf.Benchmark {
</a><a href="#h84-0-593" id="h84-0-593" class="i">+				prefix = &quot;Benchmark&quot;
</a><a href="#h84-0-594" id="h84-0-594" class="i">+			}
</a><a href="#h84-0-595" id="h84-0-595" class="i">+			if !strings.HasPrefix(method.Info.Name, prefix) {
</a><a href="#h84-0-596" id="h84-0-596" class="i">+				continue
</a><a href="#h84-0-597" id="h84-0-597" class="i">+			}
</a><a href="#h84-0-598" id="h84-0-598" class="i">+			if filterRegexp == nil || method.matches(filterRegexp) {
</a><a href="#h84-0-599" id="h84-0-599" class="i">+				runner.tests = append(runner.tests, method)
</a><a href="#h84-0-600" id="h84-0-600" class="i">+			}
</a><a href="#h84-0-601" id="h84-0-601" class="i">+		}
</a><a href="#h84-0-602" id="h84-0-602" class="i">+	}
</a><a href="#h84-0-603" id="h84-0-603" class="i">+	return runner
</a><a href="#h84-0-604" id="h84-0-604" class="i">+}
</a><a href="#h84-0-605" id="h84-0-605" class="i">+
</a><a href="#h84-0-606" id="h84-0-606" class="i">+// Run all methods in the given suite.
</a><a href="#h84-0-607" id="h84-0-607" class="i">+func (runner *suiteRunner) run() *Result {
</a><a href="#h84-0-608" id="h84-0-608" class="i">+	if runner.tracker.result.RunError == nil &amp;&amp; len(runner.tests) &gt; 0 {
</a><a href="#h84-0-609" id="h84-0-609" class="i">+		runner.tracker.start()
</a><a href="#h84-0-610" id="h84-0-610" class="i">+		if runner.checkFixtureArgs() {
</a><a href="#h84-0-611" id="h84-0-611" class="i">+			c := runner.runFixture(runner.setUpSuite, &quot;&quot;, nil)
</a><a href="#h84-0-612" id="h84-0-612" class="i">+			if c == nil || c.status() == succeededSt {
</a><a href="#h84-0-613" id="h84-0-613" class="i">+				for i := 0; i != len(runner.tests); i++ {
</a><a href="#h84-0-614" id="h84-0-614" class="i">+					c := runner.runTest(runner.tests[i])
</a><a href="#h84-0-615" id="h84-0-615" class="i">+					if c.status() == fixturePanickedSt {
</a><a href="#h84-0-616" id="h84-0-616" class="i">+						runner.skipTests(missedSt, runner.tests[i+1:])
</a><a href="#h84-0-617" id="h84-0-617" class="i">+						break
</a><a href="#h84-0-618" id="h84-0-618" class="i">+					}
</a><a href="#h84-0-619" id="h84-0-619" class="i">+				}
</a><a href="#h84-0-620" id="h84-0-620" class="i">+			} else if c != nil &amp;&amp; c.status() == skippedSt {
</a><a href="#h84-0-621" id="h84-0-621" class="i">+				runner.skipTests(skippedSt, runner.tests)
</a><a href="#h84-0-622" id="h84-0-622" class="i">+			} else {
</a><a href="#h84-0-623" id="h84-0-623" class="i">+				runner.skipTests(missedSt, runner.tests)
</a><a href="#h84-0-624" id="h84-0-624" class="i">+			}
</a><a href="#h84-0-625" id="h84-0-625" class="i">+			runner.runFixture(runner.tearDownSuite, &quot;&quot;, nil)
</a><a href="#h84-0-626" id="h84-0-626" class="i">+		} else {
</a><a href="#h84-0-627" id="h84-0-627" class="i">+			runner.skipTests(missedSt, runner.tests)
</a><a href="#h84-0-628" id="h84-0-628" class="i">+		}
</a><a href="#h84-0-629" id="h84-0-629" class="i">+		runner.tracker.waitAndStop()
</a><a href="#h84-0-630" id="h84-0-630" class="i">+		if runner.keepDir {
</a><a href="#h84-0-631" id="h84-0-631" class="i">+			runner.tracker.result.WorkDir = runner.tempDir.path
</a><a href="#h84-0-632" id="h84-0-632" class="i">+		} else {
</a><a href="#h84-0-633" id="h84-0-633" class="i">+			runner.tempDir.removeAll()
</a><a href="#h84-0-634" id="h84-0-634" class="i">+		}
</a><a href="#h84-0-635" id="h84-0-635" class="i">+	}
</a><a href="#h84-0-636" id="h84-0-636" class="i">+	return &amp;runner.tracker.result
</a><a href="#h84-0-637" id="h84-0-637" class="i">+}
</a><a href="#h84-0-638" id="h84-0-638" class="i">+
</a><a href="#h84-0-639" id="h84-0-639" class="i">+// Create a call object with the given suite method, and fork a
</a><a href="#h84-0-640" id="h84-0-640" class="i">+// goroutine with the provided dispatcher for running it.
</a><a href="#h84-0-641" id="h84-0-641" class="i">+func (runner *suiteRunner) forkCall(method *methodType, kind funcKind, testName string, logb *logger, dispatcher func(c *C)) *C {
</a><a href="#h84-0-642" id="h84-0-642" class="i">+	var logw io.Writer
</a><a href="#h84-0-643" id="h84-0-643" class="i">+	if runner.output.Stream {
</a><a href="#h84-0-644" id="h84-0-644" class="i">+		logw = runner.output
</a><a href="#h84-0-645" id="h84-0-645" class="i">+	}
</a><a href="#h84-0-646" id="h84-0-646" class="i">+	if logb == nil {
</a><a href="#h84-0-647" id="h84-0-647" class="i">+		logb = new(logger)
</a><a href="#h84-0-648" id="h84-0-648" class="i">+	}
</a><a href="#h84-0-649" id="h84-0-649" class="i">+	c := &amp;C{
</a><a href="#h84-0-650" id="h84-0-650" class="i">+		method:    method,
</a><a href="#h84-0-651" id="h84-0-651" class="i">+		kind:      kind,
</a><a href="#h84-0-652" id="h84-0-652" class="i">+		testName:  testName,
</a><a href="#h84-0-653" id="h84-0-653" class="i">+		logb:      logb,
</a><a href="#h84-0-654" id="h84-0-654" class="i">+		logw:      logw,
</a><a href="#h84-0-655" id="h84-0-655" class="i">+		tempDir:   runner.tempDir,
</a><a href="#h84-0-656" id="h84-0-656" class="i">+		done:      make(chan *C, 1),
</a><a href="#h84-0-657" id="h84-0-657" class="i">+		timer:     timer{benchTime: runner.benchTime},
</a><a href="#h84-0-658" id="h84-0-658" class="i">+		startTime: time.Now(),
</a><a href="#h84-0-659" id="h84-0-659" class="i">+		benchMem:  runner.benchMem,
</a><a href="#h84-0-660" id="h84-0-660" class="i">+	}
</a><a href="#h84-0-661" id="h84-0-661" class="i">+	runner.tracker.expectCall(c)
</a><a href="#h84-0-662" id="h84-0-662" class="i">+	go (func() {
</a><a href="#h84-0-663" id="h84-0-663" class="i">+		runner.reportCallStarted(c)
</a><a href="#h84-0-664" id="h84-0-664" class="i">+		defer runner.callDone(c)
</a><a href="#h84-0-665" id="h84-0-665" class="i">+		dispatcher(c)
</a><a href="#h84-0-666" id="h84-0-666" class="i">+	})()
</a><a href="#h84-0-667" id="h84-0-667" class="i">+	return c
</a><a href="#h84-0-668" id="h84-0-668" class="i">+}
</a><a href="#h84-0-669" id="h84-0-669" class="i">+
</a><a href="#h84-0-670" id="h84-0-670" class="i">+// Same as forkCall(), but wait for call to finish before returning.
</a><a href="#h84-0-671" id="h84-0-671" class="i">+func (runner *suiteRunner) runFunc(method *methodType, kind funcKind, testName string, logb *logger, dispatcher func(c *C)) *C {
</a><a href="#h84-0-672" id="h84-0-672" class="i">+	c := runner.forkCall(method, kind, testName, logb, dispatcher)
</a><a href="#h84-0-673" id="h84-0-673" class="i">+	&lt;-c.done
</a><a href="#h84-0-674" id="h84-0-674" class="i">+	return c
</a><a href="#h84-0-675" id="h84-0-675" class="i">+}
</a><a href="#h84-0-676" id="h84-0-676" class="i">+
</a><a href="#h84-0-677" id="h84-0-677" class="i">+// Handle a finished call.  If there were any panics, update the call status
</a><a href="#h84-0-678" id="h84-0-678" class="i">+// accordingly.  Then, mark the call as done and report to the tracker.
</a><a href="#h84-0-679" id="h84-0-679" class="i">+func (runner *suiteRunner) callDone(c *C) {
</a><a href="#h84-0-680" id="h84-0-680" class="i">+	value := recover()
</a><a href="#h84-0-681" id="h84-0-681" class="i">+	if value != nil {
</a><a href="#h84-0-682" id="h84-0-682" class="i">+		switch v := value.(type) {
</a><a href="#h84-0-683" id="h84-0-683" class="i">+		case *fixturePanic:
</a><a href="#h84-0-684" id="h84-0-684" class="i">+			if v.status == skippedSt {
</a><a href="#h84-0-685" id="h84-0-685" class="i">+				c.setStatus(skippedSt)
</a><a href="#h84-0-686" id="h84-0-686" class="i">+			} else {
</a><a href="#h84-0-687" id="h84-0-687" class="i">+				c.logSoftPanic(&quot;Fixture has panicked (see related PANIC)&quot;)
</a><a href="#h84-0-688" id="h84-0-688" class="i">+				c.setStatus(fixturePanickedSt)
</a><a href="#h84-0-689" id="h84-0-689" class="i">+			}
</a><a href="#h84-0-690" id="h84-0-690" class="i">+		default:
</a><a href="#h84-0-691" id="h84-0-691" class="i">+			c.logPanic(1, value)
</a><a href="#h84-0-692" id="h84-0-692" class="i">+			c.setStatus(panickedSt)
</a><a href="#h84-0-693" id="h84-0-693" class="i">+		}
</a><a href="#h84-0-694" id="h84-0-694" class="i">+	}
</a><a href="#h84-0-695" id="h84-0-695" class="i">+	if c.mustFail {
</a><a href="#h84-0-696" id="h84-0-696" class="i">+		switch c.status() {
</a><a href="#h84-0-697" id="h84-0-697" class="i">+		case failedSt:
</a><a href="#h84-0-698" id="h84-0-698" class="i">+			c.setStatus(succeededSt)
</a><a href="#h84-0-699" id="h84-0-699" class="i">+		case succeededSt:
</a><a href="#h84-0-700" id="h84-0-700" class="i">+			c.setStatus(failedSt)
</a><a href="#h84-0-701" id="h84-0-701" class="i">+			c.logString(&quot;Error: Test succeeded, but was expected to fail&quot;)
</a><a href="#h84-0-702" id="h84-0-702" class="i">+			c.logString(&quot;Reason: &quot; + c.reason)
</a><a href="#h84-0-703" id="h84-0-703" class="i">+		}
</a><a href="#h84-0-704" id="h84-0-704" class="i">+	}
</a><a href="#h84-0-705" id="h84-0-705" class="i">+
</a><a href="#h84-0-706" id="h84-0-706" class="i">+	runner.reportCallDone(c)
</a><a href="#h84-0-707" id="h84-0-707" class="i">+	c.done &lt;- c
</a><a href="#h84-0-708" id="h84-0-708" class="i">+}
</a><a href="#h84-0-709" id="h84-0-709" class="i">+
</a><a href="#h84-0-710" id="h84-0-710" class="i">+// Runs a fixture call synchronously.  The fixture will still be run in a
</a><a href="#h84-0-711" id="h84-0-711" class="i">+// goroutine like all suite methods, but this method will not return
</a><a href="#h84-0-712" id="h84-0-712" class="i">+// while the fixture goroutine is not done, because the fixture must be
</a><a href="#h84-0-713" id="h84-0-713" class="i">+// run in a desired order.
</a><a href="#h84-0-714" id="h84-0-714" class="i">+func (runner *suiteRunner) runFixture(method *methodType, testName string, logb *logger) *C {
</a><a href="#h84-0-715" id="h84-0-715" class="i">+	if method != nil {
</a><a href="#h84-0-716" id="h84-0-716" class="i">+		c := runner.runFunc(method, fixtureKd, testName, logb, func(c *C) {
</a><a href="#h84-0-717" id="h84-0-717" class="i">+			c.ResetTimer()
</a><a href="#h84-0-718" id="h84-0-718" class="i">+			c.StartTimer()
</a><a href="#h84-0-719" id="h84-0-719" class="i">+			defer c.StopTimer()
</a><a href="#h84-0-720" id="h84-0-720" class="i">+			c.method.Call([]reflect.Value{reflect.ValueOf(c)})
</a><a href="#h84-0-721" id="h84-0-721" class="i">+		})
</a><a href="#h84-0-722" id="h84-0-722" class="i">+		return c
</a><a href="#h84-0-723" id="h84-0-723" class="i">+	}
</a><a href="#h84-0-724" id="h84-0-724" class="i">+	return nil
</a><a href="#h84-0-725" id="h84-0-725" class="i">+}
</a><a href="#h84-0-726" id="h84-0-726" class="i">+
</a><a href="#h84-0-727" id="h84-0-727" class="i">+// Run the fixture method with runFixture(), but panic with a fixturePanic{}
</a><a href="#h84-0-728" id="h84-0-728" class="i">+// in case the fixture method panics.  This makes it easier to track the
</a><a href="#h84-0-729" id="h84-0-729" class="i">+// fixture panic together with other call panics within forkTest().
</a><a href="#h84-0-730" id="h84-0-730" class="i">+func (runner *suiteRunner) runFixtureWithPanic(method *methodType, testName string, logb *logger, skipped *bool) *C {
</a><a href="#h84-0-731" id="h84-0-731" class="i">+	if skipped != nil &amp;&amp; *skipped {
</a><a href="#h84-0-732" id="h84-0-732" class="i">+		return nil
</a><a href="#h84-0-733" id="h84-0-733" class="i">+	}
</a><a href="#h84-0-734" id="h84-0-734" class="i">+	c := runner.runFixture(method, testName, logb)
</a><a href="#h84-0-735" id="h84-0-735" class="i">+	if c != nil &amp;&amp; c.status() != succeededSt {
</a><a href="#h84-0-736" id="h84-0-736" class="i">+		if skipped != nil {
</a><a href="#h84-0-737" id="h84-0-737" class="i">+			*skipped = c.status() == skippedSt
</a><a href="#h84-0-738" id="h84-0-738" class="i">+		}
</a><a href="#h84-0-739" id="h84-0-739" class="i">+		panic(&amp;fixturePanic{c.status(), method})
</a><a href="#h84-0-740" id="h84-0-740" class="i">+	}
</a><a href="#h84-0-741" id="h84-0-741" class="i">+	return c
</a><a href="#h84-0-742" id="h84-0-742" class="i">+}
</a><a href="#h84-0-743" id="h84-0-743" class="i">+
</a><a href="#h84-0-744" id="h84-0-744" class="i">+type fixturePanic struct {
</a><a href="#h84-0-745" id="h84-0-745" class="i">+	status funcStatus
</a><a href="#h84-0-746" id="h84-0-746" class="i">+	method *methodType
</a><a href="#h84-0-747" id="h84-0-747" class="i">+}
</a><a href="#h84-0-748" id="h84-0-748" class="i">+
</a><a href="#h84-0-749" id="h84-0-749" class="i">+// Run the suite test method, together with the test-specific fixture,
</a><a href="#h84-0-750" id="h84-0-750" class="i">+// asynchronously.
</a><a href="#h84-0-751" id="h84-0-751" class="i">+func (runner *suiteRunner) forkTest(method *methodType) *C {
</a><a href="#h84-0-752" id="h84-0-752" class="i">+	testName := method.String()
</a><a href="#h84-0-753" id="h84-0-753" class="i">+	return runner.forkCall(method, testKd, testName, nil, func(c *C) {
</a><a href="#h84-0-754" id="h84-0-754" class="i">+		var skipped bool
</a><a href="#h84-0-755" id="h84-0-755" class="i">+		defer runner.runFixtureWithPanic(runner.tearDownTest, testName, nil, &amp;skipped)
</a><a href="#h84-0-756" id="h84-0-756" class="i">+		defer c.StopTimer()
</a><a href="#h84-0-757" id="h84-0-757" class="i">+		benchN := 1
</a><a href="#h84-0-758" id="h84-0-758" class="i">+		for {
</a><a href="#h84-0-759" id="h84-0-759" class="i">+			runner.runFixtureWithPanic(runner.setUpTest, testName, c.logb, &amp;skipped)
</a><a href="#h84-0-760" id="h84-0-760" class="i">+			mt := c.method.Type()
</a><a href="#h84-0-761" id="h84-0-761" class="i">+			if mt.NumIn() != 1 || mt.In(0) != reflect.TypeOf(c) {
</a><a href="#h84-0-762" id="h84-0-762" class="i">+				// Rather than a plain panic, provide a more helpful message when
</a><a href="#h84-0-763" id="h84-0-763" class="i">+				// the argument type is incorrect.
</a><a href="#h84-0-764" id="h84-0-764" class="i">+				c.setStatus(panickedSt)
</a><a href="#h84-0-765" id="h84-0-765" class="i">+				c.logArgPanic(c.method, &quot;*check.C&quot;)
</a><a href="#h84-0-766" id="h84-0-766" class="i">+				return
</a><a href="#h84-0-767" id="h84-0-767" class="i">+			}
</a><a href="#h84-0-768" id="h84-0-768" class="i">+			if strings.HasPrefix(c.method.Info.Name, &quot;Test&quot;) {
</a><a href="#h84-0-769" id="h84-0-769" class="i">+				c.ResetTimer()
</a><a href="#h84-0-770" id="h84-0-770" class="i">+				c.StartTimer()
</a><a href="#h84-0-771" id="h84-0-771" class="i">+				c.method.Call([]reflect.Value{reflect.ValueOf(c)})
</a><a href="#h84-0-772" id="h84-0-772" class="i">+				return
</a><a href="#h84-0-773" id="h84-0-773" class="i">+			}
</a><a href="#h84-0-774" id="h84-0-774" class="i">+			if !strings.HasPrefix(c.method.Info.Name, &quot;Benchmark&quot;) {
</a><a href="#h84-0-775" id="h84-0-775" class="i">+				panic(&quot;unexpected method prefix: &quot; + c.method.Info.Name)
</a><a href="#h84-0-776" id="h84-0-776" class="i">+			}
</a><a href="#h84-0-777" id="h84-0-777" class="i">+
</a><a href="#h84-0-778" id="h84-0-778" class="i">+			runtime.GC()
</a><a href="#h84-0-779" id="h84-0-779" class="i">+			c.N = benchN
</a><a href="#h84-0-780" id="h84-0-780" class="i">+			c.ResetTimer()
</a><a href="#h84-0-781" id="h84-0-781" class="i">+			c.StartTimer()
</a><a href="#h84-0-782" id="h84-0-782" class="i">+			c.method.Call([]reflect.Value{reflect.ValueOf(c)})
</a><a href="#h84-0-783" id="h84-0-783" class="i">+			c.StopTimer()
</a><a href="#h84-0-784" id="h84-0-784" class="i">+			if c.status() != succeededSt || c.duration &gt;= c.benchTime || benchN &gt;= 1e9 {
</a><a href="#h84-0-785" id="h84-0-785" class="i">+				return
</a><a href="#h84-0-786" id="h84-0-786" class="i">+			}
</a><a href="#h84-0-787" id="h84-0-787" class="i">+			perOpN := int(1e9)
</a><a href="#h84-0-788" id="h84-0-788" class="i">+			if c.nsPerOp() != 0 {
</a><a href="#h84-0-789" id="h84-0-789" class="i">+				perOpN = int(c.benchTime.Nanoseconds() / c.nsPerOp())
</a><a href="#h84-0-790" id="h84-0-790" class="i">+			}
</a><a href="#h84-0-791" id="h84-0-791" class="i">+
</a><a href="#h84-0-792" id="h84-0-792" class="i">+			// Logic taken from the stock testing package:
</a><a href="#h84-0-793" id="h84-0-793" class="i">+			// - Run more iterations than we think we&#39;ll need for a second (1.5x).
</a><a href="#h84-0-794" id="h84-0-794" class="i">+			// - Don&#39;t grow too fast in case we had timing errors previously.
</a><a href="#h84-0-795" id="h84-0-795" class="i">+			// - Be sure to run at least one more than last time.
</a><a href="#h84-0-796" id="h84-0-796" class="i">+			benchN = max(min(perOpN+perOpN/2, 100*benchN), benchN+1)
</a><a href="#h84-0-797" id="h84-0-797" class="i">+			benchN = roundUp(benchN)
</a><a href="#h84-0-798" id="h84-0-798" class="i">+
</a><a href="#h84-0-799" id="h84-0-799" class="i">+			skipped = true // Don&#39;t run the deferred one if this panics.
</a><a href="#h84-0-800" id="h84-0-800" class="i">+			runner.runFixtureWithPanic(runner.tearDownTest, testName, nil, nil)
</a><a href="#h84-0-801" id="h84-0-801" class="i">+			skipped = false
</a><a href="#h84-0-802" id="h84-0-802" class="i">+		}
</a><a href="#h84-0-803" id="h84-0-803" class="i">+	})
</a><a href="#h84-0-804" id="h84-0-804" class="i">+}
</a><a href="#h84-0-805" id="h84-0-805" class="i">+
</a><a href="#h84-0-806" id="h84-0-806" class="i">+// Same as forkTest(), but wait for the test to finish before returning.
</a><a href="#h84-0-807" id="h84-0-807" class="i">+func (runner *suiteRunner) runTest(method *methodType) *C {
</a><a href="#h84-0-808" id="h84-0-808" class="i">+	c := runner.forkTest(method)
</a><a href="#h84-0-809" id="h84-0-809" class="i">+	&lt;-c.done
</a><a href="#h84-0-810" id="h84-0-810" class="i">+	return c
</a><a href="#h84-0-811" id="h84-0-811" class="i">+}
</a><a href="#h84-0-812" id="h84-0-812" class="i">+
</a><a href="#h84-0-813" id="h84-0-813" class="i">+// Helper to mark tests as skipped or missed.  A bit heavy for what
</a><a href="#h84-0-814" id="h84-0-814" class="i">+// it does, but it enables homogeneous handling of tracking, including
</a><a href="#h84-0-815" id="h84-0-815" class="i">+// nice verbose output.
</a><a href="#h84-0-816" id="h84-0-816" class="i">+func (runner *suiteRunner) skipTests(status funcStatus, methods []*methodType) {
</a><a href="#h84-0-817" id="h84-0-817" class="i">+	for _, method := range methods {
</a><a href="#h84-0-818" id="h84-0-818" class="i">+		runner.runFunc(method, testKd, &quot;&quot;, nil, func(c *C) {
</a><a href="#h84-0-819" id="h84-0-819" class="i">+			c.setStatus(status)
</a><a href="#h84-0-820" id="h84-0-820" class="i">+		})
</a><a href="#h84-0-821" id="h84-0-821" class="i">+	}
</a><a href="#h84-0-822" id="h84-0-822" class="i">+}
</a><a href="#h84-0-823" id="h84-0-823" class="i">+
</a><a href="#h84-0-824" id="h84-0-824" class="i">+// Verify if the fixture arguments are *check.C.  In case of errors,
</a><a href="#h84-0-825" id="h84-0-825" class="i">+// log the error as a panic in the fixture method call, and return false.
</a><a href="#h84-0-826" id="h84-0-826" class="i">+func (runner *suiteRunner) checkFixtureArgs() bool {
</a><a href="#h84-0-827" id="h84-0-827" class="i">+	succeeded := true
</a><a href="#h84-0-828" id="h84-0-828" class="i">+	argType := reflect.TypeOf(&amp;C{})
</a><a href="#h84-0-829" id="h84-0-829" class="i">+	for _, method := range []*methodType{runner.setUpSuite, runner.tearDownSuite, runner.setUpTest, runner.tearDownTest} {
</a><a href="#h84-0-830" id="h84-0-830" class="i">+		if method != nil {
</a><a href="#h84-0-831" id="h84-0-831" class="i">+			mt := method.Type()
</a><a href="#h84-0-832" id="h84-0-832" class="i">+			if mt.NumIn() != 1 || mt.In(0) != argType {
</a><a href="#h84-0-833" id="h84-0-833" class="i">+				succeeded = false
</a><a href="#h84-0-834" id="h84-0-834" class="i">+				runner.runFunc(method, fixtureKd, &quot;&quot;, nil, func(c *C) {
</a><a href="#h84-0-835" id="h84-0-835" class="i">+					c.logArgPanic(method, &quot;*check.C&quot;)
</a><a href="#h84-0-836" id="h84-0-836" class="i">+					c.setStatus(panickedSt)
</a><a href="#h84-0-837" id="h84-0-837" class="i">+				})
</a><a href="#h84-0-838" id="h84-0-838" class="i">+			}
</a><a href="#h84-0-839" id="h84-0-839" class="i">+		}
</a><a href="#h84-0-840" id="h84-0-840" class="i">+	}
</a><a href="#h84-0-841" id="h84-0-841" class="i">+	return succeeded
</a><a href="#h84-0-842" id="h84-0-842" class="i">+}
</a><a href="#h84-0-843" id="h84-0-843" class="i">+
</a><a href="#h84-0-844" id="h84-0-844" class="i">+func (runner *suiteRunner) reportCallStarted(c *C) {
</a><a href="#h84-0-845" id="h84-0-845" class="i">+	runner.output.WriteCallStarted(&quot;START&quot;, c)
</a><a href="#h84-0-846" id="h84-0-846" class="i">+}
</a><a href="#h84-0-847" id="h84-0-847" class="i">+
</a><a href="#h84-0-848" id="h84-0-848" class="i">+func (runner *suiteRunner) reportCallDone(c *C) {
</a><a href="#h84-0-849" id="h84-0-849" class="i">+	runner.tracker.callDone(c)
</a><a href="#h84-0-850" id="h84-0-850" class="i">+	switch c.status() {
</a><a href="#h84-0-851" id="h84-0-851" class="i">+	case succeededSt:
</a><a href="#h84-0-852" id="h84-0-852" class="i">+		if c.mustFail {
</a><a href="#h84-0-853" id="h84-0-853" class="i">+			runner.output.WriteCallSuccess(&quot;FAIL EXPECTED&quot;, c)
</a><a href="#h84-0-854" id="h84-0-854" class="i">+		} else {
</a><a href="#h84-0-855" id="h84-0-855" class="i">+			runner.output.WriteCallSuccess(&quot;PASS&quot;, c)
</a><a href="#h84-0-856" id="h84-0-856" class="i">+		}
</a><a href="#h84-0-857" id="h84-0-857" class="i">+	case skippedSt:
</a><a href="#h84-0-858" id="h84-0-858" class="i">+		runner.output.WriteCallSuccess(&quot;SKIP&quot;, c)
</a><a href="#h84-0-859" id="h84-0-859" class="i">+	case failedSt:
</a><a href="#h84-0-860" id="h84-0-860" class="i">+		runner.output.WriteCallProblem(&quot;FAIL&quot;, c)
</a><a href="#h84-0-861" id="h84-0-861" class="i">+	case panickedSt:
</a><a href="#h84-0-862" id="h84-0-862" class="i">+		runner.output.WriteCallProblem(&quot;PANIC&quot;, c)
</a><a href="#h84-0-863" id="h84-0-863" class="i">+	case fixturePanickedSt:
</a><a href="#h84-0-864" id="h84-0-864" class="i">+		// That&#39;s a testKd call reporting that its fixture
</a><a href="#h84-0-865" id="h84-0-865" class="i">+		// has panicked. The fixture call which caused the
</a><a href="#h84-0-866" id="h84-0-866" class="i">+		// panic itself was tracked above. We&#39;ll report to
</a><a href="#h84-0-867" id="h84-0-867" class="i">+		// aid debugging.
</a><a href="#h84-0-868" id="h84-0-868" class="i">+		runner.output.WriteCallProblem(&quot;PANIC&quot;, c)
</a><a href="#h84-0-869" id="h84-0-869" class="i">+	case missedSt:
</a><a href="#h84-0-870" id="h84-0-870" class="i">+		runner.output.WriteCallSuccess(&quot;MISS&quot;, c)
</a><a href="#h84-0-871" id="h84-0-871" class="i">+	}
</a><a href="#h84-0-872" id="h84-0-872" class="i">+}
</a><b>diff --git a/<a id="h85" href="../file/vendor/gopkg.in/check.v1/checkers.go">vendor/gopkg.in/check.v1/checkers.go</a> b/<a href="../file/vendor/gopkg.in/check.v1/checkers.go">vendor/gopkg.in/check.v1/checkers.go</a></b>
<a href="#h85-0" id="h85-0" class="h">@@ -0,0 +1,458 @@
</a><a href="#h85-0-0" id="h85-0-0" class="i">+package check
</a><a href="#h85-0-1" id="h85-0-1" class="i">+
</a><a href="#h85-0-2" id="h85-0-2" class="i">+import (
</a><a href="#h85-0-3" id="h85-0-3" class="i">+	&quot;fmt&quot;
</a><a href="#h85-0-4" id="h85-0-4" class="i">+	&quot;reflect&quot;
</a><a href="#h85-0-5" id="h85-0-5" class="i">+	&quot;regexp&quot;
</a><a href="#h85-0-6" id="h85-0-6" class="i">+)
</a><a href="#h85-0-7" id="h85-0-7" class="i">+
</a><a href="#h85-0-8" id="h85-0-8" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-9" id="h85-0-9" class="i">+// CommentInterface and Commentf helper, to attach extra information to checks.
</a><a href="#h85-0-10" id="h85-0-10" class="i">+
</a><a href="#h85-0-11" id="h85-0-11" class="i">+type comment struct {
</a><a href="#h85-0-12" id="h85-0-12" class="i">+	format string
</a><a href="#h85-0-13" id="h85-0-13" class="i">+	args   []interface{}
</a><a href="#h85-0-14" id="h85-0-14" class="i">+}
</a><a href="#h85-0-15" id="h85-0-15" class="i">+
</a><a href="#h85-0-16" id="h85-0-16" class="i">+// Commentf returns an infomational value to use with Assert or Check calls.
</a><a href="#h85-0-17" id="h85-0-17" class="i">+// If the checker test fails, the provided arguments will be passed to
</a><a href="#h85-0-18" id="h85-0-18" class="i">+// fmt.Sprintf, and will be presented next to the logged failure.
</a><a href="#h85-0-19" id="h85-0-19" class="i">+//
</a><a href="#h85-0-20" id="h85-0-20" class="i">+// For example:
</a><a href="#h85-0-21" id="h85-0-21" class="i">+//
</a><a href="#h85-0-22" id="h85-0-22" class="i">+//     c.Assert(v, Equals, 42, Commentf(&quot;Iteration #%d failed.&quot;, i))
</a><a href="#h85-0-23" id="h85-0-23" class="i">+//
</a><a href="#h85-0-24" id="h85-0-24" class="i">+// Note that if the comment is constant, a better option is to
</a><a href="#h85-0-25" id="h85-0-25" class="i">+// simply use a normal comment right above or next to the line, as
</a><a href="#h85-0-26" id="h85-0-26" class="i">+// it will also get printed with any errors:
</a><a href="#h85-0-27" id="h85-0-27" class="i">+//
</a><a href="#h85-0-28" id="h85-0-28" class="i">+//     c.Assert(l, Equals, 8192) // Ensure buffer size is correct (bug #123)
</a><a href="#h85-0-29" id="h85-0-29" class="i">+//
</a><a href="#h85-0-30" id="h85-0-30" class="i">+func Commentf(format string, args ...interface{}) CommentInterface {
</a><a href="#h85-0-31" id="h85-0-31" class="i">+	return &amp;comment{format, args}
</a><a href="#h85-0-32" id="h85-0-32" class="i">+}
</a><a href="#h85-0-33" id="h85-0-33" class="i">+
</a><a href="#h85-0-34" id="h85-0-34" class="i">+// CommentInterface must be implemented by types that attach extra
</a><a href="#h85-0-35" id="h85-0-35" class="i">+// information to failed checks. See the Commentf function for details.
</a><a href="#h85-0-36" id="h85-0-36" class="i">+type CommentInterface interface {
</a><a href="#h85-0-37" id="h85-0-37" class="i">+	CheckCommentString() string
</a><a href="#h85-0-38" id="h85-0-38" class="i">+}
</a><a href="#h85-0-39" id="h85-0-39" class="i">+
</a><a href="#h85-0-40" id="h85-0-40" class="i">+func (c *comment) CheckCommentString() string {
</a><a href="#h85-0-41" id="h85-0-41" class="i">+	return fmt.Sprintf(c.format, c.args...)
</a><a href="#h85-0-42" id="h85-0-42" class="i">+}
</a><a href="#h85-0-43" id="h85-0-43" class="i">+
</a><a href="#h85-0-44" id="h85-0-44" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-45" id="h85-0-45" class="i">+// The Checker interface.
</a><a href="#h85-0-46" id="h85-0-46" class="i">+
</a><a href="#h85-0-47" id="h85-0-47" class="i">+// The Checker interface must be provided by checkers used with
</a><a href="#h85-0-48" id="h85-0-48" class="i">+// the Assert and Check verification methods.
</a><a href="#h85-0-49" id="h85-0-49" class="i">+type Checker interface {
</a><a href="#h85-0-50" id="h85-0-50" class="i">+	Info() *CheckerInfo
</a><a href="#h85-0-51" id="h85-0-51" class="i">+	Check(params []interface{}, names []string) (result bool, error string)
</a><a href="#h85-0-52" id="h85-0-52" class="i">+}
</a><a href="#h85-0-53" id="h85-0-53" class="i">+
</a><a href="#h85-0-54" id="h85-0-54" class="i">+// See the Checker interface.
</a><a href="#h85-0-55" id="h85-0-55" class="i">+type CheckerInfo struct {
</a><a href="#h85-0-56" id="h85-0-56" class="i">+	Name   string
</a><a href="#h85-0-57" id="h85-0-57" class="i">+	Params []string
</a><a href="#h85-0-58" id="h85-0-58" class="i">+}
</a><a href="#h85-0-59" id="h85-0-59" class="i">+
</a><a href="#h85-0-60" id="h85-0-60" class="i">+func (info *CheckerInfo) Info() *CheckerInfo {
</a><a href="#h85-0-61" id="h85-0-61" class="i">+	return info
</a><a href="#h85-0-62" id="h85-0-62" class="i">+}
</a><a href="#h85-0-63" id="h85-0-63" class="i">+
</a><a href="#h85-0-64" id="h85-0-64" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-65" id="h85-0-65" class="i">+// Not checker logic inverter.
</a><a href="#h85-0-66" id="h85-0-66" class="i">+
</a><a href="#h85-0-67" id="h85-0-67" class="i">+// The Not checker inverts the logic of the provided checker.  The
</a><a href="#h85-0-68" id="h85-0-68" class="i">+// resulting checker will succeed where the original one failed, and
</a><a href="#h85-0-69" id="h85-0-69" class="i">+// vice-versa.
</a><a href="#h85-0-70" id="h85-0-70" class="i">+//
</a><a href="#h85-0-71" id="h85-0-71" class="i">+// For example:
</a><a href="#h85-0-72" id="h85-0-72" class="i">+//
</a><a href="#h85-0-73" id="h85-0-73" class="i">+//     c.Assert(a, Not(Equals), b)
</a><a href="#h85-0-74" id="h85-0-74" class="i">+//
</a><a href="#h85-0-75" id="h85-0-75" class="i">+func Not(checker Checker) Checker {
</a><a href="#h85-0-76" id="h85-0-76" class="i">+	return &amp;notChecker{checker}
</a><a href="#h85-0-77" id="h85-0-77" class="i">+}
</a><a href="#h85-0-78" id="h85-0-78" class="i">+
</a><a href="#h85-0-79" id="h85-0-79" class="i">+type notChecker struct {
</a><a href="#h85-0-80" id="h85-0-80" class="i">+	sub Checker
</a><a href="#h85-0-81" id="h85-0-81" class="i">+}
</a><a href="#h85-0-82" id="h85-0-82" class="i">+
</a><a href="#h85-0-83" id="h85-0-83" class="i">+func (checker *notChecker) Info() *CheckerInfo {
</a><a href="#h85-0-84" id="h85-0-84" class="i">+	info := *checker.sub.Info()
</a><a href="#h85-0-85" id="h85-0-85" class="i">+	info.Name = &quot;Not(&quot; + info.Name + &quot;)&quot;
</a><a href="#h85-0-86" id="h85-0-86" class="i">+	return &amp;info
</a><a href="#h85-0-87" id="h85-0-87" class="i">+}
</a><a href="#h85-0-88" id="h85-0-88" class="i">+
</a><a href="#h85-0-89" id="h85-0-89" class="i">+func (checker *notChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-90" id="h85-0-90" class="i">+	result, error = checker.sub.Check(params, names)
</a><a href="#h85-0-91" id="h85-0-91" class="i">+	result = !result
</a><a href="#h85-0-92" id="h85-0-92" class="i">+	return
</a><a href="#h85-0-93" id="h85-0-93" class="i">+}
</a><a href="#h85-0-94" id="h85-0-94" class="i">+
</a><a href="#h85-0-95" id="h85-0-95" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-96" id="h85-0-96" class="i">+// IsNil checker.
</a><a href="#h85-0-97" id="h85-0-97" class="i">+
</a><a href="#h85-0-98" id="h85-0-98" class="i">+type isNilChecker struct {
</a><a href="#h85-0-99" id="h85-0-99" class="i">+	*CheckerInfo
</a><a href="#h85-0-100" id="h85-0-100" class="i">+}
</a><a href="#h85-0-101" id="h85-0-101" class="i">+
</a><a href="#h85-0-102" id="h85-0-102" class="i">+// The IsNil checker tests whether the obtained value is nil.
</a><a href="#h85-0-103" id="h85-0-103" class="i">+//
</a><a href="#h85-0-104" id="h85-0-104" class="i">+// For example:
</a><a href="#h85-0-105" id="h85-0-105" class="i">+//
</a><a href="#h85-0-106" id="h85-0-106" class="i">+//    c.Assert(err, IsNil)
</a><a href="#h85-0-107" id="h85-0-107" class="i">+//
</a><a href="#h85-0-108" id="h85-0-108" class="i">+var IsNil Checker = &amp;isNilChecker{
</a><a href="#h85-0-109" id="h85-0-109" class="i">+	&amp;CheckerInfo{Name: &quot;IsNil&quot;, Params: []string{&quot;value&quot;}},
</a><a href="#h85-0-110" id="h85-0-110" class="i">+}
</a><a href="#h85-0-111" id="h85-0-111" class="i">+
</a><a href="#h85-0-112" id="h85-0-112" class="i">+func (checker *isNilChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-113" id="h85-0-113" class="i">+	return isNil(params[0]), &quot;&quot;
</a><a href="#h85-0-114" id="h85-0-114" class="i">+}
</a><a href="#h85-0-115" id="h85-0-115" class="i">+
</a><a href="#h85-0-116" id="h85-0-116" class="i">+func isNil(obtained interface{}) (result bool) {
</a><a href="#h85-0-117" id="h85-0-117" class="i">+	if obtained == nil {
</a><a href="#h85-0-118" id="h85-0-118" class="i">+		result = true
</a><a href="#h85-0-119" id="h85-0-119" class="i">+	} else {
</a><a href="#h85-0-120" id="h85-0-120" class="i">+		switch v := reflect.ValueOf(obtained); v.Kind() {
</a><a href="#h85-0-121" id="h85-0-121" class="i">+		case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
</a><a href="#h85-0-122" id="h85-0-122" class="i">+			return v.IsNil()
</a><a href="#h85-0-123" id="h85-0-123" class="i">+		}
</a><a href="#h85-0-124" id="h85-0-124" class="i">+	}
</a><a href="#h85-0-125" id="h85-0-125" class="i">+	return
</a><a href="#h85-0-126" id="h85-0-126" class="i">+}
</a><a href="#h85-0-127" id="h85-0-127" class="i">+
</a><a href="#h85-0-128" id="h85-0-128" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-129" id="h85-0-129" class="i">+// NotNil checker. Alias for Not(IsNil), since it&#39;s so common.
</a><a href="#h85-0-130" id="h85-0-130" class="i">+
</a><a href="#h85-0-131" id="h85-0-131" class="i">+type notNilChecker struct {
</a><a href="#h85-0-132" id="h85-0-132" class="i">+	*CheckerInfo
</a><a href="#h85-0-133" id="h85-0-133" class="i">+}
</a><a href="#h85-0-134" id="h85-0-134" class="i">+
</a><a href="#h85-0-135" id="h85-0-135" class="i">+// The NotNil checker verifies that the obtained value is not nil.
</a><a href="#h85-0-136" id="h85-0-136" class="i">+//
</a><a href="#h85-0-137" id="h85-0-137" class="i">+// For example:
</a><a href="#h85-0-138" id="h85-0-138" class="i">+//
</a><a href="#h85-0-139" id="h85-0-139" class="i">+//     c.Assert(iface, NotNil)
</a><a href="#h85-0-140" id="h85-0-140" class="i">+//
</a><a href="#h85-0-141" id="h85-0-141" class="i">+// This is an alias for Not(IsNil), made available since it&#39;s a
</a><a href="#h85-0-142" id="h85-0-142" class="i">+// fairly common check.
</a><a href="#h85-0-143" id="h85-0-143" class="i">+//
</a><a href="#h85-0-144" id="h85-0-144" class="i">+var NotNil Checker = &amp;notNilChecker{
</a><a href="#h85-0-145" id="h85-0-145" class="i">+	&amp;CheckerInfo{Name: &quot;NotNil&quot;, Params: []string{&quot;value&quot;}},
</a><a href="#h85-0-146" id="h85-0-146" class="i">+}
</a><a href="#h85-0-147" id="h85-0-147" class="i">+
</a><a href="#h85-0-148" id="h85-0-148" class="i">+func (checker *notNilChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-149" id="h85-0-149" class="i">+	return !isNil(params[0]), &quot;&quot;
</a><a href="#h85-0-150" id="h85-0-150" class="i">+}
</a><a href="#h85-0-151" id="h85-0-151" class="i">+
</a><a href="#h85-0-152" id="h85-0-152" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-153" id="h85-0-153" class="i">+// Equals checker.
</a><a href="#h85-0-154" id="h85-0-154" class="i">+
</a><a href="#h85-0-155" id="h85-0-155" class="i">+type equalsChecker struct {
</a><a href="#h85-0-156" id="h85-0-156" class="i">+	*CheckerInfo
</a><a href="#h85-0-157" id="h85-0-157" class="i">+}
</a><a href="#h85-0-158" id="h85-0-158" class="i">+
</a><a href="#h85-0-159" id="h85-0-159" class="i">+// The Equals checker verifies that the obtained value is equal to
</a><a href="#h85-0-160" id="h85-0-160" class="i">+// the expected value, according to usual Go semantics for ==.
</a><a href="#h85-0-161" id="h85-0-161" class="i">+//
</a><a href="#h85-0-162" id="h85-0-162" class="i">+// For example:
</a><a href="#h85-0-163" id="h85-0-163" class="i">+//
</a><a href="#h85-0-164" id="h85-0-164" class="i">+//     c.Assert(value, Equals, 42)
</a><a href="#h85-0-165" id="h85-0-165" class="i">+//
</a><a href="#h85-0-166" id="h85-0-166" class="i">+var Equals Checker = &amp;equalsChecker{
</a><a href="#h85-0-167" id="h85-0-167" class="i">+	&amp;CheckerInfo{Name: &quot;Equals&quot;, Params: []string{&quot;obtained&quot;, &quot;expected&quot;}},
</a><a href="#h85-0-168" id="h85-0-168" class="i">+}
</a><a href="#h85-0-169" id="h85-0-169" class="i">+
</a><a href="#h85-0-170" id="h85-0-170" class="i">+func (checker *equalsChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-171" id="h85-0-171" class="i">+	defer func() {
</a><a href="#h85-0-172" id="h85-0-172" class="i">+		if v := recover(); v != nil {
</a><a href="#h85-0-173" id="h85-0-173" class="i">+			result = false
</a><a href="#h85-0-174" id="h85-0-174" class="i">+			error = fmt.Sprint(v)
</a><a href="#h85-0-175" id="h85-0-175" class="i">+		}
</a><a href="#h85-0-176" id="h85-0-176" class="i">+	}()
</a><a href="#h85-0-177" id="h85-0-177" class="i">+	return params[0] == params[1], &quot;&quot;
</a><a href="#h85-0-178" id="h85-0-178" class="i">+}
</a><a href="#h85-0-179" id="h85-0-179" class="i">+
</a><a href="#h85-0-180" id="h85-0-180" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-181" id="h85-0-181" class="i">+// DeepEquals checker.
</a><a href="#h85-0-182" id="h85-0-182" class="i">+
</a><a href="#h85-0-183" id="h85-0-183" class="i">+type deepEqualsChecker struct {
</a><a href="#h85-0-184" id="h85-0-184" class="i">+	*CheckerInfo
</a><a href="#h85-0-185" id="h85-0-185" class="i">+}
</a><a href="#h85-0-186" id="h85-0-186" class="i">+
</a><a href="#h85-0-187" id="h85-0-187" class="i">+// The DeepEquals checker verifies that the obtained value is deep-equal to
</a><a href="#h85-0-188" id="h85-0-188" class="i">+// the expected value.  The check will work correctly even when facing
</a><a href="#h85-0-189" id="h85-0-189" class="i">+// slices, interfaces, and values of different types (which always fail
</a><a href="#h85-0-190" id="h85-0-190" class="i">+// the test).
</a><a href="#h85-0-191" id="h85-0-191" class="i">+//
</a><a href="#h85-0-192" id="h85-0-192" class="i">+// For example:
</a><a href="#h85-0-193" id="h85-0-193" class="i">+//
</a><a href="#h85-0-194" id="h85-0-194" class="i">+//     c.Assert(value, DeepEquals, 42)
</a><a href="#h85-0-195" id="h85-0-195" class="i">+//     c.Assert(array, DeepEquals, []string{&quot;hi&quot;, &quot;there&quot;})
</a><a href="#h85-0-196" id="h85-0-196" class="i">+//
</a><a href="#h85-0-197" id="h85-0-197" class="i">+var DeepEquals Checker = &amp;deepEqualsChecker{
</a><a href="#h85-0-198" id="h85-0-198" class="i">+	&amp;CheckerInfo{Name: &quot;DeepEquals&quot;, Params: []string{&quot;obtained&quot;, &quot;expected&quot;}},
</a><a href="#h85-0-199" id="h85-0-199" class="i">+}
</a><a href="#h85-0-200" id="h85-0-200" class="i">+
</a><a href="#h85-0-201" id="h85-0-201" class="i">+func (checker *deepEqualsChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-202" id="h85-0-202" class="i">+	return reflect.DeepEqual(params[0], params[1]), &quot;&quot;
</a><a href="#h85-0-203" id="h85-0-203" class="i">+}
</a><a href="#h85-0-204" id="h85-0-204" class="i">+
</a><a href="#h85-0-205" id="h85-0-205" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-206" id="h85-0-206" class="i">+// HasLen checker.
</a><a href="#h85-0-207" id="h85-0-207" class="i">+
</a><a href="#h85-0-208" id="h85-0-208" class="i">+type hasLenChecker struct {
</a><a href="#h85-0-209" id="h85-0-209" class="i">+	*CheckerInfo
</a><a href="#h85-0-210" id="h85-0-210" class="i">+}
</a><a href="#h85-0-211" id="h85-0-211" class="i">+
</a><a href="#h85-0-212" id="h85-0-212" class="i">+// The HasLen checker verifies that the obtained value has the
</a><a href="#h85-0-213" id="h85-0-213" class="i">+// provided length. In many cases this is superior to using Equals
</a><a href="#h85-0-214" id="h85-0-214" class="i">+// in conjuction with the len function because in case the check
</a><a href="#h85-0-215" id="h85-0-215" class="i">+// fails the value itself will be printed, instead of its length,
</a><a href="#h85-0-216" id="h85-0-216" class="i">+// providing more details for figuring the problem.
</a><a href="#h85-0-217" id="h85-0-217" class="i">+//
</a><a href="#h85-0-218" id="h85-0-218" class="i">+// For example:
</a><a href="#h85-0-219" id="h85-0-219" class="i">+//
</a><a href="#h85-0-220" id="h85-0-220" class="i">+//     c.Assert(list, HasLen, 5)
</a><a href="#h85-0-221" id="h85-0-221" class="i">+//
</a><a href="#h85-0-222" id="h85-0-222" class="i">+var HasLen Checker = &amp;hasLenChecker{
</a><a href="#h85-0-223" id="h85-0-223" class="i">+	&amp;CheckerInfo{Name: &quot;HasLen&quot;, Params: []string{&quot;obtained&quot;, &quot;n&quot;}},
</a><a href="#h85-0-224" id="h85-0-224" class="i">+}
</a><a href="#h85-0-225" id="h85-0-225" class="i">+
</a><a href="#h85-0-226" id="h85-0-226" class="i">+func (checker *hasLenChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-227" id="h85-0-227" class="i">+	n, ok := params[1].(int)
</a><a href="#h85-0-228" id="h85-0-228" class="i">+	if !ok {
</a><a href="#h85-0-229" id="h85-0-229" class="i">+		return false, &quot;n must be an int&quot;
</a><a href="#h85-0-230" id="h85-0-230" class="i">+	}
</a><a href="#h85-0-231" id="h85-0-231" class="i">+	value := reflect.ValueOf(params[0])
</a><a href="#h85-0-232" id="h85-0-232" class="i">+	switch value.Kind() {
</a><a href="#h85-0-233" id="h85-0-233" class="i">+	case reflect.Map, reflect.Array, reflect.Slice, reflect.Chan, reflect.String:
</a><a href="#h85-0-234" id="h85-0-234" class="i">+	default:
</a><a href="#h85-0-235" id="h85-0-235" class="i">+		return false, &quot;obtained value type has no length&quot;
</a><a href="#h85-0-236" id="h85-0-236" class="i">+	}
</a><a href="#h85-0-237" id="h85-0-237" class="i">+	return value.Len() == n, &quot;&quot;
</a><a href="#h85-0-238" id="h85-0-238" class="i">+}
</a><a href="#h85-0-239" id="h85-0-239" class="i">+
</a><a href="#h85-0-240" id="h85-0-240" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-241" id="h85-0-241" class="i">+// ErrorMatches checker.
</a><a href="#h85-0-242" id="h85-0-242" class="i">+
</a><a href="#h85-0-243" id="h85-0-243" class="i">+type errorMatchesChecker struct {
</a><a href="#h85-0-244" id="h85-0-244" class="i">+	*CheckerInfo
</a><a href="#h85-0-245" id="h85-0-245" class="i">+}
</a><a href="#h85-0-246" id="h85-0-246" class="i">+
</a><a href="#h85-0-247" id="h85-0-247" class="i">+// The ErrorMatches checker verifies that the error value
</a><a href="#h85-0-248" id="h85-0-248" class="i">+// is non nil and matches the regular expression provided.
</a><a href="#h85-0-249" id="h85-0-249" class="i">+//
</a><a href="#h85-0-250" id="h85-0-250" class="i">+// For example:
</a><a href="#h85-0-251" id="h85-0-251" class="i">+//
</a><a href="#h85-0-252" id="h85-0-252" class="i">+//     c.Assert(err, ErrorMatches, &quot;perm.*denied&quot;)
</a><a href="#h85-0-253" id="h85-0-253" class="i">+//
</a><a href="#h85-0-254" id="h85-0-254" class="i">+var ErrorMatches Checker = errorMatchesChecker{
</a><a href="#h85-0-255" id="h85-0-255" class="i">+	&amp;CheckerInfo{Name: &quot;ErrorMatches&quot;, Params: []string{&quot;value&quot;, &quot;regex&quot;}},
</a><a href="#h85-0-256" id="h85-0-256" class="i">+}
</a><a href="#h85-0-257" id="h85-0-257" class="i">+
</a><a href="#h85-0-258" id="h85-0-258" class="i">+func (checker errorMatchesChecker) Check(params []interface{}, names []string) (result bool, errStr string) {
</a><a href="#h85-0-259" id="h85-0-259" class="i">+	if params[0] == nil {
</a><a href="#h85-0-260" id="h85-0-260" class="i">+		return false, &quot;Error value is nil&quot;
</a><a href="#h85-0-261" id="h85-0-261" class="i">+	}
</a><a href="#h85-0-262" id="h85-0-262" class="i">+	err, ok := params[0].(error)
</a><a href="#h85-0-263" id="h85-0-263" class="i">+	if !ok {
</a><a href="#h85-0-264" id="h85-0-264" class="i">+		return false, &quot;Value is not an error&quot;
</a><a href="#h85-0-265" id="h85-0-265" class="i">+	}
</a><a href="#h85-0-266" id="h85-0-266" class="i">+	params[0] = err.Error()
</a><a href="#h85-0-267" id="h85-0-267" class="i">+	names[0] = &quot;error&quot;
</a><a href="#h85-0-268" id="h85-0-268" class="i">+	return matches(params[0], params[1])
</a><a href="#h85-0-269" id="h85-0-269" class="i">+}
</a><a href="#h85-0-270" id="h85-0-270" class="i">+
</a><a href="#h85-0-271" id="h85-0-271" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-272" id="h85-0-272" class="i">+// Matches checker.
</a><a href="#h85-0-273" id="h85-0-273" class="i">+
</a><a href="#h85-0-274" id="h85-0-274" class="i">+type matchesChecker struct {
</a><a href="#h85-0-275" id="h85-0-275" class="i">+	*CheckerInfo
</a><a href="#h85-0-276" id="h85-0-276" class="i">+}
</a><a href="#h85-0-277" id="h85-0-277" class="i">+
</a><a href="#h85-0-278" id="h85-0-278" class="i">+// The Matches checker verifies that the string provided as the obtained
</a><a href="#h85-0-279" id="h85-0-279" class="i">+// value (or the string resulting from obtained.String()) matches the
</a><a href="#h85-0-280" id="h85-0-280" class="i">+// regular expression provided.
</a><a href="#h85-0-281" id="h85-0-281" class="i">+//
</a><a href="#h85-0-282" id="h85-0-282" class="i">+// For example:
</a><a href="#h85-0-283" id="h85-0-283" class="i">+//
</a><a href="#h85-0-284" id="h85-0-284" class="i">+//     c.Assert(err, Matches, &quot;perm.*denied&quot;)
</a><a href="#h85-0-285" id="h85-0-285" class="i">+//
</a><a href="#h85-0-286" id="h85-0-286" class="i">+var Matches Checker = &amp;matchesChecker{
</a><a href="#h85-0-287" id="h85-0-287" class="i">+	&amp;CheckerInfo{Name: &quot;Matches&quot;, Params: []string{&quot;value&quot;, &quot;regex&quot;}},
</a><a href="#h85-0-288" id="h85-0-288" class="i">+}
</a><a href="#h85-0-289" id="h85-0-289" class="i">+
</a><a href="#h85-0-290" id="h85-0-290" class="i">+func (checker *matchesChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-291" id="h85-0-291" class="i">+	return matches(params[0], params[1])
</a><a href="#h85-0-292" id="h85-0-292" class="i">+}
</a><a href="#h85-0-293" id="h85-0-293" class="i">+
</a><a href="#h85-0-294" id="h85-0-294" class="i">+func matches(value, regex interface{}) (result bool, error string) {
</a><a href="#h85-0-295" id="h85-0-295" class="i">+	reStr, ok := regex.(string)
</a><a href="#h85-0-296" id="h85-0-296" class="i">+	if !ok {
</a><a href="#h85-0-297" id="h85-0-297" class="i">+		return false, &quot;Regex must be a string&quot;
</a><a href="#h85-0-298" id="h85-0-298" class="i">+	}
</a><a href="#h85-0-299" id="h85-0-299" class="i">+	valueStr, valueIsStr := value.(string)
</a><a href="#h85-0-300" id="h85-0-300" class="i">+	if !valueIsStr {
</a><a href="#h85-0-301" id="h85-0-301" class="i">+		if valueWithStr, valueHasStr := value.(fmt.Stringer); valueHasStr {
</a><a href="#h85-0-302" id="h85-0-302" class="i">+			valueStr, valueIsStr = valueWithStr.String(), true
</a><a href="#h85-0-303" id="h85-0-303" class="i">+		}
</a><a href="#h85-0-304" id="h85-0-304" class="i">+	}
</a><a href="#h85-0-305" id="h85-0-305" class="i">+	if valueIsStr {
</a><a href="#h85-0-306" id="h85-0-306" class="i">+		matches, err := regexp.MatchString(&quot;^&quot;+reStr+&quot;$&quot;, valueStr)
</a><a href="#h85-0-307" id="h85-0-307" class="i">+		if err != nil {
</a><a href="#h85-0-308" id="h85-0-308" class="i">+			return false, &quot;Can&#39;t compile regex: &quot; + err.Error()
</a><a href="#h85-0-309" id="h85-0-309" class="i">+		}
</a><a href="#h85-0-310" id="h85-0-310" class="i">+		return matches, &quot;&quot;
</a><a href="#h85-0-311" id="h85-0-311" class="i">+	}
</a><a href="#h85-0-312" id="h85-0-312" class="i">+	return false, &quot;Obtained value is not a string and has no .String()&quot;
</a><a href="#h85-0-313" id="h85-0-313" class="i">+}
</a><a href="#h85-0-314" id="h85-0-314" class="i">+
</a><a href="#h85-0-315" id="h85-0-315" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-316" id="h85-0-316" class="i">+// Panics checker.
</a><a href="#h85-0-317" id="h85-0-317" class="i">+
</a><a href="#h85-0-318" id="h85-0-318" class="i">+type panicsChecker struct {
</a><a href="#h85-0-319" id="h85-0-319" class="i">+	*CheckerInfo
</a><a href="#h85-0-320" id="h85-0-320" class="i">+}
</a><a href="#h85-0-321" id="h85-0-321" class="i">+
</a><a href="#h85-0-322" id="h85-0-322" class="i">+// The Panics checker verifies that calling the provided zero-argument
</a><a href="#h85-0-323" id="h85-0-323" class="i">+// function will cause a panic which is deep-equal to the provided value.
</a><a href="#h85-0-324" id="h85-0-324" class="i">+//
</a><a href="#h85-0-325" id="h85-0-325" class="i">+// For example:
</a><a href="#h85-0-326" id="h85-0-326" class="i">+//
</a><a href="#h85-0-327" id="h85-0-327" class="i">+//     c.Assert(func() { f(1, 2) }, Panics, &amp;SomeErrorType{&quot;BOOM&quot;}).
</a><a href="#h85-0-328" id="h85-0-328" class="i">+//
</a><a href="#h85-0-329" id="h85-0-329" class="i">+//
</a><a href="#h85-0-330" id="h85-0-330" class="i">+var Panics Checker = &amp;panicsChecker{
</a><a href="#h85-0-331" id="h85-0-331" class="i">+	&amp;CheckerInfo{Name: &quot;Panics&quot;, Params: []string{&quot;function&quot;, &quot;expected&quot;}},
</a><a href="#h85-0-332" id="h85-0-332" class="i">+}
</a><a href="#h85-0-333" id="h85-0-333" class="i">+
</a><a href="#h85-0-334" id="h85-0-334" class="i">+func (checker *panicsChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-335" id="h85-0-335" class="i">+	f := reflect.ValueOf(params[0])
</a><a href="#h85-0-336" id="h85-0-336" class="i">+	if f.Kind() != reflect.Func || f.Type().NumIn() != 0 {
</a><a href="#h85-0-337" id="h85-0-337" class="i">+		return false, &quot;Function must take zero arguments&quot;
</a><a href="#h85-0-338" id="h85-0-338" class="i">+	}
</a><a href="#h85-0-339" id="h85-0-339" class="i">+	defer func() {
</a><a href="#h85-0-340" id="h85-0-340" class="i">+		// If the function has not panicked, then don&#39;t do the check.
</a><a href="#h85-0-341" id="h85-0-341" class="i">+		if error != &quot;&quot; {
</a><a href="#h85-0-342" id="h85-0-342" class="i">+			return
</a><a href="#h85-0-343" id="h85-0-343" class="i">+		}
</a><a href="#h85-0-344" id="h85-0-344" class="i">+		params[0] = recover()
</a><a href="#h85-0-345" id="h85-0-345" class="i">+		names[0] = &quot;panic&quot;
</a><a href="#h85-0-346" id="h85-0-346" class="i">+		result = reflect.DeepEqual(params[0], params[1])
</a><a href="#h85-0-347" id="h85-0-347" class="i">+	}()
</a><a href="#h85-0-348" id="h85-0-348" class="i">+	f.Call(nil)
</a><a href="#h85-0-349" id="h85-0-349" class="i">+	return false, &quot;Function has not panicked&quot;
</a><a href="#h85-0-350" id="h85-0-350" class="i">+}
</a><a href="#h85-0-351" id="h85-0-351" class="i">+
</a><a href="#h85-0-352" id="h85-0-352" class="i">+type panicMatchesChecker struct {
</a><a href="#h85-0-353" id="h85-0-353" class="i">+	*CheckerInfo
</a><a href="#h85-0-354" id="h85-0-354" class="i">+}
</a><a href="#h85-0-355" id="h85-0-355" class="i">+
</a><a href="#h85-0-356" id="h85-0-356" class="i">+// The PanicMatches checker verifies that calling the provided zero-argument
</a><a href="#h85-0-357" id="h85-0-357" class="i">+// function will cause a panic with an error value matching
</a><a href="#h85-0-358" id="h85-0-358" class="i">+// the regular expression provided.
</a><a href="#h85-0-359" id="h85-0-359" class="i">+//
</a><a href="#h85-0-360" id="h85-0-360" class="i">+// For example:
</a><a href="#h85-0-361" id="h85-0-361" class="i">+//
</a><a href="#h85-0-362" id="h85-0-362" class="i">+//     c.Assert(func() { f(1, 2) }, PanicMatches, `open.*: no such file or directory`).
</a><a href="#h85-0-363" id="h85-0-363" class="i">+//
</a><a href="#h85-0-364" id="h85-0-364" class="i">+//
</a><a href="#h85-0-365" id="h85-0-365" class="i">+var PanicMatches Checker = &amp;panicMatchesChecker{
</a><a href="#h85-0-366" id="h85-0-366" class="i">+	&amp;CheckerInfo{Name: &quot;PanicMatches&quot;, Params: []string{&quot;function&quot;, &quot;expected&quot;}},
</a><a href="#h85-0-367" id="h85-0-367" class="i">+}
</a><a href="#h85-0-368" id="h85-0-368" class="i">+
</a><a href="#h85-0-369" id="h85-0-369" class="i">+func (checker *panicMatchesChecker) Check(params []interface{}, names []string) (result bool, errmsg string) {
</a><a href="#h85-0-370" id="h85-0-370" class="i">+	f := reflect.ValueOf(params[0])
</a><a href="#h85-0-371" id="h85-0-371" class="i">+	if f.Kind() != reflect.Func || f.Type().NumIn() != 0 {
</a><a href="#h85-0-372" id="h85-0-372" class="i">+		return false, &quot;Function must take zero arguments&quot;
</a><a href="#h85-0-373" id="h85-0-373" class="i">+	}
</a><a href="#h85-0-374" id="h85-0-374" class="i">+	defer func() {
</a><a href="#h85-0-375" id="h85-0-375" class="i">+		// If the function has not panicked, then don&#39;t do the check.
</a><a href="#h85-0-376" id="h85-0-376" class="i">+		if errmsg != &quot;&quot; {
</a><a href="#h85-0-377" id="h85-0-377" class="i">+			return
</a><a href="#h85-0-378" id="h85-0-378" class="i">+		}
</a><a href="#h85-0-379" id="h85-0-379" class="i">+		obtained := recover()
</a><a href="#h85-0-380" id="h85-0-380" class="i">+		names[0] = &quot;panic&quot;
</a><a href="#h85-0-381" id="h85-0-381" class="i">+		if e, ok := obtained.(error); ok {
</a><a href="#h85-0-382" id="h85-0-382" class="i">+			params[0] = e.Error()
</a><a href="#h85-0-383" id="h85-0-383" class="i">+		} else if _, ok := obtained.(string); ok {
</a><a href="#h85-0-384" id="h85-0-384" class="i">+			params[0] = obtained
</a><a href="#h85-0-385" id="h85-0-385" class="i">+		} else {
</a><a href="#h85-0-386" id="h85-0-386" class="i">+			errmsg = &quot;Panic value is not a string or an error&quot;
</a><a href="#h85-0-387" id="h85-0-387" class="i">+			return
</a><a href="#h85-0-388" id="h85-0-388" class="i">+		}
</a><a href="#h85-0-389" id="h85-0-389" class="i">+		result, errmsg = matches(params[0], params[1])
</a><a href="#h85-0-390" id="h85-0-390" class="i">+	}()
</a><a href="#h85-0-391" id="h85-0-391" class="i">+	f.Call(nil)
</a><a href="#h85-0-392" id="h85-0-392" class="i">+	return false, &quot;Function has not panicked&quot;
</a><a href="#h85-0-393" id="h85-0-393" class="i">+}
</a><a href="#h85-0-394" id="h85-0-394" class="i">+
</a><a href="#h85-0-395" id="h85-0-395" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-396" id="h85-0-396" class="i">+// FitsTypeOf checker.
</a><a href="#h85-0-397" id="h85-0-397" class="i">+
</a><a href="#h85-0-398" id="h85-0-398" class="i">+type fitsTypeChecker struct {
</a><a href="#h85-0-399" id="h85-0-399" class="i">+	*CheckerInfo
</a><a href="#h85-0-400" id="h85-0-400" class="i">+}
</a><a href="#h85-0-401" id="h85-0-401" class="i">+
</a><a href="#h85-0-402" id="h85-0-402" class="i">+// The FitsTypeOf checker verifies that the obtained value is
</a><a href="#h85-0-403" id="h85-0-403" class="i">+// assignable to a variable with the same type as the provided
</a><a href="#h85-0-404" id="h85-0-404" class="i">+// sample value.
</a><a href="#h85-0-405" id="h85-0-405" class="i">+//
</a><a href="#h85-0-406" id="h85-0-406" class="i">+// For example:
</a><a href="#h85-0-407" id="h85-0-407" class="i">+//
</a><a href="#h85-0-408" id="h85-0-408" class="i">+//     c.Assert(value, FitsTypeOf, int64(0))
</a><a href="#h85-0-409" id="h85-0-409" class="i">+//     c.Assert(value, FitsTypeOf, os.Error(nil))
</a><a href="#h85-0-410" id="h85-0-410" class="i">+//
</a><a href="#h85-0-411" id="h85-0-411" class="i">+var FitsTypeOf Checker = &amp;fitsTypeChecker{
</a><a href="#h85-0-412" id="h85-0-412" class="i">+	&amp;CheckerInfo{Name: &quot;FitsTypeOf&quot;, Params: []string{&quot;obtained&quot;, &quot;sample&quot;}},
</a><a href="#h85-0-413" id="h85-0-413" class="i">+}
</a><a href="#h85-0-414" id="h85-0-414" class="i">+
</a><a href="#h85-0-415" id="h85-0-415" class="i">+func (checker *fitsTypeChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-416" id="h85-0-416" class="i">+	obtained := reflect.ValueOf(params[0])
</a><a href="#h85-0-417" id="h85-0-417" class="i">+	sample := reflect.ValueOf(params[1])
</a><a href="#h85-0-418" id="h85-0-418" class="i">+	if !obtained.IsValid() {
</a><a href="#h85-0-419" id="h85-0-419" class="i">+		return false, &quot;&quot;
</a><a href="#h85-0-420" id="h85-0-420" class="i">+	}
</a><a href="#h85-0-421" id="h85-0-421" class="i">+	if !sample.IsValid() {
</a><a href="#h85-0-422" id="h85-0-422" class="i">+		return false, &quot;Invalid sample value&quot;
</a><a href="#h85-0-423" id="h85-0-423" class="i">+	}
</a><a href="#h85-0-424" id="h85-0-424" class="i">+	return obtained.Type().AssignableTo(sample.Type()), &quot;&quot;
</a><a href="#h85-0-425" id="h85-0-425" class="i">+}
</a><a href="#h85-0-426" id="h85-0-426" class="i">+
</a><a href="#h85-0-427" id="h85-0-427" class="i">+// -----------------------------------------------------------------------
</a><a href="#h85-0-428" id="h85-0-428" class="i">+// Implements checker.
</a><a href="#h85-0-429" id="h85-0-429" class="i">+
</a><a href="#h85-0-430" id="h85-0-430" class="i">+type implementsChecker struct {
</a><a href="#h85-0-431" id="h85-0-431" class="i">+	*CheckerInfo
</a><a href="#h85-0-432" id="h85-0-432" class="i">+}
</a><a href="#h85-0-433" id="h85-0-433" class="i">+
</a><a href="#h85-0-434" id="h85-0-434" class="i">+// The Implements checker verifies that the obtained value
</a><a href="#h85-0-435" id="h85-0-435" class="i">+// implements the interface specified via a pointer to an interface
</a><a href="#h85-0-436" id="h85-0-436" class="i">+// variable.
</a><a href="#h85-0-437" id="h85-0-437" class="i">+//
</a><a href="#h85-0-438" id="h85-0-438" class="i">+// For example:
</a><a href="#h85-0-439" id="h85-0-439" class="i">+//
</a><a href="#h85-0-440" id="h85-0-440" class="i">+//     var e os.Error
</a><a href="#h85-0-441" id="h85-0-441" class="i">+//     c.Assert(err, Implements, &amp;e)
</a><a href="#h85-0-442" id="h85-0-442" class="i">+//
</a><a href="#h85-0-443" id="h85-0-443" class="i">+var Implements Checker = &amp;implementsChecker{
</a><a href="#h85-0-444" id="h85-0-444" class="i">+	&amp;CheckerInfo{Name: &quot;Implements&quot;, Params: []string{&quot;obtained&quot;, &quot;ifaceptr&quot;}},
</a><a href="#h85-0-445" id="h85-0-445" class="i">+}
</a><a href="#h85-0-446" id="h85-0-446" class="i">+
</a><a href="#h85-0-447" id="h85-0-447" class="i">+func (checker *implementsChecker) Check(params []interface{}, names []string) (result bool, error string) {
</a><a href="#h85-0-448" id="h85-0-448" class="i">+	obtained := reflect.ValueOf(params[0])
</a><a href="#h85-0-449" id="h85-0-449" class="i">+	ifaceptr := reflect.ValueOf(params[1])
</a><a href="#h85-0-450" id="h85-0-450" class="i">+	if !obtained.IsValid() {
</a><a href="#h85-0-451" id="h85-0-451" class="i">+		return false, &quot;&quot;
</a><a href="#h85-0-452" id="h85-0-452" class="i">+	}
</a><a href="#h85-0-453" id="h85-0-453" class="i">+	if !ifaceptr.IsValid() || ifaceptr.Kind() != reflect.Ptr || ifaceptr.Elem().Kind() != reflect.Interface {
</a><a href="#h85-0-454" id="h85-0-454" class="i">+		return false, &quot;ifaceptr should be a pointer to an interface variable&quot;
</a><a href="#h85-0-455" id="h85-0-455" class="i">+	}
</a><a href="#h85-0-456" id="h85-0-456" class="i">+	return obtained.Type().Implements(ifaceptr.Elem().Type()), &quot;&quot;
</a><a href="#h85-0-457" id="h85-0-457" class="i">+}
</a><b>diff --git a/<a id="h86" href="../file/vendor/gopkg.in/check.v1/helpers.go">vendor/gopkg.in/check.v1/helpers.go</a> b/<a href="../file/vendor/gopkg.in/check.v1/helpers.go">vendor/gopkg.in/check.v1/helpers.go</a></b>
<a href="#h86-0" id="h86-0" class="h">@@ -0,0 +1,231 @@
</a><a href="#h86-0-0" id="h86-0-0" class="i">+package check
</a><a href="#h86-0-1" id="h86-0-1" class="i">+
</a><a href="#h86-0-2" id="h86-0-2" class="i">+import (
</a><a href="#h86-0-3" id="h86-0-3" class="i">+	&quot;fmt&quot;
</a><a href="#h86-0-4" id="h86-0-4" class="i">+	&quot;strings&quot;
</a><a href="#h86-0-5" id="h86-0-5" class="i">+	&quot;time&quot;
</a><a href="#h86-0-6" id="h86-0-6" class="i">+)
</a><a href="#h86-0-7" id="h86-0-7" class="i">+
</a><a href="#h86-0-8" id="h86-0-8" class="i">+// TestName returns the current test name in the form &quot;SuiteName.TestName&quot;
</a><a href="#h86-0-9" id="h86-0-9" class="i">+func (c *C) TestName() string {
</a><a href="#h86-0-10" id="h86-0-10" class="i">+	return c.testName
</a><a href="#h86-0-11" id="h86-0-11" class="i">+}
</a><a href="#h86-0-12" id="h86-0-12" class="i">+
</a><a href="#h86-0-13" id="h86-0-13" class="i">+// -----------------------------------------------------------------------
</a><a href="#h86-0-14" id="h86-0-14" class="i">+// Basic succeeding/failing logic.
</a><a href="#h86-0-15" id="h86-0-15" class="i">+
</a><a href="#h86-0-16" id="h86-0-16" class="i">+// Failed returns whether the currently running test has already failed.
</a><a href="#h86-0-17" id="h86-0-17" class="i">+func (c *C) Failed() bool {
</a><a href="#h86-0-18" id="h86-0-18" class="i">+	return c.status() == failedSt
</a><a href="#h86-0-19" id="h86-0-19" class="i">+}
</a><a href="#h86-0-20" id="h86-0-20" class="i">+
</a><a href="#h86-0-21" id="h86-0-21" class="i">+// Fail marks the currently running test as failed.
</a><a href="#h86-0-22" id="h86-0-22" class="i">+//
</a><a href="#h86-0-23" id="h86-0-23" class="i">+// Something ought to have been previously logged so the developer can tell
</a><a href="#h86-0-24" id="h86-0-24" class="i">+// what went wrong. The higher level helper functions will fail the test
</a><a href="#h86-0-25" id="h86-0-25" class="i">+// and do the logging properly.
</a><a href="#h86-0-26" id="h86-0-26" class="i">+func (c *C) Fail() {
</a><a href="#h86-0-27" id="h86-0-27" class="i">+	c.setStatus(failedSt)
</a><a href="#h86-0-28" id="h86-0-28" class="i">+}
</a><a href="#h86-0-29" id="h86-0-29" class="i">+
</a><a href="#h86-0-30" id="h86-0-30" class="i">+// FailNow marks the currently running test as failed and stops running it.
</a><a href="#h86-0-31" id="h86-0-31" class="i">+// Something ought to have been previously logged so the developer can tell
</a><a href="#h86-0-32" id="h86-0-32" class="i">+// what went wrong. The higher level helper functions will fail the test
</a><a href="#h86-0-33" id="h86-0-33" class="i">+// and do the logging properly.
</a><a href="#h86-0-34" id="h86-0-34" class="i">+func (c *C) FailNow() {
</a><a href="#h86-0-35" id="h86-0-35" class="i">+	c.Fail()
</a><a href="#h86-0-36" id="h86-0-36" class="i">+	c.stopNow()
</a><a href="#h86-0-37" id="h86-0-37" class="i">+}
</a><a href="#h86-0-38" id="h86-0-38" class="i">+
</a><a href="#h86-0-39" id="h86-0-39" class="i">+// Succeed marks the currently running test as succeeded, undoing any
</a><a href="#h86-0-40" id="h86-0-40" class="i">+// previous failures.
</a><a href="#h86-0-41" id="h86-0-41" class="i">+func (c *C) Succeed() {
</a><a href="#h86-0-42" id="h86-0-42" class="i">+	c.setStatus(succeededSt)
</a><a href="#h86-0-43" id="h86-0-43" class="i">+}
</a><a href="#h86-0-44" id="h86-0-44" class="i">+
</a><a href="#h86-0-45" id="h86-0-45" class="i">+// SucceedNow marks the currently running test as succeeded, undoing any
</a><a href="#h86-0-46" id="h86-0-46" class="i">+// previous failures, and stops running the test.
</a><a href="#h86-0-47" id="h86-0-47" class="i">+func (c *C) SucceedNow() {
</a><a href="#h86-0-48" id="h86-0-48" class="i">+	c.Succeed()
</a><a href="#h86-0-49" id="h86-0-49" class="i">+	c.stopNow()
</a><a href="#h86-0-50" id="h86-0-50" class="i">+}
</a><a href="#h86-0-51" id="h86-0-51" class="i">+
</a><a href="#h86-0-52" id="h86-0-52" class="i">+// ExpectFailure informs that the running test is knowingly broken for
</a><a href="#h86-0-53" id="h86-0-53" class="i">+// the provided reason. If the test does not fail, an error will be reported
</a><a href="#h86-0-54" id="h86-0-54" class="i">+// to raise attention to this fact. This method is useful to temporarily
</a><a href="#h86-0-55" id="h86-0-55" class="i">+// disable tests which cover well known problems until a better time to
</a><a href="#h86-0-56" id="h86-0-56" class="i">+// fix the problem is found, without forgetting about the fact that a
</a><a href="#h86-0-57" id="h86-0-57" class="i">+// failure still exists.
</a><a href="#h86-0-58" id="h86-0-58" class="i">+func (c *C) ExpectFailure(reason string) {
</a><a href="#h86-0-59" id="h86-0-59" class="i">+	if reason == &quot;&quot; {
</a><a href="#h86-0-60" id="h86-0-60" class="i">+		panic(&quot;Missing reason why the test is expected to fail&quot;)
</a><a href="#h86-0-61" id="h86-0-61" class="i">+	}
</a><a href="#h86-0-62" id="h86-0-62" class="i">+	c.mustFail = true
</a><a href="#h86-0-63" id="h86-0-63" class="i">+	c.reason = reason
</a><a href="#h86-0-64" id="h86-0-64" class="i">+}
</a><a href="#h86-0-65" id="h86-0-65" class="i">+
</a><a href="#h86-0-66" id="h86-0-66" class="i">+// Skip skips the running test for the provided reason. If run from within
</a><a href="#h86-0-67" id="h86-0-67" class="i">+// SetUpTest, the individual test being set up will be skipped, and if run
</a><a href="#h86-0-68" id="h86-0-68" class="i">+// from within SetUpSuite, the whole suite is skipped.
</a><a href="#h86-0-69" id="h86-0-69" class="i">+func (c *C) Skip(reason string) {
</a><a href="#h86-0-70" id="h86-0-70" class="i">+	if reason == &quot;&quot; {
</a><a href="#h86-0-71" id="h86-0-71" class="i">+		panic(&quot;Missing reason why the test is being skipped&quot;)
</a><a href="#h86-0-72" id="h86-0-72" class="i">+	}
</a><a href="#h86-0-73" id="h86-0-73" class="i">+	c.reason = reason
</a><a href="#h86-0-74" id="h86-0-74" class="i">+	c.setStatus(skippedSt)
</a><a href="#h86-0-75" id="h86-0-75" class="i">+	c.stopNow()
</a><a href="#h86-0-76" id="h86-0-76" class="i">+}
</a><a href="#h86-0-77" id="h86-0-77" class="i">+
</a><a href="#h86-0-78" id="h86-0-78" class="i">+// -----------------------------------------------------------------------
</a><a href="#h86-0-79" id="h86-0-79" class="i">+// Basic logging.
</a><a href="#h86-0-80" id="h86-0-80" class="i">+
</a><a href="#h86-0-81" id="h86-0-81" class="i">+// GetTestLog returns the current test error output.
</a><a href="#h86-0-82" id="h86-0-82" class="i">+func (c *C) GetTestLog() string {
</a><a href="#h86-0-83" id="h86-0-83" class="i">+	return c.logb.String()
</a><a href="#h86-0-84" id="h86-0-84" class="i">+}
</a><a href="#h86-0-85" id="h86-0-85" class="i">+
</a><a href="#h86-0-86" id="h86-0-86" class="i">+// Log logs some information into the test error output.
</a><a href="#h86-0-87" id="h86-0-87" class="i">+// The provided arguments are assembled together into a string with fmt.Sprint.
</a><a href="#h86-0-88" id="h86-0-88" class="i">+func (c *C) Log(args ...interface{}) {
</a><a href="#h86-0-89" id="h86-0-89" class="i">+	c.log(args...)
</a><a href="#h86-0-90" id="h86-0-90" class="i">+}
</a><a href="#h86-0-91" id="h86-0-91" class="i">+
</a><a href="#h86-0-92" id="h86-0-92" class="i">+// Log logs some information into the test error output.
</a><a href="#h86-0-93" id="h86-0-93" class="i">+// The provided arguments are assembled together into a string with fmt.Sprintf.
</a><a href="#h86-0-94" id="h86-0-94" class="i">+func (c *C) Logf(format string, args ...interface{}) {
</a><a href="#h86-0-95" id="h86-0-95" class="i">+	c.logf(format, args...)
</a><a href="#h86-0-96" id="h86-0-96" class="i">+}
</a><a href="#h86-0-97" id="h86-0-97" class="i">+
</a><a href="#h86-0-98" id="h86-0-98" class="i">+// Output enables *C to be used as a logger in functions that require only
</a><a href="#h86-0-99" id="h86-0-99" class="i">+// the minimum interface of *log.Logger.
</a><a href="#h86-0-100" id="h86-0-100" class="i">+func (c *C) Output(calldepth int, s string) error {
</a><a href="#h86-0-101" id="h86-0-101" class="i">+	d := time.Now().Sub(c.startTime)
</a><a href="#h86-0-102" id="h86-0-102" class="i">+	msec := d / time.Millisecond
</a><a href="#h86-0-103" id="h86-0-103" class="i">+	sec := d / time.Second
</a><a href="#h86-0-104" id="h86-0-104" class="i">+	min := d / time.Minute
</a><a href="#h86-0-105" id="h86-0-105" class="i">+
</a><a href="#h86-0-106" id="h86-0-106" class="i">+	c.Logf(&quot;[LOG] %d:%02d.%03d %s&quot;, min, sec%60, msec%1000, s)
</a><a href="#h86-0-107" id="h86-0-107" class="i">+	return nil
</a><a href="#h86-0-108" id="h86-0-108" class="i">+}
</a><a href="#h86-0-109" id="h86-0-109" class="i">+
</a><a href="#h86-0-110" id="h86-0-110" class="i">+// Error logs an error into the test error output and marks the test as failed.
</a><a href="#h86-0-111" id="h86-0-111" class="i">+// The provided arguments are assembled together into a string with fmt.Sprint.
</a><a href="#h86-0-112" id="h86-0-112" class="i">+func (c *C) Error(args ...interface{}) {
</a><a href="#h86-0-113" id="h86-0-113" class="i">+	c.logCaller(1)
</a><a href="#h86-0-114" id="h86-0-114" class="i">+	c.logString(fmt.Sprint(&quot;Error: &quot;, fmt.Sprint(args...)))
</a><a href="#h86-0-115" id="h86-0-115" class="i">+	c.logNewLine()
</a><a href="#h86-0-116" id="h86-0-116" class="i">+	c.Fail()
</a><a href="#h86-0-117" id="h86-0-117" class="i">+}
</a><a href="#h86-0-118" id="h86-0-118" class="i">+
</a><a href="#h86-0-119" id="h86-0-119" class="i">+// Errorf logs an error into the test error output and marks the test as failed.
</a><a href="#h86-0-120" id="h86-0-120" class="i">+// The provided arguments are assembled together into a string with fmt.Sprintf.
</a><a href="#h86-0-121" id="h86-0-121" class="i">+func (c *C) Errorf(format string, args ...interface{}) {
</a><a href="#h86-0-122" id="h86-0-122" class="i">+	c.logCaller(1)
</a><a href="#h86-0-123" id="h86-0-123" class="i">+	c.logString(fmt.Sprintf(&quot;Error: &quot;+format, args...))
</a><a href="#h86-0-124" id="h86-0-124" class="i">+	c.logNewLine()
</a><a href="#h86-0-125" id="h86-0-125" class="i">+	c.Fail()
</a><a href="#h86-0-126" id="h86-0-126" class="i">+}
</a><a href="#h86-0-127" id="h86-0-127" class="i">+
</a><a href="#h86-0-128" id="h86-0-128" class="i">+// Fatal logs an error into the test error output, marks the test as failed, and
</a><a href="#h86-0-129" id="h86-0-129" class="i">+// stops the test execution. The provided arguments are assembled together into
</a><a href="#h86-0-130" id="h86-0-130" class="i">+// a string with fmt.Sprint.
</a><a href="#h86-0-131" id="h86-0-131" class="i">+func (c *C) Fatal(args ...interface{}) {
</a><a href="#h86-0-132" id="h86-0-132" class="i">+	c.logCaller(1)
</a><a href="#h86-0-133" id="h86-0-133" class="i">+	c.logString(fmt.Sprint(&quot;Error: &quot;, fmt.Sprint(args...)))
</a><a href="#h86-0-134" id="h86-0-134" class="i">+	c.logNewLine()
</a><a href="#h86-0-135" id="h86-0-135" class="i">+	c.FailNow()
</a><a href="#h86-0-136" id="h86-0-136" class="i">+}
</a><a href="#h86-0-137" id="h86-0-137" class="i">+
</a><a href="#h86-0-138" id="h86-0-138" class="i">+// Fatlaf logs an error into the test error output, marks the test as failed, and
</a><a href="#h86-0-139" id="h86-0-139" class="i">+// stops the test execution. The provided arguments are assembled together into
</a><a href="#h86-0-140" id="h86-0-140" class="i">+// a string with fmt.Sprintf.
</a><a href="#h86-0-141" id="h86-0-141" class="i">+func (c *C) Fatalf(format string, args ...interface{}) {
</a><a href="#h86-0-142" id="h86-0-142" class="i">+	c.logCaller(1)
</a><a href="#h86-0-143" id="h86-0-143" class="i">+	c.logString(fmt.Sprint(&quot;Error: &quot;, fmt.Sprintf(format, args...)))
</a><a href="#h86-0-144" id="h86-0-144" class="i">+	c.logNewLine()
</a><a href="#h86-0-145" id="h86-0-145" class="i">+	c.FailNow()
</a><a href="#h86-0-146" id="h86-0-146" class="i">+}
</a><a href="#h86-0-147" id="h86-0-147" class="i">+
</a><a href="#h86-0-148" id="h86-0-148" class="i">+// -----------------------------------------------------------------------
</a><a href="#h86-0-149" id="h86-0-149" class="i">+// Generic checks and assertions based on checkers.
</a><a href="#h86-0-150" id="h86-0-150" class="i">+
</a><a href="#h86-0-151" id="h86-0-151" class="i">+// Check verifies if the first value matches the expected value according
</a><a href="#h86-0-152" id="h86-0-152" class="i">+// to the provided checker. If they do not match, an error is logged, the
</a><a href="#h86-0-153" id="h86-0-153" class="i">+// test is marked as failed, and the test execution continues.
</a><a href="#h86-0-154" id="h86-0-154" class="i">+//
</a><a href="#h86-0-155" id="h86-0-155" class="i">+// Some checkers may not need the expected argument (e.g. IsNil).
</a><a href="#h86-0-156" id="h86-0-156" class="i">+//
</a><a href="#h86-0-157" id="h86-0-157" class="i">+// Extra arguments provided to the function are logged next to the reported
</a><a href="#h86-0-158" id="h86-0-158" class="i">+// problem when the matching fails.
</a><a href="#h86-0-159" id="h86-0-159" class="i">+func (c *C) Check(obtained interface{}, checker Checker, args ...interface{}) bool {
</a><a href="#h86-0-160" id="h86-0-160" class="i">+	return c.internalCheck(&quot;Check&quot;, obtained, checker, args...)
</a><a href="#h86-0-161" id="h86-0-161" class="i">+}
</a><a href="#h86-0-162" id="h86-0-162" class="i">+
</a><a href="#h86-0-163" id="h86-0-163" class="i">+// Assert ensures that the first value matches the expected value according
</a><a href="#h86-0-164" id="h86-0-164" class="i">+// to the provided checker. If they do not match, an error is logged, the
</a><a href="#h86-0-165" id="h86-0-165" class="i">+// test is marked as failed, and the test execution stops.
</a><a href="#h86-0-166" id="h86-0-166" class="i">+//
</a><a href="#h86-0-167" id="h86-0-167" class="i">+// Some checkers may not need the expected argument (e.g. IsNil).
</a><a href="#h86-0-168" id="h86-0-168" class="i">+//
</a><a href="#h86-0-169" id="h86-0-169" class="i">+// Extra arguments provided to the function are logged next to the reported
</a><a href="#h86-0-170" id="h86-0-170" class="i">+// problem when the matching fails.
</a><a href="#h86-0-171" id="h86-0-171" class="i">+func (c *C) Assert(obtained interface{}, checker Checker, args ...interface{}) {
</a><a href="#h86-0-172" id="h86-0-172" class="i">+	if !c.internalCheck(&quot;Assert&quot;, obtained, checker, args...) {
</a><a href="#h86-0-173" id="h86-0-173" class="i">+		c.stopNow()
</a><a href="#h86-0-174" id="h86-0-174" class="i">+	}
</a><a href="#h86-0-175" id="h86-0-175" class="i">+}
</a><a href="#h86-0-176" id="h86-0-176" class="i">+
</a><a href="#h86-0-177" id="h86-0-177" class="i">+func (c *C) internalCheck(funcName string, obtained interface{}, checker Checker, args ...interface{}) bool {
</a><a href="#h86-0-178" id="h86-0-178" class="i">+	if checker == nil {
</a><a href="#h86-0-179" id="h86-0-179" class="i">+		c.logCaller(2)
</a><a href="#h86-0-180" id="h86-0-180" class="i">+		c.logString(fmt.Sprintf(&quot;%s(obtained, nil!?, ...):&quot;, funcName))
</a><a href="#h86-0-181" id="h86-0-181" class="i">+		c.logString(&quot;Oops.. you&#39;ve provided a nil checker!&quot;)
</a><a href="#h86-0-182" id="h86-0-182" class="i">+		c.logNewLine()
</a><a href="#h86-0-183" id="h86-0-183" class="i">+		c.Fail()
</a><a href="#h86-0-184" id="h86-0-184" class="i">+		return false
</a><a href="#h86-0-185" id="h86-0-185" class="i">+	}
</a><a href="#h86-0-186" id="h86-0-186" class="i">+
</a><a href="#h86-0-187" id="h86-0-187" class="i">+	// If the last argument is a bug info, extract it out.
</a><a href="#h86-0-188" id="h86-0-188" class="i">+	var comment CommentInterface
</a><a href="#h86-0-189" id="h86-0-189" class="i">+	if len(args) &gt; 0 {
</a><a href="#h86-0-190" id="h86-0-190" class="i">+		if c, ok := args[len(args)-1].(CommentInterface); ok {
</a><a href="#h86-0-191" id="h86-0-191" class="i">+			comment = c
</a><a href="#h86-0-192" id="h86-0-192" class="i">+			args = args[:len(args)-1]
</a><a href="#h86-0-193" id="h86-0-193" class="i">+		}
</a><a href="#h86-0-194" id="h86-0-194" class="i">+	}
</a><a href="#h86-0-195" id="h86-0-195" class="i">+
</a><a href="#h86-0-196" id="h86-0-196" class="i">+	params := append([]interface{}{obtained}, args...)
</a><a href="#h86-0-197" id="h86-0-197" class="i">+	info := checker.Info()
</a><a href="#h86-0-198" id="h86-0-198" class="i">+
</a><a href="#h86-0-199" id="h86-0-199" class="i">+	if len(params) != len(info.Params) {
</a><a href="#h86-0-200" id="h86-0-200" class="i">+		names := append([]string{info.Params[0], info.Name}, info.Params[1:]...)
</a><a href="#h86-0-201" id="h86-0-201" class="i">+		c.logCaller(2)
</a><a href="#h86-0-202" id="h86-0-202" class="i">+		c.logString(fmt.Sprintf(&quot;%s(%s):&quot;, funcName, strings.Join(names, &quot;, &quot;)))
</a><a href="#h86-0-203" id="h86-0-203" class="i">+		c.logString(fmt.Sprintf(&quot;Wrong number of parameters for %s: want %d, got %d&quot;, info.Name, len(names), len(params)+1))
</a><a href="#h86-0-204" id="h86-0-204" class="i">+		c.logNewLine()
</a><a href="#h86-0-205" id="h86-0-205" class="i">+		c.Fail()
</a><a href="#h86-0-206" id="h86-0-206" class="i">+		return false
</a><a href="#h86-0-207" id="h86-0-207" class="i">+	}
</a><a href="#h86-0-208" id="h86-0-208" class="i">+
</a><a href="#h86-0-209" id="h86-0-209" class="i">+	// Copy since it may be mutated by Check.
</a><a href="#h86-0-210" id="h86-0-210" class="i">+	names := append([]string{}, info.Params...)
</a><a href="#h86-0-211" id="h86-0-211" class="i">+
</a><a href="#h86-0-212" id="h86-0-212" class="i">+	// Do the actual check.
</a><a href="#h86-0-213" id="h86-0-213" class="i">+	result, error := checker.Check(params, names)
</a><a href="#h86-0-214" id="h86-0-214" class="i">+	if !result || error != &quot;&quot; {
</a><a href="#h86-0-215" id="h86-0-215" class="i">+		c.logCaller(2)
</a><a href="#h86-0-216" id="h86-0-216" class="i">+		for i := 0; i != len(params); i++ {
</a><a href="#h86-0-217" id="h86-0-217" class="i">+			c.logValue(names[i], params[i])
</a><a href="#h86-0-218" id="h86-0-218" class="i">+		}
</a><a href="#h86-0-219" id="h86-0-219" class="i">+		if comment != nil {
</a><a href="#h86-0-220" id="h86-0-220" class="i">+			c.logString(comment.CheckCommentString())
</a><a href="#h86-0-221" id="h86-0-221" class="i">+		}
</a><a href="#h86-0-222" id="h86-0-222" class="i">+		if error != &quot;&quot; {
</a><a href="#h86-0-223" id="h86-0-223" class="i">+			c.logString(error)
</a><a href="#h86-0-224" id="h86-0-224" class="i">+		}
</a><a href="#h86-0-225" id="h86-0-225" class="i">+		c.logNewLine()
</a><a href="#h86-0-226" id="h86-0-226" class="i">+		c.Fail()
</a><a href="#h86-0-227" id="h86-0-227" class="i">+		return false
</a><a href="#h86-0-228" id="h86-0-228" class="i">+	}
</a><a href="#h86-0-229" id="h86-0-229" class="i">+	return true
</a><a href="#h86-0-230" id="h86-0-230" class="i">+}
</a><b>diff --git a/<a id="h87" href="../file/vendor/gopkg.in/check.v1/printer.go">vendor/gopkg.in/check.v1/printer.go</a> b/<a href="../file/vendor/gopkg.in/check.v1/printer.go">vendor/gopkg.in/check.v1/printer.go</a></b>
<a href="#h87-0" id="h87-0" class="h">@@ -0,0 +1,168 @@
</a><a href="#h87-0-0" id="h87-0-0" class="i">+package check
</a><a href="#h87-0-1" id="h87-0-1" class="i">+
</a><a href="#h87-0-2" id="h87-0-2" class="i">+import (
</a><a href="#h87-0-3" id="h87-0-3" class="i">+	&quot;bytes&quot;
</a><a href="#h87-0-4" id="h87-0-4" class="i">+	&quot;go/ast&quot;
</a><a href="#h87-0-5" id="h87-0-5" class="i">+	&quot;go/parser&quot;
</a><a href="#h87-0-6" id="h87-0-6" class="i">+	&quot;go/printer&quot;
</a><a href="#h87-0-7" id="h87-0-7" class="i">+	&quot;go/token&quot;
</a><a href="#h87-0-8" id="h87-0-8" class="i">+	&quot;os&quot;
</a><a href="#h87-0-9" id="h87-0-9" class="i">+)
</a><a href="#h87-0-10" id="h87-0-10" class="i">+
</a><a href="#h87-0-11" id="h87-0-11" class="i">+func indent(s, with string) (r string) {
</a><a href="#h87-0-12" id="h87-0-12" class="i">+	eol := true
</a><a href="#h87-0-13" id="h87-0-13" class="i">+	for i := 0; i != len(s); i++ {
</a><a href="#h87-0-14" id="h87-0-14" class="i">+		c := s[i]
</a><a href="#h87-0-15" id="h87-0-15" class="i">+		switch {
</a><a href="#h87-0-16" id="h87-0-16" class="i">+		case eol &amp;&amp; c == &#39;\n&#39; || c == &#39;\r&#39;:
</a><a href="#h87-0-17" id="h87-0-17" class="i">+		case c == &#39;\n&#39; || c == &#39;\r&#39;:
</a><a href="#h87-0-18" id="h87-0-18" class="i">+			eol = true
</a><a href="#h87-0-19" id="h87-0-19" class="i">+		case eol:
</a><a href="#h87-0-20" id="h87-0-20" class="i">+			eol = false
</a><a href="#h87-0-21" id="h87-0-21" class="i">+			s = s[:i] + with + s[i:]
</a><a href="#h87-0-22" id="h87-0-22" class="i">+			i += len(with)
</a><a href="#h87-0-23" id="h87-0-23" class="i">+		}
</a><a href="#h87-0-24" id="h87-0-24" class="i">+	}
</a><a href="#h87-0-25" id="h87-0-25" class="i">+	return s
</a><a href="#h87-0-26" id="h87-0-26" class="i">+}
</a><a href="#h87-0-27" id="h87-0-27" class="i">+
</a><a href="#h87-0-28" id="h87-0-28" class="i">+func printLine(filename string, line int) (string, error) {
</a><a href="#h87-0-29" id="h87-0-29" class="i">+	fset := token.NewFileSet()
</a><a href="#h87-0-30" id="h87-0-30" class="i">+	file, err := os.Open(filename)
</a><a href="#h87-0-31" id="h87-0-31" class="i">+	if err != nil {
</a><a href="#h87-0-32" id="h87-0-32" class="i">+		return &quot;&quot;, err
</a><a href="#h87-0-33" id="h87-0-33" class="i">+	}
</a><a href="#h87-0-34" id="h87-0-34" class="i">+	fnode, err := parser.ParseFile(fset, filename, file, parser.ParseComments)
</a><a href="#h87-0-35" id="h87-0-35" class="i">+	if err != nil {
</a><a href="#h87-0-36" id="h87-0-36" class="i">+		return &quot;&quot;, err
</a><a href="#h87-0-37" id="h87-0-37" class="i">+	}
</a><a href="#h87-0-38" id="h87-0-38" class="i">+	config := &amp;printer.Config{Mode: printer.UseSpaces, Tabwidth: 4}
</a><a href="#h87-0-39" id="h87-0-39" class="i">+	lp := &amp;linePrinter{fset: fset, fnode: fnode, line: line, config: config}
</a><a href="#h87-0-40" id="h87-0-40" class="i">+	ast.Walk(lp, fnode)
</a><a href="#h87-0-41" id="h87-0-41" class="i">+	result := lp.output.Bytes()
</a><a href="#h87-0-42" id="h87-0-42" class="i">+	// Comments leave \n at the end.
</a><a href="#h87-0-43" id="h87-0-43" class="i">+	n := len(result)
</a><a href="#h87-0-44" id="h87-0-44" class="i">+	for n &gt; 0 &amp;&amp; result[n-1] == &#39;\n&#39; {
</a><a href="#h87-0-45" id="h87-0-45" class="i">+		n--
</a><a href="#h87-0-46" id="h87-0-46" class="i">+	}
</a><a href="#h87-0-47" id="h87-0-47" class="i">+	return string(result[:n]), nil
</a><a href="#h87-0-48" id="h87-0-48" class="i">+}
</a><a href="#h87-0-49" id="h87-0-49" class="i">+
</a><a href="#h87-0-50" id="h87-0-50" class="i">+type linePrinter struct {
</a><a href="#h87-0-51" id="h87-0-51" class="i">+	config *printer.Config
</a><a href="#h87-0-52" id="h87-0-52" class="i">+	fset   *token.FileSet
</a><a href="#h87-0-53" id="h87-0-53" class="i">+	fnode  *ast.File
</a><a href="#h87-0-54" id="h87-0-54" class="i">+	line   int
</a><a href="#h87-0-55" id="h87-0-55" class="i">+	output bytes.Buffer
</a><a href="#h87-0-56" id="h87-0-56" class="i">+	stmt   ast.Stmt
</a><a href="#h87-0-57" id="h87-0-57" class="i">+}
</a><a href="#h87-0-58" id="h87-0-58" class="i">+
</a><a href="#h87-0-59" id="h87-0-59" class="i">+func (lp *linePrinter) emit() bool {
</a><a href="#h87-0-60" id="h87-0-60" class="i">+	if lp.stmt != nil {
</a><a href="#h87-0-61" id="h87-0-61" class="i">+		lp.trim(lp.stmt)
</a><a href="#h87-0-62" id="h87-0-62" class="i">+		lp.printWithComments(lp.stmt)
</a><a href="#h87-0-63" id="h87-0-63" class="i">+		lp.stmt = nil
</a><a href="#h87-0-64" id="h87-0-64" class="i">+		return true
</a><a href="#h87-0-65" id="h87-0-65" class="i">+	}
</a><a href="#h87-0-66" id="h87-0-66" class="i">+	return false
</a><a href="#h87-0-67" id="h87-0-67" class="i">+}
</a><a href="#h87-0-68" id="h87-0-68" class="i">+
</a><a href="#h87-0-69" id="h87-0-69" class="i">+func (lp *linePrinter) printWithComments(n ast.Node) {
</a><a href="#h87-0-70" id="h87-0-70" class="i">+	nfirst := lp.fset.Position(n.Pos()).Line
</a><a href="#h87-0-71" id="h87-0-71" class="i">+	nlast := lp.fset.Position(n.End()).Line
</a><a href="#h87-0-72" id="h87-0-72" class="i">+	for _, g := range lp.fnode.Comments {
</a><a href="#h87-0-73" id="h87-0-73" class="i">+		cfirst := lp.fset.Position(g.Pos()).Line
</a><a href="#h87-0-74" id="h87-0-74" class="i">+		clast := lp.fset.Position(g.End()).Line
</a><a href="#h87-0-75" id="h87-0-75" class="i">+		if clast == nfirst-1 &amp;&amp; lp.fset.Position(n.Pos()).Column == lp.fset.Position(g.Pos()).Column {
</a><a href="#h87-0-76" id="h87-0-76" class="i">+			for _, c := range g.List {
</a><a href="#h87-0-77" id="h87-0-77" class="i">+				lp.output.WriteString(c.Text)
</a><a href="#h87-0-78" id="h87-0-78" class="i">+				lp.output.WriteByte(&#39;\n&#39;)
</a><a href="#h87-0-79" id="h87-0-79" class="i">+			}
</a><a href="#h87-0-80" id="h87-0-80" class="i">+		}
</a><a href="#h87-0-81" id="h87-0-81" class="i">+		if cfirst &gt;= nfirst &amp;&amp; cfirst &lt;= nlast &amp;&amp; n.End() &lt;= g.List[0].Slash {
</a><a href="#h87-0-82" id="h87-0-82" class="i">+			// The printer will not include the comment if it starts past
</a><a href="#h87-0-83" id="h87-0-83" class="i">+			// the node itself. Trick it into printing by overlapping the
</a><a href="#h87-0-84" id="h87-0-84" class="i">+			// slash with the end of the statement.
</a><a href="#h87-0-85" id="h87-0-85" class="i">+			g.List[0].Slash = n.End() - 1
</a><a href="#h87-0-86" id="h87-0-86" class="i">+		}
</a><a href="#h87-0-87" id="h87-0-87" class="i">+	}
</a><a href="#h87-0-88" id="h87-0-88" class="i">+	node := &amp;printer.CommentedNode{n, lp.fnode.Comments}
</a><a href="#h87-0-89" id="h87-0-89" class="i">+	lp.config.Fprint(&amp;lp.output, lp.fset, node)
</a><a href="#h87-0-90" id="h87-0-90" class="i">+}
</a><a href="#h87-0-91" id="h87-0-91" class="i">+
</a><a href="#h87-0-92" id="h87-0-92" class="i">+func (lp *linePrinter) Visit(n ast.Node) (w ast.Visitor) {
</a><a href="#h87-0-93" id="h87-0-93" class="i">+	if n == nil {
</a><a href="#h87-0-94" id="h87-0-94" class="i">+		if lp.output.Len() == 0 {
</a><a href="#h87-0-95" id="h87-0-95" class="i">+			lp.emit()
</a><a href="#h87-0-96" id="h87-0-96" class="i">+		}
</a><a href="#h87-0-97" id="h87-0-97" class="i">+		return nil
</a><a href="#h87-0-98" id="h87-0-98" class="i">+	}
</a><a href="#h87-0-99" id="h87-0-99" class="i">+	first := lp.fset.Position(n.Pos()).Line
</a><a href="#h87-0-100" id="h87-0-100" class="i">+	last := lp.fset.Position(n.End()).Line
</a><a href="#h87-0-101" id="h87-0-101" class="i">+	if first &lt;= lp.line &amp;&amp; last &gt;= lp.line {
</a><a href="#h87-0-102" id="h87-0-102" class="i">+		// Print the innermost statement containing the line.
</a><a href="#h87-0-103" id="h87-0-103" class="i">+		if stmt, ok := n.(ast.Stmt); ok {
</a><a href="#h87-0-104" id="h87-0-104" class="i">+			if _, ok := n.(*ast.BlockStmt); !ok {
</a><a href="#h87-0-105" id="h87-0-105" class="i">+				lp.stmt = stmt
</a><a href="#h87-0-106" id="h87-0-106" class="i">+			}
</a><a href="#h87-0-107" id="h87-0-107" class="i">+		}
</a><a href="#h87-0-108" id="h87-0-108" class="i">+		if first == lp.line &amp;&amp; lp.emit() {
</a><a href="#h87-0-109" id="h87-0-109" class="i">+			return nil
</a><a href="#h87-0-110" id="h87-0-110" class="i">+		}
</a><a href="#h87-0-111" id="h87-0-111" class="i">+		return lp
</a><a href="#h87-0-112" id="h87-0-112" class="i">+	}
</a><a href="#h87-0-113" id="h87-0-113" class="i">+	return nil
</a><a href="#h87-0-114" id="h87-0-114" class="i">+}
</a><a href="#h87-0-115" id="h87-0-115" class="i">+
</a><a href="#h87-0-116" id="h87-0-116" class="i">+func (lp *linePrinter) trim(n ast.Node) bool {
</a><a href="#h87-0-117" id="h87-0-117" class="i">+	stmt, ok := n.(ast.Stmt)
</a><a href="#h87-0-118" id="h87-0-118" class="i">+	if !ok {
</a><a href="#h87-0-119" id="h87-0-119" class="i">+		return true
</a><a href="#h87-0-120" id="h87-0-120" class="i">+	}
</a><a href="#h87-0-121" id="h87-0-121" class="i">+	line := lp.fset.Position(n.Pos()).Line
</a><a href="#h87-0-122" id="h87-0-122" class="i">+	if line != lp.line {
</a><a href="#h87-0-123" id="h87-0-123" class="i">+		return false
</a><a href="#h87-0-124" id="h87-0-124" class="i">+	}
</a><a href="#h87-0-125" id="h87-0-125" class="i">+	switch stmt := stmt.(type) {
</a><a href="#h87-0-126" id="h87-0-126" class="i">+	case *ast.IfStmt:
</a><a href="#h87-0-127" id="h87-0-127" class="i">+		stmt.Body = lp.trimBlock(stmt.Body)
</a><a href="#h87-0-128" id="h87-0-128" class="i">+	case *ast.SwitchStmt:
</a><a href="#h87-0-129" id="h87-0-129" class="i">+		stmt.Body = lp.trimBlock(stmt.Body)
</a><a href="#h87-0-130" id="h87-0-130" class="i">+	case *ast.TypeSwitchStmt:
</a><a href="#h87-0-131" id="h87-0-131" class="i">+		stmt.Body = lp.trimBlock(stmt.Body)
</a><a href="#h87-0-132" id="h87-0-132" class="i">+	case *ast.CaseClause:
</a><a href="#h87-0-133" id="h87-0-133" class="i">+		stmt.Body = lp.trimList(stmt.Body)
</a><a href="#h87-0-134" id="h87-0-134" class="i">+	case *ast.CommClause:
</a><a href="#h87-0-135" id="h87-0-135" class="i">+		stmt.Body = lp.trimList(stmt.Body)
</a><a href="#h87-0-136" id="h87-0-136" class="i">+	case *ast.BlockStmt:
</a><a href="#h87-0-137" id="h87-0-137" class="i">+		stmt.List = lp.trimList(stmt.List)
</a><a href="#h87-0-138" id="h87-0-138" class="i">+	}
</a><a href="#h87-0-139" id="h87-0-139" class="i">+	return true
</a><a href="#h87-0-140" id="h87-0-140" class="i">+}
</a><a href="#h87-0-141" id="h87-0-141" class="i">+
</a><a href="#h87-0-142" id="h87-0-142" class="i">+func (lp *linePrinter) trimBlock(stmt *ast.BlockStmt) *ast.BlockStmt {
</a><a href="#h87-0-143" id="h87-0-143" class="i">+	if !lp.trim(stmt) {
</a><a href="#h87-0-144" id="h87-0-144" class="i">+		return lp.emptyBlock(stmt)
</a><a href="#h87-0-145" id="h87-0-145" class="i">+	}
</a><a href="#h87-0-146" id="h87-0-146" class="i">+	stmt.Rbrace = stmt.Lbrace
</a><a href="#h87-0-147" id="h87-0-147" class="i">+	return stmt
</a><a href="#h87-0-148" id="h87-0-148" class="i">+}
</a><a href="#h87-0-149" id="h87-0-149" class="i">+
</a><a href="#h87-0-150" id="h87-0-150" class="i">+func (lp *linePrinter) trimList(stmts []ast.Stmt) []ast.Stmt {
</a><a href="#h87-0-151" id="h87-0-151" class="i">+	for i := 0; i != len(stmts); i++ {
</a><a href="#h87-0-152" id="h87-0-152" class="i">+		if !lp.trim(stmts[i]) {
</a><a href="#h87-0-153" id="h87-0-153" class="i">+			stmts[i] = lp.emptyStmt(stmts[i])
</a><a href="#h87-0-154" id="h87-0-154" class="i">+			break
</a><a href="#h87-0-155" id="h87-0-155" class="i">+		}
</a><a href="#h87-0-156" id="h87-0-156" class="i">+	}
</a><a href="#h87-0-157" id="h87-0-157" class="i">+	return stmts
</a><a href="#h87-0-158" id="h87-0-158" class="i">+}
</a><a href="#h87-0-159" id="h87-0-159" class="i">+
</a><a href="#h87-0-160" id="h87-0-160" class="i">+func (lp *linePrinter) emptyStmt(n ast.Node) *ast.ExprStmt {
</a><a href="#h87-0-161" id="h87-0-161" class="i">+	return &amp;ast.ExprStmt{&amp;ast.Ellipsis{n.Pos(), nil}}
</a><a href="#h87-0-162" id="h87-0-162" class="i">+}
</a><a href="#h87-0-163" id="h87-0-163" class="i">+
</a><a href="#h87-0-164" id="h87-0-164" class="i">+func (lp *linePrinter) emptyBlock(n ast.Node) *ast.BlockStmt {
</a><a href="#h87-0-165" id="h87-0-165" class="i">+	p := n.Pos()
</a><a href="#h87-0-166" id="h87-0-166" class="i">+	return &amp;ast.BlockStmt{p, []ast.Stmt{lp.emptyStmt(n)}, p}
</a><a href="#h87-0-167" id="h87-0-167" class="i">+}
</a><b>diff --git a/<a id="h88" href="../file/vendor/gopkg.in/check.v1/reporter.go">vendor/gopkg.in/check.v1/reporter.go</a> b/<a href="../file/vendor/gopkg.in/check.v1/reporter.go">vendor/gopkg.in/check.v1/reporter.go</a></b>
<a href="#h88-0" id="h88-0" class="h">@@ -0,0 +1,88 @@
</a><a href="#h88-0-0" id="h88-0-0" class="i">+package check
</a><a href="#h88-0-1" id="h88-0-1" class="i">+
</a><a href="#h88-0-2" id="h88-0-2" class="i">+import (
</a><a href="#h88-0-3" id="h88-0-3" class="i">+	&quot;fmt&quot;
</a><a href="#h88-0-4" id="h88-0-4" class="i">+	&quot;io&quot;
</a><a href="#h88-0-5" id="h88-0-5" class="i">+	&quot;sync&quot;
</a><a href="#h88-0-6" id="h88-0-6" class="i">+)
</a><a href="#h88-0-7" id="h88-0-7" class="i">+
</a><a href="#h88-0-8" id="h88-0-8" class="i">+// -----------------------------------------------------------------------
</a><a href="#h88-0-9" id="h88-0-9" class="i">+// Output writer manages atomic output writing according to settings.
</a><a href="#h88-0-10" id="h88-0-10" class="i">+
</a><a href="#h88-0-11" id="h88-0-11" class="i">+type outputWriter struct {
</a><a href="#h88-0-12" id="h88-0-12" class="i">+	m                    sync.Mutex
</a><a href="#h88-0-13" id="h88-0-13" class="i">+	writer               io.Writer
</a><a href="#h88-0-14" id="h88-0-14" class="i">+	wroteCallProblemLast bool
</a><a href="#h88-0-15" id="h88-0-15" class="i">+	Stream               bool
</a><a href="#h88-0-16" id="h88-0-16" class="i">+	Verbose              bool
</a><a href="#h88-0-17" id="h88-0-17" class="i">+}
</a><a href="#h88-0-18" id="h88-0-18" class="i">+
</a><a href="#h88-0-19" id="h88-0-19" class="i">+func newOutputWriter(writer io.Writer, stream, verbose bool) *outputWriter {
</a><a href="#h88-0-20" id="h88-0-20" class="i">+	return &amp;outputWriter{writer: writer, Stream: stream, Verbose: verbose}
</a><a href="#h88-0-21" id="h88-0-21" class="i">+}
</a><a href="#h88-0-22" id="h88-0-22" class="i">+
</a><a href="#h88-0-23" id="h88-0-23" class="i">+func (ow *outputWriter) Write(content []byte) (n int, err error) {
</a><a href="#h88-0-24" id="h88-0-24" class="i">+	ow.m.Lock()
</a><a href="#h88-0-25" id="h88-0-25" class="i">+	n, err = ow.writer.Write(content)
</a><a href="#h88-0-26" id="h88-0-26" class="i">+	ow.m.Unlock()
</a><a href="#h88-0-27" id="h88-0-27" class="i">+	return
</a><a href="#h88-0-28" id="h88-0-28" class="i">+}
</a><a href="#h88-0-29" id="h88-0-29" class="i">+
</a><a href="#h88-0-30" id="h88-0-30" class="i">+func (ow *outputWriter) WriteCallStarted(label string, c *C) {
</a><a href="#h88-0-31" id="h88-0-31" class="i">+	if ow.Stream {
</a><a href="#h88-0-32" id="h88-0-32" class="i">+		header := renderCallHeader(label, c, &quot;&quot;, &quot;\n&quot;)
</a><a href="#h88-0-33" id="h88-0-33" class="i">+		ow.m.Lock()
</a><a href="#h88-0-34" id="h88-0-34" class="i">+		ow.writer.Write([]byte(header))
</a><a href="#h88-0-35" id="h88-0-35" class="i">+		ow.m.Unlock()
</a><a href="#h88-0-36" id="h88-0-36" class="i">+	}
</a><a href="#h88-0-37" id="h88-0-37" class="i">+}
</a><a href="#h88-0-38" id="h88-0-38" class="i">+
</a><a href="#h88-0-39" id="h88-0-39" class="i">+func (ow *outputWriter) WriteCallProblem(label string, c *C) {
</a><a href="#h88-0-40" id="h88-0-40" class="i">+	var prefix string
</a><a href="#h88-0-41" id="h88-0-41" class="i">+	if !ow.Stream {
</a><a href="#h88-0-42" id="h88-0-42" class="i">+		prefix = &quot;\n-----------------------------------&quot; +
</a><a href="#h88-0-43" id="h88-0-43" class="i">+			&quot;-----------------------------------\n&quot;
</a><a href="#h88-0-44" id="h88-0-44" class="i">+	}
</a><a href="#h88-0-45" id="h88-0-45" class="i">+	header := renderCallHeader(label, c, prefix, &quot;\n\n&quot;)
</a><a href="#h88-0-46" id="h88-0-46" class="i">+	ow.m.Lock()
</a><a href="#h88-0-47" id="h88-0-47" class="i">+	ow.wroteCallProblemLast = true
</a><a href="#h88-0-48" id="h88-0-48" class="i">+	ow.writer.Write([]byte(header))
</a><a href="#h88-0-49" id="h88-0-49" class="i">+	if !ow.Stream {
</a><a href="#h88-0-50" id="h88-0-50" class="i">+		c.logb.WriteTo(ow.writer)
</a><a href="#h88-0-51" id="h88-0-51" class="i">+	}
</a><a href="#h88-0-52" id="h88-0-52" class="i">+	ow.m.Unlock()
</a><a href="#h88-0-53" id="h88-0-53" class="i">+}
</a><a href="#h88-0-54" id="h88-0-54" class="i">+
</a><a href="#h88-0-55" id="h88-0-55" class="i">+func (ow *outputWriter) WriteCallSuccess(label string, c *C) {
</a><a href="#h88-0-56" id="h88-0-56" class="i">+	if ow.Stream || (ow.Verbose &amp;&amp; c.kind == testKd) {
</a><a href="#h88-0-57" id="h88-0-57" class="i">+		// TODO Use a buffer here.
</a><a href="#h88-0-58" id="h88-0-58" class="i">+		var suffix string
</a><a href="#h88-0-59" id="h88-0-59" class="i">+		if c.reason != &quot;&quot; {
</a><a href="#h88-0-60" id="h88-0-60" class="i">+			suffix = &quot; (&quot; + c.reason + &quot;)&quot;
</a><a href="#h88-0-61" id="h88-0-61" class="i">+		}
</a><a href="#h88-0-62" id="h88-0-62" class="i">+		if c.status() == succeededSt {
</a><a href="#h88-0-63" id="h88-0-63" class="i">+			suffix += &quot;\t&quot; + c.timerString()
</a><a href="#h88-0-64" id="h88-0-64" class="i">+		}
</a><a href="#h88-0-65" id="h88-0-65" class="i">+		suffix += &quot;\n&quot;
</a><a href="#h88-0-66" id="h88-0-66" class="i">+		if ow.Stream {
</a><a href="#h88-0-67" id="h88-0-67" class="i">+			suffix += &quot;\n&quot;
</a><a href="#h88-0-68" id="h88-0-68" class="i">+		}
</a><a href="#h88-0-69" id="h88-0-69" class="i">+		header := renderCallHeader(label, c, &quot;&quot;, suffix)
</a><a href="#h88-0-70" id="h88-0-70" class="i">+		ow.m.Lock()
</a><a href="#h88-0-71" id="h88-0-71" class="i">+		// Resist temptation of using line as prefix above due to race.
</a><a href="#h88-0-72" id="h88-0-72" class="i">+		if !ow.Stream &amp;&amp; ow.wroteCallProblemLast {
</a><a href="#h88-0-73" id="h88-0-73" class="i">+			header = &quot;\n-----------------------------------&quot; +
</a><a href="#h88-0-74" id="h88-0-74" class="i">+				&quot;-----------------------------------\n&quot; +
</a><a href="#h88-0-75" id="h88-0-75" class="i">+				header
</a><a href="#h88-0-76" id="h88-0-76" class="i">+		}
</a><a href="#h88-0-77" id="h88-0-77" class="i">+		ow.wroteCallProblemLast = false
</a><a href="#h88-0-78" id="h88-0-78" class="i">+		ow.writer.Write([]byte(header))
</a><a href="#h88-0-79" id="h88-0-79" class="i">+		ow.m.Unlock()
</a><a href="#h88-0-80" id="h88-0-80" class="i">+	}
</a><a href="#h88-0-81" id="h88-0-81" class="i">+}
</a><a href="#h88-0-82" id="h88-0-82" class="i">+
</a><a href="#h88-0-83" id="h88-0-83" class="i">+func renderCallHeader(label string, c *C, prefix, suffix string) string {
</a><a href="#h88-0-84" id="h88-0-84" class="i">+	pc := c.method.PC()
</a><a href="#h88-0-85" id="h88-0-85" class="i">+	return fmt.Sprintf(&quot;%s%s: %s: %s%s&quot;, prefix, label, niceFuncPath(pc),
</a><a href="#h88-0-86" id="h88-0-86" class="i">+		niceFuncName(pc), suffix)
</a><a href="#h88-0-87" id="h88-0-87" class="i">+}
</a><b>diff --git a/<a id="h89" href="../file/vendor/gopkg.in/check.v1/run.go">vendor/gopkg.in/check.v1/run.go</a> b/<a href="../file/vendor/gopkg.in/check.v1/run.go">vendor/gopkg.in/check.v1/run.go</a></b>
<a href="#h89-0" id="h89-0" class="h">@@ -0,0 +1,175 @@
</a><a href="#h89-0-0" id="h89-0-0" class="i">+package check
</a><a href="#h89-0-1" id="h89-0-1" class="i">+
</a><a href="#h89-0-2" id="h89-0-2" class="i">+import (
</a><a href="#h89-0-3" id="h89-0-3" class="i">+	&quot;bufio&quot;
</a><a href="#h89-0-4" id="h89-0-4" class="i">+	&quot;flag&quot;
</a><a href="#h89-0-5" id="h89-0-5" class="i">+	&quot;fmt&quot;
</a><a href="#h89-0-6" id="h89-0-6" class="i">+	&quot;os&quot;
</a><a href="#h89-0-7" id="h89-0-7" class="i">+	&quot;testing&quot;
</a><a href="#h89-0-8" id="h89-0-8" class="i">+	&quot;time&quot;
</a><a href="#h89-0-9" id="h89-0-9" class="i">+)
</a><a href="#h89-0-10" id="h89-0-10" class="i">+
</a><a href="#h89-0-11" id="h89-0-11" class="i">+// -----------------------------------------------------------------------
</a><a href="#h89-0-12" id="h89-0-12" class="i">+// Test suite registry.
</a><a href="#h89-0-13" id="h89-0-13" class="i">+
</a><a href="#h89-0-14" id="h89-0-14" class="i">+var allSuites []interface{}
</a><a href="#h89-0-15" id="h89-0-15" class="i">+
</a><a href="#h89-0-16" id="h89-0-16" class="i">+// Suite registers the given value as a test suite to be run. Any methods
</a><a href="#h89-0-17" id="h89-0-17" class="i">+// starting with the Test prefix in the given value will be considered as
</a><a href="#h89-0-18" id="h89-0-18" class="i">+// a test method.
</a><a href="#h89-0-19" id="h89-0-19" class="i">+func Suite(suite interface{}) interface{} {
</a><a href="#h89-0-20" id="h89-0-20" class="i">+	allSuites = append(allSuites, suite)
</a><a href="#h89-0-21" id="h89-0-21" class="i">+	return suite
</a><a href="#h89-0-22" id="h89-0-22" class="i">+}
</a><a href="#h89-0-23" id="h89-0-23" class="i">+
</a><a href="#h89-0-24" id="h89-0-24" class="i">+// -----------------------------------------------------------------------
</a><a href="#h89-0-25" id="h89-0-25" class="i">+// Public running interface.
</a><a href="#h89-0-26" id="h89-0-26" class="i">+
</a><a href="#h89-0-27" id="h89-0-27" class="i">+var (
</a><a href="#h89-0-28" id="h89-0-28" class="i">+	oldFilterFlag  = flag.String(&quot;gocheck.f&quot;, &quot;&quot;, &quot;Regular expression selecting which tests and/or suites to run&quot;)
</a><a href="#h89-0-29" id="h89-0-29" class="i">+	oldVerboseFlag = flag.Bool(&quot;gocheck.v&quot;, false, &quot;Verbose mode&quot;)
</a><a href="#h89-0-30" id="h89-0-30" class="i">+	oldStreamFlag  = flag.Bool(&quot;gocheck.vv&quot;, false, &quot;Super verbose mode (disables output caching)&quot;)
</a><a href="#h89-0-31" id="h89-0-31" class="i">+	oldBenchFlag   = flag.Bool(&quot;gocheck.b&quot;, false, &quot;Run benchmarks&quot;)
</a><a href="#h89-0-32" id="h89-0-32" class="i">+	oldBenchTime   = flag.Duration(&quot;gocheck.btime&quot;, 1*time.Second, &quot;approximate run time for each benchmark&quot;)
</a><a href="#h89-0-33" id="h89-0-33" class="i">+	oldListFlag    = flag.Bool(&quot;gocheck.list&quot;, false, &quot;List the names of all tests that will be run&quot;)
</a><a href="#h89-0-34" id="h89-0-34" class="i">+	oldWorkFlag    = flag.Bool(&quot;gocheck.work&quot;, false, &quot;Display and do not remove the test working directory&quot;)
</a><a href="#h89-0-35" id="h89-0-35" class="i">+
</a><a href="#h89-0-36" id="h89-0-36" class="i">+	newFilterFlag  = flag.String(&quot;check.f&quot;, &quot;&quot;, &quot;Regular expression selecting which tests and/or suites to run&quot;)
</a><a href="#h89-0-37" id="h89-0-37" class="i">+	newVerboseFlag = flag.Bool(&quot;check.v&quot;, false, &quot;Verbose mode&quot;)
</a><a href="#h89-0-38" id="h89-0-38" class="i">+	newStreamFlag  = flag.Bool(&quot;check.vv&quot;, false, &quot;Super verbose mode (disables output caching)&quot;)
</a><a href="#h89-0-39" id="h89-0-39" class="i">+	newBenchFlag   = flag.Bool(&quot;check.b&quot;, false, &quot;Run benchmarks&quot;)
</a><a href="#h89-0-40" id="h89-0-40" class="i">+	newBenchTime   = flag.Duration(&quot;check.btime&quot;, 1*time.Second, &quot;approximate run time for each benchmark&quot;)
</a><a href="#h89-0-41" id="h89-0-41" class="i">+	newBenchMem    = flag.Bool(&quot;check.bmem&quot;, false, &quot;Report memory benchmarks&quot;)
</a><a href="#h89-0-42" id="h89-0-42" class="i">+	newListFlag    = flag.Bool(&quot;check.list&quot;, false, &quot;List the names of all tests that will be run&quot;)
</a><a href="#h89-0-43" id="h89-0-43" class="i">+	newWorkFlag    = flag.Bool(&quot;check.work&quot;, false, &quot;Display and do not remove the test working directory&quot;)
</a><a href="#h89-0-44" id="h89-0-44" class="i">+)
</a><a href="#h89-0-45" id="h89-0-45" class="i">+
</a><a href="#h89-0-46" id="h89-0-46" class="i">+// TestingT runs all test suites registered with the Suite function,
</a><a href="#h89-0-47" id="h89-0-47" class="i">+// printing results to stdout, and reporting any failures back to
</a><a href="#h89-0-48" id="h89-0-48" class="i">+// the &quot;testing&quot; package.
</a><a href="#h89-0-49" id="h89-0-49" class="i">+func TestingT(testingT *testing.T) {
</a><a href="#h89-0-50" id="h89-0-50" class="i">+	benchTime := *newBenchTime
</a><a href="#h89-0-51" id="h89-0-51" class="i">+	if benchTime == 1*time.Second {
</a><a href="#h89-0-52" id="h89-0-52" class="i">+		benchTime = *oldBenchTime
</a><a href="#h89-0-53" id="h89-0-53" class="i">+	}
</a><a href="#h89-0-54" id="h89-0-54" class="i">+	conf := &amp;RunConf{
</a><a href="#h89-0-55" id="h89-0-55" class="i">+		Filter:        *oldFilterFlag + *newFilterFlag,
</a><a href="#h89-0-56" id="h89-0-56" class="i">+		Verbose:       *oldVerboseFlag || *newVerboseFlag,
</a><a href="#h89-0-57" id="h89-0-57" class="i">+		Stream:        *oldStreamFlag || *newStreamFlag,
</a><a href="#h89-0-58" id="h89-0-58" class="i">+		Benchmark:     *oldBenchFlag || *newBenchFlag,
</a><a href="#h89-0-59" id="h89-0-59" class="i">+		BenchmarkTime: benchTime,
</a><a href="#h89-0-60" id="h89-0-60" class="i">+		BenchmarkMem:  *newBenchMem,
</a><a href="#h89-0-61" id="h89-0-61" class="i">+		KeepWorkDir:   *oldWorkFlag || *newWorkFlag,
</a><a href="#h89-0-62" id="h89-0-62" class="i">+	}
</a><a href="#h89-0-63" id="h89-0-63" class="i">+	if *oldListFlag || *newListFlag {
</a><a href="#h89-0-64" id="h89-0-64" class="i">+		w := bufio.NewWriter(os.Stdout)
</a><a href="#h89-0-65" id="h89-0-65" class="i">+		for _, name := range ListAll(conf) {
</a><a href="#h89-0-66" id="h89-0-66" class="i">+			fmt.Fprintln(w, name)
</a><a href="#h89-0-67" id="h89-0-67" class="i">+		}
</a><a href="#h89-0-68" id="h89-0-68" class="i">+		w.Flush()
</a><a href="#h89-0-69" id="h89-0-69" class="i">+		return
</a><a href="#h89-0-70" id="h89-0-70" class="i">+	}
</a><a href="#h89-0-71" id="h89-0-71" class="i">+	result := RunAll(conf)
</a><a href="#h89-0-72" id="h89-0-72" class="i">+	println(result.String())
</a><a href="#h89-0-73" id="h89-0-73" class="i">+	if !result.Passed() {
</a><a href="#h89-0-74" id="h89-0-74" class="i">+		testingT.Fail()
</a><a href="#h89-0-75" id="h89-0-75" class="i">+	}
</a><a href="#h89-0-76" id="h89-0-76" class="i">+}
</a><a href="#h89-0-77" id="h89-0-77" class="i">+
</a><a href="#h89-0-78" id="h89-0-78" class="i">+// RunAll runs all test suites registered with the Suite function, using the
</a><a href="#h89-0-79" id="h89-0-79" class="i">+// provided run configuration.
</a><a href="#h89-0-80" id="h89-0-80" class="i">+func RunAll(runConf *RunConf) *Result {
</a><a href="#h89-0-81" id="h89-0-81" class="i">+	result := Result{}
</a><a href="#h89-0-82" id="h89-0-82" class="i">+	for _, suite := range allSuites {
</a><a href="#h89-0-83" id="h89-0-83" class="i">+		result.Add(Run(suite, runConf))
</a><a href="#h89-0-84" id="h89-0-84" class="i">+	}
</a><a href="#h89-0-85" id="h89-0-85" class="i">+	return &amp;result
</a><a href="#h89-0-86" id="h89-0-86" class="i">+}
</a><a href="#h89-0-87" id="h89-0-87" class="i">+
</a><a href="#h89-0-88" id="h89-0-88" class="i">+// Run runs the provided test suite using the provided run configuration.
</a><a href="#h89-0-89" id="h89-0-89" class="i">+func Run(suite interface{}, runConf *RunConf) *Result {
</a><a href="#h89-0-90" id="h89-0-90" class="i">+	runner := newSuiteRunner(suite, runConf)
</a><a href="#h89-0-91" id="h89-0-91" class="i">+	return runner.run()
</a><a href="#h89-0-92" id="h89-0-92" class="i">+}
</a><a href="#h89-0-93" id="h89-0-93" class="i">+
</a><a href="#h89-0-94" id="h89-0-94" class="i">+// ListAll returns the names of all the test functions registered with the
</a><a href="#h89-0-95" id="h89-0-95" class="i">+// Suite function that will be run with the provided run configuration.
</a><a href="#h89-0-96" id="h89-0-96" class="i">+func ListAll(runConf *RunConf) []string {
</a><a href="#h89-0-97" id="h89-0-97" class="i">+	var names []string
</a><a href="#h89-0-98" id="h89-0-98" class="i">+	for _, suite := range allSuites {
</a><a href="#h89-0-99" id="h89-0-99" class="i">+		names = append(names, List(suite, runConf)...)
</a><a href="#h89-0-100" id="h89-0-100" class="i">+	}
</a><a href="#h89-0-101" id="h89-0-101" class="i">+	return names
</a><a href="#h89-0-102" id="h89-0-102" class="i">+}
</a><a href="#h89-0-103" id="h89-0-103" class="i">+
</a><a href="#h89-0-104" id="h89-0-104" class="i">+// List returns the names of the test functions in the given
</a><a href="#h89-0-105" id="h89-0-105" class="i">+// suite that will be run with the provided run configuration.
</a><a href="#h89-0-106" id="h89-0-106" class="i">+func List(suite interface{}, runConf *RunConf) []string {
</a><a href="#h89-0-107" id="h89-0-107" class="i">+	var names []string
</a><a href="#h89-0-108" id="h89-0-108" class="i">+	runner := newSuiteRunner(suite, runConf)
</a><a href="#h89-0-109" id="h89-0-109" class="i">+	for _, t := range runner.tests {
</a><a href="#h89-0-110" id="h89-0-110" class="i">+		names = append(names, t.String())
</a><a href="#h89-0-111" id="h89-0-111" class="i">+	}
</a><a href="#h89-0-112" id="h89-0-112" class="i">+	return names
</a><a href="#h89-0-113" id="h89-0-113" class="i">+}
</a><a href="#h89-0-114" id="h89-0-114" class="i">+
</a><a href="#h89-0-115" id="h89-0-115" class="i">+// -----------------------------------------------------------------------
</a><a href="#h89-0-116" id="h89-0-116" class="i">+// Result methods.
</a><a href="#h89-0-117" id="h89-0-117" class="i">+
</a><a href="#h89-0-118" id="h89-0-118" class="i">+func (r *Result) Add(other *Result) {
</a><a href="#h89-0-119" id="h89-0-119" class="i">+	r.Succeeded += other.Succeeded
</a><a href="#h89-0-120" id="h89-0-120" class="i">+	r.Skipped += other.Skipped
</a><a href="#h89-0-121" id="h89-0-121" class="i">+	r.Failed += other.Failed
</a><a href="#h89-0-122" id="h89-0-122" class="i">+	r.Panicked += other.Panicked
</a><a href="#h89-0-123" id="h89-0-123" class="i">+	r.FixturePanicked += other.FixturePanicked
</a><a href="#h89-0-124" id="h89-0-124" class="i">+	r.ExpectedFailures += other.ExpectedFailures
</a><a href="#h89-0-125" id="h89-0-125" class="i">+	r.Missed += other.Missed
</a><a href="#h89-0-126" id="h89-0-126" class="i">+	if r.WorkDir != &quot;&quot; &amp;&amp; other.WorkDir != &quot;&quot; {
</a><a href="#h89-0-127" id="h89-0-127" class="i">+		r.WorkDir += &quot;:&quot; + other.WorkDir
</a><a href="#h89-0-128" id="h89-0-128" class="i">+	} else if other.WorkDir != &quot;&quot; {
</a><a href="#h89-0-129" id="h89-0-129" class="i">+		r.WorkDir = other.WorkDir
</a><a href="#h89-0-130" id="h89-0-130" class="i">+	}
</a><a href="#h89-0-131" id="h89-0-131" class="i">+}
</a><a href="#h89-0-132" id="h89-0-132" class="i">+
</a><a href="#h89-0-133" id="h89-0-133" class="i">+func (r *Result) Passed() bool {
</a><a href="#h89-0-134" id="h89-0-134" class="i">+	return (r.Failed == 0 &amp;&amp; r.Panicked == 0 &amp;&amp;
</a><a href="#h89-0-135" id="h89-0-135" class="i">+		r.FixturePanicked == 0 &amp;&amp; r.Missed == 0 &amp;&amp;
</a><a href="#h89-0-136" id="h89-0-136" class="i">+		r.RunError == nil)
</a><a href="#h89-0-137" id="h89-0-137" class="i">+}
</a><a href="#h89-0-138" id="h89-0-138" class="i">+
</a><a href="#h89-0-139" id="h89-0-139" class="i">+func (r *Result) String() string {
</a><a href="#h89-0-140" id="h89-0-140" class="i">+	if r.RunError != nil {
</a><a href="#h89-0-141" id="h89-0-141" class="i">+		return &quot;ERROR: &quot; + r.RunError.Error()
</a><a href="#h89-0-142" id="h89-0-142" class="i">+	}
</a><a href="#h89-0-143" id="h89-0-143" class="i">+
</a><a href="#h89-0-144" id="h89-0-144" class="i">+	var value string
</a><a href="#h89-0-145" id="h89-0-145" class="i">+	if r.Failed == 0 &amp;&amp; r.Panicked == 0 &amp;&amp; r.FixturePanicked == 0 &amp;&amp;
</a><a href="#h89-0-146" id="h89-0-146" class="i">+		r.Missed == 0 {
</a><a href="#h89-0-147" id="h89-0-147" class="i">+		value = &quot;OK: &quot;
</a><a href="#h89-0-148" id="h89-0-148" class="i">+	} else {
</a><a href="#h89-0-149" id="h89-0-149" class="i">+		value = &quot;OOPS: &quot;
</a><a href="#h89-0-150" id="h89-0-150" class="i">+	}
</a><a href="#h89-0-151" id="h89-0-151" class="i">+	value += fmt.Sprintf(&quot;%d passed&quot;, r.Succeeded)
</a><a href="#h89-0-152" id="h89-0-152" class="i">+	if r.Skipped != 0 {
</a><a href="#h89-0-153" id="h89-0-153" class="i">+		value += fmt.Sprintf(&quot;, %d skipped&quot;, r.Skipped)
</a><a href="#h89-0-154" id="h89-0-154" class="i">+	}
</a><a href="#h89-0-155" id="h89-0-155" class="i">+	if r.ExpectedFailures != 0 {
</a><a href="#h89-0-156" id="h89-0-156" class="i">+		value += fmt.Sprintf(&quot;, %d expected failures&quot;, r.ExpectedFailures)
</a><a href="#h89-0-157" id="h89-0-157" class="i">+	}
</a><a href="#h89-0-158" id="h89-0-158" class="i">+	if r.Failed != 0 {
</a><a href="#h89-0-159" id="h89-0-159" class="i">+		value += fmt.Sprintf(&quot;, %d FAILED&quot;, r.Failed)
</a><a href="#h89-0-160" id="h89-0-160" class="i">+	}
</a><a href="#h89-0-161" id="h89-0-161" class="i">+	if r.Panicked != 0 {
</a><a href="#h89-0-162" id="h89-0-162" class="i">+		value += fmt.Sprintf(&quot;, %d PANICKED&quot;, r.Panicked)
</a><a href="#h89-0-163" id="h89-0-163" class="i">+	}
</a><a href="#h89-0-164" id="h89-0-164" class="i">+	if r.FixturePanicked != 0 {
</a><a href="#h89-0-165" id="h89-0-165" class="i">+		value += fmt.Sprintf(&quot;, %d FIXTURE-PANICKED&quot;, r.FixturePanicked)
</a><a href="#h89-0-166" id="h89-0-166" class="i">+	}
</a><a href="#h89-0-167" id="h89-0-167" class="i">+	if r.Missed != 0 {
</a><a href="#h89-0-168" id="h89-0-168" class="i">+		value += fmt.Sprintf(&quot;, %d MISSED&quot;, r.Missed)
</a><a href="#h89-0-169" id="h89-0-169" class="i">+	}
</a><a href="#h89-0-170" id="h89-0-170" class="i">+	if r.WorkDir != &quot;&quot; {
</a><a href="#h89-0-171" id="h89-0-171" class="i">+		value += &quot;\nWORK=&quot; + r.WorkDir
</a><a href="#h89-0-172" id="h89-0-172" class="i">+	}
</a><a href="#h89-0-173" id="h89-0-173" class="i">+	return value
</a><a href="#h89-0-174" id="h89-0-174" class="i">+}
</a><b>diff --git a/<a id="h90" href="../file/vendor/vendor.json">vendor/vendor.json</a> b/<a href="../file/vendor/vendor.json">vendor/vendor.json</a></b>
<a href="#h90-0" id="h90-0" class="h">@@ -0,0 +1,55 @@
</a><a href="#h90-0-0" id="h90-0-0" class="i">+{
</a><a href="#h90-0-1" id="h90-0-1" class="i">+	&quot;comment&quot;: &quot;&quot;,
</a><a href="#h90-0-2" id="h90-0-2" class="i">+	&quot;ignore&quot;: &quot;test&quot;,
</a><a href="#h90-0-3" id="h90-0-3" class="i">+	&quot;package&quot;: [
</a><a href="#h90-0-4" id="h90-0-4" class="i">+		{
</a><a href="#h90-0-5" id="h90-0-5" class="i">+			&quot;checksumSHA1&quot;: &quot;AKjqgiWov1IJWbnpCkjVEs6NunQ=&quot;,
</a><a href="#h90-0-6" id="h90-0-6" class="i">+			&quot;path&quot;: &quot;github.com/bmizerany/pat&quot;,
</a><a href="#h90-0-7" id="h90-0-7" class="i">+			&quot;revision&quot;: &quot;c068ca2f0aacee5ac3681d68e4d0a003b7d1fd2c&quot;,
</a><a href="#h90-0-8" id="h90-0-8" class="i">+			&quot;revisionTime&quot;: &quot;2016-02-17T10:30:50Z&quot;
</a><a href="#h90-0-9" id="h90-0-9" class="i">+		},
</a><a href="#h90-0-10" id="h90-0-10" class="i">+		{
</a><a href="#h90-0-11" id="h90-0-11" class="i">+			&quot;checksumSHA1&quot;: &quot;lRiXw/k3wMbVticu4UnHSmqdhSI=&quot;,
</a><a href="#h90-0-12" id="h90-0-12" class="i">+			&quot;path&quot;: &quot;github.com/google/go-github/github&quot;,
</a><a href="#h90-0-13" id="h90-0-13" class="i">+			&quot;revision&quot;: &quot;63f6986f05c3e857d0bd9d7245b24c12a6c11147&quot;,
</a><a href="#h90-0-14" id="h90-0-14" class="i">+			&quot;revisionTime&quot;: &quot;2016-04-05T22:16:35Z&quot;
</a><a href="#h90-0-15" id="h90-0-15" class="i">+		},
</a><a href="#h90-0-16" id="h90-0-16" class="i">+		{
</a><a href="#h90-0-17" id="h90-0-17" class="i">+			&quot;checksumSHA1&quot;: &quot;dz3Of7nwquNfShyXNkLSA36RrLo=&quot;,
</a><a href="#h90-0-18" id="h90-0-18" class="i">+			&quot;path&quot;: &quot;github.com/google/go-querystring/query&quot;,
</a><a href="#h90-0-19" id="h90-0-19" class="i">+			&quot;revision&quot;: &quot;6bb77fe6f42b85397288d4f6f67ac72f8f400ee7&quot;,
</a><a href="#h90-0-20" id="h90-0-20" class="i">+			&quot;revisionTime&quot;: &quot;2016-02-18T00:51:18Z&quot;
</a><a href="#h90-0-21" id="h90-0-21" class="i">+		},
</a><a href="#h90-0-22" id="h90-0-22" class="i">+		{
</a><a href="#h90-0-23" id="h90-0-23" class="i">+			&quot;checksumSHA1&quot;: &quot;Dsggox33NpBqmkEYgaYD6vEf1KQ=&quot;,
</a><a href="#h90-0-24" id="h90-0-24" class="i">+			&quot;path&quot;: &quot;github.com/nelhage/go.cli/config&quot;,
</a><a href="#h90-0-25" id="h90-0-25" class="i">+			&quot;revision&quot;: &quot;2aeb96ef8025f3646befae8353b90f95e9e79bdc&quot;,
</a><a href="#h90-0-26" id="h90-0-26" class="i">+			&quot;revisionTime&quot;: &quot;2014-07-17T04:35:04Z&quot;
</a><a href="#h90-0-27" id="h90-0-27" class="i">+		},
</a><a href="#h90-0-28" id="h90-0-28" class="i">+		{
</a><a href="#h90-0-29" id="h90-0-29" class="i">+			&quot;checksumSHA1&quot;: &quot;pancewZW3HwGvpDwfH5Imrbadc4=&quot;,
</a><a href="#h90-0-30" id="h90-0-30" class="i">+			&quot;path&quot;: &quot;golang.org/x/net/context&quot;,
</a><a href="#h90-0-31" id="h90-0-31" class="i">+			&quot;revision&quot;: &quot;e45385e9b226f570b1f086bf287b25d3d4117776&quot;,
</a><a href="#h90-0-32" id="h90-0-32" class="i">+			&quot;revisionTime&quot;: &quot;2016-04-07T02:17:48Z&quot;
</a><a href="#h90-0-33" id="h90-0-33" class="i">+		},
</a><a href="#h90-0-34" id="h90-0-34" class="i">+		{
</a><a href="#h90-0-35" id="h90-0-35" class="i">+			&quot;checksumSHA1&quot;: &quot;mktBVED98G2vv+OKcSgtnFVZC1Y=&quot;,
</a><a href="#h90-0-36" id="h90-0-36" class="i">+			&quot;path&quot;: &quot;golang.org/x/oauth2&quot;,
</a><a href="#h90-0-37" id="h90-0-37" class="i">+			&quot;revision&quot;: &quot;33fa30fe45020622640e947917fd1fc4c81e3dce&quot;,
</a><a href="#h90-0-38" id="h90-0-38" class="i">+			&quot;revisionTime&quot;: &quot;2016-03-25T17:08:19Z&quot;
</a><a href="#h90-0-39" id="h90-0-39" class="i">+		},
</a><a href="#h90-0-40" id="h90-0-40" class="i">+		{
</a><a href="#h90-0-41" id="h90-0-41" class="i">+			&quot;checksumSHA1&quot;: &quot;W/GiDqzsagBnR7/yEvxatMhUDBs=&quot;,
</a><a href="#h90-0-42" id="h90-0-42" class="i">+			&quot;path&quot;: &quot;golang.org/x/oauth2/internal&quot;,
</a><a href="#h90-0-43" id="h90-0-43" class="i">+			&quot;revision&quot;: &quot;33fa30fe45020622640e947917fd1fc4c81e3dce&quot;,
</a><a href="#h90-0-44" id="h90-0-44" class="i">+			&quot;revisionTime&quot;: &quot;2016-03-25T17:08:19Z&quot;
</a><a href="#h90-0-45" id="h90-0-45" class="i">+		},
</a><a href="#h90-0-46" id="h90-0-46" class="i">+		{
</a><a href="#h90-0-47" id="h90-0-47" class="i">+			&quot;checksumSHA1&quot;: &quot;I2d7Kn572Fz02mnnlcI4MHXCu0c=&quot;,
</a><a href="#h90-0-48" id="h90-0-48" class="i">+			&quot;path&quot;: &quot;gopkg.in/check.v1&quot;,
</a><a href="#h90-0-49" id="h90-0-49" class="i">+			&quot;revision&quot;: &quot;4f90aeace3a26ad7021961c297b22c42160c7b25&quot;,
</a><a href="#h90-0-50" id="h90-0-50" class="i">+			&quot;revisionTime&quot;: &quot;2016-01-05T16:49:36Z&quot;
</a><a href="#h90-0-51" id="h90-0-51" class="i">+		}
</a><a href="#h90-0-52" id="h90-0-52" class="i">+	],
</a><a href="#h90-0-53" id="h90-0-53" class="i">+	&quot;rootPath&quot;: &quot;github.com/livegrep/livegrep&quot;
</a><a href="#h90-0-54" id="h90-0-54" class="i">+}
</a></pre>
</div>
</body>
</html>
