package schema

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNewKey(t *testing.T) {
	t.Parallel()

	key, err := NewKey("key")

	assert.NoError(t, err)
	assert.Equal(t, "key", key.Key)
	assert.Equal(t, [8]byte{0xa0, 0xf8, 0x87, 0xf3, 0x1, 0x1d, 0x3e, 0xbc}, key.Salt)
}

func TestKeyMarshal(t *testing.T) {
	t.Parallel()

	key, _ := NewKey("key")
	keyb, err := key.MarshalBinary()

	assert.NoError(t, err)
	assert.Equal(t, []byte{0xa0, 0xf8, 0x87, 0xf3, 0x1, 0x1d, 0x3e, 0xbc, 0x6b, 0x65, 0x79}, keyb)
}

func TestKeyUnmarshal(t *testing.T) {
	t.Parallel()

	key := &Key{}
	err := key.UnmarshalBinary([]byte{0xa0, 0xf8, 0x87, 0xf3, 0x1, 0x1d, 0x3e, 0xbc, 0x6b, 0x65, 0x79})

	assert.NoError(t, err)
	assert.Equal(t, "key", key.Key)
	assert.Equal(t, [8]byte{0xa0, 0xf8, 0x87, 0xf3, 0x1, 0x1d, 0x3e, 0xbc}, key.Salt)
}

func TestNewValue(t *testing.T) {
	t.Parallel()

	value, err := NewValue(Simple, 1, 2, 3, []byte{4, 5, 6})

	assert.NoError(t, err)
	assert.Equal(t, Magic, value.Magic)
	assert.Equal(t, Version, value.Version)
	assert.Equal(t, Reserved, value.Reserved)
	assert.Equal(t, Simple, value.Kind)
	assert.Equal(t, uint16(1), value.Flags)
	assert.Equal(t, uint32(2), value.TTL)
	assert.Equal(t, uint64(3), value.CasUnique)
	assert.Equal(t, []byte{4, 5, 6}, value.Data)
}

func TestValueMarshal(t *testing.T) {
	t.Parallel()

	value, _ := NewValue(Simple, 1, 2, 3, []byte{4, 5, 6})
	valueb, err := value.MarshalBinary()

	assert.NoError(t, err)
	assert.Equal(t, Magic[:], valueb[:4])
	assert.Equal(t, []byte{0x00, 0x00, 0x00, 0x01}, valueb[4:8])
	assert.Equal(t, Reserved[:], valueb[8:12])
	assert.Equal(t, []byte{0x00, 0x01}, valueb[12:14])
	assert.Equal(t, []byte{0x00, 0x01}, valueb[14:16])
	assert.Equal(t, []byte{0x00, 0x00, 0x00, 0x02}, valueb[16:20])
	assert.Equal(t, []byte{0x00, 0x00, 0x00, 0x03}, valueb[20:24])
	assert.Equal(t, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03}, valueb[24:32])
	assert.Equal(t, []byte{0x04, 0x05, 0x06}, valueb[32:])
}

func TestValueUnmarshal(t *testing.T) {
	t.Parallel()

	value := &Value{}
	valueb := []byte{
		0x71, 0x60, 0xca, 0x8e, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1,
		0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x4,
		0x5, 0x6,
	}
	err := value.UnmarshalBinary(valueb)

	assert.NoError(t, err)
	assert.Equal(t, Magic, value.Magic)
	assert.Equal(t, Version, value.Version)
	assert.Equal(t, Reserved, value.Reserved)
	assert.Equal(t, Simple, value.Kind)
	assert.Equal(t, uint16(1), value.Flags)
	assert.Equal(t, uint32(2), value.TTL)
	assert.Equal(t, uint64(3), value.CasUnique)
	assert.Equal(t, []byte{4, 5, 6}, value.Data)
}

func TestValueUnmarshalError(t *testing.T) {
	t.Parallel()

	cases := []struct {
		value []byte
		err   error
	}{
		// Insufficient data length to accommodate header
		{
			value: []byte{0x71, 0x60, 0xca, 0x8e},
			err:   ErrShortData,
		},
		// Bad magic value
		{
			value: []byte{
				0x71, 0x60, 0xca, 0x8d, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x4, 0x5, 0x6,
			},
			err: ErrCorruptedData,
		},
		// Incompatible schema version
		{
			value: []byte{
				0x71, 0x60, 0xca, 0x8e, 0x0, 0x0, 0x0, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x4, 0x5, 0x6,
			},
			err: ErrIncompatibleVersion,
		},
		// Disagreement between reported size and data length
		{
			value: []byte{
				0x71, 0x60, 0xca, 0x8e, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x4, 0x5, 0x6,
			},
			err: ErrCorruptedData,
		},
	}

	for _, testCase := range cases {
		value := &Value{}
		err := value.UnmarshalBinary(testCase.value)

		assert.Error(t, err)
		assert.Equal(t, testCase.err, err)
	}
}
