package filters

import (
	"context"
	"net"
	"net/http"
	"os"

	"go.uber.org/zap"
	"lib.kevinlin.info/aperture/lib"

	"courier/internal/config"
	"courier/internal/meta"
	"courier/internal/middleware"
	"courier/internal/util"
)

const (
	// Client request headers
	headerForwardedFor = "X-Forwarded-For"
	// Proxy request headers
	headerHost           = "X-Courier-Host"
	headerClientIP       = "X-Courier-Client-IP"
	headerClientIdentity = "X-Courier-Client-Identity"
	// Client response headers
	headerVersion        = "X-Courier-Version"
	headerServerIdentity = "X-Courier-Server"
	headerDuration       = "X-Courier-Duration"
	headerServer         = "Server"
)

// metadataParams is the configuration descriptor for the metadata filter.
type metadataParams struct {
	DisableRequestHeaders  bool `yaml:"disable_request_headers"`
	DisableResponseHeaders bool `yaml:"disable_response_headers"`
}

// metadata adds useful metadata as headers in the proxied request and outgoing response.
type metadata struct {
	tags   map[string]string
	params *metadataParams
}

// NewMetadata creates a new metadata filter.
func NewMetadata(cfg *config.Filter) (middleware.Filter, error) {
	var params metadataParams

	if err := cfg.Params.Decode(&params); err != nil {
		return nil, &util.Error{
			Namespace:    "filters",
			Message:      "failed to parse metadata filter params",
			StackedError: err,
		}
	}

	tags := map[string]string{
		headerServer:  "courier",
		headerVersion: meta.Version,
	}

	if hostname, err := os.Hostname(); err == nil {
		tags[headerServerIdentity] = hostname
	}

	filter := &metadata{tags: tags, params: &params}

	return middleware.NewInstrumentedFilter("metadata", filter), nil
}

// ProcessRequest sets headers in the outgoing proxy request with pertinent client request metadata.
func (m *metadata) ProcessRequest(clientReq *http.Request) (*http.Request, *http.Response, error) {
	ctx := context.WithValue(clientReq.Context(), ctxMetadataStopwatch, lib.NewStopwatch())

	// First, strip any potential existing header values sent by mischievous clients seeking to
	// override the headers generated by the proxy
	clientReq.Header.Del(headerForwardedFor)
	clientReq.Header.Del(headerHost)
	clientReq.Header.Del(headerClientIP)
	clientReq.Header.Del(headerClientIdentity)

	if m.params.DisableRequestHeaders {
		return clientReq, nil, nil
	}

	clientReq.Header.Set(headerHost, clientReq.Host)

	clientIP, _, err := net.SplitHostPort(clientReq.RemoteAddr)
	if err != nil {
		if clientReq.RemoteAddr == "@" {
			clientIP = "@" // Special address for Unix socket transports
		} else {
			zap.L().Warn(
				"failed to parse client remote address",
				zap.String("address", clientReq.RemoteAddr),
				zap.Error(err),
			)
		}
	}

	clientReq.Header.Set(headerClientIP, clientIP)

	if clientReq.TLS != nil && len(clientReq.TLS.PeerCertificates) > 0 {
		for _, name := range clientReq.TLS.PeerCertificates[0].DNSNames {
			clientReq.Header.Add(headerClientIdentity, name)
		}
	}

	return clientReq.WithContext(ctx), nil, nil
}

// ProcessResponse adds Courier metadata as outgoing response headers.
func (m *metadata) ProcessResponse(proxyResp *http.Response) (*http.Response, error) {
	if m.params.DisableResponseHeaders || proxyResp.Header == nil {
		return proxyResp, nil
	}

	stopwatch := proxyResp.Request.Context().Value(ctxMetadataStopwatch).(*lib.Stopwatch)

	proxyResp.Header.Set(headerDuration, stopwatch.Elapsed().String())

	for tag, value := range m.tags {
		proxyResp.Header.Set(tag, value)
	}

	return proxyResp, nil
}
