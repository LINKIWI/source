<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Add honeycomb - livegrep - Fast, regular expression code search service</title>
<link rel="icon" type="image/png" href="https://static.kevinlin.info/favicon.png" />
<link rel="alternate" type="application/atom+xml" title="livegrep Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="livegrep Atom Feed (tags)" href="../tags.xml" />
<style type="text/css">
body {
	color: #000;
	background-color: #fff;
	font-family: monospace;
}

h1, h2, h3, h4, h5, h6 {
	font-size: 1em;
	margin: 0;
}

img, h1, h2 {
	vertical-align: middle;
}

img {
	border: 0;
}

a:target {
	background-color: #ccc;
}

a.d,
a.h,
a.i {
	text-decoration: none;
}

a.line {
	text-decoration: none;
	user-select: none;
}

#blob a {
	color: #555;
}

#blob a:hover {
	color: blue;
	text-decoration: none;
}

table thead td {
	font-weight: bold;
}

table td {
	padding: 0 0.4em;
}

#content table td {
	vertical-align: top;
	white-space: nowrap;
}

#branches tr:hover td,
#tags tr:hover td,
#index tr:hover td,
#log tr:hover td,
#files tr:hover td {
	background-color: #eee;
}

#index tr td:nth-child(2),
#tags tr td:nth-child(3),
#branches tr td:nth-child(3),
#log tr td:nth-child(2) {
	white-space: normal;
}

td.num {
	text-align: right;
}

.desc {
	color: #555;
}

hr {
	border: 0;
	border-top: 1px solid #555;
	height: 1px;
}

pre {
	font-family: monospace;
}

pre a.h {
	color: #00a;
}

.A,
span.i,
pre a.i {
	color: #070;
}

.D,
span.d,
pre a.d {
	color: #e00;
}

pre a.h:hover,
pre a.i:hover,
pre a.d:hover {
	text-decoration: none;
}
</style>
</head>
<body>
<table><tr><td><a href="../../"><img src="https://static.kevinlin.info/favicon.png" alt="" width="32" height="32" /></a></td><td><h1>livegrep</h1><span class="desc">Fast, regular expression code search service</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://source.static.kevinlin.info/external/livegrep.git">https://source.static.kevinlin.info/external/livegrep.git</a></td></tr><tr><td></td><td>
<a href="../log">Log</a> | <a href="../files">Files</a> | <a href="../refs">Refs</a> | <a href="../file/README.md">README</a> | <a href="../file/COPYING">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/21d71de6a4908c631f915a6b914dac847708ac9d">21d71de6a4908c631f915a6b914dac847708ac9d</a>
<b>parent</b> <a href="../commit/7a212d889b6a0ad3be0eff264e1df39eaf182fdd">7a212d889b6a0ad3be0eff264e1df39eaf182fdd</a>
<b>Author:</b> Nelson Elhage &lt;<a href="mailto:nelhage@nelhage.com">nelhage@nelhage.com</a>&gt;
<b>Date:</b>   Thu, 18 Aug 2016 20:06:28 -0700

Add honeycomb

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">WORKSPACE</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">server/BUILD</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">server/api.go</a></td><td> | </td><td class="num">26</td><td><span class="i">++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">server/config/config.go</a></td><td> | </td><td class="num">14</td><td><span class="i">++++++++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">server/server.go</a></td><td> | </td><td class="num">9</td><td><span class="i">+++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">tools/gen_build.go</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="A">A</td><td><a href="#h6">vendor/github.com/facebookgo/clock/BUILD</a></td><td> | </td><td class="num">18</td><td><span class="i">++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h7">vendor/github.com/facebookgo/clock/LICENSE</a></td><td> | </td><td class="num">21</td><td><span class="i">+++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h8">vendor/github.com/facebookgo/clock/README.md</a></td><td> | </td><td class="num">104</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h9">vendor/github.com/facebookgo/clock/clock.go</a></td><td> | </td><td class="num">363</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h10">vendor/github.com/facebookgo/limitgroup/BUILD</a></td><td> | </td><td class="num">18</td><td><span class="i">++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h11">vendor/github.com/facebookgo/limitgroup/license</a></td><td> | </td><td class="num">30</td><td><span class="i">++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h12">vendor/github.com/facebookgo/limitgroup/limitgroup.go</a></td><td> | </td><td class="num">65</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h13">vendor/github.com/facebookgo/limitgroup/patents</a></td><td> | </td><td class="num">33</td><td><span class="i">+++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h14">vendor/github.com/facebookgo/limitgroup/readme.md</a></td><td> | </td><td class="num">4</td><td><span class="i">++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h15">vendor/github.com/facebookgo/muster/BUILD</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h16">vendor/github.com/facebookgo/muster/license</a></td><td> | </td><td class="num">30</td><td><span class="i">++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h17">vendor/github.com/facebookgo/muster/muster.go</a></td><td> | </td><td class="num">175</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h18">vendor/github.com/facebookgo/muster/patents</a></td><td> | </td><td class="num">33</td><td><span class="i">+++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h19">vendor/github.com/facebookgo/muster/readme.md</a></td><td> | </td><td class="num">4</td><td><span class="i">++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h20">vendor/github.com/golang/protobuf/LICENSE</a></td><td> | </td><td class="num">31</td><td><span class="i">+++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h21">vendor/github.com/golang/protobuf/proto/BUILD</a></td><td> | </td><td class="num">28</td><td><span class="i">++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h22">vendor/github.com/golang/protobuf/proto/Makefile</a></td><td> | </td><td class="num">43</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h23">vendor/github.com/golang/protobuf/proto/clone.go</a></td><td> | </td><td class="num">229</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h24">vendor/github.com/golang/protobuf/proto/decode.go</a></td><td> | </td><td class="num">874</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h25">vendor/github.com/golang/protobuf/proto/encode.go</a></td><td> | </td><td class="num">1363</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h26">vendor/github.com/golang/protobuf/proto/equal.go</a></td><td> | </td><td class="num">296</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h27">vendor/github.com/golang/protobuf/proto/extensions.go</a></td><td> | </td><td class="num">586</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h28">vendor/github.com/golang/protobuf/proto/lib.go</a></td><td> | </td><td class="num">898</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h29">vendor/github.com/golang/protobuf/proto/message_set.go</a></td><td> | </td><td class="num">311</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h30">vendor/github.com/golang/protobuf/proto/pointer_reflect.go</a></td><td> | </td><td class="num">484</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h31">vendor/github.com/golang/protobuf/proto/pointer_unsafe.go</a></td><td> | </td><td class="num">270</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h32">vendor/github.com/golang/protobuf/proto/properties.go</a></td><td> | </td><td class="num">864</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h33">vendor/github.com/golang/protobuf/proto/text.go</a></td><td> | </td><td class="num">854</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h34">vendor/github.com/golang/protobuf/proto/text_parser.go</a></td><td> | </td><td class="num">891</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h35">vendor/github.com/honeycombio/libhoney-go/BUILD</a></td><td> | </td><td class="num">24</td><td><span class="i">++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h36">vendor/github.com/honeycombio/libhoney-go/CONTRIBUTORS</a></td><td> | </td><td class="num">8</td><td><span class="i">++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h37">vendor/github.com/honeycombio/libhoney-go/LICENSE</a></td><td> | </td><td class="num">201</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h38">vendor/github.com/honeycombio/libhoney-go/README.md</a></td><td> | </td><td class="num">29</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h39">vendor/github.com/honeycombio/libhoney-go/doc.go</a></td><td> | </td><td class="num">13</td><td><span class="i">+++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h40">vendor/github.com/honeycombio/libhoney-go/libhoney.go</a></td><td> | </td><td class="num">528</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h41">vendor/github.com/honeycombio/libhoney-go/response.go</a></td><td> | </td><td class="num">32</td><td><span class="i">++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h42">vendor/github.com/honeycombio/libhoney-go/test_helpers.go</a></td><td> | </td><td class="num">114</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h43">vendor/github.com/honeycombio/libhoney-go/transmission.go</a></td><td> | </td><td class="num">222</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h44">vendor/golang.org/x/net/context/BUILD</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="A">A</td><td><a href="#h45">vendor/google.golang.org/appengine/LICENSE</a></td><td> | </td><td class="num">202</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h46">vendor/google.golang.org/appengine/internal/BUILD</a></td><td> | </td><td class="num">33</td><td><span class="i">+++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h47">vendor/google.golang.org/appengine/internal/api.go</a></td><td> | </td><td class="num">646</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h48">vendor/google.golang.org/appengine/internal/api_classic.go</a></td><td> | </td><td class="num">159</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h49">vendor/google.golang.org/appengine/internal/api_common.go</a></td><td> | </td><td class="num">86</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h50">vendor/google.golang.org/appengine/internal/app_id.go</a></td><td> | </td><td class="num">28</td><td><span class="i">++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h51">vendor/google.golang.org/appengine/internal/base/BUILD</a></td><td> | </td><td class="num">19</td><td><span class="i">+++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h52">vendor/google.golang.org/appengine/internal/base/api_base.pb.go</a></td><td> | </td><td class="num">133</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h53">vendor/google.golang.org/appengine/internal/base/api_base.proto</a></td><td> | </td><td class="num">33</td><td><span class="i">+++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h54">vendor/google.golang.org/appengine/internal/datastore/BUILD</a></td><td> | </td><td class="num">19</td><td><span class="i">+++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h55">vendor/google.golang.org/appengine/internal/datastore/datastore_v3.pb.go</a></td><td> | </td><td class="num">2778</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h56">vendor/google.golang.org/appengine/internal/datastore/datastore_v3.proto</a></td><td> | </td><td class="num">541</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h57">vendor/google.golang.org/appengine/internal/identity.go</a></td><td> | </td><td class="num">14</td><td><span class="i">++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h58">vendor/google.golang.org/appengine/internal/identity_classic.go</a></td><td> | </td><td class="num">27</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h59">vendor/google.golang.org/appengine/internal/identity_vm.go</a></td><td> | </td><td class="num">97</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h60">vendor/google.golang.org/appengine/internal/internal.go</a></td><td> | </td><td class="num">110</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h61">vendor/google.golang.org/appengine/internal/log/BUILD</a></td><td> | </td><td class="num">19</td><td><span class="i">+++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h62">vendor/google.golang.org/appengine/internal/log/log_service.pb.go</a></td><td> | </td><td class="num">899</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h63">vendor/google.golang.org/appengine/internal/log/log_service.proto</a></td><td> | </td><td class="num">150</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h64">vendor/google.golang.org/appengine/internal/main.go</a></td><td> | </td><td class="num">15</td><td><span class="i">+++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h65">vendor/google.golang.org/appengine/internal/main_vm.go</a></td><td> | </td><td class="num">44</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h66">vendor/google.golang.org/appengine/internal/metadata.go</a></td><td> | </td><td class="num">61</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h67">vendor/google.golang.org/appengine/internal/net.go</a></td><td> | </td><td class="num">56</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h68">vendor/google.golang.org/appengine/internal/regen.sh</a></td><td> | </td><td class="num">40</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h69">vendor/google.golang.org/appengine/internal/remote_api/BUILD</a></td><td> | </td><td class="num">19</td><td><span class="i">+++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h70">vendor/google.golang.org/appengine/internal/remote_api/remote_api.pb.go</a></td><td> | </td><td class="num">231</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h71">vendor/google.golang.org/appengine/internal/remote_api/remote_api.proto</a></td><td> | </td><td class="num">44</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h72">vendor/google.golang.org/appengine/internal/transaction.go</a></td><td> | </td><td class="num">107</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h73">vendor/google.golang.org/appengine/internal/urlfetch/BUILD</a></td><td> | </td><td class="num">19</td><td><span class="i">+++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h74">vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.pb.go</a></td><td> | </td><td class="num">355</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h75">vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.proto</a></td><td> | </td><td class="num">64</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h76">vendor/google.golang.org/appengine/urlfetch/BUILD</a></td><td> | </td><td class="num">22</td><td><span class="i">++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h77">vendor/google.golang.org/appengine/urlfetch/urlfetch.go</a></td><td> | </td><td class="num">210</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h78">vendor/gopkg.in/alexcesaro/statsd.v2/BUILD</a></td><td> | </td><td class="num">21</td><td><span class="i">+++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h79">vendor/gopkg.in/alexcesaro/statsd.v2/CHANGELOG.md</a></td><td> | </td><td class="num">64</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h80">vendor/gopkg.in/alexcesaro/statsd.v2/LICENSE</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h81">vendor/gopkg.in/alexcesaro/statsd.v2/README.md</a></td><td> | </td><td class="num">50</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h82">vendor/gopkg.in/alexcesaro/statsd.v2/conn.go</a></td><td> | </td><td class="num">270</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h83">vendor/gopkg.in/alexcesaro/statsd.v2/doc.go</a></td><td> | </td><td class="num">29</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h84">vendor/gopkg.in/alexcesaro/statsd.v2/options.go</a></td><td> | </td><td class="num">250</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h85">vendor/gopkg.in/alexcesaro/statsd.v2/statsd.go</a></td><td> | </td><td class="num">169</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h86">vendor/vendor.json</a></td><td> | </td><td class="num">94</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
</table></pre><pre>87 files changed, 18407 insertions(+), 7 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/WORKSPACE">WORKSPACE</a> b/<a href="../file/WORKSPACE">WORKSPACE</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -70,7 +70,7 @@ new_patched_http_archive(
</a> git_repository(
     name = &quot;io_bazel_rules_go&quot;,
     remote = &quot;https://github.com/bazelbuild/rules_go.git&quot;,
<a href="#h0-0-3" id="h0-0-3" class="d">-    tag = &quot;0.0.4&quot;,
</a><a href="#h0-0-4" id="h0-0-4" class="i">+    commit = &quot;ae8ea32be1af991eef77d6347591dc8ba56c40a2&quot;,
</a> )
 load(&quot;@io_bazel_rules_go//go:def.bzl&quot;, &quot;go_repositories&quot;)
 
<b>diff --git a/<a id="h1" href="../file/server/BUILD">server/BUILD</a> b/<a href="../file/server/BUILD">server/BUILD</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -24,6 +24,7 @@ name = &quot;go_default_library&quot;,
</a>     &quot;//server/reqid:go_default_library&quot;,
     &quot;//server/templates:go_default_library&quot;,
     &quot;//vendor/github.com/bmizerany/pat:go_default_library&quot;,
<a href="#h1-0-3" id="h1-0-3" class="i">+    &quot;//vendor/github.com/honeycombio/libhoney-go:go_default_library&quot;,
</a>     &quot;//vendor/golang.org/x/net/context:go_default_library&quot;,
   ],
   visibility = [&quot;//visibility:public&quot;],
<b>diff --git a/<a id="h2" href="../file/server/api.go">server/api.go</a> b/<a href="../file/server/api.go">server/api.go</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -11,6 +11,7 @@ import (
</a> 	&quot;github.com/livegrep/livegrep/client&quot;
 	&quot;github.com/livegrep/livegrep/server/api&quot;
 	&quot;github.com/livegrep/livegrep/server/log&quot;
<a href="#h2-0-3" id="h2-0-3" class="i">+	&quot;github.com/livegrep/livegrep/server/reqid&quot;
</a> )
 
 func replyJSON(ctx context.Context, w http.ResponseWriter, status int, obj interface{}) {
<a href="#h2-1" id="h2-1" class="h">@@ -150,6 +151,31 @@ func (s *server) ServeAPISearch(ctx context.Context, w http.ResponseWriter, r *h
</a> 		return
 	}
 
<a href="#h2-1-3" id="h2-1-3" class="i">+	if s.honey != nil {
</a><a href="#h2-1-4" id="h2-1-4" class="i">+		e := s.honey.NewEvent()
</a><a href="#h2-1-5" id="h2-1-5" class="i">+		reqid, ok := reqid.FromContext(ctx)
</a><a href="#h2-1-6" id="h2-1-6" class="i">+		if ok {
</a><a href="#h2-1-7" id="h2-1-7" class="i">+			e.AddField(&quot;request_id&quot;, reqid)
</a><a href="#h2-1-8" id="h2-1-8" class="i">+		}
</a><a href="#h2-1-9" id="h2-1-9" class="i">+		e.AddField(&quot;backend&quot;, backend.Id)
</a><a href="#h2-1-10" id="h2-1-10" class="i">+		e.AddField(&quot;query_line&quot;, q.Line)
</a><a href="#h2-1-11" id="h2-1-11" class="i">+		e.AddField(&quot;query_file&quot;, q.File)
</a><a href="#h2-1-12" id="h2-1-12" class="i">+		e.AddField(&quot;query_repo&quot;, q.Repo)
</a><a href="#h2-1-13" id="h2-1-13" class="i">+		e.AddField(&quot;query_foldcase&quot;, q.FoldCase)
</a><a href="#h2-1-14" id="h2-1-14" class="i">+		e.AddField(&quot;query_not_file&quot;, q.Not.File)
</a><a href="#h2-1-15" id="h2-1-15" class="i">+		e.AddField(&quot;query_not_repo&quot;, q.Not.Repo)
</a><a href="#h2-1-16" id="h2-1-16" class="i">+
</a><a href="#h2-1-17" id="h2-1-17" class="i">+		e.AddField(&quot;result_count&quot;, len(reply.Results))
</a><a href="#h2-1-18" id="h2-1-18" class="i">+		e.AddField(&quot;re2_time&quot;, reply.Info.RE2Time)
</a><a href="#h2-1-19" id="h2-1-19" class="i">+		e.AddField(&quot;git_time&quot;, reply.Info.GitTime)
</a><a href="#h2-1-20" id="h2-1-20" class="i">+		e.AddField(&quot;sort_time&quot;, reply.Info.SortTime)
</a><a href="#h2-1-21" id="h2-1-21" class="i">+		e.AddField(&quot;index_time&quot;, reply.Info.IndexTime)
</a><a href="#h2-1-22" id="h2-1-22" class="i">+		e.AddField(&quot;analyze_time&quot;, reply.Info.AnalyzeTime)
</a><a href="#h2-1-23" id="h2-1-23" class="i">+
</a><a href="#h2-1-24" id="h2-1-24" class="i">+		e.AddField(&quot;exit_reason&quot;, reply.Info.ExitReason)
</a><a href="#h2-1-25" id="h2-1-25" class="i">+		e.Send()
</a><a href="#h2-1-26" id="h2-1-26" class="i">+	}
</a><a href="#h2-1-27" id="h2-1-27" class="i">+
</a> 	log.Printf(ctx,
 		&quot;responding success results=%d why=%s stats=%s&quot;,
 		len(reply.Results),
<b>diff --git a/<a id="h3" href="../file/server/config/config.go">server/config/config.go</a> b/<a href="../file/server/config/config.go">server/config/config.go</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,7 +1,7 @@
</a> package config
 
 import (
<a href="#h3-0-3" id="h3-0-3" class="d">-  &quot;html/template&quot;
</a><a href="#h3-0-4" id="h3-0-4" class="i">+	&quot;html/template&quot;
</a> )
 
 type Backend struct {
<a href="#h3-1" id="h3-1" class="h">@@ -31,9 +31,9 @@ type Config struct {
</a> 	// The address to listen on, as HOST:PORT.
 	Listen string `json:&quot;listen&quot;`
 
<a href="#h3-1-3" id="h3-1-3" class="d">-        // HTML injected into layout template
</a><a href="#h3-1-4" id="h3-1-4" class="d">-        // for site-specific customizations
</a><a href="#h3-1-5" id="h3-1-5" class="d">-        HeaderHTML template.HTML `json:&quot;header_html&quot;`
</a><a href="#h3-1-6" id="h3-1-6" class="i">+	// HTML injected into layout template
</a><a href="#h3-1-7" id="h3-1-7" class="i">+	// for site-specific customizations
</a><a href="#h3-1-8" id="h3-1-8" class="i">+	HeaderHTML template.HTML `json:&quot;header_html&quot;`
</a> 
 	Sentry struct {
 		URI string `json:&quot;uri&quot;`
<a href="#h3-2" id="h3-2" class="h">@@ -41,4 +41,10 @@ type Config struct {
</a> 
 	// Whether to re-load templates on every request
 	Reload bool `json:&quot;reload&quot;`
<a href="#h3-2-3" id="h3-2-3" class="i">+
</a><a href="#h3-2-4" id="h3-2-4" class="i">+	// honeycomb API write key
</a><a href="#h3-2-5" id="h3-2-5" class="i">+	Honeycomb struct {
</a><a href="#h3-2-6" id="h3-2-6" class="i">+		WriteKey string `json:&quot;write_key&quot;`
</a><a href="#h3-2-7" id="h3-2-7" class="i">+		Dataset  string `json:&quot;dataset&quot;`
</a><a href="#h3-2-8" id="h3-2-8" class="i">+	} `json:&quot;honeycomb&quot;`
</a> }
<b>diff --git a/<a id="h4" href="../file/server/server.go">server/server.go</a> b/<a href="../file/server/server.go">server/server.go</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -12,6 +12,7 @@ import (
</a> 	&quot;golang.org/x/net/context&quot;
 
 	&quot;github.com/bmizerany/pat&quot;
<a href="#h4-0-3" id="h4-0-3" class="i">+	libhoney &quot;github.com/honeycombio/libhoney-go&quot;
</a> 
 	&quot;github.com/livegrep/livegrep/client&quot;
 	&quot;github.com/livegrep/livegrep/server/config&quot;
<a href="#h4-1" id="h4-1" class="h">@@ -34,6 +35,8 @@ type server struct {
</a> 	inner  http.Handler
 	T      Templates
 	Layout *template.Template
<a href="#h4-1-3" id="h4-1-3" class="i">+
</a><a href="#h4-1-4" id="h4-1-4" class="i">+	honey *libhoney.Builder
</a> }
 
 func (s *server) loadTemplates() {
<a href="#h4-2" id="h4-2" class="h">@@ -172,6 +175,12 @@ func New(cfg *config.Config) (http.Handler, error) {
</a> 	srv := &amp;server{config: cfg, bk: make(map[string]*Backend)}
 	srv.loadTemplates()
 
<a href="#h4-2-3" id="h4-2-3" class="i">+	if cfg.Honeycomb.WriteKey != &quot;&quot; {
</a><a href="#h4-2-4" id="h4-2-4" class="i">+		srv.honey = libhoney.NewBuilder()
</a><a href="#h4-2-5" id="h4-2-5" class="i">+		srv.honey.WriteKey = cfg.Honeycomb.WriteKey
</a><a href="#h4-2-6" id="h4-2-6" class="i">+		srv.honey.Dataset = cfg.Honeycomb.Dataset
</a><a href="#h4-2-7" id="h4-2-7" class="i">+	}
</a><a href="#h4-2-8" id="h4-2-8" class="i">+
</a> 	for _, bk := range srv.config.Backends {
 		addr := bk.Addr
 		be := &amp;Backend{
<b>diff --git a/<a id="h5" href="../file/tools/gen_build.go">tools/gen_build.go</a> b/<a href="../file/tools/gen_build.go">tools/gen_build.go</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -55,7 +55,7 @@ func main() {
</a> 
 	for _, d := range dirs {
 		if e := genBuild(&amp;ctx, d); e != nil {
<a href="#h5-0-3" id="h5-0-3" class="d">-			fmt.Print(&quot;!&quot;, e)
</a><a href="#h5-0-4" id="h5-0-4" class="i">+			fmt.Printf(&quot;[%s]: %v&quot;, d, e)
</a> 		}
 	}
 }
<b>diff --git a/<a id="h6" href="../file/vendor/github.com/facebookgo/clock/BUILD">vendor/github.com/facebookgo/clock/BUILD</a> b/<a href="../file/vendor/github.com/facebookgo/clock/BUILD">vendor/github.com/facebookgo/clock/BUILD</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -0,0 +1,18 @@
</a><a href="#h6-0-0" id="h6-0-0" class="i">+
</a><a href="#h6-0-1" id="h6-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h6-0-2" id="h6-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h6-0-3" id="h6-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h6-0-4" id="h6-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h6-0-5" id="h6-0-5" class="i">+)
</a><a href="#h6-0-6" id="h6-0-6" class="i">+
</a><a href="#h6-0-7" id="h6-0-7" class="i">+go_library(
</a><a href="#h6-0-8" id="h6-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h6-0-9" id="h6-0-9" class="i">+  srcs = [
</a><a href="#h6-0-10" id="h6-0-10" class="i">+    &quot;clock.go&quot;,
</a><a href="#h6-0-11" id="h6-0-11" class="i">+  ],
</a><a href="#h6-0-12" id="h6-0-12" class="i">+  deps = [
</a><a href="#h6-0-13" id="h6-0-13" class="i">+  ],
</a><a href="#h6-0-14" id="h6-0-14" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h6-0-15" id="h6-0-15" class="i">+)
</a><a href="#h6-0-16" id="h6-0-16" class="i">+
</a><a href="#h6-0-17" id="h6-0-17" class="i">+
</a><b>diff --git a/<a id="h7" href="../file/vendor/github.com/facebookgo/clock/LICENSE">vendor/github.com/facebookgo/clock/LICENSE</a> b/<a href="../file/vendor/github.com/facebookgo/clock/LICENSE">vendor/github.com/facebookgo/clock/LICENSE</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -0,0 +1,21 @@
</a><a href="#h7-0-0" id="h7-0-0" class="i">+The MIT License (MIT)
</a><a href="#h7-0-1" id="h7-0-1" class="i">+
</a><a href="#h7-0-2" id="h7-0-2" class="i">+Copyright (c) 2014 Ben Johnson
</a><a href="#h7-0-3" id="h7-0-3" class="i">+
</a><a href="#h7-0-4" id="h7-0-4" class="i">+Permission is hereby granted, free of charge, to any person obtaining a copy
</a><a href="#h7-0-5" id="h7-0-5" class="i">+of this software and associated documentation files (the &quot;Software&quot;), to deal
</a><a href="#h7-0-6" id="h7-0-6" class="i">+in the Software without restriction, including without limitation the rights
</a><a href="#h7-0-7" id="h7-0-7" class="i">+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
</a><a href="#h7-0-8" id="h7-0-8" class="i">+copies of the Software, and to permit persons to whom the Software is
</a><a href="#h7-0-9" id="h7-0-9" class="i">+furnished to do so, subject to the following conditions:
</a><a href="#h7-0-10" id="h7-0-10" class="i">+
</a><a href="#h7-0-11" id="h7-0-11" class="i">+The above copyright notice and this permission notice shall be included in all
</a><a href="#h7-0-12" id="h7-0-12" class="i">+copies or substantial portions of the Software.
</a><a href="#h7-0-13" id="h7-0-13" class="i">+
</a><a href="#h7-0-14" id="h7-0-14" class="i">+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
</a><a href="#h7-0-15" id="h7-0-15" class="i">+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</a><a href="#h7-0-16" id="h7-0-16" class="i">+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
</a><a href="#h7-0-17" id="h7-0-17" class="i">+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
</a><a href="#h7-0-18" id="h7-0-18" class="i">+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
</a><a href="#h7-0-19" id="h7-0-19" class="i">+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
</a><a href="#h7-0-20" id="h7-0-20" class="i">+SOFTWARE.
</a><b>diff --git a/<a id="h8" href="../file/vendor/github.com/facebookgo/clock/README.md">vendor/github.com/facebookgo/clock/README.md</a> b/<a href="../file/vendor/github.com/facebookgo/clock/README.md">vendor/github.com/facebookgo/clock/README.md</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -0,0 +1,104 @@
</a><a href="#h8-0-0" id="h8-0-0" class="i">+clock [![Build Status](https://drone.io/github.com/benbjohnson/clock/status.png)](https://drone.io/github.com/benbjohnson/clock/latest) [![Coverage Status](https://coveralls.io/repos/benbjohnson/clock/badge.png?branch=master)](https://coveralls.io/r/benbjohnson/clock?branch=master) [![GoDoc](https://godoc.org/github.com/benbjohnson/clock?status.png)](https://godoc.org/github.com/benbjohnson/clock) ![Project status](http://img.shields.io/status/experimental.png?color=red)
</a><a href="#h8-0-1" id="h8-0-1" class="i">+=====
</a><a href="#h8-0-2" id="h8-0-2" class="i">+
</a><a href="#h8-0-3" id="h8-0-3" class="i">+Clock is a small library for mocking time in Go. It provides an interface
</a><a href="#h8-0-4" id="h8-0-4" class="i">+around the standard library&#39;s [`time`][time] package so that the application
</a><a href="#h8-0-5" id="h8-0-5" class="i">+can use the realtime clock while tests can use the mock clock.
</a><a href="#h8-0-6" id="h8-0-6" class="i">+
</a><a href="#h8-0-7" id="h8-0-7" class="i">+[time]: http://golang.org/pkg/time/
</a><a href="#h8-0-8" id="h8-0-8" class="i">+
</a><a href="#h8-0-9" id="h8-0-9" class="i">+
</a><a href="#h8-0-10" id="h8-0-10" class="i">+## Usage
</a><a href="#h8-0-11" id="h8-0-11" class="i">+
</a><a href="#h8-0-12" id="h8-0-12" class="i">+### Realtime Clock
</a><a href="#h8-0-13" id="h8-0-13" class="i">+
</a><a href="#h8-0-14" id="h8-0-14" class="i">+Your application can maintain a `Clock` variable that will allow realtime and
</a><a href="#h8-0-15" id="h8-0-15" class="i">+mock clocks to be interchangable. For example, if you had an `Application` type:
</a><a href="#h8-0-16" id="h8-0-16" class="i">+
</a><a href="#h8-0-17" id="h8-0-17" class="i">+```go
</a><a href="#h8-0-18" id="h8-0-18" class="i">+import &quot;github.com/benbjohnson/clock&quot;
</a><a href="#h8-0-19" id="h8-0-19" class="i">+
</a><a href="#h8-0-20" id="h8-0-20" class="i">+type Application struct {
</a><a href="#h8-0-21" id="h8-0-21" class="i">+	Clock clock.Clock
</a><a href="#h8-0-22" id="h8-0-22" class="i">+}
</a><a href="#h8-0-23" id="h8-0-23" class="i">+```
</a><a href="#h8-0-24" id="h8-0-24" class="i">+
</a><a href="#h8-0-25" id="h8-0-25" class="i">+You could initialize it to use the realtime clock like this:
</a><a href="#h8-0-26" id="h8-0-26" class="i">+
</a><a href="#h8-0-27" id="h8-0-27" class="i">+```go
</a><a href="#h8-0-28" id="h8-0-28" class="i">+var app Application
</a><a href="#h8-0-29" id="h8-0-29" class="i">+app.Clock = clock.New()
</a><a href="#h8-0-30" id="h8-0-30" class="i">+...
</a><a href="#h8-0-31" id="h8-0-31" class="i">+```
</a><a href="#h8-0-32" id="h8-0-32" class="i">+
</a><a href="#h8-0-33" id="h8-0-33" class="i">+Then all timers and time-related functionality should be performed from the
</a><a href="#h8-0-34" id="h8-0-34" class="i">+`Clock` variable.
</a><a href="#h8-0-35" id="h8-0-35" class="i">+
</a><a href="#h8-0-36" id="h8-0-36" class="i">+
</a><a href="#h8-0-37" id="h8-0-37" class="i">+### Mocking time
</a><a href="#h8-0-38" id="h8-0-38" class="i">+
</a><a href="#h8-0-39" id="h8-0-39" class="i">+In your tests, you will want to use a `Mock` clock:
</a><a href="#h8-0-40" id="h8-0-40" class="i">+
</a><a href="#h8-0-41" id="h8-0-41" class="i">+```go
</a><a href="#h8-0-42" id="h8-0-42" class="i">+import (
</a><a href="#h8-0-43" id="h8-0-43" class="i">+	&quot;testing&quot;
</a><a href="#h8-0-44" id="h8-0-44" class="i">+
</a><a href="#h8-0-45" id="h8-0-45" class="i">+	&quot;github.com/benbjohnson/clock&quot;
</a><a href="#h8-0-46" id="h8-0-46" class="i">+)
</a><a href="#h8-0-47" id="h8-0-47" class="i">+
</a><a href="#h8-0-48" id="h8-0-48" class="i">+func TestApplication_DoSomething(t *testing.T) {
</a><a href="#h8-0-49" id="h8-0-49" class="i">+	mock := clock.NewMock()
</a><a href="#h8-0-50" id="h8-0-50" class="i">+	app := Application{Clock: mock}
</a><a href="#h8-0-51" id="h8-0-51" class="i">+	...
</a><a href="#h8-0-52" id="h8-0-52" class="i">+}
</a><a href="#h8-0-53" id="h8-0-53" class="i">+```
</a><a href="#h8-0-54" id="h8-0-54" class="i">+
</a><a href="#h8-0-55" id="h8-0-55" class="i">+Now that you&#39;ve initialized your application to use the mock clock, you can
</a><a href="#h8-0-56" id="h8-0-56" class="i">+adjust the time programmatically. The mock clock always starts from the Unix
</a><a href="#h8-0-57" id="h8-0-57" class="i">+epoch (midnight, Jan 1, 1970 UTC).
</a><a href="#h8-0-58" id="h8-0-58" class="i">+
</a><a href="#h8-0-59" id="h8-0-59" class="i">+
</a><a href="#h8-0-60" id="h8-0-60" class="i">+### Controlling time
</a><a href="#h8-0-61" id="h8-0-61" class="i">+
</a><a href="#h8-0-62" id="h8-0-62" class="i">+The mock clock provides the same functions that the standard library&#39;s `time`
</a><a href="#h8-0-63" id="h8-0-63" class="i">+package provides. For example, to find the current time, you use the `Now()`
</a><a href="#h8-0-64" id="h8-0-64" class="i">+function:
</a><a href="#h8-0-65" id="h8-0-65" class="i">+
</a><a href="#h8-0-66" id="h8-0-66" class="i">+```go
</a><a href="#h8-0-67" id="h8-0-67" class="i">+mock := clock.NewMock()
</a><a href="#h8-0-68" id="h8-0-68" class="i">+
</a><a href="#h8-0-69" id="h8-0-69" class="i">+// Find the current time.
</a><a href="#h8-0-70" id="h8-0-70" class="i">+mock.Now().UTC() // 1970-01-01 00:00:00 +0000 UTC
</a><a href="#h8-0-71" id="h8-0-71" class="i">+
</a><a href="#h8-0-72" id="h8-0-72" class="i">+// Move the clock forward.
</a><a href="#h8-0-73" id="h8-0-73" class="i">+mock.Add(2 * time.Hour)
</a><a href="#h8-0-74" id="h8-0-74" class="i">+
</a><a href="#h8-0-75" id="h8-0-75" class="i">+// Check the time again. It&#39;s 2 hours later!
</a><a href="#h8-0-76" id="h8-0-76" class="i">+mock.Now().UTC() // 1970-01-01 02:00:00 +0000 UTC
</a><a href="#h8-0-77" id="h8-0-77" class="i">+```
</a><a href="#h8-0-78" id="h8-0-78" class="i">+
</a><a href="#h8-0-79" id="h8-0-79" class="i">+Timers and Tickers are also controlled by this same mock clock. They will only
</a><a href="#h8-0-80" id="h8-0-80" class="i">+execute when the clock is moved forward:
</a><a href="#h8-0-81" id="h8-0-81" class="i">+
</a><a href="#h8-0-82" id="h8-0-82" class="i">+```
</a><a href="#h8-0-83" id="h8-0-83" class="i">+mock := clock.NewMock()
</a><a href="#h8-0-84" id="h8-0-84" class="i">+count := 0
</a><a href="#h8-0-85" id="h8-0-85" class="i">+
</a><a href="#h8-0-86" id="h8-0-86" class="i">+// Kick off a timer to increment every 1 mock second.
</a><a href="#h8-0-87" id="h8-0-87" class="i">+go func() {
</a><a href="#h8-0-88" id="h8-0-88" class="i">+    ticker := clock.Ticker(1 * time.Second)
</a><a href="#h8-0-89" id="h8-0-89" class="i">+    for {
</a><a href="#h8-0-90" id="h8-0-90" class="i">+        &lt;-ticker.C
</a><a href="#h8-0-91" id="h8-0-91" class="i">+        count++
</a><a href="#h8-0-92" id="h8-0-92" class="i">+    }
</a><a href="#h8-0-93" id="h8-0-93" class="i">+}()
</a><a href="#h8-0-94" id="h8-0-94" class="i">+runtime.Gosched()
</a><a href="#h8-0-95" id="h8-0-95" class="i">+
</a><a href="#h8-0-96" id="h8-0-96" class="i">+// Move the clock forward 10 second.
</a><a href="#h8-0-97" id="h8-0-97" class="i">+mock.Add(10 * time.Second)
</a><a href="#h8-0-98" id="h8-0-98" class="i">+
</a><a href="#h8-0-99" id="h8-0-99" class="i">+// This prints 10.
</a><a href="#h8-0-100" id="h8-0-100" class="i">+fmt.Println(count)
</a><a href="#h8-0-101" id="h8-0-101" class="i">+```
</a><a href="#h8-0-102" id="h8-0-102" class="i">+
</a><a href="#h8-0-103" id="h8-0-103" class="i">+
</a><b>diff --git a/<a id="h9" href="../file/vendor/github.com/facebookgo/clock/clock.go">vendor/github.com/facebookgo/clock/clock.go</a> b/<a href="../file/vendor/github.com/facebookgo/clock/clock.go">vendor/github.com/facebookgo/clock/clock.go</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -0,0 +1,363 @@
</a><a href="#h9-0-0" id="h9-0-0" class="i">+package clock
</a><a href="#h9-0-1" id="h9-0-1" class="i">+
</a><a href="#h9-0-2" id="h9-0-2" class="i">+import (
</a><a href="#h9-0-3" id="h9-0-3" class="i">+	&quot;runtime&quot;
</a><a href="#h9-0-4" id="h9-0-4" class="i">+	&quot;sort&quot;
</a><a href="#h9-0-5" id="h9-0-5" class="i">+	&quot;sync&quot;
</a><a href="#h9-0-6" id="h9-0-6" class="i">+	&quot;time&quot;
</a><a href="#h9-0-7" id="h9-0-7" class="i">+)
</a><a href="#h9-0-8" id="h9-0-8" class="i">+
</a><a href="#h9-0-9" id="h9-0-9" class="i">+// Clock represents an interface to the functions in the standard library time
</a><a href="#h9-0-10" id="h9-0-10" class="i">+// package. Two implementations are available in the clock package. The first
</a><a href="#h9-0-11" id="h9-0-11" class="i">+// is a real-time clock which simply wraps the time package&#39;s functions. The
</a><a href="#h9-0-12" id="h9-0-12" class="i">+// second is a mock clock which will only make forward progress when
</a><a href="#h9-0-13" id="h9-0-13" class="i">+// programmatically adjusted.
</a><a href="#h9-0-14" id="h9-0-14" class="i">+type Clock interface {
</a><a href="#h9-0-15" id="h9-0-15" class="i">+	After(d time.Duration) &lt;-chan time.Time
</a><a href="#h9-0-16" id="h9-0-16" class="i">+	AfterFunc(d time.Duration, f func()) *Timer
</a><a href="#h9-0-17" id="h9-0-17" class="i">+	Now() time.Time
</a><a href="#h9-0-18" id="h9-0-18" class="i">+	Sleep(d time.Duration)
</a><a href="#h9-0-19" id="h9-0-19" class="i">+	Tick(d time.Duration) &lt;-chan time.Time
</a><a href="#h9-0-20" id="h9-0-20" class="i">+	Ticker(d time.Duration) *Ticker
</a><a href="#h9-0-21" id="h9-0-21" class="i">+	Timer(d time.Duration) *Timer
</a><a href="#h9-0-22" id="h9-0-22" class="i">+}
</a><a href="#h9-0-23" id="h9-0-23" class="i">+
</a><a href="#h9-0-24" id="h9-0-24" class="i">+// New returns an instance of a real-time clock.
</a><a href="#h9-0-25" id="h9-0-25" class="i">+func New() Clock {
</a><a href="#h9-0-26" id="h9-0-26" class="i">+	return &amp;clock{}
</a><a href="#h9-0-27" id="h9-0-27" class="i">+}
</a><a href="#h9-0-28" id="h9-0-28" class="i">+
</a><a href="#h9-0-29" id="h9-0-29" class="i">+// clock implements a real-time clock by simply wrapping the time package functions.
</a><a href="#h9-0-30" id="h9-0-30" class="i">+type clock struct{}
</a><a href="#h9-0-31" id="h9-0-31" class="i">+
</a><a href="#h9-0-32" id="h9-0-32" class="i">+func (c *clock) After(d time.Duration) &lt;-chan time.Time { return time.After(d) }
</a><a href="#h9-0-33" id="h9-0-33" class="i">+
</a><a href="#h9-0-34" id="h9-0-34" class="i">+func (c *clock) AfterFunc(d time.Duration, f func()) *Timer {
</a><a href="#h9-0-35" id="h9-0-35" class="i">+	return &amp;Timer{timer: time.AfterFunc(d, f)}
</a><a href="#h9-0-36" id="h9-0-36" class="i">+}
</a><a href="#h9-0-37" id="h9-0-37" class="i">+
</a><a href="#h9-0-38" id="h9-0-38" class="i">+func (c *clock) Now() time.Time { return time.Now() }
</a><a href="#h9-0-39" id="h9-0-39" class="i">+
</a><a href="#h9-0-40" id="h9-0-40" class="i">+func (c *clock) Sleep(d time.Duration) { time.Sleep(d) }
</a><a href="#h9-0-41" id="h9-0-41" class="i">+
</a><a href="#h9-0-42" id="h9-0-42" class="i">+func (c *clock) Tick(d time.Duration) &lt;-chan time.Time { return time.Tick(d) }
</a><a href="#h9-0-43" id="h9-0-43" class="i">+
</a><a href="#h9-0-44" id="h9-0-44" class="i">+func (c *clock) Ticker(d time.Duration) *Ticker {
</a><a href="#h9-0-45" id="h9-0-45" class="i">+	t := time.NewTicker(d)
</a><a href="#h9-0-46" id="h9-0-46" class="i">+	return &amp;Ticker{C: t.C, ticker: t}
</a><a href="#h9-0-47" id="h9-0-47" class="i">+}
</a><a href="#h9-0-48" id="h9-0-48" class="i">+
</a><a href="#h9-0-49" id="h9-0-49" class="i">+func (c *clock) Timer(d time.Duration) *Timer {
</a><a href="#h9-0-50" id="h9-0-50" class="i">+	t := time.NewTimer(d)
</a><a href="#h9-0-51" id="h9-0-51" class="i">+	return &amp;Timer{C: t.C, timer: t}
</a><a href="#h9-0-52" id="h9-0-52" class="i">+}
</a><a href="#h9-0-53" id="h9-0-53" class="i">+
</a><a href="#h9-0-54" id="h9-0-54" class="i">+// Mock represents a mock clock that only moves forward programmically.
</a><a href="#h9-0-55" id="h9-0-55" class="i">+// It can be preferable to a real-time clock when testing time-based functionality.
</a><a href="#h9-0-56" id="h9-0-56" class="i">+type Mock struct {
</a><a href="#h9-0-57" id="h9-0-57" class="i">+	mu     sync.Mutex
</a><a href="#h9-0-58" id="h9-0-58" class="i">+	now    time.Time   // current time
</a><a href="#h9-0-59" id="h9-0-59" class="i">+	timers clockTimers // tickers &amp; timers
</a><a href="#h9-0-60" id="h9-0-60" class="i">+
</a><a href="#h9-0-61" id="h9-0-61" class="i">+	calls      Calls
</a><a href="#h9-0-62" id="h9-0-62" class="i">+	waiting    []waiting
</a><a href="#h9-0-63" id="h9-0-63" class="i">+	callsMutex sync.Mutex
</a><a href="#h9-0-64" id="h9-0-64" class="i">+}
</a><a href="#h9-0-65" id="h9-0-65" class="i">+
</a><a href="#h9-0-66" id="h9-0-66" class="i">+// NewMock returns an instance of a mock clock.
</a><a href="#h9-0-67" id="h9-0-67" class="i">+// The current time of the mock clock on initialization is the Unix epoch.
</a><a href="#h9-0-68" id="h9-0-68" class="i">+func NewMock() *Mock {
</a><a href="#h9-0-69" id="h9-0-69" class="i">+	return &amp;Mock{now: time.Unix(0, 0)}
</a><a href="#h9-0-70" id="h9-0-70" class="i">+}
</a><a href="#h9-0-71" id="h9-0-71" class="i">+
</a><a href="#h9-0-72" id="h9-0-72" class="i">+// Add moves the current time of the mock clock forward by the duration.
</a><a href="#h9-0-73" id="h9-0-73" class="i">+// This should only be called from a single goroutine at a time.
</a><a href="#h9-0-74" id="h9-0-74" class="i">+func (m *Mock) Add(d time.Duration) {
</a><a href="#h9-0-75" id="h9-0-75" class="i">+	// Calculate the final current time.
</a><a href="#h9-0-76" id="h9-0-76" class="i">+	t := m.now.Add(d)
</a><a href="#h9-0-77" id="h9-0-77" class="i">+
</a><a href="#h9-0-78" id="h9-0-78" class="i">+	// Continue to execute timers until there are no more before the new time.
</a><a href="#h9-0-79" id="h9-0-79" class="i">+	for {
</a><a href="#h9-0-80" id="h9-0-80" class="i">+		if !m.runNextTimer(t) {
</a><a href="#h9-0-81" id="h9-0-81" class="i">+			break
</a><a href="#h9-0-82" id="h9-0-82" class="i">+		}
</a><a href="#h9-0-83" id="h9-0-83" class="i">+	}
</a><a href="#h9-0-84" id="h9-0-84" class="i">+
</a><a href="#h9-0-85" id="h9-0-85" class="i">+	// Ensure that we end with the new time.
</a><a href="#h9-0-86" id="h9-0-86" class="i">+	m.mu.Lock()
</a><a href="#h9-0-87" id="h9-0-87" class="i">+	m.now = t
</a><a href="#h9-0-88" id="h9-0-88" class="i">+	m.mu.Unlock()
</a><a href="#h9-0-89" id="h9-0-89" class="i">+
</a><a href="#h9-0-90" id="h9-0-90" class="i">+	// Give a small buffer to make sure the other goroutines get handled.
</a><a href="#h9-0-91" id="h9-0-91" class="i">+	gosched()
</a><a href="#h9-0-92" id="h9-0-92" class="i">+}
</a><a href="#h9-0-93" id="h9-0-93" class="i">+
</a><a href="#h9-0-94" id="h9-0-94" class="i">+// runNextTimer executes the next timer in chronological order and moves the
</a><a href="#h9-0-95" id="h9-0-95" class="i">+// current time to the timer&#39;s next tick time. The next time is not executed if
</a><a href="#h9-0-96" id="h9-0-96" class="i">+// it&#39;s next time if after the max time. Returns true if a timer is executed.
</a><a href="#h9-0-97" id="h9-0-97" class="i">+func (m *Mock) runNextTimer(max time.Time) bool {
</a><a href="#h9-0-98" id="h9-0-98" class="i">+	m.mu.Lock()
</a><a href="#h9-0-99" id="h9-0-99" class="i">+
</a><a href="#h9-0-100" id="h9-0-100" class="i">+	// Sort timers by time.
</a><a href="#h9-0-101" id="h9-0-101" class="i">+	sort.Sort(m.timers)
</a><a href="#h9-0-102" id="h9-0-102" class="i">+
</a><a href="#h9-0-103" id="h9-0-103" class="i">+	// If we have no more timers then exit.
</a><a href="#h9-0-104" id="h9-0-104" class="i">+	if len(m.timers) == 0 {
</a><a href="#h9-0-105" id="h9-0-105" class="i">+		m.mu.Unlock()
</a><a href="#h9-0-106" id="h9-0-106" class="i">+		return false
</a><a href="#h9-0-107" id="h9-0-107" class="i">+	}
</a><a href="#h9-0-108" id="h9-0-108" class="i">+
</a><a href="#h9-0-109" id="h9-0-109" class="i">+	// Retrieve next timer. Exit if next tick is after new time.
</a><a href="#h9-0-110" id="h9-0-110" class="i">+	t := m.timers[0]
</a><a href="#h9-0-111" id="h9-0-111" class="i">+	if t.Next().After(max) {
</a><a href="#h9-0-112" id="h9-0-112" class="i">+		m.mu.Unlock()
</a><a href="#h9-0-113" id="h9-0-113" class="i">+		return false
</a><a href="#h9-0-114" id="h9-0-114" class="i">+	}
</a><a href="#h9-0-115" id="h9-0-115" class="i">+
</a><a href="#h9-0-116" id="h9-0-116" class="i">+	// Move &quot;now&quot; forward and unlock clock.
</a><a href="#h9-0-117" id="h9-0-117" class="i">+	m.now = t.Next()
</a><a href="#h9-0-118" id="h9-0-118" class="i">+	m.mu.Unlock()
</a><a href="#h9-0-119" id="h9-0-119" class="i">+
</a><a href="#h9-0-120" id="h9-0-120" class="i">+	// Execute timer.
</a><a href="#h9-0-121" id="h9-0-121" class="i">+	t.Tick(m.now)
</a><a href="#h9-0-122" id="h9-0-122" class="i">+	return true
</a><a href="#h9-0-123" id="h9-0-123" class="i">+}
</a><a href="#h9-0-124" id="h9-0-124" class="i">+
</a><a href="#h9-0-125" id="h9-0-125" class="i">+// After waits for the duration to elapse and then sends the current time on the returned channel.
</a><a href="#h9-0-126" id="h9-0-126" class="i">+func (m *Mock) After(d time.Duration) &lt;-chan time.Time {
</a><a href="#h9-0-127" id="h9-0-127" class="i">+	defer m.inc(&amp;m.calls.After)
</a><a href="#h9-0-128" id="h9-0-128" class="i">+	return m.Timer(d).C
</a><a href="#h9-0-129" id="h9-0-129" class="i">+}
</a><a href="#h9-0-130" id="h9-0-130" class="i">+
</a><a href="#h9-0-131" id="h9-0-131" class="i">+// AfterFunc waits for the duration to elapse and then executes a function.
</a><a href="#h9-0-132" id="h9-0-132" class="i">+// A Timer is returned that can be stopped.
</a><a href="#h9-0-133" id="h9-0-133" class="i">+func (m *Mock) AfterFunc(d time.Duration, f func()) *Timer {
</a><a href="#h9-0-134" id="h9-0-134" class="i">+	defer m.inc(&amp;m.calls.AfterFunc)
</a><a href="#h9-0-135" id="h9-0-135" class="i">+	t := m.Timer(d)
</a><a href="#h9-0-136" id="h9-0-136" class="i">+	t.C = nil
</a><a href="#h9-0-137" id="h9-0-137" class="i">+	t.fn = f
</a><a href="#h9-0-138" id="h9-0-138" class="i">+	return t
</a><a href="#h9-0-139" id="h9-0-139" class="i">+}
</a><a href="#h9-0-140" id="h9-0-140" class="i">+
</a><a href="#h9-0-141" id="h9-0-141" class="i">+// Now returns the current wall time on the mock clock.
</a><a href="#h9-0-142" id="h9-0-142" class="i">+func (m *Mock) Now() time.Time {
</a><a href="#h9-0-143" id="h9-0-143" class="i">+	defer m.inc(&amp;m.calls.Now)
</a><a href="#h9-0-144" id="h9-0-144" class="i">+	m.mu.Lock()
</a><a href="#h9-0-145" id="h9-0-145" class="i">+	defer m.mu.Unlock()
</a><a href="#h9-0-146" id="h9-0-146" class="i">+	return m.now
</a><a href="#h9-0-147" id="h9-0-147" class="i">+}
</a><a href="#h9-0-148" id="h9-0-148" class="i">+
</a><a href="#h9-0-149" id="h9-0-149" class="i">+// Sleep pauses the goroutine for the given duration on the mock clock.
</a><a href="#h9-0-150" id="h9-0-150" class="i">+// The clock must be moved forward in a separate goroutine.
</a><a href="#h9-0-151" id="h9-0-151" class="i">+func (m *Mock) Sleep(d time.Duration) {
</a><a href="#h9-0-152" id="h9-0-152" class="i">+	defer m.inc(&amp;m.calls.Sleep)
</a><a href="#h9-0-153" id="h9-0-153" class="i">+	&lt;-m.After(d)
</a><a href="#h9-0-154" id="h9-0-154" class="i">+}
</a><a href="#h9-0-155" id="h9-0-155" class="i">+
</a><a href="#h9-0-156" id="h9-0-156" class="i">+// Tick is a convenience function for Ticker().
</a><a href="#h9-0-157" id="h9-0-157" class="i">+// It will return a ticker channel that cannot be stopped.
</a><a href="#h9-0-158" id="h9-0-158" class="i">+func (m *Mock) Tick(d time.Duration) &lt;-chan time.Time {
</a><a href="#h9-0-159" id="h9-0-159" class="i">+	defer m.inc(&amp;m.calls.Tick)
</a><a href="#h9-0-160" id="h9-0-160" class="i">+	return m.Ticker(d).C
</a><a href="#h9-0-161" id="h9-0-161" class="i">+}
</a><a href="#h9-0-162" id="h9-0-162" class="i">+
</a><a href="#h9-0-163" id="h9-0-163" class="i">+// Ticker creates a new instance of Ticker.
</a><a href="#h9-0-164" id="h9-0-164" class="i">+func (m *Mock) Ticker(d time.Duration) *Ticker {
</a><a href="#h9-0-165" id="h9-0-165" class="i">+	defer m.inc(&amp;m.calls.Ticker)
</a><a href="#h9-0-166" id="h9-0-166" class="i">+	m.mu.Lock()
</a><a href="#h9-0-167" id="h9-0-167" class="i">+	defer m.mu.Unlock()
</a><a href="#h9-0-168" id="h9-0-168" class="i">+	ch := make(chan time.Time)
</a><a href="#h9-0-169" id="h9-0-169" class="i">+	t := &amp;Ticker{
</a><a href="#h9-0-170" id="h9-0-170" class="i">+		C:    ch,
</a><a href="#h9-0-171" id="h9-0-171" class="i">+		c:    ch,
</a><a href="#h9-0-172" id="h9-0-172" class="i">+		mock: m,
</a><a href="#h9-0-173" id="h9-0-173" class="i">+		d:    d,
</a><a href="#h9-0-174" id="h9-0-174" class="i">+		next: m.now.Add(d),
</a><a href="#h9-0-175" id="h9-0-175" class="i">+	}
</a><a href="#h9-0-176" id="h9-0-176" class="i">+	m.timers = append(m.timers, (*internalTicker)(t))
</a><a href="#h9-0-177" id="h9-0-177" class="i">+	return t
</a><a href="#h9-0-178" id="h9-0-178" class="i">+}
</a><a href="#h9-0-179" id="h9-0-179" class="i">+
</a><a href="#h9-0-180" id="h9-0-180" class="i">+// Timer creates a new instance of Timer.
</a><a href="#h9-0-181" id="h9-0-181" class="i">+func (m *Mock) Timer(d time.Duration) *Timer {
</a><a href="#h9-0-182" id="h9-0-182" class="i">+	defer m.inc(&amp;m.calls.Timer)
</a><a href="#h9-0-183" id="h9-0-183" class="i">+	m.mu.Lock()
</a><a href="#h9-0-184" id="h9-0-184" class="i">+	defer m.mu.Unlock()
</a><a href="#h9-0-185" id="h9-0-185" class="i">+	ch := make(chan time.Time)
</a><a href="#h9-0-186" id="h9-0-186" class="i">+	t := &amp;Timer{
</a><a href="#h9-0-187" id="h9-0-187" class="i">+		C:    ch,
</a><a href="#h9-0-188" id="h9-0-188" class="i">+		c:    ch,
</a><a href="#h9-0-189" id="h9-0-189" class="i">+		mock: m,
</a><a href="#h9-0-190" id="h9-0-190" class="i">+		next: m.now.Add(d),
</a><a href="#h9-0-191" id="h9-0-191" class="i">+	}
</a><a href="#h9-0-192" id="h9-0-192" class="i">+	m.timers = append(m.timers, (*internalTimer)(t))
</a><a href="#h9-0-193" id="h9-0-193" class="i">+	return t
</a><a href="#h9-0-194" id="h9-0-194" class="i">+}
</a><a href="#h9-0-195" id="h9-0-195" class="i">+
</a><a href="#h9-0-196" id="h9-0-196" class="i">+func (m *Mock) removeClockTimer(t clockTimer) {
</a><a href="#h9-0-197" id="h9-0-197" class="i">+	m.mu.Lock()
</a><a href="#h9-0-198" id="h9-0-198" class="i">+	defer m.mu.Unlock()
</a><a href="#h9-0-199" id="h9-0-199" class="i">+	for i, timer := range m.timers {
</a><a href="#h9-0-200" id="h9-0-200" class="i">+		if timer == t {
</a><a href="#h9-0-201" id="h9-0-201" class="i">+			copy(m.timers[i:], m.timers[i+1:])
</a><a href="#h9-0-202" id="h9-0-202" class="i">+			m.timers[len(m.timers)-1] = nil
</a><a href="#h9-0-203" id="h9-0-203" class="i">+			m.timers = m.timers[:len(m.timers)-1]
</a><a href="#h9-0-204" id="h9-0-204" class="i">+			break
</a><a href="#h9-0-205" id="h9-0-205" class="i">+		}
</a><a href="#h9-0-206" id="h9-0-206" class="i">+	}
</a><a href="#h9-0-207" id="h9-0-207" class="i">+	sort.Sort(m.timers)
</a><a href="#h9-0-208" id="h9-0-208" class="i">+}
</a><a href="#h9-0-209" id="h9-0-209" class="i">+
</a><a href="#h9-0-210" id="h9-0-210" class="i">+func (m *Mock) inc(addr *uint32) {
</a><a href="#h9-0-211" id="h9-0-211" class="i">+	m.callsMutex.Lock()
</a><a href="#h9-0-212" id="h9-0-212" class="i">+	defer m.callsMutex.Unlock()
</a><a href="#h9-0-213" id="h9-0-213" class="i">+	*addr++
</a><a href="#h9-0-214" id="h9-0-214" class="i">+	var newWaiting []waiting
</a><a href="#h9-0-215" id="h9-0-215" class="i">+	for _, w := range m.waiting {
</a><a href="#h9-0-216" id="h9-0-216" class="i">+		if m.calls.atLeast(w.expected) {
</a><a href="#h9-0-217" id="h9-0-217" class="i">+			close(w.done)
</a><a href="#h9-0-218" id="h9-0-218" class="i">+			continue
</a><a href="#h9-0-219" id="h9-0-219" class="i">+		}
</a><a href="#h9-0-220" id="h9-0-220" class="i">+		newWaiting = append(newWaiting, w)
</a><a href="#h9-0-221" id="h9-0-221" class="i">+	}
</a><a href="#h9-0-222" id="h9-0-222" class="i">+	m.waiting = newWaiting
</a><a href="#h9-0-223" id="h9-0-223" class="i">+}
</a><a href="#h9-0-224" id="h9-0-224" class="i">+
</a><a href="#h9-0-225" id="h9-0-225" class="i">+// Wait waits for at least the relevant calls before returning. The expected
</a><a href="#h9-0-226" id="h9-0-226" class="i">+// Calls are always over the lifetime of the Mock. Values in the Calls struct
</a><a href="#h9-0-227" id="h9-0-227" class="i">+// are used as the minimum number of calls, this allows you to wait for only
</a><a href="#h9-0-228" id="h9-0-228" class="i">+// the calls you care about.
</a><a href="#h9-0-229" id="h9-0-229" class="i">+func (m *Mock) Wait(s Calls) {
</a><a href="#h9-0-230" id="h9-0-230" class="i">+	m.callsMutex.Lock()
</a><a href="#h9-0-231" id="h9-0-231" class="i">+	if m.calls.atLeast(s) {
</a><a href="#h9-0-232" id="h9-0-232" class="i">+		m.callsMutex.Unlock()
</a><a href="#h9-0-233" id="h9-0-233" class="i">+		return
</a><a href="#h9-0-234" id="h9-0-234" class="i">+	}
</a><a href="#h9-0-235" id="h9-0-235" class="i">+	done := make(chan struct{})
</a><a href="#h9-0-236" id="h9-0-236" class="i">+	m.waiting = append(m.waiting, waiting{expected: s, done: done})
</a><a href="#h9-0-237" id="h9-0-237" class="i">+	m.callsMutex.Unlock()
</a><a href="#h9-0-238" id="h9-0-238" class="i">+	&lt;-done
</a><a href="#h9-0-239" id="h9-0-239" class="i">+}
</a><a href="#h9-0-240" id="h9-0-240" class="i">+
</a><a href="#h9-0-241" id="h9-0-241" class="i">+// clockTimer represents an object with an associated start time.
</a><a href="#h9-0-242" id="h9-0-242" class="i">+type clockTimer interface {
</a><a href="#h9-0-243" id="h9-0-243" class="i">+	Next() time.Time
</a><a href="#h9-0-244" id="h9-0-244" class="i">+	Tick(time.Time)
</a><a href="#h9-0-245" id="h9-0-245" class="i">+}
</a><a href="#h9-0-246" id="h9-0-246" class="i">+
</a><a href="#h9-0-247" id="h9-0-247" class="i">+// clockTimers represents a list of sortable timers.
</a><a href="#h9-0-248" id="h9-0-248" class="i">+type clockTimers []clockTimer
</a><a href="#h9-0-249" id="h9-0-249" class="i">+
</a><a href="#h9-0-250" id="h9-0-250" class="i">+func (a clockTimers) Len() int           { return len(a) }
</a><a href="#h9-0-251" id="h9-0-251" class="i">+func (a clockTimers) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
</a><a href="#h9-0-252" id="h9-0-252" class="i">+func (a clockTimers) Less(i, j int) bool { return a[i].Next().Before(a[j].Next()) }
</a><a href="#h9-0-253" id="h9-0-253" class="i">+
</a><a href="#h9-0-254" id="h9-0-254" class="i">+// Timer represents a single event.
</a><a href="#h9-0-255" id="h9-0-255" class="i">+// The current time will be sent on C, unless the timer was created by AfterFunc.
</a><a href="#h9-0-256" id="h9-0-256" class="i">+type Timer struct {
</a><a href="#h9-0-257" id="h9-0-257" class="i">+	C     &lt;-chan time.Time
</a><a href="#h9-0-258" id="h9-0-258" class="i">+	c     chan time.Time
</a><a href="#h9-0-259" id="h9-0-259" class="i">+	timer *time.Timer // realtime impl, if set
</a><a href="#h9-0-260" id="h9-0-260" class="i">+	next  time.Time   // next tick time
</a><a href="#h9-0-261" id="h9-0-261" class="i">+	mock  *Mock       // mock clock, if set
</a><a href="#h9-0-262" id="h9-0-262" class="i">+	fn    func()      // AfterFunc function, if set
</a><a href="#h9-0-263" id="h9-0-263" class="i">+}
</a><a href="#h9-0-264" id="h9-0-264" class="i">+
</a><a href="#h9-0-265" id="h9-0-265" class="i">+// Stop turns off the ticker.
</a><a href="#h9-0-266" id="h9-0-266" class="i">+func (t *Timer) Stop() {
</a><a href="#h9-0-267" id="h9-0-267" class="i">+	if t.timer != nil {
</a><a href="#h9-0-268" id="h9-0-268" class="i">+		t.timer.Stop()
</a><a href="#h9-0-269" id="h9-0-269" class="i">+	} else {
</a><a href="#h9-0-270" id="h9-0-270" class="i">+		t.mock.removeClockTimer((*internalTimer)(t))
</a><a href="#h9-0-271" id="h9-0-271" class="i">+	}
</a><a href="#h9-0-272" id="h9-0-272" class="i">+}
</a><a href="#h9-0-273" id="h9-0-273" class="i">+
</a><a href="#h9-0-274" id="h9-0-274" class="i">+type internalTimer Timer
</a><a href="#h9-0-275" id="h9-0-275" class="i">+
</a><a href="#h9-0-276" id="h9-0-276" class="i">+func (t *internalTimer) Next() time.Time { return t.next }
</a><a href="#h9-0-277" id="h9-0-277" class="i">+func (t *internalTimer) Tick(now time.Time) {
</a><a href="#h9-0-278" id="h9-0-278" class="i">+	if t.fn != nil {
</a><a href="#h9-0-279" id="h9-0-279" class="i">+		t.fn()
</a><a href="#h9-0-280" id="h9-0-280" class="i">+	} else {
</a><a href="#h9-0-281" id="h9-0-281" class="i">+		t.c &lt;- now
</a><a href="#h9-0-282" id="h9-0-282" class="i">+	}
</a><a href="#h9-0-283" id="h9-0-283" class="i">+	t.mock.removeClockTimer((*internalTimer)(t))
</a><a href="#h9-0-284" id="h9-0-284" class="i">+	gosched()
</a><a href="#h9-0-285" id="h9-0-285" class="i">+}
</a><a href="#h9-0-286" id="h9-0-286" class="i">+
</a><a href="#h9-0-287" id="h9-0-287" class="i">+// Ticker holds a channel that receives &quot;ticks&quot; at regular intervals.
</a><a href="#h9-0-288" id="h9-0-288" class="i">+type Ticker struct {
</a><a href="#h9-0-289" id="h9-0-289" class="i">+	C      &lt;-chan time.Time
</a><a href="#h9-0-290" id="h9-0-290" class="i">+	c      chan time.Time
</a><a href="#h9-0-291" id="h9-0-291" class="i">+	ticker *time.Ticker  // realtime impl, if set
</a><a href="#h9-0-292" id="h9-0-292" class="i">+	next   time.Time     // next tick time
</a><a href="#h9-0-293" id="h9-0-293" class="i">+	mock   *Mock         // mock clock, if set
</a><a href="#h9-0-294" id="h9-0-294" class="i">+	d      time.Duration // time between ticks
</a><a href="#h9-0-295" id="h9-0-295" class="i">+}
</a><a href="#h9-0-296" id="h9-0-296" class="i">+
</a><a href="#h9-0-297" id="h9-0-297" class="i">+// Stop turns off the ticker.
</a><a href="#h9-0-298" id="h9-0-298" class="i">+func (t *Ticker) Stop() {
</a><a href="#h9-0-299" id="h9-0-299" class="i">+	if t.ticker != nil {
</a><a href="#h9-0-300" id="h9-0-300" class="i">+		t.ticker.Stop()
</a><a href="#h9-0-301" id="h9-0-301" class="i">+	} else {
</a><a href="#h9-0-302" id="h9-0-302" class="i">+		t.mock.removeClockTimer((*internalTicker)(t))
</a><a href="#h9-0-303" id="h9-0-303" class="i">+	}
</a><a href="#h9-0-304" id="h9-0-304" class="i">+}
</a><a href="#h9-0-305" id="h9-0-305" class="i">+
</a><a href="#h9-0-306" id="h9-0-306" class="i">+type internalTicker Ticker
</a><a href="#h9-0-307" id="h9-0-307" class="i">+
</a><a href="#h9-0-308" id="h9-0-308" class="i">+func (t *internalTicker) Next() time.Time { return t.next }
</a><a href="#h9-0-309" id="h9-0-309" class="i">+func (t *internalTicker) Tick(now time.Time) {
</a><a href="#h9-0-310" id="h9-0-310" class="i">+	select {
</a><a href="#h9-0-311" id="h9-0-311" class="i">+	case t.c &lt;- now:
</a><a href="#h9-0-312" id="h9-0-312" class="i">+	case &lt;-time.After(1 * time.Millisecond):
</a><a href="#h9-0-313" id="h9-0-313" class="i">+	}
</a><a href="#h9-0-314" id="h9-0-314" class="i">+	t.next = now.Add(t.d)
</a><a href="#h9-0-315" id="h9-0-315" class="i">+	gosched()
</a><a href="#h9-0-316" id="h9-0-316" class="i">+}
</a><a href="#h9-0-317" id="h9-0-317" class="i">+
</a><a href="#h9-0-318" id="h9-0-318" class="i">+// Sleep momentarily so that other goroutines can process.
</a><a href="#h9-0-319" id="h9-0-319" class="i">+func gosched() { runtime.Gosched() }
</a><a href="#h9-0-320" id="h9-0-320" class="i">+
</a><a href="#h9-0-321" id="h9-0-321" class="i">+// Calls keeps track of the count of calls for each of the methods on the Clock
</a><a href="#h9-0-322" id="h9-0-322" class="i">+// interface.
</a><a href="#h9-0-323" id="h9-0-323" class="i">+type Calls struct {
</a><a href="#h9-0-324" id="h9-0-324" class="i">+	After     uint32
</a><a href="#h9-0-325" id="h9-0-325" class="i">+	AfterFunc uint32
</a><a href="#h9-0-326" id="h9-0-326" class="i">+	Now       uint32
</a><a href="#h9-0-327" id="h9-0-327" class="i">+	Sleep     uint32
</a><a href="#h9-0-328" id="h9-0-328" class="i">+	Tick      uint32
</a><a href="#h9-0-329" id="h9-0-329" class="i">+	Ticker    uint32
</a><a href="#h9-0-330" id="h9-0-330" class="i">+	Timer     uint32
</a><a href="#h9-0-331" id="h9-0-331" class="i">+}
</a><a href="#h9-0-332" id="h9-0-332" class="i">+
</a><a href="#h9-0-333" id="h9-0-333" class="i">+// atLeast returns true if at least the number of calls in o have been made.
</a><a href="#h9-0-334" id="h9-0-334" class="i">+func (c Calls) atLeast(o Calls) bool {
</a><a href="#h9-0-335" id="h9-0-335" class="i">+	if c.After &lt; o.After {
</a><a href="#h9-0-336" id="h9-0-336" class="i">+		return false
</a><a href="#h9-0-337" id="h9-0-337" class="i">+	}
</a><a href="#h9-0-338" id="h9-0-338" class="i">+	if c.AfterFunc &lt; o.AfterFunc {
</a><a href="#h9-0-339" id="h9-0-339" class="i">+		return false
</a><a href="#h9-0-340" id="h9-0-340" class="i">+	}
</a><a href="#h9-0-341" id="h9-0-341" class="i">+	if c.Now &lt; o.Now {
</a><a href="#h9-0-342" id="h9-0-342" class="i">+		return false
</a><a href="#h9-0-343" id="h9-0-343" class="i">+	}
</a><a href="#h9-0-344" id="h9-0-344" class="i">+	if c.Sleep &lt; o.Sleep {
</a><a href="#h9-0-345" id="h9-0-345" class="i">+		return false
</a><a href="#h9-0-346" id="h9-0-346" class="i">+	}
</a><a href="#h9-0-347" id="h9-0-347" class="i">+	if c.Tick &lt; o.Tick {
</a><a href="#h9-0-348" id="h9-0-348" class="i">+		return false
</a><a href="#h9-0-349" id="h9-0-349" class="i">+	}
</a><a href="#h9-0-350" id="h9-0-350" class="i">+	if c.Ticker &lt; o.Ticker {
</a><a href="#h9-0-351" id="h9-0-351" class="i">+		return false
</a><a href="#h9-0-352" id="h9-0-352" class="i">+	}
</a><a href="#h9-0-353" id="h9-0-353" class="i">+	if c.Timer &lt; o.Timer {
</a><a href="#h9-0-354" id="h9-0-354" class="i">+		return false
</a><a href="#h9-0-355" id="h9-0-355" class="i">+	}
</a><a href="#h9-0-356" id="h9-0-356" class="i">+	return true
</a><a href="#h9-0-357" id="h9-0-357" class="i">+}
</a><a href="#h9-0-358" id="h9-0-358" class="i">+
</a><a href="#h9-0-359" id="h9-0-359" class="i">+type waiting struct {
</a><a href="#h9-0-360" id="h9-0-360" class="i">+	expected Calls
</a><a href="#h9-0-361" id="h9-0-361" class="i">+	done     chan struct{}
</a><a href="#h9-0-362" id="h9-0-362" class="i">+}
</a><b>diff --git a/<a id="h10" href="../file/vendor/github.com/facebookgo/limitgroup/BUILD">vendor/github.com/facebookgo/limitgroup/BUILD</a> b/<a href="../file/vendor/github.com/facebookgo/limitgroup/BUILD">vendor/github.com/facebookgo/limitgroup/BUILD</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -0,0 +1,18 @@
</a><a href="#h10-0-0" id="h10-0-0" class="i">+
</a><a href="#h10-0-1" id="h10-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h10-0-2" id="h10-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h10-0-3" id="h10-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h10-0-4" id="h10-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h10-0-5" id="h10-0-5" class="i">+)
</a><a href="#h10-0-6" id="h10-0-6" class="i">+
</a><a href="#h10-0-7" id="h10-0-7" class="i">+go_library(
</a><a href="#h10-0-8" id="h10-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h10-0-9" id="h10-0-9" class="i">+  srcs = [
</a><a href="#h10-0-10" id="h10-0-10" class="i">+    &quot;limitgroup.go&quot;,
</a><a href="#h10-0-11" id="h10-0-11" class="i">+  ],
</a><a href="#h10-0-12" id="h10-0-12" class="i">+  deps = [
</a><a href="#h10-0-13" id="h10-0-13" class="i">+  ],
</a><a href="#h10-0-14" id="h10-0-14" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h10-0-15" id="h10-0-15" class="i">+)
</a><a href="#h10-0-16" id="h10-0-16" class="i">+
</a><a href="#h10-0-17" id="h10-0-17" class="i">+
</a><b>diff --git a/<a id="h11" href="../file/vendor/github.com/facebookgo/limitgroup/license">vendor/github.com/facebookgo/limitgroup/license</a> b/<a href="../file/vendor/github.com/facebookgo/limitgroup/license">vendor/github.com/facebookgo/limitgroup/license</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -0,0 +1,30 @@
</a><a href="#h11-0-0" id="h11-0-0" class="i">+BSD License
</a><a href="#h11-0-1" id="h11-0-1" class="i">+
</a><a href="#h11-0-2" id="h11-0-2" class="i">+For limitgroup software
</a><a href="#h11-0-3" id="h11-0-3" class="i">+
</a><a href="#h11-0-4" id="h11-0-4" class="i">+Copyright (c) 2015, Facebook, Inc. All rights reserved.
</a><a href="#h11-0-5" id="h11-0-5" class="i">+
</a><a href="#h11-0-6" id="h11-0-6" class="i">+Redistribution and use in source and binary forms, with or without modification,
</a><a href="#h11-0-7" id="h11-0-7" class="i">+are permitted provided that the following conditions are met:
</a><a href="#h11-0-8" id="h11-0-8" class="i">+
</a><a href="#h11-0-9" id="h11-0-9" class="i">+ * Redistributions of source code must retain the above copyright notice, this
</a><a href="#h11-0-10" id="h11-0-10" class="i">+   list of conditions and the following disclaimer.
</a><a href="#h11-0-11" id="h11-0-11" class="i">+
</a><a href="#h11-0-12" id="h11-0-12" class="i">+ * Redistributions in binary form must reproduce the above copyright notice,
</a><a href="#h11-0-13" id="h11-0-13" class="i">+   this list of conditions and the following disclaimer in the documentation
</a><a href="#h11-0-14" id="h11-0-14" class="i">+   and/or other materials provided with the distribution.
</a><a href="#h11-0-15" id="h11-0-15" class="i">+
</a><a href="#h11-0-16" id="h11-0-16" class="i">+ * Neither the name Facebook nor the names of its contributors may be used to
</a><a href="#h11-0-17" id="h11-0-17" class="i">+   endorse or promote products derived from this software without specific
</a><a href="#h11-0-18" id="h11-0-18" class="i">+   prior written permission.
</a><a href="#h11-0-19" id="h11-0-19" class="i">+
</a><a href="#h11-0-20" id="h11-0-20" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</a><a href="#h11-0-21" id="h11-0-21" class="i">+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
</a><a href="#h11-0-22" id="h11-0-22" class="i">+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
</a><a href="#h11-0-23" id="h11-0-23" class="i">+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
</a><a href="#h11-0-24" id="h11-0-24" class="i">+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
</a><a href="#h11-0-25" id="h11-0-25" class="i">+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
</a><a href="#h11-0-26" id="h11-0-26" class="i">+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
</a><a href="#h11-0-27" id="h11-0-27" class="i">+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h11-0-28" id="h11-0-28" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
</a><a href="#h11-0-29" id="h11-0-29" class="i">+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><b>diff --git a/<a id="h12" href="../file/vendor/github.com/facebookgo/limitgroup/limitgroup.go">vendor/github.com/facebookgo/limitgroup/limitgroup.go</a> b/<a href="../file/vendor/github.com/facebookgo/limitgroup/limitgroup.go">vendor/github.com/facebookgo/limitgroup/limitgroup.go</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -0,0 +1,65 @@
</a><a href="#h12-0-0" id="h12-0-0" class="i">+// Package limitgroup provides a sync.WaitGroup equivalent with a
</a><a href="#h12-0-1" id="h12-0-1" class="i">+// configurable upper bound. This is implemented by having Add() block as well
</a><a href="#h12-0-2" id="h12-0-2" class="i">+// if necessary.
</a><a href="#h12-0-3" id="h12-0-3" class="i">+package limitgroup
</a><a href="#h12-0-4" id="h12-0-4" class="i">+
</a><a href="#h12-0-5" id="h12-0-5" class="i">+import (
</a><a href="#h12-0-6" id="h12-0-6" class="i">+	&quot;sync&quot;
</a><a href="#h12-0-7" id="h12-0-7" class="i">+)
</a><a href="#h12-0-8" id="h12-0-8" class="i">+
</a><a href="#h12-0-9" id="h12-0-9" class="i">+var sentinel = struct{}{}
</a><a href="#h12-0-10" id="h12-0-10" class="i">+
</a><a href="#h12-0-11" id="h12-0-11" class="i">+// LimitGroup provides a WaitGroup with a limited upper bound. Once the limit
</a><a href="#h12-0-12" id="h12-0-12" class="i">+// is hit, Add will block until sufficient deltas are returned.
</a><a href="#h12-0-13" id="h12-0-13" class="i">+type LimitGroup struct {
</a><a href="#h12-0-14" id="h12-0-14" class="i">+	sync.WaitGroup
</a><a href="#h12-0-15" id="h12-0-15" class="i">+	slots chan struct{}
</a><a href="#h12-0-16" id="h12-0-16" class="i">+}
</a><a href="#h12-0-17" id="h12-0-17" class="i">+
</a><a href="#h12-0-18" id="h12-0-18" class="i">+// NewLimitGroup creates a new LimitGroup with the configured limit.
</a><a href="#h12-0-19" id="h12-0-19" class="i">+func NewLimitGroup(limit uint) *LimitGroup {
</a><a href="#h12-0-20" id="h12-0-20" class="i">+	if limit == 0 {
</a><a href="#h12-0-21" id="h12-0-21" class="i">+		panic(&quot;zero is not a valid limit&quot;)
</a><a href="#h12-0-22" id="h12-0-22" class="i">+	}
</a><a href="#h12-0-23" id="h12-0-23" class="i">+	slots := make(chan struct{}, limit)
</a><a href="#h12-0-24" id="h12-0-24" class="i">+	return &amp;LimitGroup{slots: slots}
</a><a href="#h12-0-25" id="h12-0-25" class="i">+}
</a><a href="#h12-0-26" id="h12-0-26" class="i">+
</a><a href="#h12-0-27" id="h12-0-27" class="i">+// Add adds delta, which may be negative. It will block if we have hit the
</a><a href="#h12-0-28" id="h12-0-28" class="i">+// limit, and will unblock as Done is called.
</a><a href="#h12-0-29" id="h12-0-29" class="i">+func (l *LimitGroup) Add(delta int) {
</a><a href="#h12-0-30" id="h12-0-30" class="i">+	if delta &gt; cap(l.slots) {
</a><a href="#h12-0-31" id="h12-0-31" class="i">+		panic(&quot;delta greater than limit&quot;)
</a><a href="#h12-0-32" id="h12-0-32" class="i">+	}
</a><a href="#h12-0-33" id="h12-0-33" class="i">+	if delta == 0 {
</a><a href="#h12-0-34" id="h12-0-34" class="i">+		return
</a><a href="#h12-0-35" id="h12-0-35" class="i">+	}
</a><a href="#h12-0-36" id="h12-0-36" class="i">+
</a><a href="#h12-0-37" id="h12-0-37" class="i">+	// If we&#39;re adding, we need to accquire slots, if we&#39;re subtracting, we need
</a><a href="#h12-0-38" id="h12-0-38" class="i">+	// to return slots.
</a><a href="#h12-0-39" id="h12-0-39" class="i">+	if delta &gt; 0 {
</a><a href="#h12-0-40" id="h12-0-40" class="i">+		l.WaitGroup.Add(delta)
</a><a href="#h12-0-41" id="h12-0-41" class="i">+		for i := 0; i &lt; delta; i++ {
</a><a href="#h12-0-42" id="h12-0-42" class="i">+			l.slots &lt;- sentinel
</a><a href="#h12-0-43" id="h12-0-43" class="i">+		}
</a><a href="#h12-0-44" id="h12-0-44" class="i">+	} else {
</a><a href="#h12-0-45" id="h12-0-45" class="i">+		for i := 0; i &gt; delta; i-- {
</a><a href="#h12-0-46" id="h12-0-46" class="i">+			select {
</a><a href="#h12-0-47" id="h12-0-47" class="i">+			case &lt;-l.slots:
</a><a href="#h12-0-48" id="h12-0-48" class="i">+			default:
</a><a href="#h12-0-49" id="h12-0-49" class="i">+				panic(&quot;trying to return more slots than acquired&quot;)
</a><a href="#h12-0-50" id="h12-0-50" class="i">+			}
</a><a href="#h12-0-51" id="h12-0-51" class="i">+		}
</a><a href="#h12-0-52" id="h12-0-52" class="i">+		l.WaitGroup.Add(delta)
</a><a href="#h12-0-53" id="h12-0-53" class="i">+	}
</a><a href="#h12-0-54" id="h12-0-54" class="i">+}
</a><a href="#h12-0-55" id="h12-0-55" class="i">+
</a><a href="#h12-0-56" id="h12-0-56" class="i">+// Done decrements the counter.
</a><a href="#h12-0-57" id="h12-0-57" class="i">+func (l *LimitGroup) Done() {
</a><a href="#h12-0-58" id="h12-0-58" class="i">+	select {
</a><a href="#h12-0-59" id="h12-0-59" class="i">+	case &lt;-l.slots:
</a><a href="#h12-0-60" id="h12-0-60" class="i">+	default:
</a><a href="#h12-0-61" id="h12-0-61" class="i">+		panic(&quot;trying to return more slots than acquired&quot;)
</a><a href="#h12-0-62" id="h12-0-62" class="i">+	}
</a><a href="#h12-0-63" id="h12-0-63" class="i">+	l.WaitGroup.Done()
</a><a href="#h12-0-64" id="h12-0-64" class="i">+}
</a><b>diff --git a/<a id="h13" href="../file/vendor/github.com/facebookgo/limitgroup/patents">vendor/github.com/facebookgo/limitgroup/patents</a> b/<a href="../file/vendor/github.com/facebookgo/limitgroup/patents">vendor/github.com/facebookgo/limitgroup/patents</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -0,0 +1,33 @@
</a><a href="#h13-0-0" id="h13-0-0" class="i">+Additional Grant of Patent Rights Version 2
</a><a href="#h13-0-1" id="h13-0-1" class="i">+
</a><a href="#h13-0-2" id="h13-0-2" class="i">+&quot;Software&quot; means the limitgroup software distributed by Facebook, Inc.
</a><a href="#h13-0-3" id="h13-0-3" class="i">+
</a><a href="#h13-0-4" id="h13-0-4" class="i">+Facebook, Inc. (&quot;Facebook&quot;) hereby grants to each recipient of the Software
</a><a href="#h13-0-5" id="h13-0-5" class="i">+(&quot;you&quot;) a perpetual, worldwide, royalty-free, non-exclusive, irrevocable
</a><a href="#h13-0-6" id="h13-0-6" class="i">+(subject to the termination provision below) license under any Necessary
</a><a href="#h13-0-7" id="h13-0-7" class="i">+Claims, to make, have made, use, sell, offer to sell, import, and otherwise
</a><a href="#h13-0-8" id="h13-0-8" class="i">+transfer the Software. For avoidance of doubt, no license is granted under
</a><a href="#h13-0-9" id="h13-0-9" class="i">+Facebook’s rights in any patent claims that are infringed by (i) modifications
</a><a href="#h13-0-10" id="h13-0-10" class="i">+to the Software made by you or any third party or (ii) the Software in
</a><a href="#h13-0-11" id="h13-0-11" class="i">+combination with any software or other technology.
</a><a href="#h13-0-12" id="h13-0-12" class="i">+
</a><a href="#h13-0-13" id="h13-0-13" class="i">+The license granted hereunder will terminate, automatically and without notice,
</a><a href="#h13-0-14" id="h13-0-14" class="i">+if you (or any of your subsidiaries, corporate affiliates or agents) initiate
</a><a href="#h13-0-15" id="h13-0-15" class="i">+directly or indirectly, or take a direct financial interest in, any Patent
</a><a href="#h13-0-16" id="h13-0-16" class="i">+Assertion: (i) against Facebook or any of its subsidiaries or corporate
</a><a href="#h13-0-17" id="h13-0-17" class="i">+affiliates, (ii) against any party if such Patent Assertion arises in whole or
</a><a href="#h13-0-18" id="h13-0-18" class="i">+in part from any software, technology, product or service of Facebook or any of
</a><a href="#h13-0-19" id="h13-0-19" class="i">+its subsidiaries or corporate affiliates, or (iii) against any party relating
</a><a href="#h13-0-20" id="h13-0-20" class="i">+to the Software. Notwithstanding the foregoing, if Facebook or any of its
</a><a href="#h13-0-21" id="h13-0-21" class="i">+subsidiaries or corporate affiliates files a lawsuit alleging patent
</a><a href="#h13-0-22" id="h13-0-22" class="i">+infringement against you in the first instance, and you respond by filing a
</a><a href="#h13-0-23" id="h13-0-23" class="i">+patent infringement counterclaim in that lawsuit against that party that is
</a><a href="#h13-0-24" id="h13-0-24" class="i">+unrelated to the Software, the license granted hereunder will not terminate
</a><a href="#h13-0-25" id="h13-0-25" class="i">+under section (i) of this paragraph due to such counterclaim.
</a><a href="#h13-0-26" id="h13-0-26" class="i">+
</a><a href="#h13-0-27" id="h13-0-27" class="i">+A &quot;Necessary Claim&quot; is a claim of a patent owned by Facebook that is
</a><a href="#h13-0-28" id="h13-0-28" class="i">+necessarily infringed by the Software standing alone.
</a><a href="#h13-0-29" id="h13-0-29" class="i">+
</a><a href="#h13-0-30" id="h13-0-30" class="i">+A &quot;Patent Assertion&quot; is any lawsuit or other action alleging direct, indirect,
</a><a href="#h13-0-31" id="h13-0-31" class="i">+or contributory infringement or inducement to infringe any patent, including a
</a><a href="#h13-0-32" id="h13-0-32" class="i">+cross-claim or counterclaim.
</a><b>diff --git a/<a id="h14" href="../file/vendor/github.com/facebookgo/limitgroup/readme.md">vendor/github.com/facebookgo/limitgroup/readme.md</a> b/<a href="../file/vendor/github.com/facebookgo/limitgroup/readme.md">vendor/github.com/facebookgo/limitgroup/readme.md</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -0,0 +1,4 @@
</a><a href="#h14-0-0" id="h14-0-0" class="i">+limitgroup [![Build Status](https://secure.travis-ci.org/facebookgo/limitgroup.png)](https://travis-ci.org/facebookgo/limitgroup)
</a><a href="#h14-0-1" id="h14-0-1" class="i">+==========
</a><a href="#h14-0-2" id="h14-0-2" class="i">+
</a><a href="#h14-0-3" id="h14-0-3" class="i">+Documentation: https://godoc.org/github.com/facebookgo/limitgroup
</a><b>diff --git a/<a id="h15" href="../file/vendor/github.com/facebookgo/muster/BUILD">vendor/github.com/facebookgo/muster/BUILD</a> b/<a href="../file/vendor/github.com/facebookgo/muster/BUILD">vendor/github.com/facebookgo/muster/BUILD</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -0,0 +1,20 @@
</a><a href="#h15-0-0" id="h15-0-0" class="i">+
</a><a href="#h15-0-1" id="h15-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h15-0-2" id="h15-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h15-0-3" id="h15-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h15-0-4" id="h15-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h15-0-5" id="h15-0-5" class="i">+)
</a><a href="#h15-0-6" id="h15-0-6" class="i">+
</a><a href="#h15-0-7" id="h15-0-7" class="i">+go_library(
</a><a href="#h15-0-8" id="h15-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h15-0-9" id="h15-0-9" class="i">+  srcs = [
</a><a href="#h15-0-10" id="h15-0-10" class="i">+    &quot;muster.go&quot;,
</a><a href="#h15-0-11" id="h15-0-11" class="i">+  ],
</a><a href="#h15-0-12" id="h15-0-12" class="i">+  deps = [
</a><a href="#h15-0-13" id="h15-0-13" class="i">+    &quot;//vendor/github.com/facebookgo/clock:go_default_library&quot;,
</a><a href="#h15-0-14" id="h15-0-14" class="i">+    &quot;//vendor/github.com/facebookgo/limitgroup:go_default_library&quot;,
</a><a href="#h15-0-15" id="h15-0-15" class="i">+  ],
</a><a href="#h15-0-16" id="h15-0-16" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h15-0-17" id="h15-0-17" class="i">+)
</a><a href="#h15-0-18" id="h15-0-18" class="i">+
</a><a href="#h15-0-19" id="h15-0-19" class="i">+
</a><b>diff --git a/<a id="h16" href="../file/vendor/github.com/facebookgo/muster/license">vendor/github.com/facebookgo/muster/license</a> b/<a href="../file/vendor/github.com/facebookgo/muster/license">vendor/github.com/facebookgo/muster/license</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -0,0 +1,30 @@
</a><a href="#h16-0-0" id="h16-0-0" class="i">+BSD License
</a><a href="#h16-0-1" id="h16-0-1" class="i">+
</a><a href="#h16-0-2" id="h16-0-2" class="i">+For muster software
</a><a href="#h16-0-3" id="h16-0-3" class="i">+
</a><a href="#h16-0-4" id="h16-0-4" class="i">+Copyright (c) 2015, Facebook, Inc. All rights reserved.
</a><a href="#h16-0-5" id="h16-0-5" class="i">+
</a><a href="#h16-0-6" id="h16-0-6" class="i">+Redistribution and use in source and binary forms, with or without modification,
</a><a href="#h16-0-7" id="h16-0-7" class="i">+are permitted provided that the following conditions are met:
</a><a href="#h16-0-8" id="h16-0-8" class="i">+
</a><a href="#h16-0-9" id="h16-0-9" class="i">+ * Redistributions of source code must retain the above copyright notice, this
</a><a href="#h16-0-10" id="h16-0-10" class="i">+   list of conditions and the following disclaimer.
</a><a href="#h16-0-11" id="h16-0-11" class="i">+
</a><a href="#h16-0-12" id="h16-0-12" class="i">+ * Redistributions in binary form must reproduce the above copyright notice,
</a><a href="#h16-0-13" id="h16-0-13" class="i">+   this list of conditions and the following disclaimer in the documentation
</a><a href="#h16-0-14" id="h16-0-14" class="i">+   and/or other materials provided with the distribution.
</a><a href="#h16-0-15" id="h16-0-15" class="i">+
</a><a href="#h16-0-16" id="h16-0-16" class="i">+ * Neither the name Facebook nor the names of its contributors may be used to
</a><a href="#h16-0-17" id="h16-0-17" class="i">+   endorse or promote products derived from this software without specific
</a><a href="#h16-0-18" id="h16-0-18" class="i">+   prior written permission.
</a><a href="#h16-0-19" id="h16-0-19" class="i">+
</a><a href="#h16-0-20" id="h16-0-20" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
</a><a href="#h16-0-21" id="h16-0-21" class="i">+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
</a><a href="#h16-0-22" id="h16-0-22" class="i">+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
</a><a href="#h16-0-23" id="h16-0-23" class="i">+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
</a><a href="#h16-0-24" id="h16-0-24" class="i">+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
</a><a href="#h16-0-25" id="h16-0-25" class="i">+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
</a><a href="#h16-0-26" id="h16-0-26" class="i">+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
</a><a href="#h16-0-27" id="h16-0-27" class="i">+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h16-0-28" id="h16-0-28" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
</a><a href="#h16-0-29" id="h16-0-29" class="i">+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><b>diff --git a/<a id="h17" href="../file/vendor/github.com/facebookgo/muster/muster.go">vendor/github.com/facebookgo/muster/muster.go</a> b/<a href="../file/vendor/github.com/facebookgo/muster/muster.go">vendor/github.com/facebookgo/muster/muster.go</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -0,0 +1,175 @@
</a><a href="#h17-0-0" id="h17-0-0" class="i">+// Package muster provides a framework for writing libraries that internally
</a><a href="#h17-0-1" id="h17-0-1" class="i">+// batch operations.
</a><a href="#h17-0-2" id="h17-0-2" class="i">+//
</a><a href="#h17-0-3" id="h17-0-3" class="i">+// It will be useful to you if you&#39;re building an API that benefits from
</a><a href="#h17-0-4" id="h17-0-4" class="i">+// performing work in batches for whatever reason. Batching is triggered based
</a><a href="#h17-0-5" id="h17-0-5" class="i">+// on a maximum number of items in a batch, and/or based on a timeout for how
</a><a href="#h17-0-6" id="h17-0-6" class="i">+// long a batch waits before it is dispatched. For example if you&#39;re willing to
</a><a href="#h17-0-7" id="h17-0-7" class="i">+// wait for a maximum of a 1m duration, you can just set BatchTimeout and keep
</a><a href="#h17-0-8" id="h17-0-8" class="i">+// adding things. Or if you want batches of 50 just set MaxBatchSize and it
</a><a href="#h17-0-9" id="h17-0-9" class="i">+// will only fire when the batch is filled. For best results set both.
</a><a href="#h17-0-10" id="h17-0-10" class="i">+//
</a><a href="#h17-0-11" id="h17-0-11" class="i">+// It would be in your best interest to use this library in a hidden fashion in
</a><a href="#h17-0-12" id="h17-0-12" class="i">+// order to avoid unnecessary coupling. You will typically achieve this by
</a><a href="#h17-0-13" id="h17-0-13" class="i">+// ensuring your implementation of muster.Batch and the use of muster.Client
</a><a href="#h17-0-14" id="h17-0-14" class="i">+// are private.
</a><a href="#h17-0-15" id="h17-0-15" class="i">+package muster
</a><a href="#h17-0-16" id="h17-0-16" class="i">+
</a><a href="#h17-0-17" id="h17-0-17" class="i">+import (
</a><a href="#h17-0-18" id="h17-0-18" class="i">+	&quot;errors&quot;
</a><a href="#h17-0-19" id="h17-0-19" class="i">+	&quot;sync&quot;
</a><a href="#h17-0-20" id="h17-0-20" class="i">+	&quot;time&quot;
</a><a href="#h17-0-21" id="h17-0-21" class="i">+
</a><a href="#h17-0-22" id="h17-0-22" class="i">+	&quot;github.com/facebookgo/clock&quot;
</a><a href="#h17-0-23" id="h17-0-23" class="i">+	&quot;github.com/facebookgo/limitgroup&quot;
</a><a href="#h17-0-24" id="h17-0-24" class="i">+)
</a><a href="#h17-0-25" id="h17-0-25" class="i">+
</a><a href="#h17-0-26" id="h17-0-26" class="i">+var errZeroBoth = errors.New(
</a><a href="#h17-0-27" id="h17-0-27" class="i">+	&quot;muster: MaxBatchSize and BatchTimeout can&#39;t both be zero&quot;,
</a><a href="#h17-0-28" id="h17-0-28" class="i">+)
</a><a href="#h17-0-29" id="h17-0-29" class="i">+
</a><a href="#h17-0-30" id="h17-0-30" class="i">+type waitGroup interface {
</a><a href="#h17-0-31" id="h17-0-31" class="i">+	Add(delta int)
</a><a href="#h17-0-32" id="h17-0-32" class="i">+	Done()
</a><a href="#h17-0-33" id="h17-0-33" class="i">+	Wait()
</a><a href="#h17-0-34" id="h17-0-34" class="i">+}
</a><a href="#h17-0-35" id="h17-0-35" class="i">+
</a><a href="#h17-0-36" id="h17-0-36" class="i">+// Notifier is used to indicate to the Client when a batch has finished
</a><a href="#h17-0-37" id="h17-0-37" class="i">+// processing.
</a><a href="#h17-0-38" id="h17-0-38" class="i">+type Notifier interface {
</a><a href="#h17-0-39" id="h17-0-39" class="i">+	// Calling Done will indicate the batch has finished processing.
</a><a href="#h17-0-40" id="h17-0-40" class="i">+	Done()
</a><a href="#h17-0-41" id="h17-0-41" class="i">+}
</a><a href="#h17-0-42" id="h17-0-42" class="i">+
</a><a href="#h17-0-43" id="h17-0-43" class="i">+// Batch collects added items. Fire will be called exactly once. The Batch does
</a><a href="#h17-0-44" id="h17-0-44" class="i">+// not need to be safe for concurrent access; synchronization will be handled
</a><a href="#h17-0-45" id="h17-0-45" class="i">+// by the Client.
</a><a href="#h17-0-46" id="h17-0-46" class="i">+type Batch interface {
</a><a href="#h17-0-47" id="h17-0-47" class="i">+	// This should add the given single item to the Batch. This is the &quot;other
</a><a href="#h17-0-48" id="h17-0-48" class="i">+	// end&quot; of the Client.Work channel where your application will send items.
</a><a href="#h17-0-49" id="h17-0-49" class="i">+	Add(item interface{})
</a><a href="#h17-0-50" id="h17-0-50" class="i">+
</a><a href="#h17-0-51" id="h17-0-51" class="i">+	// Fire off the Batch. It should call Notifier.Done() when it has finished
</a><a href="#h17-0-52" id="h17-0-52" class="i">+	// processing the Batch.
</a><a href="#h17-0-53" id="h17-0-53" class="i">+	Fire(notifier Notifier)
</a><a href="#h17-0-54" id="h17-0-54" class="i">+}
</a><a href="#h17-0-55" id="h17-0-55" class="i">+
</a><a href="#h17-0-56" id="h17-0-56" class="i">+// The Client manages the background process that makes, populates &amp; fires
</a><a href="#h17-0-57" id="h17-0-57" class="i">+// Batches.
</a><a href="#h17-0-58" id="h17-0-58" class="i">+type Client struct {
</a><a href="#h17-0-59" id="h17-0-59" class="i">+	// Maximum number of items in a batch. If this is zero batches will only be
</a><a href="#h17-0-60" id="h17-0-60" class="i">+	// dispatched upon hitting the BatchTimeout. It is an error for both this and
</a><a href="#h17-0-61" id="h17-0-61" class="i">+	// the BatchTimeout to be zero.
</a><a href="#h17-0-62" id="h17-0-62" class="i">+	MaxBatchSize uint
</a><a href="#h17-0-63" id="h17-0-63" class="i">+
</a><a href="#h17-0-64" id="h17-0-64" class="i">+	// Duration after which to send a pending batch. If this is zero batches will
</a><a href="#h17-0-65" id="h17-0-65" class="i">+	// only be dispatched upon hitting the MaxBatchSize. It is an error for both
</a><a href="#h17-0-66" id="h17-0-66" class="i">+	// this and the MaxBatchSize to be zero.
</a><a href="#h17-0-67" id="h17-0-67" class="i">+	BatchTimeout time.Duration
</a><a href="#h17-0-68" id="h17-0-68" class="i">+
</a><a href="#h17-0-69" id="h17-0-69" class="i">+	// MaxConcurrentBatches determines how many parallel batches we&#39;ll allow to
</a><a href="#h17-0-70" id="h17-0-70" class="i">+	// be &quot;in flight&quot; concurrently. Once these many batches are in flight, the
</a><a href="#h17-0-71" id="h17-0-71" class="i">+	// PendingWorkCapacity determines when sending to the Work channel will start
</a><a href="#h17-0-72" id="h17-0-72" class="i">+	// blocking. In other words, once MaxConcurrentBatches hits, the system
</a><a href="#h17-0-73" id="h17-0-73" class="i">+	// starts blocking. This allows for tighter control over memory utilization.
</a><a href="#h17-0-74" id="h17-0-74" class="i">+	// If not set, the number of parallel batches in-flight will not be limited.
</a><a href="#h17-0-75" id="h17-0-75" class="i">+	MaxConcurrentBatches uint
</a><a href="#h17-0-76" id="h17-0-76" class="i">+
</a><a href="#h17-0-77" id="h17-0-77" class="i">+	// Capacity of work channel. If this is zero, the Work channel will be
</a><a href="#h17-0-78" id="h17-0-78" class="i">+	// blocking.
</a><a href="#h17-0-79" id="h17-0-79" class="i">+	PendingWorkCapacity uint
</a><a href="#h17-0-80" id="h17-0-80" class="i">+
</a><a href="#h17-0-81" id="h17-0-81" class="i">+	// This function should create a new empty Batch on each invocation.
</a><a href="#h17-0-82" id="h17-0-82" class="i">+	BatchMaker func() Batch
</a><a href="#h17-0-83" id="h17-0-83" class="i">+
</a><a href="#h17-0-84" id="h17-0-84" class="i">+	// Once this Client has been started, send work items here to add to batch.
</a><a href="#h17-0-85" id="h17-0-85" class="i">+	Work chan interface{}
</a><a href="#h17-0-86" id="h17-0-86" class="i">+
</a><a href="#h17-0-87" id="h17-0-87" class="i">+	klock     clock.Clock
</a><a href="#h17-0-88" id="h17-0-88" class="i">+	workGroup waitGroup
</a><a href="#h17-0-89" id="h17-0-89" class="i">+}
</a><a href="#h17-0-90" id="h17-0-90" class="i">+
</a><a href="#h17-0-91" id="h17-0-91" class="i">+func (c *Client) clock() clock.Clock {
</a><a href="#h17-0-92" id="h17-0-92" class="i">+	if c.klock == nil {
</a><a href="#h17-0-93" id="h17-0-93" class="i">+		return clock.New()
</a><a href="#h17-0-94" id="h17-0-94" class="i">+	}
</a><a href="#h17-0-95" id="h17-0-95" class="i">+	return c.klock
</a><a href="#h17-0-96" id="h17-0-96" class="i">+}
</a><a href="#h17-0-97" id="h17-0-97" class="i">+
</a><a href="#h17-0-98" id="h17-0-98" class="i">+// Start the background worker goroutines and get ready for accepting requests.
</a><a href="#h17-0-99" id="h17-0-99" class="i">+func (c *Client) Start() error {
</a><a href="#h17-0-100" id="h17-0-100" class="i">+	if int64(c.BatchTimeout) == 0 &amp;&amp; c.MaxBatchSize == 0 {
</a><a href="#h17-0-101" id="h17-0-101" class="i">+		return errZeroBoth
</a><a href="#h17-0-102" id="h17-0-102" class="i">+	}
</a><a href="#h17-0-103" id="h17-0-103" class="i">+
</a><a href="#h17-0-104" id="h17-0-104" class="i">+	if c.MaxConcurrentBatches == 0 {
</a><a href="#h17-0-105" id="h17-0-105" class="i">+		c.workGroup = &amp;sync.WaitGroup{}
</a><a href="#h17-0-106" id="h17-0-106" class="i">+	} else {
</a><a href="#h17-0-107" id="h17-0-107" class="i">+		c.workGroup = limitgroup.NewLimitGroup(c.MaxConcurrentBatches + 1)
</a><a href="#h17-0-108" id="h17-0-108" class="i">+	}
</a><a href="#h17-0-109" id="h17-0-109" class="i">+
</a><a href="#h17-0-110" id="h17-0-110" class="i">+	c.Work = make(chan interface{}, c.PendingWorkCapacity)
</a><a href="#h17-0-111" id="h17-0-111" class="i">+	c.workGroup.Add(1) // this is the worker itself
</a><a href="#h17-0-112" id="h17-0-112" class="i">+	go c.worker()
</a><a href="#h17-0-113" id="h17-0-113" class="i">+	return nil
</a><a href="#h17-0-114" id="h17-0-114" class="i">+}
</a><a href="#h17-0-115" id="h17-0-115" class="i">+
</a><a href="#h17-0-116" id="h17-0-116" class="i">+// Stop gracefully and return once all processing has finished.
</a><a href="#h17-0-117" id="h17-0-117" class="i">+func (c *Client) Stop() error {
</a><a href="#h17-0-118" id="h17-0-118" class="i">+	close(c.Work)
</a><a href="#h17-0-119" id="h17-0-119" class="i">+	c.workGroup.Wait()
</a><a href="#h17-0-120" id="h17-0-120" class="i">+	return nil
</a><a href="#h17-0-121" id="h17-0-121" class="i">+}
</a><a href="#h17-0-122" id="h17-0-122" class="i">+
</a><a href="#h17-0-123" id="h17-0-123" class="i">+// Background process.
</a><a href="#h17-0-124" id="h17-0-124" class="i">+func (c *Client) worker() {
</a><a href="#h17-0-125" id="h17-0-125" class="i">+	defer c.workGroup.Done()
</a><a href="#h17-0-126" id="h17-0-126" class="i">+	var batch = c.BatchMaker()
</a><a href="#h17-0-127" id="h17-0-127" class="i">+	var count uint
</a><a href="#h17-0-128" id="h17-0-128" class="i">+	var batchTimer *clock.Timer
</a><a href="#h17-0-129" id="h17-0-129" class="i">+	var batchTimeout &lt;-chan time.Time
</a><a href="#h17-0-130" id="h17-0-130" class="i">+	send := func() {
</a><a href="#h17-0-131" id="h17-0-131" class="i">+		c.workGroup.Add(1)
</a><a href="#h17-0-132" id="h17-0-132" class="i">+		go batch.Fire(c.workGroup)
</a><a href="#h17-0-133" id="h17-0-133" class="i">+		batch = c.BatchMaker()
</a><a href="#h17-0-134" id="h17-0-134" class="i">+		count = 0
</a><a href="#h17-0-135" id="h17-0-135" class="i">+		if batchTimer != nil {
</a><a href="#h17-0-136" id="h17-0-136" class="i">+			batchTimer.Stop()
</a><a href="#h17-0-137" id="h17-0-137" class="i">+		}
</a><a href="#h17-0-138" id="h17-0-138" class="i">+	}
</a><a href="#h17-0-139" id="h17-0-139" class="i">+	recv := func(item interface{}, open bool) bool {
</a><a href="#h17-0-140" id="h17-0-140" class="i">+		if !open {
</a><a href="#h17-0-141" id="h17-0-141" class="i">+			if count != 0 {
</a><a href="#h17-0-142" id="h17-0-142" class="i">+				send()
</a><a href="#h17-0-143" id="h17-0-143" class="i">+			}
</a><a href="#h17-0-144" id="h17-0-144" class="i">+			return true
</a><a href="#h17-0-145" id="h17-0-145" class="i">+		}
</a><a href="#h17-0-146" id="h17-0-146" class="i">+		batch.Add(item)
</a><a href="#h17-0-147" id="h17-0-147" class="i">+		count++
</a><a href="#h17-0-148" id="h17-0-148" class="i">+		if c.MaxBatchSize != 0 &amp;&amp; count &gt;= c.MaxBatchSize {
</a><a href="#h17-0-149" id="h17-0-149" class="i">+			send()
</a><a href="#h17-0-150" id="h17-0-150" class="i">+		} else if int64(c.BatchTimeout) != 0 &amp;&amp; count == 1 {
</a><a href="#h17-0-151" id="h17-0-151" class="i">+			batchTimer = c.clock().Timer(c.BatchTimeout)
</a><a href="#h17-0-152" id="h17-0-152" class="i">+			batchTimeout = batchTimer.C
</a><a href="#h17-0-153" id="h17-0-153" class="i">+		}
</a><a href="#h17-0-154" id="h17-0-154" class="i">+		return false
</a><a href="#h17-0-155" id="h17-0-155" class="i">+	}
</a><a href="#h17-0-156" id="h17-0-156" class="i">+	for {
</a><a href="#h17-0-157" id="h17-0-157" class="i">+		// We use two selects in order to first prefer draining the work queue.
</a><a href="#h17-0-158" id="h17-0-158" class="i">+		select {
</a><a href="#h17-0-159" id="h17-0-159" class="i">+		case item, open := &lt;-c.Work:
</a><a href="#h17-0-160" id="h17-0-160" class="i">+			if recv(item, open) {
</a><a href="#h17-0-161" id="h17-0-161" class="i">+				return
</a><a href="#h17-0-162" id="h17-0-162" class="i">+			}
</a><a href="#h17-0-163" id="h17-0-163" class="i">+		default:
</a><a href="#h17-0-164" id="h17-0-164" class="i">+			select {
</a><a href="#h17-0-165" id="h17-0-165" class="i">+			case item, open := &lt;-c.Work:
</a><a href="#h17-0-166" id="h17-0-166" class="i">+				if recv(item, open) {
</a><a href="#h17-0-167" id="h17-0-167" class="i">+					return
</a><a href="#h17-0-168" id="h17-0-168" class="i">+				}
</a><a href="#h17-0-169" id="h17-0-169" class="i">+			case &lt;-batchTimeout:
</a><a href="#h17-0-170" id="h17-0-170" class="i">+				send()
</a><a href="#h17-0-171" id="h17-0-171" class="i">+			}
</a><a href="#h17-0-172" id="h17-0-172" class="i">+		}
</a><a href="#h17-0-173" id="h17-0-173" class="i">+	}
</a><a href="#h17-0-174" id="h17-0-174" class="i">+}
</a><b>diff --git a/<a id="h18" href="../file/vendor/github.com/facebookgo/muster/patents">vendor/github.com/facebookgo/muster/patents</a> b/<a href="../file/vendor/github.com/facebookgo/muster/patents">vendor/github.com/facebookgo/muster/patents</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -0,0 +1,33 @@
</a><a href="#h18-0-0" id="h18-0-0" class="i">+Additional Grant of Patent Rights Version 2
</a><a href="#h18-0-1" id="h18-0-1" class="i">+
</a><a href="#h18-0-2" id="h18-0-2" class="i">+&quot;Software&quot; means the muster software distributed by Facebook, Inc.
</a><a href="#h18-0-3" id="h18-0-3" class="i">+
</a><a href="#h18-0-4" id="h18-0-4" class="i">+Facebook, Inc. (&quot;Facebook&quot;) hereby grants to each recipient of the Software
</a><a href="#h18-0-5" id="h18-0-5" class="i">+(&quot;you&quot;) a perpetual, worldwide, royalty-free, non-exclusive, irrevocable
</a><a href="#h18-0-6" id="h18-0-6" class="i">+(subject to the termination provision below) license under any Necessary
</a><a href="#h18-0-7" id="h18-0-7" class="i">+Claims, to make, have made, use, sell, offer to sell, import, and otherwise
</a><a href="#h18-0-8" id="h18-0-8" class="i">+transfer the Software. For avoidance of doubt, no license is granted under
</a><a href="#h18-0-9" id="h18-0-9" class="i">+Facebook’s rights in any patent claims that are infringed by (i) modifications
</a><a href="#h18-0-10" id="h18-0-10" class="i">+to the Software made by you or any third party or (ii) the Software in
</a><a href="#h18-0-11" id="h18-0-11" class="i">+combination with any software or other technology.
</a><a href="#h18-0-12" id="h18-0-12" class="i">+
</a><a href="#h18-0-13" id="h18-0-13" class="i">+The license granted hereunder will terminate, automatically and without notice,
</a><a href="#h18-0-14" id="h18-0-14" class="i">+if you (or any of your subsidiaries, corporate affiliates or agents) initiate
</a><a href="#h18-0-15" id="h18-0-15" class="i">+directly or indirectly, or take a direct financial interest in, any Patent
</a><a href="#h18-0-16" id="h18-0-16" class="i">+Assertion: (i) against Facebook or any of its subsidiaries or corporate
</a><a href="#h18-0-17" id="h18-0-17" class="i">+affiliates, (ii) against any party if such Patent Assertion arises in whole or
</a><a href="#h18-0-18" id="h18-0-18" class="i">+in part from any software, technology, product or service of Facebook or any of
</a><a href="#h18-0-19" id="h18-0-19" class="i">+its subsidiaries or corporate affiliates, or (iii) against any party relating
</a><a href="#h18-0-20" id="h18-0-20" class="i">+to the Software. Notwithstanding the foregoing, if Facebook or any of its
</a><a href="#h18-0-21" id="h18-0-21" class="i">+subsidiaries or corporate affiliates files a lawsuit alleging patent
</a><a href="#h18-0-22" id="h18-0-22" class="i">+infringement against you in the first instance, and you respond by filing a
</a><a href="#h18-0-23" id="h18-0-23" class="i">+patent infringement counterclaim in that lawsuit against that party that is
</a><a href="#h18-0-24" id="h18-0-24" class="i">+unrelated to the Software, the license granted hereunder will not terminate
</a><a href="#h18-0-25" id="h18-0-25" class="i">+under section (i) of this paragraph due to such counterclaim.
</a><a href="#h18-0-26" id="h18-0-26" class="i">+
</a><a href="#h18-0-27" id="h18-0-27" class="i">+A &quot;Necessary Claim&quot; is a claim of a patent owned by Facebook that is
</a><a href="#h18-0-28" id="h18-0-28" class="i">+necessarily infringed by the Software standing alone.
</a><a href="#h18-0-29" id="h18-0-29" class="i">+
</a><a href="#h18-0-30" id="h18-0-30" class="i">+A &quot;Patent Assertion&quot; is any lawsuit or other action alleging direct, indirect,
</a><a href="#h18-0-31" id="h18-0-31" class="i">+or contributory infringement or inducement to infringe any patent, including a
</a><a href="#h18-0-32" id="h18-0-32" class="i">+cross-claim or counterclaim.
</a><b>diff --git a/<a id="h19" href="../file/vendor/github.com/facebookgo/muster/readme.md">vendor/github.com/facebookgo/muster/readme.md</a> b/<a href="../file/vendor/github.com/facebookgo/muster/readme.md">vendor/github.com/facebookgo/muster/readme.md</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -0,0 +1,4 @@
</a><a href="#h19-0-0" id="h19-0-0" class="i">+muster [![Build Status](https://secure.travis-ci.org/facebookgo/muster.png)](http://travis-ci.org/facebookgo/muster)
</a><a href="#h19-0-1" id="h19-0-1" class="i">+======
</a><a href="#h19-0-2" id="h19-0-2" class="i">+
</a><a href="#h19-0-3" id="h19-0-3" class="i">+Documentation: http://godoc.org/github.com/facebookgo/muster
</a><b>diff --git a/<a id="h20" href="../file/vendor/github.com/golang/protobuf/LICENSE">vendor/github.com/golang/protobuf/LICENSE</a> b/<a href="../file/vendor/github.com/golang/protobuf/LICENSE">vendor/github.com/golang/protobuf/LICENSE</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -0,0 +1,31 @@
</a><a href="#h20-0-0" id="h20-0-0" class="i">+Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h20-0-1" id="h20-0-1" class="i">+
</a><a href="#h20-0-2" id="h20-0-2" class="i">+Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h20-0-3" id="h20-0-3" class="i">+https://github.com/golang/protobuf
</a><a href="#h20-0-4" id="h20-0-4" class="i">+
</a><a href="#h20-0-5" id="h20-0-5" class="i">+Redistribution and use in source and binary forms, with or without
</a><a href="#h20-0-6" id="h20-0-6" class="i">+modification, are permitted provided that the following conditions are
</a><a href="#h20-0-7" id="h20-0-7" class="i">+met:
</a><a href="#h20-0-8" id="h20-0-8" class="i">+
</a><a href="#h20-0-9" id="h20-0-9" class="i">+    * Redistributions of source code must retain the above copyright
</a><a href="#h20-0-10" id="h20-0-10" class="i">+notice, this list of conditions and the following disclaimer.
</a><a href="#h20-0-11" id="h20-0-11" class="i">+    * Redistributions in binary form must reproduce the above
</a><a href="#h20-0-12" id="h20-0-12" class="i">+copyright notice, this list of conditions and the following disclaimer
</a><a href="#h20-0-13" id="h20-0-13" class="i">+in the documentation and/or other materials provided with the
</a><a href="#h20-0-14" id="h20-0-14" class="i">+distribution.
</a><a href="#h20-0-15" id="h20-0-15" class="i">+    * Neither the name of Google Inc. nor the names of its
</a><a href="#h20-0-16" id="h20-0-16" class="i">+contributors may be used to endorse or promote products derived from
</a><a href="#h20-0-17" id="h20-0-17" class="i">+this software without specific prior written permission.
</a><a href="#h20-0-18" id="h20-0-18" class="i">+
</a><a href="#h20-0-19" id="h20-0-19" class="i">+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h20-0-20" id="h20-0-20" class="i">+&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h20-0-21" id="h20-0-21" class="i">+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h20-0-22" id="h20-0-22" class="i">+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h20-0-23" id="h20-0-23" class="i">+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h20-0-24" id="h20-0-24" class="i">+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h20-0-25" id="h20-0-25" class="i">+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h20-0-26" id="h20-0-26" class="i">+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h20-0-27" id="h20-0-27" class="i">+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h20-0-28" id="h20-0-28" class="i">+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h20-0-29" id="h20-0-29" class="i">+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h20-0-30" id="h20-0-30" class="i">+
</a><b>diff --git a/<a id="h21" href="../file/vendor/github.com/golang/protobuf/proto/BUILD">vendor/github.com/golang/protobuf/proto/BUILD</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/BUILD">vendor/github.com/golang/protobuf/proto/BUILD</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -0,0 +1,28 @@
</a><a href="#h21-0-0" id="h21-0-0" class="i">+
</a><a href="#h21-0-1" id="h21-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h21-0-2" id="h21-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h21-0-3" id="h21-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h21-0-4" id="h21-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h21-0-5" id="h21-0-5" class="i">+)
</a><a href="#h21-0-6" id="h21-0-6" class="i">+
</a><a href="#h21-0-7" id="h21-0-7" class="i">+go_library(
</a><a href="#h21-0-8" id="h21-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h21-0-9" id="h21-0-9" class="i">+  srcs = [
</a><a href="#h21-0-10" id="h21-0-10" class="i">+    &quot;clone.go&quot;,
</a><a href="#h21-0-11" id="h21-0-11" class="i">+    &quot;decode.go&quot;,
</a><a href="#h21-0-12" id="h21-0-12" class="i">+    &quot;encode.go&quot;,
</a><a href="#h21-0-13" id="h21-0-13" class="i">+    &quot;equal.go&quot;,
</a><a href="#h21-0-14" id="h21-0-14" class="i">+    &quot;extensions.go&quot;,
</a><a href="#h21-0-15" id="h21-0-15" class="i">+    &quot;lib.go&quot;,
</a><a href="#h21-0-16" id="h21-0-16" class="i">+    &quot;message_set.go&quot;,
</a><a href="#h21-0-17" id="h21-0-17" class="i">+    &quot;pointer_unsafe.go&quot;,
</a><a href="#h21-0-18" id="h21-0-18" class="i">+    &quot;properties.go&quot;,
</a><a href="#h21-0-19" id="h21-0-19" class="i">+    &quot;text.go&quot;,
</a><a href="#h21-0-20" id="h21-0-20" class="i">+    &quot;text_parser.go&quot;,
</a><a href="#h21-0-21" id="h21-0-21" class="i">+  ],
</a><a href="#h21-0-22" id="h21-0-22" class="i">+  deps = [
</a><a href="#h21-0-23" id="h21-0-23" class="i">+  ],
</a><a href="#h21-0-24" id="h21-0-24" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h21-0-25" id="h21-0-25" class="i">+)
</a><a href="#h21-0-26" id="h21-0-26" class="i">+
</a><a href="#h21-0-27" id="h21-0-27" class="i">+
</a><b>diff --git a/<a id="h22" href="../file/vendor/github.com/golang/protobuf/proto/Makefile">vendor/github.com/golang/protobuf/proto/Makefile</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/Makefile">vendor/github.com/golang/protobuf/proto/Makefile</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -0,0 +1,43 @@
</a><a href="#h22-0-0" id="h22-0-0" class="i">+# Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h22-0-1" id="h22-0-1" class="i">+#
</a><a href="#h22-0-2" id="h22-0-2" class="i">+# Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h22-0-3" id="h22-0-3" class="i">+# https://github.com/golang/protobuf
</a><a href="#h22-0-4" id="h22-0-4" class="i">+#
</a><a href="#h22-0-5" id="h22-0-5" class="i">+# Redistribution and use in source and binary forms, with or without
</a><a href="#h22-0-6" id="h22-0-6" class="i">+# modification, are permitted provided that the following conditions are
</a><a href="#h22-0-7" id="h22-0-7" class="i">+# met:
</a><a href="#h22-0-8" id="h22-0-8" class="i">+#
</a><a href="#h22-0-9" id="h22-0-9" class="i">+#     * Redistributions of source code must retain the above copyright
</a><a href="#h22-0-10" id="h22-0-10" class="i">+# notice, this list of conditions and the following disclaimer.
</a><a href="#h22-0-11" id="h22-0-11" class="i">+#     * Redistributions in binary form must reproduce the above
</a><a href="#h22-0-12" id="h22-0-12" class="i">+# copyright notice, this list of conditions and the following disclaimer
</a><a href="#h22-0-13" id="h22-0-13" class="i">+# in the documentation and/or other materials provided with the
</a><a href="#h22-0-14" id="h22-0-14" class="i">+# distribution.
</a><a href="#h22-0-15" id="h22-0-15" class="i">+#     * Neither the name of Google Inc. nor the names of its
</a><a href="#h22-0-16" id="h22-0-16" class="i">+# contributors may be used to endorse or promote products derived from
</a><a href="#h22-0-17" id="h22-0-17" class="i">+# this software without specific prior written permission.
</a><a href="#h22-0-18" id="h22-0-18" class="i">+#
</a><a href="#h22-0-19" id="h22-0-19" class="i">+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h22-0-20" id="h22-0-20" class="i">+# &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h22-0-21" id="h22-0-21" class="i">+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h22-0-22" id="h22-0-22" class="i">+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h22-0-23" id="h22-0-23" class="i">+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h22-0-24" id="h22-0-24" class="i">+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h22-0-25" id="h22-0-25" class="i">+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h22-0-26" id="h22-0-26" class="i">+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h22-0-27" id="h22-0-27" class="i">+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h22-0-28" id="h22-0-28" class="i">+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h22-0-29" id="h22-0-29" class="i">+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h22-0-30" id="h22-0-30" class="i">+
</a><a href="#h22-0-31" id="h22-0-31" class="i">+install:
</a><a href="#h22-0-32" id="h22-0-32" class="i">+	go install
</a><a href="#h22-0-33" id="h22-0-33" class="i">+
</a><a href="#h22-0-34" id="h22-0-34" class="i">+test: install generate-test-pbs
</a><a href="#h22-0-35" id="h22-0-35" class="i">+	go test
</a><a href="#h22-0-36" id="h22-0-36" class="i">+
</a><a href="#h22-0-37" id="h22-0-37" class="i">+
</a><a href="#h22-0-38" id="h22-0-38" class="i">+generate-test-pbs:
</a><a href="#h22-0-39" id="h22-0-39" class="i">+	make install
</a><a href="#h22-0-40" id="h22-0-40" class="i">+	make -C testdata
</a><a href="#h22-0-41" id="h22-0-41" class="i">+	protoc --go_out=Mtestdata/test.proto=github.com/golang/protobuf/proto/testdata,Mgoogle/protobuf/any.proto=github.com/golang/protobuf/ptypes/any:. proto3_proto/proto3.proto
</a><a href="#h22-0-42" id="h22-0-42" class="i">+	make
</a><b>diff --git a/<a id="h23" href="../file/vendor/github.com/golang/protobuf/proto/clone.go">vendor/github.com/golang/protobuf/proto/clone.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/clone.go">vendor/github.com/golang/protobuf/proto/clone.go</a></b>
<a href="#h23-0" id="h23-0" class="h">@@ -0,0 +1,229 @@
</a><a href="#h23-0-0" id="h23-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h23-0-1" id="h23-0-1" class="i">+//
</a><a href="#h23-0-2" id="h23-0-2" class="i">+// Copyright 2011 The Go Authors.  All rights reserved.
</a><a href="#h23-0-3" id="h23-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h23-0-4" id="h23-0-4" class="i">+//
</a><a href="#h23-0-5" id="h23-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h23-0-6" id="h23-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h23-0-7" id="h23-0-7" class="i">+// met:
</a><a href="#h23-0-8" id="h23-0-8" class="i">+//
</a><a href="#h23-0-9" id="h23-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h23-0-10" id="h23-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h23-0-11" id="h23-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h23-0-12" id="h23-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h23-0-13" id="h23-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h23-0-14" id="h23-0-14" class="i">+// distribution.
</a><a href="#h23-0-15" id="h23-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h23-0-16" id="h23-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h23-0-17" id="h23-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h23-0-18" id="h23-0-18" class="i">+//
</a><a href="#h23-0-19" id="h23-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h23-0-20" id="h23-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h23-0-21" id="h23-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h23-0-22" id="h23-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h23-0-23" id="h23-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h23-0-24" id="h23-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h23-0-25" id="h23-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h23-0-26" id="h23-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h23-0-27" id="h23-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h23-0-28" id="h23-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h23-0-29" id="h23-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h23-0-30" id="h23-0-30" class="i">+
</a><a href="#h23-0-31" id="h23-0-31" class="i">+// Protocol buffer deep copy and merge.
</a><a href="#h23-0-32" id="h23-0-32" class="i">+// TODO: RawMessage.
</a><a href="#h23-0-33" id="h23-0-33" class="i">+
</a><a href="#h23-0-34" id="h23-0-34" class="i">+package proto
</a><a href="#h23-0-35" id="h23-0-35" class="i">+
</a><a href="#h23-0-36" id="h23-0-36" class="i">+import (
</a><a href="#h23-0-37" id="h23-0-37" class="i">+	&quot;log&quot;
</a><a href="#h23-0-38" id="h23-0-38" class="i">+	&quot;reflect&quot;
</a><a href="#h23-0-39" id="h23-0-39" class="i">+	&quot;strings&quot;
</a><a href="#h23-0-40" id="h23-0-40" class="i">+)
</a><a href="#h23-0-41" id="h23-0-41" class="i">+
</a><a href="#h23-0-42" id="h23-0-42" class="i">+// Clone returns a deep copy of a protocol buffer.
</a><a href="#h23-0-43" id="h23-0-43" class="i">+func Clone(pb Message) Message {
</a><a href="#h23-0-44" id="h23-0-44" class="i">+	in := reflect.ValueOf(pb)
</a><a href="#h23-0-45" id="h23-0-45" class="i">+	if in.IsNil() {
</a><a href="#h23-0-46" id="h23-0-46" class="i">+		return pb
</a><a href="#h23-0-47" id="h23-0-47" class="i">+	}
</a><a href="#h23-0-48" id="h23-0-48" class="i">+
</a><a href="#h23-0-49" id="h23-0-49" class="i">+	out := reflect.New(in.Type().Elem())
</a><a href="#h23-0-50" id="h23-0-50" class="i">+	// out is empty so a merge is a deep copy.
</a><a href="#h23-0-51" id="h23-0-51" class="i">+	mergeStruct(out.Elem(), in.Elem())
</a><a href="#h23-0-52" id="h23-0-52" class="i">+	return out.Interface().(Message)
</a><a href="#h23-0-53" id="h23-0-53" class="i">+}
</a><a href="#h23-0-54" id="h23-0-54" class="i">+
</a><a href="#h23-0-55" id="h23-0-55" class="i">+// Merge merges src into dst.
</a><a href="#h23-0-56" id="h23-0-56" class="i">+// Required and optional fields that are set in src will be set to that value in dst.
</a><a href="#h23-0-57" id="h23-0-57" class="i">+// Elements of repeated fields will be appended.
</a><a href="#h23-0-58" id="h23-0-58" class="i">+// Merge panics if src and dst are not the same type, or if dst is nil.
</a><a href="#h23-0-59" id="h23-0-59" class="i">+func Merge(dst, src Message) {
</a><a href="#h23-0-60" id="h23-0-60" class="i">+	in := reflect.ValueOf(src)
</a><a href="#h23-0-61" id="h23-0-61" class="i">+	out := reflect.ValueOf(dst)
</a><a href="#h23-0-62" id="h23-0-62" class="i">+	if out.IsNil() {
</a><a href="#h23-0-63" id="h23-0-63" class="i">+		panic(&quot;proto: nil destination&quot;)
</a><a href="#h23-0-64" id="h23-0-64" class="i">+	}
</a><a href="#h23-0-65" id="h23-0-65" class="i">+	if in.Type() != out.Type() {
</a><a href="#h23-0-66" id="h23-0-66" class="i">+		// Explicit test prior to mergeStruct so that mistyped nils will fail
</a><a href="#h23-0-67" id="h23-0-67" class="i">+		panic(&quot;proto: type mismatch&quot;)
</a><a href="#h23-0-68" id="h23-0-68" class="i">+	}
</a><a href="#h23-0-69" id="h23-0-69" class="i">+	if in.IsNil() {
</a><a href="#h23-0-70" id="h23-0-70" class="i">+		// Merging nil into non-nil is a quiet no-op
</a><a href="#h23-0-71" id="h23-0-71" class="i">+		return
</a><a href="#h23-0-72" id="h23-0-72" class="i">+	}
</a><a href="#h23-0-73" id="h23-0-73" class="i">+	mergeStruct(out.Elem(), in.Elem())
</a><a href="#h23-0-74" id="h23-0-74" class="i">+}
</a><a href="#h23-0-75" id="h23-0-75" class="i">+
</a><a href="#h23-0-76" id="h23-0-76" class="i">+func mergeStruct(out, in reflect.Value) {
</a><a href="#h23-0-77" id="h23-0-77" class="i">+	sprop := GetProperties(in.Type())
</a><a href="#h23-0-78" id="h23-0-78" class="i">+	for i := 0; i &lt; in.NumField(); i++ {
</a><a href="#h23-0-79" id="h23-0-79" class="i">+		f := in.Type().Field(i)
</a><a href="#h23-0-80" id="h23-0-80" class="i">+		if strings.HasPrefix(f.Name, &quot;XXX_&quot;) {
</a><a href="#h23-0-81" id="h23-0-81" class="i">+			continue
</a><a href="#h23-0-82" id="h23-0-82" class="i">+		}
</a><a href="#h23-0-83" id="h23-0-83" class="i">+		mergeAny(out.Field(i), in.Field(i), false, sprop.Prop[i])
</a><a href="#h23-0-84" id="h23-0-84" class="i">+	}
</a><a href="#h23-0-85" id="h23-0-85" class="i">+
</a><a href="#h23-0-86" id="h23-0-86" class="i">+	if emIn, ok := extendable(in.Addr().Interface()); ok {
</a><a href="#h23-0-87" id="h23-0-87" class="i">+		emOut, _ := extendable(out.Addr().Interface())
</a><a href="#h23-0-88" id="h23-0-88" class="i">+		mIn, muIn := emIn.extensionsRead()
</a><a href="#h23-0-89" id="h23-0-89" class="i">+		if mIn != nil {
</a><a href="#h23-0-90" id="h23-0-90" class="i">+			mOut := emOut.extensionsWrite()
</a><a href="#h23-0-91" id="h23-0-91" class="i">+			muIn.Lock()
</a><a href="#h23-0-92" id="h23-0-92" class="i">+			mergeExtension(mOut, mIn)
</a><a href="#h23-0-93" id="h23-0-93" class="i">+			muIn.Unlock()
</a><a href="#h23-0-94" id="h23-0-94" class="i">+		}
</a><a href="#h23-0-95" id="h23-0-95" class="i">+	}
</a><a href="#h23-0-96" id="h23-0-96" class="i">+
</a><a href="#h23-0-97" id="h23-0-97" class="i">+	uf := in.FieldByName(&quot;XXX_unrecognized&quot;)
</a><a href="#h23-0-98" id="h23-0-98" class="i">+	if !uf.IsValid() {
</a><a href="#h23-0-99" id="h23-0-99" class="i">+		return
</a><a href="#h23-0-100" id="h23-0-100" class="i">+	}
</a><a href="#h23-0-101" id="h23-0-101" class="i">+	uin := uf.Bytes()
</a><a href="#h23-0-102" id="h23-0-102" class="i">+	if len(uin) &gt; 0 {
</a><a href="#h23-0-103" id="h23-0-103" class="i">+		out.FieldByName(&quot;XXX_unrecognized&quot;).SetBytes(append([]byte(nil), uin...))
</a><a href="#h23-0-104" id="h23-0-104" class="i">+	}
</a><a href="#h23-0-105" id="h23-0-105" class="i">+}
</a><a href="#h23-0-106" id="h23-0-106" class="i">+
</a><a href="#h23-0-107" id="h23-0-107" class="i">+// mergeAny performs a merge between two values of the same type.
</a><a href="#h23-0-108" id="h23-0-108" class="i">+// viaPtr indicates whether the values were indirected through a pointer (implying proto2).
</a><a href="#h23-0-109" id="h23-0-109" class="i">+// prop is set if this is a struct field (it may be nil).
</a><a href="#h23-0-110" id="h23-0-110" class="i">+func mergeAny(out, in reflect.Value, viaPtr bool, prop *Properties) {
</a><a href="#h23-0-111" id="h23-0-111" class="i">+	if in.Type() == protoMessageType {
</a><a href="#h23-0-112" id="h23-0-112" class="i">+		if !in.IsNil() {
</a><a href="#h23-0-113" id="h23-0-113" class="i">+			if out.IsNil() {
</a><a href="#h23-0-114" id="h23-0-114" class="i">+				out.Set(reflect.ValueOf(Clone(in.Interface().(Message))))
</a><a href="#h23-0-115" id="h23-0-115" class="i">+			} else {
</a><a href="#h23-0-116" id="h23-0-116" class="i">+				Merge(out.Interface().(Message), in.Interface().(Message))
</a><a href="#h23-0-117" id="h23-0-117" class="i">+			}
</a><a href="#h23-0-118" id="h23-0-118" class="i">+		}
</a><a href="#h23-0-119" id="h23-0-119" class="i">+		return
</a><a href="#h23-0-120" id="h23-0-120" class="i">+	}
</a><a href="#h23-0-121" id="h23-0-121" class="i">+	switch in.Kind() {
</a><a href="#h23-0-122" id="h23-0-122" class="i">+	case reflect.Bool, reflect.Float32, reflect.Float64, reflect.Int32, reflect.Int64,
</a><a href="#h23-0-123" id="h23-0-123" class="i">+		reflect.String, reflect.Uint32, reflect.Uint64:
</a><a href="#h23-0-124" id="h23-0-124" class="i">+		if !viaPtr &amp;&amp; isProto3Zero(in) {
</a><a href="#h23-0-125" id="h23-0-125" class="i">+			return
</a><a href="#h23-0-126" id="h23-0-126" class="i">+		}
</a><a href="#h23-0-127" id="h23-0-127" class="i">+		out.Set(in)
</a><a href="#h23-0-128" id="h23-0-128" class="i">+	case reflect.Interface:
</a><a href="#h23-0-129" id="h23-0-129" class="i">+		// Probably a oneof field; copy non-nil values.
</a><a href="#h23-0-130" id="h23-0-130" class="i">+		if in.IsNil() {
</a><a href="#h23-0-131" id="h23-0-131" class="i">+			return
</a><a href="#h23-0-132" id="h23-0-132" class="i">+		}
</a><a href="#h23-0-133" id="h23-0-133" class="i">+		// Allocate destination if it is not set, or set to a different type.
</a><a href="#h23-0-134" id="h23-0-134" class="i">+		// Otherwise we will merge as normal.
</a><a href="#h23-0-135" id="h23-0-135" class="i">+		if out.IsNil() || out.Elem().Type() != in.Elem().Type() {
</a><a href="#h23-0-136" id="h23-0-136" class="i">+			out.Set(reflect.New(in.Elem().Elem().Type())) // interface -&gt; *T -&gt; T -&gt; new(T)
</a><a href="#h23-0-137" id="h23-0-137" class="i">+		}
</a><a href="#h23-0-138" id="h23-0-138" class="i">+		mergeAny(out.Elem(), in.Elem(), false, nil)
</a><a href="#h23-0-139" id="h23-0-139" class="i">+	case reflect.Map:
</a><a href="#h23-0-140" id="h23-0-140" class="i">+		if in.Len() == 0 {
</a><a href="#h23-0-141" id="h23-0-141" class="i">+			return
</a><a href="#h23-0-142" id="h23-0-142" class="i">+		}
</a><a href="#h23-0-143" id="h23-0-143" class="i">+		if out.IsNil() {
</a><a href="#h23-0-144" id="h23-0-144" class="i">+			out.Set(reflect.MakeMap(in.Type()))
</a><a href="#h23-0-145" id="h23-0-145" class="i">+		}
</a><a href="#h23-0-146" id="h23-0-146" class="i">+		// For maps with value types of *T or []byte we need to deep copy each value.
</a><a href="#h23-0-147" id="h23-0-147" class="i">+		elemKind := in.Type().Elem().Kind()
</a><a href="#h23-0-148" id="h23-0-148" class="i">+		for _, key := range in.MapKeys() {
</a><a href="#h23-0-149" id="h23-0-149" class="i">+			var val reflect.Value
</a><a href="#h23-0-150" id="h23-0-150" class="i">+			switch elemKind {
</a><a href="#h23-0-151" id="h23-0-151" class="i">+			case reflect.Ptr:
</a><a href="#h23-0-152" id="h23-0-152" class="i">+				val = reflect.New(in.Type().Elem().Elem())
</a><a href="#h23-0-153" id="h23-0-153" class="i">+				mergeAny(val, in.MapIndex(key), false, nil)
</a><a href="#h23-0-154" id="h23-0-154" class="i">+			case reflect.Slice:
</a><a href="#h23-0-155" id="h23-0-155" class="i">+				val = in.MapIndex(key)
</a><a href="#h23-0-156" id="h23-0-156" class="i">+				val = reflect.ValueOf(append([]byte{}, val.Bytes()...))
</a><a href="#h23-0-157" id="h23-0-157" class="i">+			default:
</a><a href="#h23-0-158" id="h23-0-158" class="i">+				val = in.MapIndex(key)
</a><a href="#h23-0-159" id="h23-0-159" class="i">+			}
</a><a href="#h23-0-160" id="h23-0-160" class="i">+			out.SetMapIndex(key, val)
</a><a href="#h23-0-161" id="h23-0-161" class="i">+		}
</a><a href="#h23-0-162" id="h23-0-162" class="i">+	case reflect.Ptr:
</a><a href="#h23-0-163" id="h23-0-163" class="i">+		if in.IsNil() {
</a><a href="#h23-0-164" id="h23-0-164" class="i">+			return
</a><a href="#h23-0-165" id="h23-0-165" class="i">+		}
</a><a href="#h23-0-166" id="h23-0-166" class="i">+		if out.IsNil() {
</a><a href="#h23-0-167" id="h23-0-167" class="i">+			out.Set(reflect.New(in.Elem().Type()))
</a><a href="#h23-0-168" id="h23-0-168" class="i">+		}
</a><a href="#h23-0-169" id="h23-0-169" class="i">+		mergeAny(out.Elem(), in.Elem(), true, nil)
</a><a href="#h23-0-170" id="h23-0-170" class="i">+	case reflect.Slice:
</a><a href="#h23-0-171" id="h23-0-171" class="i">+		if in.IsNil() {
</a><a href="#h23-0-172" id="h23-0-172" class="i">+			return
</a><a href="#h23-0-173" id="h23-0-173" class="i">+		}
</a><a href="#h23-0-174" id="h23-0-174" class="i">+		if in.Type().Elem().Kind() == reflect.Uint8 {
</a><a href="#h23-0-175" id="h23-0-175" class="i">+			// []byte is a scalar bytes field, not a repeated field.
</a><a href="#h23-0-176" id="h23-0-176" class="i">+
</a><a href="#h23-0-177" id="h23-0-177" class="i">+			// Edge case: if this is in a proto3 message, a zero length
</a><a href="#h23-0-178" id="h23-0-178" class="i">+			// bytes field is considered the zero value, and should not
</a><a href="#h23-0-179" id="h23-0-179" class="i">+			// be merged.
</a><a href="#h23-0-180" id="h23-0-180" class="i">+			if prop != nil &amp;&amp; prop.proto3 &amp;&amp; in.Len() == 0 {
</a><a href="#h23-0-181" id="h23-0-181" class="i">+				return
</a><a href="#h23-0-182" id="h23-0-182" class="i">+			}
</a><a href="#h23-0-183" id="h23-0-183" class="i">+
</a><a href="#h23-0-184" id="h23-0-184" class="i">+			// Make a deep copy.
</a><a href="#h23-0-185" id="h23-0-185" class="i">+			// Append to []byte{} instead of []byte(nil) so that we never end up
</a><a href="#h23-0-186" id="h23-0-186" class="i">+			// with a nil result.
</a><a href="#h23-0-187" id="h23-0-187" class="i">+			out.SetBytes(append([]byte{}, in.Bytes()...))
</a><a href="#h23-0-188" id="h23-0-188" class="i">+			return
</a><a href="#h23-0-189" id="h23-0-189" class="i">+		}
</a><a href="#h23-0-190" id="h23-0-190" class="i">+		n := in.Len()
</a><a href="#h23-0-191" id="h23-0-191" class="i">+		if out.IsNil() {
</a><a href="#h23-0-192" id="h23-0-192" class="i">+			out.Set(reflect.MakeSlice(in.Type(), 0, n))
</a><a href="#h23-0-193" id="h23-0-193" class="i">+		}
</a><a href="#h23-0-194" id="h23-0-194" class="i">+		switch in.Type().Elem().Kind() {
</a><a href="#h23-0-195" id="h23-0-195" class="i">+		case reflect.Bool, reflect.Float32, reflect.Float64, reflect.Int32, reflect.Int64,
</a><a href="#h23-0-196" id="h23-0-196" class="i">+			reflect.String, reflect.Uint32, reflect.Uint64:
</a><a href="#h23-0-197" id="h23-0-197" class="i">+			out.Set(reflect.AppendSlice(out, in))
</a><a href="#h23-0-198" id="h23-0-198" class="i">+		default:
</a><a href="#h23-0-199" id="h23-0-199" class="i">+			for i := 0; i &lt; n; i++ {
</a><a href="#h23-0-200" id="h23-0-200" class="i">+				x := reflect.Indirect(reflect.New(in.Type().Elem()))
</a><a href="#h23-0-201" id="h23-0-201" class="i">+				mergeAny(x, in.Index(i), false, nil)
</a><a href="#h23-0-202" id="h23-0-202" class="i">+				out.Set(reflect.Append(out, x))
</a><a href="#h23-0-203" id="h23-0-203" class="i">+			}
</a><a href="#h23-0-204" id="h23-0-204" class="i">+		}
</a><a href="#h23-0-205" id="h23-0-205" class="i">+	case reflect.Struct:
</a><a href="#h23-0-206" id="h23-0-206" class="i">+		mergeStruct(out, in)
</a><a href="#h23-0-207" id="h23-0-207" class="i">+	default:
</a><a href="#h23-0-208" id="h23-0-208" class="i">+		// unknown type, so not a protocol buffer
</a><a href="#h23-0-209" id="h23-0-209" class="i">+		log.Printf(&quot;proto: don&#39;t know how to copy %v&quot;, in)
</a><a href="#h23-0-210" id="h23-0-210" class="i">+	}
</a><a href="#h23-0-211" id="h23-0-211" class="i">+}
</a><a href="#h23-0-212" id="h23-0-212" class="i">+
</a><a href="#h23-0-213" id="h23-0-213" class="i">+func mergeExtension(out, in map[int32]Extension) {
</a><a href="#h23-0-214" id="h23-0-214" class="i">+	for extNum, eIn := range in {
</a><a href="#h23-0-215" id="h23-0-215" class="i">+		eOut := Extension{desc: eIn.desc}
</a><a href="#h23-0-216" id="h23-0-216" class="i">+		if eIn.value != nil {
</a><a href="#h23-0-217" id="h23-0-217" class="i">+			v := reflect.New(reflect.TypeOf(eIn.value)).Elem()
</a><a href="#h23-0-218" id="h23-0-218" class="i">+			mergeAny(v, reflect.ValueOf(eIn.value), false, nil)
</a><a href="#h23-0-219" id="h23-0-219" class="i">+			eOut.value = v.Interface()
</a><a href="#h23-0-220" id="h23-0-220" class="i">+		}
</a><a href="#h23-0-221" id="h23-0-221" class="i">+		if eIn.enc != nil {
</a><a href="#h23-0-222" id="h23-0-222" class="i">+			eOut.enc = make([]byte, len(eIn.enc))
</a><a href="#h23-0-223" id="h23-0-223" class="i">+			copy(eOut.enc, eIn.enc)
</a><a href="#h23-0-224" id="h23-0-224" class="i">+		}
</a><a href="#h23-0-225" id="h23-0-225" class="i">+
</a><a href="#h23-0-226" id="h23-0-226" class="i">+		out[extNum] = eOut
</a><a href="#h23-0-227" id="h23-0-227" class="i">+	}
</a><a href="#h23-0-228" id="h23-0-228" class="i">+}
</a><b>diff --git a/<a id="h24" href="../file/vendor/github.com/golang/protobuf/proto/decode.go">vendor/github.com/golang/protobuf/proto/decode.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/decode.go">vendor/github.com/golang/protobuf/proto/decode.go</a></b>
<a href="#h24-0" id="h24-0" class="h">@@ -0,0 +1,874 @@
</a><a href="#h24-0-0" id="h24-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h24-0-1" id="h24-0-1" class="i">+//
</a><a href="#h24-0-2" id="h24-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h24-0-3" id="h24-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h24-0-4" id="h24-0-4" class="i">+//
</a><a href="#h24-0-5" id="h24-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h24-0-6" id="h24-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h24-0-7" id="h24-0-7" class="i">+// met:
</a><a href="#h24-0-8" id="h24-0-8" class="i">+//
</a><a href="#h24-0-9" id="h24-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h24-0-10" id="h24-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h24-0-11" id="h24-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h24-0-12" id="h24-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h24-0-13" id="h24-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h24-0-14" id="h24-0-14" class="i">+// distribution.
</a><a href="#h24-0-15" id="h24-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h24-0-16" id="h24-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h24-0-17" id="h24-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h24-0-18" id="h24-0-18" class="i">+//
</a><a href="#h24-0-19" id="h24-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h24-0-20" id="h24-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h24-0-21" id="h24-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h24-0-22" id="h24-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h24-0-23" id="h24-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h24-0-24" id="h24-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h24-0-25" id="h24-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h24-0-26" id="h24-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h24-0-27" id="h24-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h24-0-28" id="h24-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h24-0-29" id="h24-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h24-0-30" id="h24-0-30" class="i">+
</a><a href="#h24-0-31" id="h24-0-31" class="i">+package proto
</a><a href="#h24-0-32" id="h24-0-32" class="i">+
</a><a href="#h24-0-33" id="h24-0-33" class="i">+/*
</a><a href="#h24-0-34" id="h24-0-34" class="i">+ * Routines for decoding protocol buffer data to construct in-memory representations.
</a><a href="#h24-0-35" id="h24-0-35" class="i">+ */
</a><a href="#h24-0-36" id="h24-0-36" class="i">+
</a><a href="#h24-0-37" id="h24-0-37" class="i">+import (
</a><a href="#h24-0-38" id="h24-0-38" class="i">+	&quot;errors&quot;
</a><a href="#h24-0-39" id="h24-0-39" class="i">+	&quot;fmt&quot;
</a><a href="#h24-0-40" id="h24-0-40" class="i">+	&quot;io&quot;
</a><a href="#h24-0-41" id="h24-0-41" class="i">+	&quot;os&quot;
</a><a href="#h24-0-42" id="h24-0-42" class="i">+	&quot;reflect&quot;
</a><a href="#h24-0-43" id="h24-0-43" class="i">+)
</a><a href="#h24-0-44" id="h24-0-44" class="i">+
</a><a href="#h24-0-45" id="h24-0-45" class="i">+// errOverflow is returned when an integer is too large to be represented.
</a><a href="#h24-0-46" id="h24-0-46" class="i">+var errOverflow = errors.New(&quot;proto: integer overflow&quot;)
</a><a href="#h24-0-47" id="h24-0-47" class="i">+
</a><a href="#h24-0-48" id="h24-0-48" class="i">+// ErrInternalBadWireType is returned by generated code when an incorrect
</a><a href="#h24-0-49" id="h24-0-49" class="i">+// wire type is encountered. It does not get returned to user code.
</a><a href="#h24-0-50" id="h24-0-50" class="i">+var ErrInternalBadWireType = errors.New(&quot;proto: internal error: bad wiretype for oneof&quot;)
</a><a href="#h24-0-51" id="h24-0-51" class="i">+
</a><a href="#h24-0-52" id="h24-0-52" class="i">+// The fundamental decoders that interpret bytes on the wire.
</a><a href="#h24-0-53" id="h24-0-53" class="i">+// Those that take integer types all return uint64 and are
</a><a href="#h24-0-54" id="h24-0-54" class="i">+// therefore of type valueDecoder.
</a><a href="#h24-0-55" id="h24-0-55" class="i">+
</a><a href="#h24-0-56" id="h24-0-56" class="i">+// DecodeVarint reads a varint-encoded integer from the slice.
</a><a href="#h24-0-57" id="h24-0-57" class="i">+// It returns the integer and the number of bytes consumed, or
</a><a href="#h24-0-58" id="h24-0-58" class="i">+// zero if there is not enough.
</a><a href="#h24-0-59" id="h24-0-59" class="i">+// This is the format for the
</a><a href="#h24-0-60" id="h24-0-60" class="i">+// int32, int64, uint32, uint64, bool, and enum
</a><a href="#h24-0-61" id="h24-0-61" class="i">+// protocol buffer types.
</a><a href="#h24-0-62" id="h24-0-62" class="i">+func DecodeVarint(buf []byte) (x uint64, n int) {
</a><a href="#h24-0-63" id="h24-0-63" class="i">+	// x, n already 0
</a><a href="#h24-0-64" id="h24-0-64" class="i">+	for shift := uint(0); shift &lt; 64; shift += 7 {
</a><a href="#h24-0-65" id="h24-0-65" class="i">+		if n &gt;= len(buf) {
</a><a href="#h24-0-66" id="h24-0-66" class="i">+			return 0, 0
</a><a href="#h24-0-67" id="h24-0-67" class="i">+		}
</a><a href="#h24-0-68" id="h24-0-68" class="i">+		b := uint64(buf[n])
</a><a href="#h24-0-69" id="h24-0-69" class="i">+		n++
</a><a href="#h24-0-70" id="h24-0-70" class="i">+		x |= (b &amp; 0x7F) &lt;&lt; shift
</a><a href="#h24-0-71" id="h24-0-71" class="i">+		if (b &amp; 0x80) == 0 {
</a><a href="#h24-0-72" id="h24-0-72" class="i">+			return x, n
</a><a href="#h24-0-73" id="h24-0-73" class="i">+		}
</a><a href="#h24-0-74" id="h24-0-74" class="i">+	}
</a><a href="#h24-0-75" id="h24-0-75" class="i">+
</a><a href="#h24-0-76" id="h24-0-76" class="i">+	// The number is too large to represent in a 64-bit value.
</a><a href="#h24-0-77" id="h24-0-77" class="i">+	return 0, 0
</a><a href="#h24-0-78" id="h24-0-78" class="i">+}
</a><a href="#h24-0-79" id="h24-0-79" class="i">+
</a><a href="#h24-0-80" id="h24-0-80" class="i">+// DecodeVarint reads a varint-encoded integer from the Buffer.
</a><a href="#h24-0-81" id="h24-0-81" class="i">+// This is the format for the
</a><a href="#h24-0-82" id="h24-0-82" class="i">+// int32, int64, uint32, uint64, bool, and enum
</a><a href="#h24-0-83" id="h24-0-83" class="i">+// protocol buffer types.
</a><a href="#h24-0-84" id="h24-0-84" class="i">+func (p *Buffer) DecodeVarint() (x uint64, err error) {
</a><a href="#h24-0-85" id="h24-0-85" class="i">+	// x, err already 0
</a><a href="#h24-0-86" id="h24-0-86" class="i">+
</a><a href="#h24-0-87" id="h24-0-87" class="i">+	i := p.index
</a><a href="#h24-0-88" id="h24-0-88" class="i">+	l := len(p.buf)
</a><a href="#h24-0-89" id="h24-0-89" class="i">+
</a><a href="#h24-0-90" id="h24-0-90" class="i">+	for shift := uint(0); shift &lt; 64; shift += 7 {
</a><a href="#h24-0-91" id="h24-0-91" class="i">+		if i &gt;= l {
</a><a href="#h24-0-92" id="h24-0-92" class="i">+			err = io.ErrUnexpectedEOF
</a><a href="#h24-0-93" id="h24-0-93" class="i">+			return
</a><a href="#h24-0-94" id="h24-0-94" class="i">+		}
</a><a href="#h24-0-95" id="h24-0-95" class="i">+		b := p.buf[i]
</a><a href="#h24-0-96" id="h24-0-96" class="i">+		i++
</a><a href="#h24-0-97" id="h24-0-97" class="i">+		x |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
</a><a href="#h24-0-98" id="h24-0-98" class="i">+		if b &lt; 0x80 {
</a><a href="#h24-0-99" id="h24-0-99" class="i">+			p.index = i
</a><a href="#h24-0-100" id="h24-0-100" class="i">+			return
</a><a href="#h24-0-101" id="h24-0-101" class="i">+		}
</a><a href="#h24-0-102" id="h24-0-102" class="i">+	}
</a><a href="#h24-0-103" id="h24-0-103" class="i">+
</a><a href="#h24-0-104" id="h24-0-104" class="i">+	// The number is too large to represent in a 64-bit value.
</a><a href="#h24-0-105" id="h24-0-105" class="i">+	err = errOverflow
</a><a href="#h24-0-106" id="h24-0-106" class="i">+	return
</a><a href="#h24-0-107" id="h24-0-107" class="i">+}
</a><a href="#h24-0-108" id="h24-0-108" class="i">+
</a><a href="#h24-0-109" id="h24-0-109" class="i">+// DecodeFixed64 reads a 64-bit integer from the Buffer.
</a><a href="#h24-0-110" id="h24-0-110" class="i">+// This is the format for the
</a><a href="#h24-0-111" id="h24-0-111" class="i">+// fixed64, sfixed64, and double protocol buffer types.
</a><a href="#h24-0-112" id="h24-0-112" class="i">+func (p *Buffer) DecodeFixed64() (x uint64, err error) {
</a><a href="#h24-0-113" id="h24-0-113" class="i">+	// x, err already 0
</a><a href="#h24-0-114" id="h24-0-114" class="i">+	i := p.index + 8
</a><a href="#h24-0-115" id="h24-0-115" class="i">+	if i &lt; 0 || i &gt; len(p.buf) {
</a><a href="#h24-0-116" id="h24-0-116" class="i">+		err = io.ErrUnexpectedEOF
</a><a href="#h24-0-117" id="h24-0-117" class="i">+		return
</a><a href="#h24-0-118" id="h24-0-118" class="i">+	}
</a><a href="#h24-0-119" id="h24-0-119" class="i">+	p.index = i
</a><a href="#h24-0-120" id="h24-0-120" class="i">+
</a><a href="#h24-0-121" id="h24-0-121" class="i">+	x = uint64(p.buf[i-8])
</a><a href="#h24-0-122" id="h24-0-122" class="i">+	x |= uint64(p.buf[i-7]) &lt;&lt; 8
</a><a href="#h24-0-123" id="h24-0-123" class="i">+	x |= uint64(p.buf[i-6]) &lt;&lt; 16
</a><a href="#h24-0-124" id="h24-0-124" class="i">+	x |= uint64(p.buf[i-5]) &lt;&lt; 24
</a><a href="#h24-0-125" id="h24-0-125" class="i">+	x |= uint64(p.buf[i-4]) &lt;&lt; 32
</a><a href="#h24-0-126" id="h24-0-126" class="i">+	x |= uint64(p.buf[i-3]) &lt;&lt; 40
</a><a href="#h24-0-127" id="h24-0-127" class="i">+	x |= uint64(p.buf[i-2]) &lt;&lt; 48
</a><a href="#h24-0-128" id="h24-0-128" class="i">+	x |= uint64(p.buf[i-1]) &lt;&lt; 56
</a><a href="#h24-0-129" id="h24-0-129" class="i">+	return
</a><a href="#h24-0-130" id="h24-0-130" class="i">+}
</a><a href="#h24-0-131" id="h24-0-131" class="i">+
</a><a href="#h24-0-132" id="h24-0-132" class="i">+// DecodeFixed32 reads a 32-bit integer from the Buffer.
</a><a href="#h24-0-133" id="h24-0-133" class="i">+// This is the format for the
</a><a href="#h24-0-134" id="h24-0-134" class="i">+// fixed32, sfixed32, and float protocol buffer types.
</a><a href="#h24-0-135" id="h24-0-135" class="i">+func (p *Buffer) DecodeFixed32() (x uint64, err error) {
</a><a href="#h24-0-136" id="h24-0-136" class="i">+	// x, err already 0
</a><a href="#h24-0-137" id="h24-0-137" class="i">+	i := p.index + 4
</a><a href="#h24-0-138" id="h24-0-138" class="i">+	if i &lt; 0 || i &gt; len(p.buf) {
</a><a href="#h24-0-139" id="h24-0-139" class="i">+		err = io.ErrUnexpectedEOF
</a><a href="#h24-0-140" id="h24-0-140" class="i">+		return
</a><a href="#h24-0-141" id="h24-0-141" class="i">+	}
</a><a href="#h24-0-142" id="h24-0-142" class="i">+	p.index = i
</a><a href="#h24-0-143" id="h24-0-143" class="i">+
</a><a href="#h24-0-144" id="h24-0-144" class="i">+	x = uint64(p.buf[i-4])
</a><a href="#h24-0-145" id="h24-0-145" class="i">+	x |= uint64(p.buf[i-3]) &lt;&lt; 8
</a><a href="#h24-0-146" id="h24-0-146" class="i">+	x |= uint64(p.buf[i-2]) &lt;&lt; 16
</a><a href="#h24-0-147" id="h24-0-147" class="i">+	x |= uint64(p.buf[i-1]) &lt;&lt; 24
</a><a href="#h24-0-148" id="h24-0-148" class="i">+	return
</a><a href="#h24-0-149" id="h24-0-149" class="i">+}
</a><a href="#h24-0-150" id="h24-0-150" class="i">+
</a><a href="#h24-0-151" id="h24-0-151" class="i">+// DecodeZigzag64 reads a zigzag-encoded 64-bit integer
</a><a href="#h24-0-152" id="h24-0-152" class="i">+// from the Buffer.
</a><a href="#h24-0-153" id="h24-0-153" class="i">+// This is the format used for the sint64 protocol buffer type.
</a><a href="#h24-0-154" id="h24-0-154" class="i">+func (p *Buffer) DecodeZigzag64() (x uint64, err error) {
</a><a href="#h24-0-155" id="h24-0-155" class="i">+	x, err = p.DecodeVarint()
</a><a href="#h24-0-156" id="h24-0-156" class="i">+	if err != nil {
</a><a href="#h24-0-157" id="h24-0-157" class="i">+		return
</a><a href="#h24-0-158" id="h24-0-158" class="i">+	}
</a><a href="#h24-0-159" id="h24-0-159" class="i">+	x = (x &gt;&gt; 1) ^ uint64((int64(x&amp;1)&lt;&lt;63)&gt;&gt;63)
</a><a href="#h24-0-160" id="h24-0-160" class="i">+	return
</a><a href="#h24-0-161" id="h24-0-161" class="i">+}
</a><a href="#h24-0-162" id="h24-0-162" class="i">+
</a><a href="#h24-0-163" id="h24-0-163" class="i">+// DecodeZigzag32 reads a zigzag-encoded 32-bit integer
</a><a href="#h24-0-164" id="h24-0-164" class="i">+// from  the Buffer.
</a><a href="#h24-0-165" id="h24-0-165" class="i">+// This is the format used for the sint32 protocol buffer type.
</a><a href="#h24-0-166" id="h24-0-166" class="i">+func (p *Buffer) DecodeZigzag32() (x uint64, err error) {
</a><a href="#h24-0-167" id="h24-0-167" class="i">+	x, err = p.DecodeVarint()
</a><a href="#h24-0-168" id="h24-0-168" class="i">+	if err != nil {
</a><a href="#h24-0-169" id="h24-0-169" class="i">+		return
</a><a href="#h24-0-170" id="h24-0-170" class="i">+	}
</a><a href="#h24-0-171" id="h24-0-171" class="i">+	x = uint64((uint32(x) &gt;&gt; 1) ^ uint32((int32(x&amp;1)&lt;&lt;31)&gt;&gt;31))
</a><a href="#h24-0-172" id="h24-0-172" class="i">+	return
</a><a href="#h24-0-173" id="h24-0-173" class="i">+}
</a><a href="#h24-0-174" id="h24-0-174" class="i">+
</a><a href="#h24-0-175" id="h24-0-175" class="i">+// These are not ValueDecoders: they produce an array of bytes or a string.
</a><a href="#h24-0-176" id="h24-0-176" class="i">+// bytes, embedded messages
</a><a href="#h24-0-177" id="h24-0-177" class="i">+
</a><a href="#h24-0-178" id="h24-0-178" class="i">+// DecodeRawBytes reads a count-delimited byte buffer from the Buffer.
</a><a href="#h24-0-179" id="h24-0-179" class="i">+// This is the format used for the bytes protocol buffer
</a><a href="#h24-0-180" id="h24-0-180" class="i">+// type and for embedded messages.
</a><a href="#h24-0-181" id="h24-0-181" class="i">+func (p *Buffer) DecodeRawBytes(alloc bool) (buf []byte, err error) {
</a><a href="#h24-0-182" id="h24-0-182" class="i">+	n, err := p.DecodeVarint()
</a><a href="#h24-0-183" id="h24-0-183" class="i">+	if err != nil {
</a><a href="#h24-0-184" id="h24-0-184" class="i">+		return nil, err
</a><a href="#h24-0-185" id="h24-0-185" class="i">+	}
</a><a href="#h24-0-186" id="h24-0-186" class="i">+
</a><a href="#h24-0-187" id="h24-0-187" class="i">+	nb := int(n)
</a><a href="#h24-0-188" id="h24-0-188" class="i">+	if nb &lt; 0 {
</a><a href="#h24-0-189" id="h24-0-189" class="i">+		return nil, fmt.Errorf(&quot;proto: bad byte length %d&quot;, nb)
</a><a href="#h24-0-190" id="h24-0-190" class="i">+	}
</a><a href="#h24-0-191" id="h24-0-191" class="i">+	end := p.index + nb
</a><a href="#h24-0-192" id="h24-0-192" class="i">+	if end &lt; p.index || end &gt; len(p.buf) {
</a><a href="#h24-0-193" id="h24-0-193" class="i">+		return nil, io.ErrUnexpectedEOF
</a><a href="#h24-0-194" id="h24-0-194" class="i">+	}
</a><a href="#h24-0-195" id="h24-0-195" class="i">+
</a><a href="#h24-0-196" id="h24-0-196" class="i">+	if !alloc {
</a><a href="#h24-0-197" id="h24-0-197" class="i">+		// todo: check if can get more uses of alloc=false
</a><a href="#h24-0-198" id="h24-0-198" class="i">+		buf = p.buf[p.index:end]
</a><a href="#h24-0-199" id="h24-0-199" class="i">+		p.index += nb
</a><a href="#h24-0-200" id="h24-0-200" class="i">+		return
</a><a href="#h24-0-201" id="h24-0-201" class="i">+	}
</a><a href="#h24-0-202" id="h24-0-202" class="i">+
</a><a href="#h24-0-203" id="h24-0-203" class="i">+	buf = make([]byte, nb)
</a><a href="#h24-0-204" id="h24-0-204" class="i">+	copy(buf, p.buf[p.index:])
</a><a href="#h24-0-205" id="h24-0-205" class="i">+	p.index += nb
</a><a href="#h24-0-206" id="h24-0-206" class="i">+	return
</a><a href="#h24-0-207" id="h24-0-207" class="i">+}
</a><a href="#h24-0-208" id="h24-0-208" class="i">+
</a><a href="#h24-0-209" id="h24-0-209" class="i">+// DecodeStringBytes reads an encoded string from the Buffer.
</a><a href="#h24-0-210" id="h24-0-210" class="i">+// This is the format used for the proto2 string type.
</a><a href="#h24-0-211" id="h24-0-211" class="i">+func (p *Buffer) DecodeStringBytes() (s string, err error) {
</a><a href="#h24-0-212" id="h24-0-212" class="i">+	buf, err := p.DecodeRawBytes(false)
</a><a href="#h24-0-213" id="h24-0-213" class="i">+	if err != nil {
</a><a href="#h24-0-214" id="h24-0-214" class="i">+		return
</a><a href="#h24-0-215" id="h24-0-215" class="i">+	}
</a><a href="#h24-0-216" id="h24-0-216" class="i">+	return string(buf), nil
</a><a href="#h24-0-217" id="h24-0-217" class="i">+}
</a><a href="#h24-0-218" id="h24-0-218" class="i">+
</a><a href="#h24-0-219" id="h24-0-219" class="i">+// Skip the next item in the buffer. Its wire type is decoded and presented as an argument.
</a><a href="#h24-0-220" id="h24-0-220" class="i">+// If the protocol buffer has extensions, and the field matches, add it as an extension.
</a><a href="#h24-0-221" id="h24-0-221" class="i">+// Otherwise, if the XXX_unrecognized field exists, append the skipped data there.
</a><a href="#h24-0-222" id="h24-0-222" class="i">+func (o *Buffer) skipAndSave(t reflect.Type, tag, wire int, base structPointer, unrecField field) error {
</a><a href="#h24-0-223" id="h24-0-223" class="i">+	oi := o.index
</a><a href="#h24-0-224" id="h24-0-224" class="i">+
</a><a href="#h24-0-225" id="h24-0-225" class="i">+	err := o.skip(t, tag, wire)
</a><a href="#h24-0-226" id="h24-0-226" class="i">+	if err != nil {
</a><a href="#h24-0-227" id="h24-0-227" class="i">+		return err
</a><a href="#h24-0-228" id="h24-0-228" class="i">+	}
</a><a href="#h24-0-229" id="h24-0-229" class="i">+
</a><a href="#h24-0-230" id="h24-0-230" class="i">+	if !unrecField.IsValid() {
</a><a href="#h24-0-231" id="h24-0-231" class="i">+		return nil
</a><a href="#h24-0-232" id="h24-0-232" class="i">+	}
</a><a href="#h24-0-233" id="h24-0-233" class="i">+
</a><a href="#h24-0-234" id="h24-0-234" class="i">+	ptr := structPointer_Bytes(base, unrecField)
</a><a href="#h24-0-235" id="h24-0-235" class="i">+
</a><a href="#h24-0-236" id="h24-0-236" class="i">+	// Add the skipped field to struct field
</a><a href="#h24-0-237" id="h24-0-237" class="i">+	obuf := o.buf
</a><a href="#h24-0-238" id="h24-0-238" class="i">+
</a><a href="#h24-0-239" id="h24-0-239" class="i">+	o.buf = *ptr
</a><a href="#h24-0-240" id="h24-0-240" class="i">+	o.EncodeVarint(uint64(tag&lt;&lt;3 | wire))
</a><a href="#h24-0-241" id="h24-0-241" class="i">+	*ptr = append(o.buf, obuf[oi:o.index]...)
</a><a href="#h24-0-242" id="h24-0-242" class="i">+
</a><a href="#h24-0-243" id="h24-0-243" class="i">+	o.buf = obuf
</a><a href="#h24-0-244" id="h24-0-244" class="i">+
</a><a href="#h24-0-245" id="h24-0-245" class="i">+	return nil
</a><a href="#h24-0-246" id="h24-0-246" class="i">+}
</a><a href="#h24-0-247" id="h24-0-247" class="i">+
</a><a href="#h24-0-248" id="h24-0-248" class="i">+// Skip the next item in the buffer. Its wire type is decoded and presented as an argument.
</a><a href="#h24-0-249" id="h24-0-249" class="i">+func (o *Buffer) skip(t reflect.Type, tag, wire int) error {
</a><a href="#h24-0-250" id="h24-0-250" class="i">+
</a><a href="#h24-0-251" id="h24-0-251" class="i">+	var u uint64
</a><a href="#h24-0-252" id="h24-0-252" class="i">+	var err error
</a><a href="#h24-0-253" id="h24-0-253" class="i">+
</a><a href="#h24-0-254" id="h24-0-254" class="i">+	switch wire {
</a><a href="#h24-0-255" id="h24-0-255" class="i">+	case WireVarint:
</a><a href="#h24-0-256" id="h24-0-256" class="i">+		_, err = o.DecodeVarint()
</a><a href="#h24-0-257" id="h24-0-257" class="i">+	case WireFixed64:
</a><a href="#h24-0-258" id="h24-0-258" class="i">+		_, err = o.DecodeFixed64()
</a><a href="#h24-0-259" id="h24-0-259" class="i">+	case WireBytes:
</a><a href="#h24-0-260" id="h24-0-260" class="i">+		_, err = o.DecodeRawBytes(false)
</a><a href="#h24-0-261" id="h24-0-261" class="i">+	case WireFixed32:
</a><a href="#h24-0-262" id="h24-0-262" class="i">+		_, err = o.DecodeFixed32()
</a><a href="#h24-0-263" id="h24-0-263" class="i">+	case WireStartGroup:
</a><a href="#h24-0-264" id="h24-0-264" class="i">+		for {
</a><a href="#h24-0-265" id="h24-0-265" class="i">+			u, err = o.DecodeVarint()
</a><a href="#h24-0-266" id="h24-0-266" class="i">+			if err != nil {
</a><a href="#h24-0-267" id="h24-0-267" class="i">+				break
</a><a href="#h24-0-268" id="h24-0-268" class="i">+			}
</a><a href="#h24-0-269" id="h24-0-269" class="i">+			fwire := int(u &amp; 0x7)
</a><a href="#h24-0-270" id="h24-0-270" class="i">+			if fwire == WireEndGroup {
</a><a href="#h24-0-271" id="h24-0-271" class="i">+				break
</a><a href="#h24-0-272" id="h24-0-272" class="i">+			}
</a><a href="#h24-0-273" id="h24-0-273" class="i">+			ftag := int(u &gt;&gt; 3)
</a><a href="#h24-0-274" id="h24-0-274" class="i">+			err = o.skip(t, ftag, fwire)
</a><a href="#h24-0-275" id="h24-0-275" class="i">+			if err != nil {
</a><a href="#h24-0-276" id="h24-0-276" class="i">+				break
</a><a href="#h24-0-277" id="h24-0-277" class="i">+			}
</a><a href="#h24-0-278" id="h24-0-278" class="i">+		}
</a><a href="#h24-0-279" id="h24-0-279" class="i">+	default:
</a><a href="#h24-0-280" id="h24-0-280" class="i">+		err = fmt.Errorf(&quot;proto: can&#39;t skip unknown wire type %d for %s&quot;, wire, t)
</a><a href="#h24-0-281" id="h24-0-281" class="i">+	}
</a><a href="#h24-0-282" id="h24-0-282" class="i">+	return err
</a><a href="#h24-0-283" id="h24-0-283" class="i">+}
</a><a href="#h24-0-284" id="h24-0-284" class="i">+
</a><a href="#h24-0-285" id="h24-0-285" class="i">+// Unmarshaler is the interface representing objects that can
</a><a href="#h24-0-286" id="h24-0-286" class="i">+// unmarshal themselves.  The method should reset the receiver before
</a><a href="#h24-0-287" id="h24-0-287" class="i">+// decoding starts.  The argument points to data that may be
</a><a href="#h24-0-288" id="h24-0-288" class="i">+// overwritten, so implementations should not keep references to the
</a><a href="#h24-0-289" id="h24-0-289" class="i">+// buffer.
</a><a href="#h24-0-290" id="h24-0-290" class="i">+type Unmarshaler interface {
</a><a href="#h24-0-291" id="h24-0-291" class="i">+	Unmarshal([]byte) error
</a><a href="#h24-0-292" id="h24-0-292" class="i">+}
</a><a href="#h24-0-293" id="h24-0-293" class="i">+
</a><a href="#h24-0-294" id="h24-0-294" class="i">+// Unmarshal parses the protocol buffer representation in buf and places the
</a><a href="#h24-0-295" id="h24-0-295" class="i">+// decoded result in pb.  If the struct underlying pb does not match
</a><a href="#h24-0-296" id="h24-0-296" class="i">+// the data in buf, the results can be unpredictable.
</a><a href="#h24-0-297" id="h24-0-297" class="i">+//
</a><a href="#h24-0-298" id="h24-0-298" class="i">+// Unmarshal resets pb before starting to unmarshal, so any
</a><a href="#h24-0-299" id="h24-0-299" class="i">+// existing data in pb is always removed. Use UnmarshalMerge
</a><a href="#h24-0-300" id="h24-0-300" class="i">+// to preserve and append to existing data.
</a><a href="#h24-0-301" id="h24-0-301" class="i">+func Unmarshal(buf []byte, pb Message) error {
</a><a href="#h24-0-302" id="h24-0-302" class="i">+	pb.Reset()
</a><a href="#h24-0-303" id="h24-0-303" class="i">+	return UnmarshalMerge(buf, pb)
</a><a href="#h24-0-304" id="h24-0-304" class="i">+}
</a><a href="#h24-0-305" id="h24-0-305" class="i">+
</a><a href="#h24-0-306" id="h24-0-306" class="i">+// UnmarshalMerge parses the protocol buffer representation in buf and
</a><a href="#h24-0-307" id="h24-0-307" class="i">+// writes the decoded result to pb.  If the struct underlying pb does not match
</a><a href="#h24-0-308" id="h24-0-308" class="i">+// the data in buf, the results can be unpredictable.
</a><a href="#h24-0-309" id="h24-0-309" class="i">+//
</a><a href="#h24-0-310" id="h24-0-310" class="i">+// UnmarshalMerge merges into existing data in pb.
</a><a href="#h24-0-311" id="h24-0-311" class="i">+// Most code should use Unmarshal instead.
</a><a href="#h24-0-312" id="h24-0-312" class="i">+func UnmarshalMerge(buf []byte, pb Message) error {
</a><a href="#h24-0-313" id="h24-0-313" class="i">+	// If the object can unmarshal itself, let it.
</a><a href="#h24-0-314" id="h24-0-314" class="i">+	if u, ok := pb.(Unmarshaler); ok {
</a><a href="#h24-0-315" id="h24-0-315" class="i">+		return u.Unmarshal(buf)
</a><a href="#h24-0-316" id="h24-0-316" class="i">+	}
</a><a href="#h24-0-317" id="h24-0-317" class="i">+	return NewBuffer(buf).Unmarshal(pb)
</a><a href="#h24-0-318" id="h24-0-318" class="i">+}
</a><a href="#h24-0-319" id="h24-0-319" class="i">+
</a><a href="#h24-0-320" id="h24-0-320" class="i">+// DecodeMessage reads a count-delimited message from the Buffer.
</a><a href="#h24-0-321" id="h24-0-321" class="i">+func (p *Buffer) DecodeMessage(pb Message) error {
</a><a href="#h24-0-322" id="h24-0-322" class="i">+	enc, err := p.DecodeRawBytes(false)
</a><a href="#h24-0-323" id="h24-0-323" class="i">+	if err != nil {
</a><a href="#h24-0-324" id="h24-0-324" class="i">+		return err
</a><a href="#h24-0-325" id="h24-0-325" class="i">+	}
</a><a href="#h24-0-326" id="h24-0-326" class="i">+	return NewBuffer(enc).Unmarshal(pb)
</a><a href="#h24-0-327" id="h24-0-327" class="i">+}
</a><a href="#h24-0-328" id="h24-0-328" class="i">+
</a><a href="#h24-0-329" id="h24-0-329" class="i">+// DecodeGroup reads a tag-delimited group from the Buffer.
</a><a href="#h24-0-330" id="h24-0-330" class="i">+func (p *Buffer) DecodeGroup(pb Message) error {
</a><a href="#h24-0-331" id="h24-0-331" class="i">+	typ, base, err := getbase(pb)
</a><a href="#h24-0-332" id="h24-0-332" class="i">+	if err != nil {
</a><a href="#h24-0-333" id="h24-0-333" class="i">+		return err
</a><a href="#h24-0-334" id="h24-0-334" class="i">+	}
</a><a href="#h24-0-335" id="h24-0-335" class="i">+	return p.unmarshalType(typ.Elem(), GetProperties(typ.Elem()), true, base)
</a><a href="#h24-0-336" id="h24-0-336" class="i">+}
</a><a href="#h24-0-337" id="h24-0-337" class="i">+
</a><a href="#h24-0-338" id="h24-0-338" class="i">+// Unmarshal parses the protocol buffer representation in the
</a><a href="#h24-0-339" id="h24-0-339" class="i">+// Buffer and places the decoded result in pb.  If the struct
</a><a href="#h24-0-340" id="h24-0-340" class="i">+// underlying pb does not match the data in the buffer, the results can be
</a><a href="#h24-0-341" id="h24-0-341" class="i">+// unpredictable.
</a><a href="#h24-0-342" id="h24-0-342" class="i">+func (p *Buffer) Unmarshal(pb Message) error {
</a><a href="#h24-0-343" id="h24-0-343" class="i">+	// If the object can unmarshal itself, let it.
</a><a href="#h24-0-344" id="h24-0-344" class="i">+	if u, ok := pb.(Unmarshaler); ok {
</a><a href="#h24-0-345" id="h24-0-345" class="i">+		err := u.Unmarshal(p.buf[p.index:])
</a><a href="#h24-0-346" id="h24-0-346" class="i">+		p.index = len(p.buf)
</a><a href="#h24-0-347" id="h24-0-347" class="i">+		return err
</a><a href="#h24-0-348" id="h24-0-348" class="i">+	}
</a><a href="#h24-0-349" id="h24-0-349" class="i">+
</a><a href="#h24-0-350" id="h24-0-350" class="i">+	typ, base, err := getbase(pb)
</a><a href="#h24-0-351" id="h24-0-351" class="i">+	if err != nil {
</a><a href="#h24-0-352" id="h24-0-352" class="i">+		return err
</a><a href="#h24-0-353" id="h24-0-353" class="i">+	}
</a><a href="#h24-0-354" id="h24-0-354" class="i">+
</a><a href="#h24-0-355" id="h24-0-355" class="i">+	err = p.unmarshalType(typ.Elem(), GetProperties(typ.Elem()), false, base)
</a><a href="#h24-0-356" id="h24-0-356" class="i">+
</a><a href="#h24-0-357" id="h24-0-357" class="i">+	if collectStats {
</a><a href="#h24-0-358" id="h24-0-358" class="i">+		stats.Decode++
</a><a href="#h24-0-359" id="h24-0-359" class="i">+	}
</a><a href="#h24-0-360" id="h24-0-360" class="i">+
</a><a href="#h24-0-361" id="h24-0-361" class="i">+	return err
</a><a href="#h24-0-362" id="h24-0-362" class="i">+}
</a><a href="#h24-0-363" id="h24-0-363" class="i">+
</a><a href="#h24-0-364" id="h24-0-364" class="i">+// unmarshalType does the work of unmarshaling a structure.
</a><a href="#h24-0-365" id="h24-0-365" class="i">+func (o *Buffer) unmarshalType(st reflect.Type, prop *StructProperties, is_group bool, base structPointer) error {
</a><a href="#h24-0-366" id="h24-0-366" class="i">+	var state errorState
</a><a href="#h24-0-367" id="h24-0-367" class="i">+	required, reqFields := prop.reqCount, uint64(0)
</a><a href="#h24-0-368" id="h24-0-368" class="i">+
</a><a href="#h24-0-369" id="h24-0-369" class="i">+	var err error
</a><a href="#h24-0-370" id="h24-0-370" class="i">+	for err == nil &amp;&amp; o.index &lt; len(o.buf) {
</a><a href="#h24-0-371" id="h24-0-371" class="i">+		oi := o.index
</a><a href="#h24-0-372" id="h24-0-372" class="i">+		var u uint64
</a><a href="#h24-0-373" id="h24-0-373" class="i">+		u, err = o.DecodeVarint()
</a><a href="#h24-0-374" id="h24-0-374" class="i">+		if err != nil {
</a><a href="#h24-0-375" id="h24-0-375" class="i">+			break
</a><a href="#h24-0-376" id="h24-0-376" class="i">+		}
</a><a href="#h24-0-377" id="h24-0-377" class="i">+		wire := int(u &amp; 0x7)
</a><a href="#h24-0-378" id="h24-0-378" class="i">+		if wire == WireEndGroup {
</a><a href="#h24-0-379" id="h24-0-379" class="i">+			if is_group {
</a><a href="#h24-0-380" id="h24-0-380" class="i">+				if required &gt; 0 {
</a><a href="#h24-0-381" id="h24-0-381" class="i">+					// Not enough information to determine the exact field.
</a><a href="#h24-0-382" id="h24-0-382" class="i">+					// (See below.)
</a><a href="#h24-0-383" id="h24-0-383" class="i">+					return &amp;RequiredNotSetError{&quot;{Unknown}&quot;}
</a><a href="#h24-0-384" id="h24-0-384" class="i">+				}
</a><a href="#h24-0-385" id="h24-0-385" class="i">+				return nil // input is satisfied
</a><a href="#h24-0-386" id="h24-0-386" class="i">+			}
</a><a href="#h24-0-387" id="h24-0-387" class="i">+			return fmt.Errorf(&quot;proto: %s: wiretype end group for non-group&quot;, st)
</a><a href="#h24-0-388" id="h24-0-388" class="i">+		}
</a><a href="#h24-0-389" id="h24-0-389" class="i">+		tag := int(u &gt;&gt; 3)
</a><a href="#h24-0-390" id="h24-0-390" class="i">+		if tag &lt;= 0 {
</a><a href="#h24-0-391" id="h24-0-391" class="i">+			return fmt.Errorf(&quot;proto: %s: illegal tag %d (wire type %d)&quot;, st, tag, wire)
</a><a href="#h24-0-392" id="h24-0-392" class="i">+		}
</a><a href="#h24-0-393" id="h24-0-393" class="i">+		fieldnum, ok := prop.decoderTags.get(tag)
</a><a href="#h24-0-394" id="h24-0-394" class="i">+		if !ok {
</a><a href="#h24-0-395" id="h24-0-395" class="i">+			// Maybe it&#39;s an extension?
</a><a href="#h24-0-396" id="h24-0-396" class="i">+			if prop.extendable {
</a><a href="#h24-0-397" id="h24-0-397" class="i">+				if e, _ := extendable(structPointer_Interface(base, st)); isExtensionField(e, int32(tag)) {
</a><a href="#h24-0-398" id="h24-0-398" class="i">+					if err = o.skip(st, tag, wire); err == nil {
</a><a href="#h24-0-399" id="h24-0-399" class="i">+						extmap := e.extensionsWrite()
</a><a href="#h24-0-400" id="h24-0-400" class="i">+						ext := extmap[int32(tag)] // may be missing
</a><a href="#h24-0-401" id="h24-0-401" class="i">+						ext.enc = append(ext.enc, o.buf[oi:o.index]...)
</a><a href="#h24-0-402" id="h24-0-402" class="i">+						extmap[int32(tag)] = ext
</a><a href="#h24-0-403" id="h24-0-403" class="i">+					}
</a><a href="#h24-0-404" id="h24-0-404" class="i">+					continue
</a><a href="#h24-0-405" id="h24-0-405" class="i">+				}
</a><a href="#h24-0-406" id="h24-0-406" class="i">+			}
</a><a href="#h24-0-407" id="h24-0-407" class="i">+			// Maybe it&#39;s a oneof?
</a><a href="#h24-0-408" id="h24-0-408" class="i">+			if prop.oneofUnmarshaler != nil {
</a><a href="#h24-0-409" id="h24-0-409" class="i">+				m := structPointer_Interface(base, st).(Message)
</a><a href="#h24-0-410" id="h24-0-410" class="i">+				// First return value indicates whether tag is a oneof field.
</a><a href="#h24-0-411" id="h24-0-411" class="i">+				ok, err = prop.oneofUnmarshaler(m, tag, wire, o)
</a><a href="#h24-0-412" id="h24-0-412" class="i">+				if err == ErrInternalBadWireType {
</a><a href="#h24-0-413" id="h24-0-413" class="i">+					// Map the error to something more descriptive.
</a><a href="#h24-0-414" id="h24-0-414" class="i">+					// Do the formatting here to save generated code space.
</a><a href="#h24-0-415" id="h24-0-415" class="i">+					err = fmt.Errorf(&quot;bad wiretype for oneof field in %T&quot;, m)
</a><a href="#h24-0-416" id="h24-0-416" class="i">+				}
</a><a href="#h24-0-417" id="h24-0-417" class="i">+				if ok {
</a><a href="#h24-0-418" id="h24-0-418" class="i">+					continue
</a><a href="#h24-0-419" id="h24-0-419" class="i">+				}
</a><a href="#h24-0-420" id="h24-0-420" class="i">+			}
</a><a href="#h24-0-421" id="h24-0-421" class="i">+			err = o.skipAndSave(st, tag, wire, base, prop.unrecField)
</a><a href="#h24-0-422" id="h24-0-422" class="i">+			continue
</a><a href="#h24-0-423" id="h24-0-423" class="i">+		}
</a><a href="#h24-0-424" id="h24-0-424" class="i">+		p := prop.Prop[fieldnum]
</a><a href="#h24-0-425" id="h24-0-425" class="i">+
</a><a href="#h24-0-426" id="h24-0-426" class="i">+		if p.dec == nil {
</a><a href="#h24-0-427" id="h24-0-427" class="i">+			fmt.Fprintf(os.Stderr, &quot;proto: no protobuf decoder for %s.%s\n&quot;, st, st.Field(fieldnum).Name)
</a><a href="#h24-0-428" id="h24-0-428" class="i">+			continue
</a><a href="#h24-0-429" id="h24-0-429" class="i">+		}
</a><a href="#h24-0-430" id="h24-0-430" class="i">+		dec := p.dec
</a><a href="#h24-0-431" id="h24-0-431" class="i">+		if wire != WireStartGroup &amp;&amp; wire != p.WireType {
</a><a href="#h24-0-432" id="h24-0-432" class="i">+			if wire == WireBytes &amp;&amp; p.packedDec != nil {
</a><a href="#h24-0-433" id="h24-0-433" class="i">+				// a packable field
</a><a href="#h24-0-434" id="h24-0-434" class="i">+				dec = p.packedDec
</a><a href="#h24-0-435" id="h24-0-435" class="i">+			} else {
</a><a href="#h24-0-436" id="h24-0-436" class="i">+				err = fmt.Errorf(&quot;proto: bad wiretype for field %s.%s: got wiretype %d, want %d&quot;, st, st.Field(fieldnum).Name, wire, p.WireType)
</a><a href="#h24-0-437" id="h24-0-437" class="i">+				continue
</a><a href="#h24-0-438" id="h24-0-438" class="i">+			}
</a><a href="#h24-0-439" id="h24-0-439" class="i">+		}
</a><a href="#h24-0-440" id="h24-0-440" class="i">+		decErr := dec(o, p, base)
</a><a href="#h24-0-441" id="h24-0-441" class="i">+		if decErr != nil &amp;&amp; !state.shouldContinue(decErr, p) {
</a><a href="#h24-0-442" id="h24-0-442" class="i">+			err = decErr
</a><a href="#h24-0-443" id="h24-0-443" class="i">+		}
</a><a href="#h24-0-444" id="h24-0-444" class="i">+		if err == nil &amp;&amp; p.Required {
</a><a href="#h24-0-445" id="h24-0-445" class="i">+			// Successfully decoded a required field.
</a><a href="#h24-0-446" id="h24-0-446" class="i">+			if tag &lt;= 64 {
</a><a href="#h24-0-447" id="h24-0-447" class="i">+				// use bitmap for fields 1-64 to catch field reuse.
</a><a href="#h24-0-448" id="h24-0-448" class="i">+				var mask uint64 = 1 &lt;&lt; uint64(tag-1)
</a><a href="#h24-0-449" id="h24-0-449" class="i">+				if reqFields&amp;mask == 0 {
</a><a href="#h24-0-450" id="h24-0-450" class="i">+					// new required field
</a><a href="#h24-0-451" id="h24-0-451" class="i">+					reqFields |= mask
</a><a href="#h24-0-452" id="h24-0-452" class="i">+					required--
</a><a href="#h24-0-453" id="h24-0-453" class="i">+				}
</a><a href="#h24-0-454" id="h24-0-454" class="i">+			} else {
</a><a href="#h24-0-455" id="h24-0-455" class="i">+				// This is imprecise. It can be fooled by a required field
</a><a href="#h24-0-456" id="h24-0-456" class="i">+				// with a tag &gt; 64 that is encoded twice; that&#39;s very rare.
</a><a href="#h24-0-457" id="h24-0-457" class="i">+				// A fully correct implementation would require allocating
</a><a href="#h24-0-458" id="h24-0-458" class="i">+				// a data structure, which we would like to avoid.
</a><a href="#h24-0-459" id="h24-0-459" class="i">+				required--
</a><a href="#h24-0-460" id="h24-0-460" class="i">+			}
</a><a href="#h24-0-461" id="h24-0-461" class="i">+		}
</a><a href="#h24-0-462" id="h24-0-462" class="i">+	}
</a><a href="#h24-0-463" id="h24-0-463" class="i">+	if err == nil {
</a><a href="#h24-0-464" id="h24-0-464" class="i">+		if is_group {
</a><a href="#h24-0-465" id="h24-0-465" class="i">+			return io.ErrUnexpectedEOF
</a><a href="#h24-0-466" id="h24-0-466" class="i">+		}
</a><a href="#h24-0-467" id="h24-0-467" class="i">+		if state.err != nil {
</a><a href="#h24-0-468" id="h24-0-468" class="i">+			return state.err
</a><a href="#h24-0-469" id="h24-0-469" class="i">+		}
</a><a href="#h24-0-470" id="h24-0-470" class="i">+		if required &gt; 0 {
</a><a href="#h24-0-471" id="h24-0-471" class="i">+			// Not enough information to determine the exact field. If we use extra
</a><a href="#h24-0-472" id="h24-0-472" class="i">+			// CPU, we could determine the field only if the missing required field
</a><a href="#h24-0-473" id="h24-0-473" class="i">+			// has a tag &lt;= 64 and we check reqFields.
</a><a href="#h24-0-474" id="h24-0-474" class="i">+			return &amp;RequiredNotSetError{&quot;{Unknown}&quot;}
</a><a href="#h24-0-475" id="h24-0-475" class="i">+		}
</a><a href="#h24-0-476" id="h24-0-476" class="i">+	}
</a><a href="#h24-0-477" id="h24-0-477" class="i">+	return err
</a><a href="#h24-0-478" id="h24-0-478" class="i">+}
</a><a href="#h24-0-479" id="h24-0-479" class="i">+
</a><a href="#h24-0-480" id="h24-0-480" class="i">+// Individual type decoders
</a><a href="#h24-0-481" id="h24-0-481" class="i">+// For each,
</a><a href="#h24-0-482" id="h24-0-482" class="i">+//	u is the decoded value,
</a><a href="#h24-0-483" id="h24-0-483" class="i">+//	v is a pointer to the field (pointer) in the struct
</a><a href="#h24-0-484" id="h24-0-484" class="i">+
</a><a href="#h24-0-485" id="h24-0-485" class="i">+// Sizes of the pools to allocate inside the Buffer.
</a><a href="#h24-0-486" id="h24-0-486" class="i">+// The goal is modest amortization and allocation
</a><a href="#h24-0-487" id="h24-0-487" class="i">+// on at least 16-byte boundaries.
</a><a href="#h24-0-488" id="h24-0-488" class="i">+const (
</a><a href="#h24-0-489" id="h24-0-489" class="i">+	boolPoolSize   = 16
</a><a href="#h24-0-490" id="h24-0-490" class="i">+	uint32PoolSize = 8
</a><a href="#h24-0-491" id="h24-0-491" class="i">+	uint64PoolSize = 4
</a><a href="#h24-0-492" id="h24-0-492" class="i">+)
</a><a href="#h24-0-493" id="h24-0-493" class="i">+
</a><a href="#h24-0-494" id="h24-0-494" class="i">+// Decode a bool.
</a><a href="#h24-0-495" id="h24-0-495" class="i">+func (o *Buffer) dec_bool(p *Properties, base structPointer) error {
</a><a href="#h24-0-496" id="h24-0-496" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-497" id="h24-0-497" class="i">+	if err != nil {
</a><a href="#h24-0-498" id="h24-0-498" class="i">+		return err
</a><a href="#h24-0-499" id="h24-0-499" class="i">+	}
</a><a href="#h24-0-500" id="h24-0-500" class="i">+	if len(o.bools) == 0 {
</a><a href="#h24-0-501" id="h24-0-501" class="i">+		o.bools = make([]bool, boolPoolSize)
</a><a href="#h24-0-502" id="h24-0-502" class="i">+	}
</a><a href="#h24-0-503" id="h24-0-503" class="i">+	o.bools[0] = u != 0
</a><a href="#h24-0-504" id="h24-0-504" class="i">+	*structPointer_Bool(base, p.field) = &amp;o.bools[0]
</a><a href="#h24-0-505" id="h24-0-505" class="i">+	o.bools = o.bools[1:]
</a><a href="#h24-0-506" id="h24-0-506" class="i">+	return nil
</a><a href="#h24-0-507" id="h24-0-507" class="i">+}
</a><a href="#h24-0-508" id="h24-0-508" class="i">+
</a><a href="#h24-0-509" id="h24-0-509" class="i">+func (o *Buffer) dec_proto3_bool(p *Properties, base structPointer) error {
</a><a href="#h24-0-510" id="h24-0-510" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-511" id="h24-0-511" class="i">+	if err != nil {
</a><a href="#h24-0-512" id="h24-0-512" class="i">+		return err
</a><a href="#h24-0-513" id="h24-0-513" class="i">+	}
</a><a href="#h24-0-514" id="h24-0-514" class="i">+	*structPointer_BoolVal(base, p.field) = u != 0
</a><a href="#h24-0-515" id="h24-0-515" class="i">+	return nil
</a><a href="#h24-0-516" id="h24-0-516" class="i">+}
</a><a href="#h24-0-517" id="h24-0-517" class="i">+
</a><a href="#h24-0-518" id="h24-0-518" class="i">+// Decode an int32.
</a><a href="#h24-0-519" id="h24-0-519" class="i">+func (o *Buffer) dec_int32(p *Properties, base structPointer) error {
</a><a href="#h24-0-520" id="h24-0-520" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-521" id="h24-0-521" class="i">+	if err != nil {
</a><a href="#h24-0-522" id="h24-0-522" class="i">+		return err
</a><a href="#h24-0-523" id="h24-0-523" class="i">+	}
</a><a href="#h24-0-524" id="h24-0-524" class="i">+	word32_Set(structPointer_Word32(base, p.field), o, uint32(u))
</a><a href="#h24-0-525" id="h24-0-525" class="i">+	return nil
</a><a href="#h24-0-526" id="h24-0-526" class="i">+}
</a><a href="#h24-0-527" id="h24-0-527" class="i">+
</a><a href="#h24-0-528" id="h24-0-528" class="i">+func (o *Buffer) dec_proto3_int32(p *Properties, base structPointer) error {
</a><a href="#h24-0-529" id="h24-0-529" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-530" id="h24-0-530" class="i">+	if err != nil {
</a><a href="#h24-0-531" id="h24-0-531" class="i">+		return err
</a><a href="#h24-0-532" id="h24-0-532" class="i">+	}
</a><a href="#h24-0-533" id="h24-0-533" class="i">+	word32Val_Set(structPointer_Word32Val(base, p.field), uint32(u))
</a><a href="#h24-0-534" id="h24-0-534" class="i">+	return nil
</a><a href="#h24-0-535" id="h24-0-535" class="i">+}
</a><a href="#h24-0-536" id="h24-0-536" class="i">+
</a><a href="#h24-0-537" id="h24-0-537" class="i">+// Decode an int64.
</a><a href="#h24-0-538" id="h24-0-538" class="i">+func (o *Buffer) dec_int64(p *Properties, base structPointer) error {
</a><a href="#h24-0-539" id="h24-0-539" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-540" id="h24-0-540" class="i">+	if err != nil {
</a><a href="#h24-0-541" id="h24-0-541" class="i">+		return err
</a><a href="#h24-0-542" id="h24-0-542" class="i">+	}
</a><a href="#h24-0-543" id="h24-0-543" class="i">+	word64_Set(structPointer_Word64(base, p.field), o, u)
</a><a href="#h24-0-544" id="h24-0-544" class="i">+	return nil
</a><a href="#h24-0-545" id="h24-0-545" class="i">+}
</a><a href="#h24-0-546" id="h24-0-546" class="i">+
</a><a href="#h24-0-547" id="h24-0-547" class="i">+func (o *Buffer) dec_proto3_int64(p *Properties, base structPointer) error {
</a><a href="#h24-0-548" id="h24-0-548" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-549" id="h24-0-549" class="i">+	if err != nil {
</a><a href="#h24-0-550" id="h24-0-550" class="i">+		return err
</a><a href="#h24-0-551" id="h24-0-551" class="i">+	}
</a><a href="#h24-0-552" id="h24-0-552" class="i">+	word64Val_Set(structPointer_Word64Val(base, p.field), o, u)
</a><a href="#h24-0-553" id="h24-0-553" class="i">+	return nil
</a><a href="#h24-0-554" id="h24-0-554" class="i">+}
</a><a href="#h24-0-555" id="h24-0-555" class="i">+
</a><a href="#h24-0-556" id="h24-0-556" class="i">+// Decode a string.
</a><a href="#h24-0-557" id="h24-0-557" class="i">+func (o *Buffer) dec_string(p *Properties, base structPointer) error {
</a><a href="#h24-0-558" id="h24-0-558" class="i">+	s, err := o.DecodeStringBytes()
</a><a href="#h24-0-559" id="h24-0-559" class="i">+	if err != nil {
</a><a href="#h24-0-560" id="h24-0-560" class="i">+		return err
</a><a href="#h24-0-561" id="h24-0-561" class="i">+	}
</a><a href="#h24-0-562" id="h24-0-562" class="i">+	*structPointer_String(base, p.field) = &amp;s
</a><a href="#h24-0-563" id="h24-0-563" class="i">+	return nil
</a><a href="#h24-0-564" id="h24-0-564" class="i">+}
</a><a href="#h24-0-565" id="h24-0-565" class="i">+
</a><a href="#h24-0-566" id="h24-0-566" class="i">+func (o *Buffer) dec_proto3_string(p *Properties, base structPointer) error {
</a><a href="#h24-0-567" id="h24-0-567" class="i">+	s, err := o.DecodeStringBytes()
</a><a href="#h24-0-568" id="h24-0-568" class="i">+	if err != nil {
</a><a href="#h24-0-569" id="h24-0-569" class="i">+		return err
</a><a href="#h24-0-570" id="h24-0-570" class="i">+	}
</a><a href="#h24-0-571" id="h24-0-571" class="i">+	*structPointer_StringVal(base, p.field) = s
</a><a href="#h24-0-572" id="h24-0-572" class="i">+	return nil
</a><a href="#h24-0-573" id="h24-0-573" class="i">+}
</a><a href="#h24-0-574" id="h24-0-574" class="i">+
</a><a href="#h24-0-575" id="h24-0-575" class="i">+// Decode a slice of bytes ([]byte).
</a><a href="#h24-0-576" id="h24-0-576" class="i">+func (o *Buffer) dec_slice_byte(p *Properties, base structPointer) error {
</a><a href="#h24-0-577" id="h24-0-577" class="i">+	b, err := o.DecodeRawBytes(true)
</a><a href="#h24-0-578" id="h24-0-578" class="i">+	if err != nil {
</a><a href="#h24-0-579" id="h24-0-579" class="i">+		return err
</a><a href="#h24-0-580" id="h24-0-580" class="i">+	}
</a><a href="#h24-0-581" id="h24-0-581" class="i">+	*structPointer_Bytes(base, p.field) = b
</a><a href="#h24-0-582" id="h24-0-582" class="i">+	return nil
</a><a href="#h24-0-583" id="h24-0-583" class="i">+}
</a><a href="#h24-0-584" id="h24-0-584" class="i">+
</a><a href="#h24-0-585" id="h24-0-585" class="i">+// Decode a slice of bools ([]bool).
</a><a href="#h24-0-586" id="h24-0-586" class="i">+func (o *Buffer) dec_slice_bool(p *Properties, base structPointer) error {
</a><a href="#h24-0-587" id="h24-0-587" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-588" id="h24-0-588" class="i">+	if err != nil {
</a><a href="#h24-0-589" id="h24-0-589" class="i">+		return err
</a><a href="#h24-0-590" id="h24-0-590" class="i">+	}
</a><a href="#h24-0-591" id="h24-0-591" class="i">+	v := structPointer_BoolSlice(base, p.field)
</a><a href="#h24-0-592" id="h24-0-592" class="i">+	*v = append(*v, u != 0)
</a><a href="#h24-0-593" id="h24-0-593" class="i">+	return nil
</a><a href="#h24-0-594" id="h24-0-594" class="i">+}
</a><a href="#h24-0-595" id="h24-0-595" class="i">+
</a><a href="#h24-0-596" id="h24-0-596" class="i">+// Decode a slice of bools ([]bool) in packed format.
</a><a href="#h24-0-597" id="h24-0-597" class="i">+func (o *Buffer) dec_slice_packed_bool(p *Properties, base structPointer) error {
</a><a href="#h24-0-598" id="h24-0-598" class="i">+	v := structPointer_BoolSlice(base, p.field)
</a><a href="#h24-0-599" id="h24-0-599" class="i">+
</a><a href="#h24-0-600" id="h24-0-600" class="i">+	nn, err := o.DecodeVarint()
</a><a href="#h24-0-601" id="h24-0-601" class="i">+	if err != nil {
</a><a href="#h24-0-602" id="h24-0-602" class="i">+		return err
</a><a href="#h24-0-603" id="h24-0-603" class="i">+	}
</a><a href="#h24-0-604" id="h24-0-604" class="i">+	nb := int(nn) // number of bytes of encoded bools
</a><a href="#h24-0-605" id="h24-0-605" class="i">+	fin := o.index + nb
</a><a href="#h24-0-606" id="h24-0-606" class="i">+	if fin &lt; o.index {
</a><a href="#h24-0-607" id="h24-0-607" class="i">+		return errOverflow
</a><a href="#h24-0-608" id="h24-0-608" class="i">+	}
</a><a href="#h24-0-609" id="h24-0-609" class="i">+
</a><a href="#h24-0-610" id="h24-0-610" class="i">+	y := *v
</a><a href="#h24-0-611" id="h24-0-611" class="i">+	for o.index &lt; fin {
</a><a href="#h24-0-612" id="h24-0-612" class="i">+		u, err := p.valDec(o)
</a><a href="#h24-0-613" id="h24-0-613" class="i">+		if err != nil {
</a><a href="#h24-0-614" id="h24-0-614" class="i">+			return err
</a><a href="#h24-0-615" id="h24-0-615" class="i">+		}
</a><a href="#h24-0-616" id="h24-0-616" class="i">+		y = append(y, u != 0)
</a><a href="#h24-0-617" id="h24-0-617" class="i">+	}
</a><a href="#h24-0-618" id="h24-0-618" class="i">+
</a><a href="#h24-0-619" id="h24-0-619" class="i">+	*v = y
</a><a href="#h24-0-620" id="h24-0-620" class="i">+	return nil
</a><a href="#h24-0-621" id="h24-0-621" class="i">+}
</a><a href="#h24-0-622" id="h24-0-622" class="i">+
</a><a href="#h24-0-623" id="h24-0-623" class="i">+// Decode a slice of int32s ([]int32).
</a><a href="#h24-0-624" id="h24-0-624" class="i">+func (o *Buffer) dec_slice_int32(p *Properties, base structPointer) error {
</a><a href="#h24-0-625" id="h24-0-625" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-626" id="h24-0-626" class="i">+	if err != nil {
</a><a href="#h24-0-627" id="h24-0-627" class="i">+		return err
</a><a href="#h24-0-628" id="h24-0-628" class="i">+	}
</a><a href="#h24-0-629" id="h24-0-629" class="i">+	structPointer_Word32Slice(base, p.field).Append(uint32(u))
</a><a href="#h24-0-630" id="h24-0-630" class="i">+	return nil
</a><a href="#h24-0-631" id="h24-0-631" class="i">+}
</a><a href="#h24-0-632" id="h24-0-632" class="i">+
</a><a href="#h24-0-633" id="h24-0-633" class="i">+// Decode a slice of int32s ([]int32) in packed format.
</a><a href="#h24-0-634" id="h24-0-634" class="i">+func (o *Buffer) dec_slice_packed_int32(p *Properties, base structPointer) error {
</a><a href="#h24-0-635" id="h24-0-635" class="i">+	v := structPointer_Word32Slice(base, p.field)
</a><a href="#h24-0-636" id="h24-0-636" class="i">+
</a><a href="#h24-0-637" id="h24-0-637" class="i">+	nn, err := o.DecodeVarint()
</a><a href="#h24-0-638" id="h24-0-638" class="i">+	if err != nil {
</a><a href="#h24-0-639" id="h24-0-639" class="i">+		return err
</a><a href="#h24-0-640" id="h24-0-640" class="i">+	}
</a><a href="#h24-0-641" id="h24-0-641" class="i">+	nb := int(nn) // number of bytes of encoded int32s
</a><a href="#h24-0-642" id="h24-0-642" class="i">+
</a><a href="#h24-0-643" id="h24-0-643" class="i">+	fin := o.index + nb
</a><a href="#h24-0-644" id="h24-0-644" class="i">+	if fin &lt; o.index {
</a><a href="#h24-0-645" id="h24-0-645" class="i">+		return errOverflow
</a><a href="#h24-0-646" id="h24-0-646" class="i">+	}
</a><a href="#h24-0-647" id="h24-0-647" class="i">+	for o.index &lt; fin {
</a><a href="#h24-0-648" id="h24-0-648" class="i">+		u, err := p.valDec(o)
</a><a href="#h24-0-649" id="h24-0-649" class="i">+		if err != nil {
</a><a href="#h24-0-650" id="h24-0-650" class="i">+			return err
</a><a href="#h24-0-651" id="h24-0-651" class="i">+		}
</a><a href="#h24-0-652" id="h24-0-652" class="i">+		v.Append(uint32(u))
</a><a href="#h24-0-653" id="h24-0-653" class="i">+	}
</a><a href="#h24-0-654" id="h24-0-654" class="i">+	return nil
</a><a href="#h24-0-655" id="h24-0-655" class="i">+}
</a><a href="#h24-0-656" id="h24-0-656" class="i">+
</a><a href="#h24-0-657" id="h24-0-657" class="i">+// Decode a slice of int64s ([]int64).
</a><a href="#h24-0-658" id="h24-0-658" class="i">+func (o *Buffer) dec_slice_int64(p *Properties, base structPointer) error {
</a><a href="#h24-0-659" id="h24-0-659" class="i">+	u, err := p.valDec(o)
</a><a href="#h24-0-660" id="h24-0-660" class="i">+	if err != nil {
</a><a href="#h24-0-661" id="h24-0-661" class="i">+		return err
</a><a href="#h24-0-662" id="h24-0-662" class="i">+	}
</a><a href="#h24-0-663" id="h24-0-663" class="i">+
</a><a href="#h24-0-664" id="h24-0-664" class="i">+	structPointer_Word64Slice(base, p.field).Append(u)
</a><a href="#h24-0-665" id="h24-0-665" class="i">+	return nil
</a><a href="#h24-0-666" id="h24-0-666" class="i">+}
</a><a href="#h24-0-667" id="h24-0-667" class="i">+
</a><a href="#h24-0-668" id="h24-0-668" class="i">+// Decode a slice of int64s ([]int64) in packed format.
</a><a href="#h24-0-669" id="h24-0-669" class="i">+func (o *Buffer) dec_slice_packed_int64(p *Properties, base structPointer) error {
</a><a href="#h24-0-670" id="h24-0-670" class="i">+	v := structPointer_Word64Slice(base, p.field)
</a><a href="#h24-0-671" id="h24-0-671" class="i">+
</a><a href="#h24-0-672" id="h24-0-672" class="i">+	nn, err := o.DecodeVarint()
</a><a href="#h24-0-673" id="h24-0-673" class="i">+	if err != nil {
</a><a href="#h24-0-674" id="h24-0-674" class="i">+		return err
</a><a href="#h24-0-675" id="h24-0-675" class="i">+	}
</a><a href="#h24-0-676" id="h24-0-676" class="i">+	nb := int(nn) // number of bytes of encoded int64s
</a><a href="#h24-0-677" id="h24-0-677" class="i">+
</a><a href="#h24-0-678" id="h24-0-678" class="i">+	fin := o.index + nb
</a><a href="#h24-0-679" id="h24-0-679" class="i">+	if fin &lt; o.index {
</a><a href="#h24-0-680" id="h24-0-680" class="i">+		return errOverflow
</a><a href="#h24-0-681" id="h24-0-681" class="i">+	}
</a><a href="#h24-0-682" id="h24-0-682" class="i">+	for o.index &lt; fin {
</a><a href="#h24-0-683" id="h24-0-683" class="i">+		u, err := p.valDec(o)
</a><a href="#h24-0-684" id="h24-0-684" class="i">+		if err != nil {
</a><a href="#h24-0-685" id="h24-0-685" class="i">+			return err
</a><a href="#h24-0-686" id="h24-0-686" class="i">+		}
</a><a href="#h24-0-687" id="h24-0-687" class="i">+		v.Append(u)
</a><a href="#h24-0-688" id="h24-0-688" class="i">+	}
</a><a href="#h24-0-689" id="h24-0-689" class="i">+	return nil
</a><a href="#h24-0-690" id="h24-0-690" class="i">+}
</a><a href="#h24-0-691" id="h24-0-691" class="i">+
</a><a href="#h24-0-692" id="h24-0-692" class="i">+// Decode a slice of strings ([]string).
</a><a href="#h24-0-693" id="h24-0-693" class="i">+func (o *Buffer) dec_slice_string(p *Properties, base structPointer) error {
</a><a href="#h24-0-694" id="h24-0-694" class="i">+	s, err := o.DecodeStringBytes()
</a><a href="#h24-0-695" id="h24-0-695" class="i">+	if err != nil {
</a><a href="#h24-0-696" id="h24-0-696" class="i">+		return err
</a><a href="#h24-0-697" id="h24-0-697" class="i">+	}
</a><a href="#h24-0-698" id="h24-0-698" class="i">+	v := structPointer_StringSlice(base, p.field)
</a><a href="#h24-0-699" id="h24-0-699" class="i">+	*v = append(*v, s)
</a><a href="#h24-0-700" id="h24-0-700" class="i">+	return nil
</a><a href="#h24-0-701" id="h24-0-701" class="i">+}
</a><a href="#h24-0-702" id="h24-0-702" class="i">+
</a><a href="#h24-0-703" id="h24-0-703" class="i">+// Decode a slice of slice of bytes ([][]byte).
</a><a href="#h24-0-704" id="h24-0-704" class="i">+func (o *Buffer) dec_slice_slice_byte(p *Properties, base structPointer) error {
</a><a href="#h24-0-705" id="h24-0-705" class="i">+	b, err := o.DecodeRawBytes(true)
</a><a href="#h24-0-706" id="h24-0-706" class="i">+	if err != nil {
</a><a href="#h24-0-707" id="h24-0-707" class="i">+		return err
</a><a href="#h24-0-708" id="h24-0-708" class="i">+	}
</a><a href="#h24-0-709" id="h24-0-709" class="i">+	v := structPointer_BytesSlice(base, p.field)
</a><a href="#h24-0-710" id="h24-0-710" class="i">+	*v = append(*v, b)
</a><a href="#h24-0-711" id="h24-0-711" class="i">+	return nil
</a><a href="#h24-0-712" id="h24-0-712" class="i">+}
</a><a href="#h24-0-713" id="h24-0-713" class="i">+
</a><a href="#h24-0-714" id="h24-0-714" class="i">+// Decode a map field.
</a><a href="#h24-0-715" id="h24-0-715" class="i">+func (o *Buffer) dec_new_map(p *Properties, base structPointer) error {
</a><a href="#h24-0-716" id="h24-0-716" class="i">+	raw, err := o.DecodeRawBytes(false)
</a><a href="#h24-0-717" id="h24-0-717" class="i">+	if err != nil {
</a><a href="#h24-0-718" id="h24-0-718" class="i">+		return err
</a><a href="#h24-0-719" id="h24-0-719" class="i">+	}
</a><a href="#h24-0-720" id="h24-0-720" class="i">+	oi := o.index       // index at the end of this map entry
</a><a href="#h24-0-721" id="h24-0-721" class="i">+	o.index -= len(raw) // move buffer back to start of map entry
</a><a href="#h24-0-722" id="h24-0-722" class="i">+
</a><a href="#h24-0-723" id="h24-0-723" class="i">+	mptr := structPointer_NewAt(base, p.field, p.mtype) // *map[K]V
</a><a href="#h24-0-724" id="h24-0-724" class="i">+	if mptr.Elem().IsNil() {
</a><a href="#h24-0-725" id="h24-0-725" class="i">+		mptr.Elem().Set(reflect.MakeMap(mptr.Type().Elem()))
</a><a href="#h24-0-726" id="h24-0-726" class="i">+	}
</a><a href="#h24-0-727" id="h24-0-727" class="i">+	v := mptr.Elem() // map[K]V
</a><a href="#h24-0-728" id="h24-0-728" class="i">+
</a><a href="#h24-0-729" id="h24-0-729" class="i">+	// Prepare addressable doubly-indirect placeholders for the key and value types.
</a><a href="#h24-0-730" id="h24-0-730" class="i">+	// See enc_new_map for why.
</a><a href="#h24-0-731" id="h24-0-731" class="i">+	keyptr := reflect.New(reflect.PtrTo(p.mtype.Key())).Elem() // addressable *K
</a><a href="#h24-0-732" id="h24-0-732" class="i">+	keybase := toStructPointer(keyptr.Addr())                  // **K
</a><a href="#h24-0-733" id="h24-0-733" class="i">+
</a><a href="#h24-0-734" id="h24-0-734" class="i">+	var valbase structPointer
</a><a href="#h24-0-735" id="h24-0-735" class="i">+	var valptr reflect.Value
</a><a href="#h24-0-736" id="h24-0-736" class="i">+	switch p.mtype.Elem().Kind() {
</a><a href="#h24-0-737" id="h24-0-737" class="i">+	case reflect.Slice:
</a><a href="#h24-0-738" id="h24-0-738" class="i">+		// []byte
</a><a href="#h24-0-739" id="h24-0-739" class="i">+		var dummy []byte
</a><a href="#h24-0-740" id="h24-0-740" class="i">+		valptr = reflect.ValueOf(&amp;dummy)  // *[]byte
</a><a href="#h24-0-741" id="h24-0-741" class="i">+		valbase = toStructPointer(valptr) // *[]byte
</a><a href="#h24-0-742" id="h24-0-742" class="i">+	case reflect.Ptr:
</a><a href="#h24-0-743" id="h24-0-743" class="i">+		// message; valptr is **Msg; need to allocate the intermediate pointer
</a><a href="#h24-0-744" id="h24-0-744" class="i">+		valptr = reflect.New(reflect.PtrTo(p.mtype.Elem())).Elem() // addressable *V
</a><a href="#h24-0-745" id="h24-0-745" class="i">+		valptr.Set(reflect.New(valptr.Type().Elem()))
</a><a href="#h24-0-746" id="h24-0-746" class="i">+		valbase = toStructPointer(valptr)
</a><a href="#h24-0-747" id="h24-0-747" class="i">+	default:
</a><a href="#h24-0-748" id="h24-0-748" class="i">+		// everything else
</a><a href="#h24-0-749" id="h24-0-749" class="i">+		valptr = reflect.New(reflect.PtrTo(p.mtype.Elem())).Elem() // addressable *V
</a><a href="#h24-0-750" id="h24-0-750" class="i">+		valbase = toStructPointer(valptr.Addr())                   // **V
</a><a href="#h24-0-751" id="h24-0-751" class="i">+	}
</a><a href="#h24-0-752" id="h24-0-752" class="i">+
</a><a href="#h24-0-753" id="h24-0-753" class="i">+	// Decode.
</a><a href="#h24-0-754" id="h24-0-754" class="i">+	// This parses a restricted wire format, namely the encoding of a message
</a><a href="#h24-0-755" id="h24-0-755" class="i">+	// with two fields. See enc_new_map for the format.
</a><a href="#h24-0-756" id="h24-0-756" class="i">+	for o.index &lt; oi {
</a><a href="#h24-0-757" id="h24-0-757" class="i">+		// tagcode for key and value properties are always a single byte
</a><a href="#h24-0-758" id="h24-0-758" class="i">+		// because they have tags 1 and 2.
</a><a href="#h24-0-759" id="h24-0-759" class="i">+		tagcode := o.buf[o.index]
</a><a href="#h24-0-760" id="h24-0-760" class="i">+		o.index++
</a><a href="#h24-0-761" id="h24-0-761" class="i">+		switch tagcode {
</a><a href="#h24-0-762" id="h24-0-762" class="i">+		case p.mkeyprop.tagcode[0]:
</a><a href="#h24-0-763" id="h24-0-763" class="i">+			if err := p.mkeyprop.dec(o, p.mkeyprop, keybase); err != nil {
</a><a href="#h24-0-764" id="h24-0-764" class="i">+				return err
</a><a href="#h24-0-765" id="h24-0-765" class="i">+			}
</a><a href="#h24-0-766" id="h24-0-766" class="i">+		case p.mvalprop.tagcode[0]:
</a><a href="#h24-0-767" id="h24-0-767" class="i">+			if err := p.mvalprop.dec(o, p.mvalprop, valbase); err != nil {
</a><a href="#h24-0-768" id="h24-0-768" class="i">+				return err
</a><a href="#h24-0-769" id="h24-0-769" class="i">+			}
</a><a href="#h24-0-770" id="h24-0-770" class="i">+		default:
</a><a href="#h24-0-771" id="h24-0-771" class="i">+			// TODO: Should we silently skip this instead?
</a><a href="#h24-0-772" id="h24-0-772" class="i">+			return fmt.Errorf(&quot;proto: bad map data tag %d&quot;, raw[0])
</a><a href="#h24-0-773" id="h24-0-773" class="i">+		}
</a><a href="#h24-0-774" id="h24-0-774" class="i">+	}
</a><a href="#h24-0-775" id="h24-0-775" class="i">+	keyelem, valelem := keyptr.Elem(), valptr.Elem()
</a><a href="#h24-0-776" id="h24-0-776" class="i">+	if !keyelem.IsValid() {
</a><a href="#h24-0-777" id="h24-0-777" class="i">+		keyelem = reflect.Zero(p.mtype.Key())
</a><a href="#h24-0-778" id="h24-0-778" class="i">+	}
</a><a href="#h24-0-779" id="h24-0-779" class="i">+	if !valelem.IsValid() {
</a><a href="#h24-0-780" id="h24-0-780" class="i">+		valelem = reflect.Zero(p.mtype.Elem())
</a><a href="#h24-0-781" id="h24-0-781" class="i">+	}
</a><a href="#h24-0-782" id="h24-0-782" class="i">+
</a><a href="#h24-0-783" id="h24-0-783" class="i">+	v.SetMapIndex(keyelem, valelem)
</a><a href="#h24-0-784" id="h24-0-784" class="i">+	return nil
</a><a href="#h24-0-785" id="h24-0-785" class="i">+}
</a><a href="#h24-0-786" id="h24-0-786" class="i">+
</a><a href="#h24-0-787" id="h24-0-787" class="i">+// Decode a group.
</a><a href="#h24-0-788" id="h24-0-788" class="i">+func (o *Buffer) dec_struct_group(p *Properties, base structPointer) error {
</a><a href="#h24-0-789" id="h24-0-789" class="i">+	bas := structPointer_GetStructPointer(base, p.field)
</a><a href="#h24-0-790" id="h24-0-790" class="i">+	if structPointer_IsNil(bas) {
</a><a href="#h24-0-791" id="h24-0-791" class="i">+		// allocate new nested message
</a><a href="#h24-0-792" id="h24-0-792" class="i">+		bas = toStructPointer(reflect.New(p.stype))
</a><a href="#h24-0-793" id="h24-0-793" class="i">+		structPointer_SetStructPointer(base, p.field, bas)
</a><a href="#h24-0-794" id="h24-0-794" class="i">+	}
</a><a href="#h24-0-795" id="h24-0-795" class="i">+	return o.unmarshalType(p.stype, p.sprop, true, bas)
</a><a href="#h24-0-796" id="h24-0-796" class="i">+}
</a><a href="#h24-0-797" id="h24-0-797" class="i">+
</a><a href="#h24-0-798" id="h24-0-798" class="i">+// Decode an embedded message.
</a><a href="#h24-0-799" id="h24-0-799" class="i">+func (o *Buffer) dec_struct_message(p *Properties, base structPointer) (err error) {
</a><a href="#h24-0-800" id="h24-0-800" class="i">+	raw, e := o.DecodeRawBytes(false)
</a><a href="#h24-0-801" id="h24-0-801" class="i">+	if e != nil {
</a><a href="#h24-0-802" id="h24-0-802" class="i">+		return e
</a><a href="#h24-0-803" id="h24-0-803" class="i">+	}
</a><a href="#h24-0-804" id="h24-0-804" class="i">+
</a><a href="#h24-0-805" id="h24-0-805" class="i">+	bas := structPointer_GetStructPointer(base, p.field)
</a><a href="#h24-0-806" id="h24-0-806" class="i">+	if structPointer_IsNil(bas) {
</a><a href="#h24-0-807" id="h24-0-807" class="i">+		// allocate new nested message
</a><a href="#h24-0-808" id="h24-0-808" class="i">+		bas = toStructPointer(reflect.New(p.stype))
</a><a href="#h24-0-809" id="h24-0-809" class="i">+		structPointer_SetStructPointer(base, p.field, bas)
</a><a href="#h24-0-810" id="h24-0-810" class="i">+	}
</a><a href="#h24-0-811" id="h24-0-811" class="i">+
</a><a href="#h24-0-812" id="h24-0-812" class="i">+	// If the object can unmarshal itself, let it.
</a><a href="#h24-0-813" id="h24-0-813" class="i">+	if p.isUnmarshaler {
</a><a href="#h24-0-814" id="h24-0-814" class="i">+		iv := structPointer_Interface(bas, p.stype)
</a><a href="#h24-0-815" id="h24-0-815" class="i">+		return iv.(Unmarshaler).Unmarshal(raw)
</a><a href="#h24-0-816" id="h24-0-816" class="i">+	}
</a><a href="#h24-0-817" id="h24-0-817" class="i">+
</a><a href="#h24-0-818" id="h24-0-818" class="i">+	obuf := o.buf
</a><a href="#h24-0-819" id="h24-0-819" class="i">+	oi := o.index
</a><a href="#h24-0-820" id="h24-0-820" class="i">+	o.buf = raw
</a><a href="#h24-0-821" id="h24-0-821" class="i">+	o.index = 0
</a><a href="#h24-0-822" id="h24-0-822" class="i">+
</a><a href="#h24-0-823" id="h24-0-823" class="i">+	err = o.unmarshalType(p.stype, p.sprop, false, bas)
</a><a href="#h24-0-824" id="h24-0-824" class="i">+	o.buf = obuf
</a><a href="#h24-0-825" id="h24-0-825" class="i">+	o.index = oi
</a><a href="#h24-0-826" id="h24-0-826" class="i">+
</a><a href="#h24-0-827" id="h24-0-827" class="i">+	return err
</a><a href="#h24-0-828" id="h24-0-828" class="i">+}
</a><a href="#h24-0-829" id="h24-0-829" class="i">+
</a><a href="#h24-0-830" id="h24-0-830" class="i">+// Decode a slice of embedded messages.
</a><a href="#h24-0-831" id="h24-0-831" class="i">+func (o *Buffer) dec_slice_struct_message(p *Properties, base structPointer) error {
</a><a href="#h24-0-832" id="h24-0-832" class="i">+	return o.dec_slice_struct(p, false, base)
</a><a href="#h24-0-833" id="h24-0-833" class="i">+}
</a><a href="#h24-0-834" id="h24-0-834" class="i">+
</a><a href="#h24-0-835" id="h24-0-835" class="i">+// Decode a slice of embedded groups.
</a><a href="#h24-0-836" id="h24-0-836" class="i">+func (o *Buffer) dec_slice_struct_group(p *Properties, base structPointer) error {
</a><a href="#h24-0-837" id="h24-0-837" class="i">+	return o.dec_slice_struct(p, true, base)
</a><a href="#h24-0-838" id="h24-0-838" class="i">+}
</a><a href="#h24-0-839" id="h24-0-839" class="i">+
</a><a href="#h24-0-840" id="h24-0-840" class="i">+// Decode a slice of structs ([]*struct).
</a><a href="#h24-0-841" id="h24-0-841" class="i">+func (o *Buffer) dec_slice_struct(p *Properties, is_group bool, base structPointer) error {
</a><a href="#h24-0-842" id="h24-0-842" class="i">+	v := reflect.New(p.stype)
</a><a href="#h24-0-843" id="h24-0-843" class="i">+	bas := toStructPointer(v)
</a><a href="#h24-0-844" id="h24-0-844" class="i">+	structPointer_StructPointerSlice(base, p.field).Append(bas)
</a><a href="#h24-0-845" id="h24-0-845" class="i">+
</a><a href="#h24-0-846" id="h24-0-846" class="i">+	if is_group {
</a><a href="#h24-0-847" id="h24-0-847" class="i">+		err := o.unmarshalType(p.stype, p.sprop, is_group, bas)
</a><a href="#h24-0-848" id="h24-0-848" class="i">+		return err
</a><a href="#h24-0-849" id="h24-0-849" class="i">+	}
</a><a href="#h24-0-850" id="h24-0-850" class="i">+
</a><a href="#h24-0-851" id="h24-0-851" class="i">+	raw, err := o.DecodeRawBytes(false)
</a><a href="#h24-0-852" id="h24-0-852" class="i">+	if err != nil {
</a><a href="#h24-0-853" id="h24-0-853" class="i">+		return err
</a><a href="#h24-0-854" id="h24-0-854" class="i">+	}
</a><a href="#h24-0-855" id="h24-0-855" class="i">+
</a><a href="#h24-0-856" id="h24-0-856" class="i">+	// If the object can unmarshal itself, let it.
</a><a href="#h24-0-857" id="h24-0-857" class="i">+	if p.isUnmarshaler {
</a><a href="#h24-0-858" id="h24-0-858" class="i">+		iv := v.Interface()
</a><a href="#h24-0-859" id="h24-0-859" class="i">+		return iv.(Unmarshaler).Unmarshal(raw)
</a><a href="#h24-0-860" id="h24-0-860" class="i">+	}
</a><a href="#h24-0-861" id="h24-0-861" class="i">+
</a><a href="#h24-0-862" id="h24-0-862" class="i">+	obuf := o.buf
</a><a href="#h24-0-863" id="h24-0-863" class="i">+	oi := o.index
</a><a href="#h24-0-864" id="h24-0-864" class="i">+	o.buf = raw
</a><a href="#h24-0-865" id="h24-0-865" class="i">+	o.index = 0
</a><a href="#h24-0-866" id="h24-0-866" class="i">+
</a><a href="#h24-0-867" id="h24-0-867" class="i">+	err = o.unmarshalType(p.stype, p.sprop, is_group, bas)
</a><a href="#h24-0-868" id="h24-0-868" class="i">+
</a><a href="#h24-0-869" id="h24-0-869" class="i">+	o.buf = obuf
</a><a href="#h24-0-870" id="h24-0-870" class="i">+	o.index = oi
</a><a href="#h24-0-871" id="h24-0-871" class="i">+
</a><a href="#h24-0-872" id="h24-0-872" class="i">+	return err
</a><a href="#h24-0-873" id="h24-0-873" class="i">+}
</a><b>diff --git a/<a id="h25" href="../file/vendor/github.com/golang/protobuf/proto/encode.go">vendor/github.com/golang/protobuf/proto/encode.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/encode.go">vendor/github.com/golang/protobuf/proto/encode.go</a></b>
<a href="#h25-0" id="h25-0" class="h">@@ -0,0 +1,1363 @@
</a><a href="#h25-0-0" id="h25-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h25-0-1" id="h25-0-1" class="i">+//
</a><a href="#h25-0-2" id="h25-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h25-0-3" id="h25-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h25-0-4" id="h25-0-4" class="i">+//
</a><a href="#h25-0-5" id="h25-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h25-0-6" id="h25-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h25-0-7" id="h25-0-7" class="i">+// met:
</a><a href="#h25-0-8" id="h25-0-8" class="i">+//
</a><a href="#h25-0-9" id="h25-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h25-0-10" id="h25-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h25-0-11" id="h25-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h25-0-12" id="h25-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h25-0-13" id="h25-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h25-0-14" id="h25-0-14" class="i">+// distribution.
</a><a href="#h25-0-15" id="h25-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h25-0-16" id="h25-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h25-0-17" id="h25-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h25-0-18" id="h25-0-18" class="i">+//
</a><a href="#h25-0-19" id="h25-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h25-0-20" id="h25-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h25-0-21" id="h25-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h25-0-22" id="h25-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h25-0-23" id="h25-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h25-0-24" id="h25-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h25-0-25" id="h25-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h25-0-26" id="h25-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h25-0-27" id="h25-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h25-0-28" id="h25-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h25-0-29" id="h25-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h25-0-30" id="h25-0-30" class="i">+
</a><a href="#h25-0-31" id="h25-0-31" class="i">+package proto
</a><a href="#h25-0-32" id="h25-0-32" class="i">+
</a><a href="#h25-0-33" id="h25-0-33" class="i">+/*
</a><a href="#h25-0-34" id="h25-0-34" class="i">+ * Routines for encoding data into the wire format for protocol buffers.
</a><a href="#h25-0-35" id="h25-0-35" class="i">+ */
</a><a href="#h25-0-36" id="h25-0-36" class="i">+
</a><a href="#h25-0-37" id="h25-0-37" class="i">+import (
</a><a href="#h25-0-38" id="h25-0-38" class="i">+	&quot;errors&quot;
</a><a href="#h25-0-39" id="h25-0-39" class="i">+	&quot;fmt&quot;
</a><a href="#h25-0-40" id="h25-0-40" class="i">+	&quot;reflect&quot;
</a><a href="#h25-0-41" id="h25-0-41" class="i">+	&quot;sort&quot;
</a><a href="#h25-0-42" id="h25-0-42" class="i">+)
</a><a href="#h25-0-43" id="h25-0-43" class="i">+
</a><a href="#h25-0-44" id="h25-0-44" class="i">+// RequiredNotSetError is the error returned if Marshal is called with
</a><a href="#h25-0-45" id="h25-0-45" class="i">+// a protocol buffer struct whose required fields have not
</a><a href="#h25-0-46" id="h25-0-46" class="i">+// all been initialized. It is also the error returned if Unmarshal is
</a><a href="#h25-0-47" id="h25-0-47" class="i">+// called with an encoded protocol buffer that does not include all the
</a><a href="#h25-0-48" id="h25-0-48" class="i">+// required fields.
</a><a href="#h25-0-49" id="h25-0-49" class="i">+//
</a><a href="#h25-0-50" id="h25-0-50" class="i">+// When printed, RequiredNotSetError reports the first unset required field in a
</a><a href="#h25-0-51" id="h25-0-51" class="i">+// message. If the field cannot be precisely determined, it is reported as
</a><a href="#h25-0-52" id="h25-0-52" class="i">+// &quot;{Unknown}&quot;.
</a><a href="#h25-0-53" id="h25-0-53" class="i">+type RequiredNotSetError struct {
</a><a href="#h25-0-54" id="h25-0-54" class="i">+	field string
</a><a href="#h25-0-55" id="h25-0-55" class="i">+}
</a><a href="#h25-0-56" id="h25-0-56" class="i">+
</a><a href="#h25-0-57" id="h25-0-57" class="i">+func (e *RequiredNotSetError) Error() string {
</a><a href="#h25-0-58" id="h25-0-58" class="i">+	return fmt.Sprintf(&quot;proto: required field %q not set&quot;, e.field)
</a><a href="#h25-0-59" id="h25-0-59" class="i">+}
</a><a href="#h25-0-60" id="h25-0-60" class="i">+
</a><a href="#h25-0-61" id="h25-0-61" class="i">+var (
</a><a href="#h25-0-62" id="h25-0-62" class="i">+	// errRepeatedHasNil is the error returned if Marshal is called with
</a><a href="#h25-0-63" id="h25-0-63" class="i">+	// a struct with a repeated field containing a nil element.
</a><a href="#h25-0-64" id="h25-0-64" class="i">+	errRepeatedHasNil = errors.New(&quot;proto: repeated field has nil element&quot;)
</a><a href="#h25-0-65" id="h25-0-65" class="i">+
</a><a href="#h25-0-66" id="h25-0-66" class="i">+	// errOneofHasNil is the error returned if Marshal is called with
</a><a href="#h25-0-67" id="h25-0-67" class="i">+	// a struct with a oneof field containing a nil element.
</a><a href="#h25-0-68" id="h25-0-68" class="i">+	errOneofHasNil = errors.New(&quot;proto: oneof field has nil value&quot;)
</a><a href="#h25-0-69" id="h25-0-69" class="i">+
</a><a href="#h25-0-70" id="h25-0-70" class="i">+	// ErrNil is the error returned if Marshal is called with nil.
</a><a href="#h25-0-71" id="h25-0-71" class="i">+	ErrNil = errors.New(&quot;proto: Marshal called with nil&quot;)
</a><a href="#h25-0-72" id="h25-0-72" class="i">+
</a><a href="#h25-0-73" id="h25-0-73" class="i">+	// ErrTooLarge is the error returned if Marshal is called with a
</a><a href="#h25-0-74" id="h25-0-74" class="i">+	// message that encodes to &gt;2GB.
</a><a href="#h25-0-75" id="h25-0-75" class="i">+	ErrTooLarge = errors.New(&quot;proto: message encodes to over 2 GB&quot;)
</a><a href="#h25-0-76" id="h25-0-76" class="i">+)
</a><a href="#h25-0-77" id="h25-0-77" class="i">+
</a><a href="#h25-0-78" id="h25-0-78" class="i">+// The fundamental encoders that put bytes on the wire.
</a><a href="#h25-0-79" id="h25-0-79" class="i">+// Those that take integer types all accept uint64 and are
</a><a href="#h25-0-80" id="h25-0-80" class="i">+// therefore of type valueEncoder.
</a><a href="#h25-0-81" id="h25-0-81" class="i">+
</a><a href="#h25-0-82" id="h25-0-82" class="i">+const maxVarintBytes = 10 // maximum length of a varint
</a><a href="#h25-0-83" id="h25-0-83" class="i">+
</a><a href="#h25-0-84" id="h25-0-84" class="i">+// maxMarshalSize is the largest allowed size of an encoded protobuf,
</a><a href="#h25-0-85" id="h25-0-85" class="i">+// since C++ and Java use signed int32s for the size.
</a><a href="#h25-0-86" id="h25-0-86" class="i">+const maxMarshalSize = 1&lt;&lt;31 - 1
</a><a href="#h25-0-87" id="h25-0-87" class="i">+
</a><a href="#h25-0-88" id="h25-0-88" class="i">+// EncodeVarint returns the varint encoding of x.
</a><a href="#h25-0-89" id="h25-0-89" class="i">+// This is the format for the
</a><a href="#h25-0-90" id="h25-0-90" class="i">+// int32, int64, uint32, uint64, bool, and enum
</a><a href="#h25-0-91" id="h25-0-91" class="i">+// protocol buffer types.
</a><a href="#h25-0-92" id="h25-0-92" class="i">+// Not used by the package itself, but helpful to clients
</a><a href="#h25-0-93" id="h25-0-93" class="i">+// wishing to use the same encoding.
</a><a href="#h25-0-94" id="h25-0-94" class="i">+func EncodeVarint(x uint64) []byte {
</a><a href="#h25-0-95" id="h25-0-95" class="i">+	var buf [maxVarintBytes]byte
</a><a href="#h25-0-96" id="h25-0-96" class="i">+	var n int
</a><a href="#h25-0-97" id="h25-0-97" class="i">+	for n = 0; x &gt; 127; n++ {
</a><a href="#h25-0-98" id="h25-0-98" class="i">+		buf[n] = 0x80 | uint8(x&amp;0x7F)
</a><a href="#h25-0-99" id="h25-0-99" class="i">+		x &gt;&gt;= 7
</a><a href="#h25-0-100" id="h25-0-100" class="i">+	}
</a><a href="#h25-0-101" id="h25-0-101" class="i">+	buf[n] = uint8(x)
</a><a href="#h25-0-102" id="h25-0-102" class="i">+	n++
</a><a href="#h25-0-103" id="h25-0-103" class="i">+	return buf[0:n]
</a><a href="#h25-0-104" id="h25-0-104" class="i">+}
</a><a href="#h25-0-105" id="h25-0-105" class="i">+
</a><a href="#h25-0-106" id="h25-0-106" class="i">+// EncodeVarint writes a varint-encoded integer to the Buffer.
</a><a href="#h25-0-107" id="h25-0-107" class="i">+// This is the format for the
</a><a href="#h25-0-108" id="h25-0-108" class="i">+// int32, int64, uint32, uint64, bool, and enum
</a><a href="#h25-0-109" id="h25-0-109" class="i">+// protocol buffer types.
</a><a href="#h25-0-110" id="h25-0-110" class="i">+func (p *Buffer) EncodeVarint(x uint64) error {
</a><a href="#h25-0-111" id="h25-0-111" class="i">+	for x &gt;= 1&lt;&lt;7 {
</a><a href="#h25-0-112" id="h25-0-112" class="i">+		p.buf = append(p.buf, uint8(x&amp;0x7f|0x80))
</a><a href="#h25-0-113" id="h25-0-113" class="i">+		x &gt;&gt;= 7
</a><a href="#h25-0-114" id="h25-0-114" class="i">+	}
</a><a href="#h25-0-115" id="h25-0-115" class="i">+	p.buf = append(p.buf, uint8(x))
</a><a href="#h25-0-116" id="h25-0-116" class="i">+	return nil
</a><a href="#h25-0-117" id="h25-0-117" class="i">+}
</a><a href="#h25-0-118" id="h25-0-118" class="i">+
</a><a href="#h25-0-119" id="h25-0-119" class="i">+// SizeVarint returns the varint encoding size of an integer.
</a><a href="#h25-0-120" id="h25-0-120" class="i">+func SizeVarint(x uint64) int {
</a><a href="#h25-0-121" id="h25-0-121" class="i">+	return sizeVarint(x)
</a><a href="#h25-0-122" id="h25-0-122" class="i">+}
</a><a href="#h25-0-123" id="h25-0-123" class="i">+
</a><a href="#h25-0-124" id="h25-0-124" class="i">+func sizeVarint(x uint64) (n int) {
</a><a href="#h25-0-125" id="h25-0-125" class="i">+	for {
</a><a href="#h25-0-126" id="h25-0-126" class="i">+		n++
</a><a href="#h25-0-127" id="h25-0-127" class="i">+		x &gt;&gt;= 7
</a><a href="#h25-0-128" id="h25-0-128" class="i">+		if x == 0 {
</a><a href="#h25-0-129" id="h25-0-129" class="i">+			break
</a><a href="#h25-0-130" id="h25-0-130" class="i">+		}
</a><a href="#h25-0-131" id="h25-0-131" class="i">+	}
</a><a href="#h25-0-132" id="h25-0-132" class="i">+	return n
</a><a href="#h25-0-133" id="h25-0-133" class="i">+}
</a><a href="#h25-0-134" id="h25-0-134" class="i">+
</a><a href="#h25-0-135" id="h25-0-135" class="i">+// EncodeFixed64 writes a 64-bit integer to the Buffer.
</a><a href="#h25-0-136" id="h25-0-136" class="i">+// This is the format for the
</a><a href="#h25-0-137" id="h25-0-137" class="i">+// fixed64, sfixed64, and double protocol buffer types.
</a><a href="#h25-0-138" id="h25-0-138" class="i">+func (p *Buffer) EncodeFixed64(x uint64) error {
</a><a href="#h25-0-139" id="h25-0-139" class="i">+	p.buf = append(p.buf,
</a><a href="#h25-0-140" id="h25-0-140" class="i">+		uint8(x),
</a><a href="#h25-0-141" id="h25-0-141" class="i">+		uint8(x&gt;&gt;8),
</a><a href="#h25-0-142" id="h25-0-142" class="i">+		uint8(x&gt;&gt;16),
</a><a href="#h25-0-143" id="h25-0-143" class="i">+		uint8(x&gt;&gt;24),
</a><a href="#h25-0-144" id="h25-0-144" class="i">+		uint8(x&gt;&gt;32),
</a><a href="#h25-0-145" id="h25-0-145" class="i">+		uint8(x&gt;&gt;40),
</a><a href="#h25-0-146" id="h25-0-146" class="i">+		uint8(x&gt;&gt;48),
</a><a href="#h25-0-147" id="h25-0-147" class="i">+		uint8(x&gt;&gt;56))
</a><a href="#h25-0-148" id="h25-0-148" class="i">+	return nil
</a><a href="#h25-0-149" id="h25-0-149" class="i">+}
</a><a href="#h25-0-150" id="h25-0-150" class="i">+
</a><a href="#h25-0-151" id="h25-0-151" class="i">+func sizeFixed64(x uint64) int {
</a><a href="#h25-0-152" id="h25-0-152" class="i">+	return 8
</a><a href="#h25-0-153" id="h25-0-153" class="i">+}
</a><a href="#h25-0-154" id="h25-0-154" class="i">+
</a><a href="#h25-0-155" id="h25-0-155" class="i">+// EncodeFixed32 writes a 32-bit integer to the Buffer.
</a><a href="#h25-0-156" id="h25-0-156" class="i">+// This is the format for the
</a><a href="#h25-0-157" id="h25-0-157" class="i">+// fixed32, sfixed32, and float protocol buffer types.
</a><a href="#h25-0-158" id="h25-0-158" class="i">+func (p *Buffer) EncodeFixed32(x uint64) error {
</a><a href="#h25-0-159" id="h25-0-159" class="i">+	p.buf = append(p.buf,
</a><a href="#h25-0-160" id="h25-0-160" class="i">+		uint8(x),
</a><a href="#h25-0-161" id="h25-0-161" class="i">+		uint8(x&gt;&gt;8),
</a><a href="#h25-0-162" id="h25-0-162" class="i">+		uint8(x&gt;&gt;16),
</a><a href="#h25-0-163" id="h25-0-163" class="i">+		uint8(x&gt;&gt;24))
</a><a href="#h25-0-164" id="h25-0-164" class="i">+	return nil
</a><a href="#h25-0-165" id="h25-0-165" class="i">+}
</a><a href="#h25-0-166" id="h25-0-166" class="i">+
</a><a href="#h25-0-167" id="h25-0-167" class="i">+func sizeFixed32(x uint64) int {
</a><a href="#h25-0-168" id="h25-0-168" class="i">+	return 4
</a><a href="#h25-0-169" id="h25-0-169" class="i">+}
</a><a href="#h25-0-170" id="h25-0-170" class="i">+
</a><a href="#h25-0-171" id="h25-0-171" class="i">+// EncodeZigzag64 writes a zigzag-encoded 64-bit integer
</a><a href="#h25-0-172" id="h25-0-172" class="i">+// to the Buffer.
</a><a href="#h25-0-173" id="h25-0-173" class="i">+// This is the format used for the sint64 protocol buffer type.
</a><a href="#h25-0-174" id="h25-0-174" class="i">+func (p *Buffer) EncodeZigzag64(x uint64) error {
</a><a href="#h25-0-175" id="h25-0-175" class="i">+	// use signed number to get arithmetic right shift.
</a><a href="#h25-0-176" id="h25-0-176" class="i">+	return p.EncodeVarint(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
</a><a href="#h25-0-177" id="h25-0-177" class="i">+}
</a><a href="#h25-0-178" id="h25-0-178" class="i">+
</a><a href="#h25-0-179" id="h25-0-179" class="i">+func sizeZigzag64(x uint64) int {
</a><a href="#h25-0-180" id="h25-0-180" class="i">+	return sizeVarint(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
</a><a href="#h25-0-181" id="h25-0-181" class="i">+}
</a><a href="#h25-0-182" id="h25-0-182" class="i">+
</a><a href="#h25-0-183" id="h25-0-183" class="i">+// EncodeZigzag32 writes a zigzag-encoded 32-bit integer
</a><a href="#h25-0-184" id="h25-0-184" class="i">+// to the Buffer.
</a><a href="#h25-0-185" id="h25-0-185" class="i">+// This is the format used for the sint32 protocol buffer type.
</a><a href="#h25-0-186" id="h25-0-186" class="i">+func (p *Buffer) EncodeZigzag32(x uint64) error {
</a><a href="#h25-0-187" id="h25-0-187" class="i">+	// use signed number to get arithmetic right shift.
</a><a href="#h25-0-188" id="h25-0-188" class="i">+	return p.EncodeVarint(uint64((uint32(x) &lt;&lt; 1) ^ uint32((int32(x) &gt;&gt; 31))))
</a><a href="#h25-0-189" id="h25-0-189" class="i">+}
</a><a href="#h25-0-190" id="h25-0-190" class="i">+
</a><a href="#h25-0-191" id="h25-0-191" class="i">+func sizeZigzag32(x uint64) int {
</a><a href="#h25-0-192" id="h25-0-192" class="i">+	return sizeVarint(uint64((uint32(x) &lt;&lt; 1) ^ uint32((int32(x) &gt;&gt; 31))))
</a><a href="#h25-0-193" id="h25-0-193" class="i">+}
</a><a href="#h25-0-194" id="h25-0-194" class="i">+
</a><a href="#h25-0-195" id="h25-0-195" class="i">+// EncodeRawBytes writes a count-delimited byte buffer to the Buffer.
</a><a href="#h25-0-196" id="h25-0-196" class="i">+// This is the format used for the bytes protocol buffer
</a><a href="#h25-0-197" id="h25-0-197" class="i">+// type and for embedded messages.
</a><a href="#h25-0-198" id="h25-0-198" class="i">+func (p *Buffer) EncodeRawBytes(b []byte) error {
</a><a href="#h25-0-199" id="h25-0-199" class="i">+	p.EncodeVarint(uint64(len(b)))
</a><a href="#h25-0-200" id="h25-0-200" class="i">+	p.buf = append(p.buf, b...)
</a><a href="#h25-0-201" id="h25-0-201" class="i">+	return nil
</a><a href="#h25-0-202" id="h25-0-202" class="i">+}
</a><a href="#h25-0-203" id="h25-0-203" class="i">+
</a><a href="#h25-0-204" id="h25-0-204" class="i">+func sizeRawBytes(b []byte) int {
</a><a href="#h25-0-205" id="h25-0-205" class="i">+	return sizeVarint(uint64(len(b))) +
</a><a href="#h25-0-206" id="h25-0-206" class="i">+		len(b)
</a><a href="#h25-0-207" id="h25-0-207" class="i">+}
</a><a href="#h25-0-208" id="h25-0-208" class="i">+
</a><a href="#h25-0-209" id="h25-0-209" class="i">+// EncodeStringBytes writes an encoded string to the Buffer.
</a><a href="#h25-0-210" id="h25-0-210" class="i">+// This is the format used for the proto2 string type.
</a><a href="#h25-0-211" id="h25-0-211" class="i">+func (p *Buffer) EncodeStringBytes(s string) error {
</a><a href="#h25-0-212" id="h25-0-212" class="i">+	p.EncodeVarint(uint64(len(s)))
</a><a href="#h25-0-213" id="h25-0-213" class="i">+	p.buf = append(p.buf, s...)
</a><a href="#h25-0-214" id="h25-0-214" class="i">+	return nil
</a><a href="#h25-0-215" id="h25-0-215" class="i">+}
</a><a href="#h25-0-216" id="h25-0-216" class="i">+
</a><a href="#h25-0-217" id="h25-0-217" class="i">+func sizeStringBytes(s string) int {
</a><a href="#h25-0-218" id="h25-0-218" class="i">+	return sizeVarint(uint64(len(s))) +
</a><a href="#h25-0-219" id="h25-0-219" class="i">+		len(s)
</a><a href="#h25-0-220" id="h25-0-220" class="i">+}
</a><a href="#h25-0-221" id="h25-0-221" class="i">+
</a><a href="#h25-0-222" id="h25-0-222" class="i">+// Marshaler is the interface representing objects that can marshal themselves.
</a><a href="#h25-0-223" id="h25-0-223" class="i">+type Marshaler interface {
</a><a href="#h25-0-224" id="h25-0-224" class="i">+	Marshal() ([]byte, error)
</a><a href="#h25-0-225" id="h25-0-225" class="i">+}
</a><a href="#h25-0-226" id="h25-0-226" class="i">+
</a><a href="#h25-0-227" id="h25-0-227" class="i">+// Marshal takes the protocol buffer
</a><a href="#h25-0-228" id="h25-0-228" class="i">+// and encodes it into the wire format, returning the data.
</a><a href="#h25-0-229" id="h25-0-229" class="i">+func Marshal(pb Message) ([]byte, error) {
</a><a href="#h25-0-230" id="h25-0-230" class="i">+	// Can the object marshal itself?
</a><a href="#h25-0-231" id="h25-0-231" class="i">+	if m, ok := pb.(Marshaler); ok {
</a><a href="#h25-0-232" id="h25-0-232" class="i">+		return m.Marshal()
</a><a href="#h25-0-233" id="h25-0-233" class="i">+	}
</a><a href="#h25-0-234" id="h25-0-234" class="i">+	p := NewBuffer(nil)
</a><a href="#h25-0-235" id="h25-0-235" class="i">+	err := p.Marshal(pb)
</a><a href="#h25-0-236" id="h25-0-236" class="i">+	var state errorState
</a><a href="#h25-0-237" id="h25-0-237" class="i">+	if err != nil &amp;&amp; !state.shouldContinue(err, nil) {
</a><a href="#h25-0-238" id="h25-0-238" class="i">+		return nil, err
</a><a href="#h25-0-239" id="h25-0-239" class="i">+	}
</a><a href="#h25-0-240" id="h25-0-240" class="i">+	if p.buf == nil &amp;&amp; err == nil {
</a><a href="#h25-0-241" id="h25-0-241" class="i">+		// Return a non-nil slice on success.
</a><a href="#h25-0-242" id="h25-0-242" class="i">+		return []byte{}, nil
</a><a href="#h25-0-243" id="h25-0-243" class="i">+	}
</a><a href="#h25-0-244" id="h25-0-244" class="i">+	return p.buf, err
</a><a href="#h25-0-245" id="h25-0-245" class="i">+}
</a><a href="#h25-0-246" id="h25-0-246" class="i">+
</a><a href="#h25-0-247" id="h25-0-247" class="i">+// EncodeMessage writes the protocol buffer to the Buffer,
</a><a href="#h25-0-248" id="h25-0-248" class="i">+// prefixed by a varint-encoded length.
</a><a href="#h25-0-249" id="h25-0-249" class="i">+func (p *Buffer) EncodeMessage(pb Message) error {
</a><a href="#h25-0-250" id="h25-0-250" class="i">+	t, base, err := getbase(pb)
</a><a href="#h25-0-251" id="h25-0-251" class="i">+	if structPointer_IsNil(base) {
</a><a href="#h25-0-252" id="h25-0-252" class="i">+		return ErrNil
</a><a href="#h25-0-253" id="h25-0-253" class="i">+	}
</a><a href="#h25-0-254" id="h25-0-254" class="i">+	if err == nil {
</a><a href="#h25-0-255" id="h25-0-255" class="i">+		var state errorState
</a><a href="#h25-0-256" id="h25-0-256" class="i">+		err = p.enc_len_struct(GetProperties(t.Elem()), base, &amp;state)
</a><a href="#h25-0-257" id="h25-0-257" class="i">+	}
</a><a href="#h25-0-258" id="h25-0-258" class="i">+	return err
</a><a href="#h25-0-259" id="h25-0-259" class="i">+}
</a><a href="#h25-0-260" id="h25-0-260" class="i">+
</a><a href="#h25-0-261" id="h25-0-261" class="i">+// Marshal takes the protocol buffer
</a><a href="#h25-0-262" id="h25-0-262" class="i">+// and encodes it into the wire format, writing the result to the
</a><a href="#h25-0-263" id="h25-0-263" class="i">+// Buffer.
</a><a href="#h25-0-264" id="h25-0-264" class="i">+func (p *Buffer) Marshal(pb Message) error {
</a><a href="#h25-0-265" id="h25-0-265" class="i">+	// Can the object marshal itself?
</a><a href="#h25-0-266" id="h25-0-266" class="i">+	if m, ok := pb.(Marshaler); ok {
</a><a href="#h25-0-267" id="h25-0-267" class="i">+		data, err := m.Marshal()
</a><a href="#h25-0-268" id="h25-0-268" class="i">+		if err != nil {
</a><a href="#h25-0-269" id="h25-0-269" class="i">+			return err
</a><a href="#h25-0-270" id="h25-0-270" class="i">+		}
</a><a href="#h25-0-271" id="h25-0-271" class="i">+		p.buf = append(p.buf, data...)
</a><a href="#h25-0-272" id="h25-0-272" class="i">+		return nil
</a><a href="#h25-0-273" id="h25-0-273" class="i">+	}
</a><a href="#h25-0-274" id="h25-0-274" class="i">+
</a><a href="#h25-0-275" id="h25-0-275" class="i">+	t, base, err := getbase(pb)
</a><a href="#h25-0-276" id="h25-0-276" class="i">+	if structPointer_IsNil(base) {
</a><a href="#h25-0-277" id="h25-0-277" class="i">+		return ErrNil
</a><a href="#h25-0-278" id="h25-0-278" class="i">+	}
</a><a href="#h25-0-279" id="h25-0-279" class="i">+	if err == nil {
</a><a href="#h25-0-280" id="h25-0-280" class="i">+		err = p.enc_struct(GetProperties(t.Elem()), base)
</a><a href="#h25-0-281" id="h25-0-281" class="i">+	}
</a><a href="#h25-0-282" id="h25-0-282" class="i">+
</a><a href="#h25-0-283" id="h25-0-283" class="i">+	if collectStats {
</a><a href="#h25-0-284" id="h25-0-284" class="i">+		stats.Encode++
</a><a href="#h25-0-285" id="h25-0-285" class="i">+	}
</a><a href="#h25-0-286" id="h25-0-286" class="i">+
</a><a href="#h25-0-287" id="h25-0-287" class="i">+	if len(p.buf) &gt; maxMarshalSize {
</a><a href="#h25-0-288" id="h25-0-288" class="i">+		return ErrTooLarge
</a><a href="#h25-0-289" id="h25-0-289" class="i">+	}
</a><a href="#h25-0-290" id="h25-0-290" class="i">+	return err
</a><a href="#h25-0-291" id="h25-0-291" class="i">+}
</a><a href="#h25-0-292" id="h25-0-292" class="i">+
</a><a href="#h25-0-293" id="h25-0-293" class="i">+// Size returns the encoded size of a protocol buffer.
</a><a href="#h25-0-294" id="h25-0-294" class="i">+func Size(pb Message) (n int) {
</a><a href="#h25-0-295" id="h25-0-295" class="i">+	// Can the object marshal itself?  If so, Size is slow.
</a><a href="#h25-0-296" id="h25-0-296" class="i">+	// TODO: add Size to Marshaler, or add a Sizer interface.
</a><a href="#h25-0-297" id="h25-0-297" class="i">+	if m, ok := pb.(Marshaler); ok {
</a><a href="#h25-0-298" id="h25-0-298" class="i">+		b, _ := m.Marshal()
</a><a href="#h25-0-299" id="h25-0-299" class="i">+		return len(b)
</a><a href="#h25-0-300" id="h25-0-300" class="i">+	}
</a><a href="#h25-0-301" id="h25-0-301" class="i">+
</a><a href="#h25-0-302" id="h25-0-302" class="i">+	t, base, err := getbase(pb)
</a><a href="#h25-0-303" id="h25-0-303" class="i">+	if structPointer_IsNil(base) {
</a><a href="#h25-0-304" id="h25-0-304" class="i">+		return 0
</a><a href="#h25-0-305" id="h25-0-305" class="i">+	}
</a><a href="#h25-0-306" id="h25-0-306" class="i">+	if err == nil {
</a><a href="#h25-0-307" id="h25-0-307" class="i">+		n = size_struct(GetProperties(t.Elem()), base)
</a><a href="#h25-0-308" id="h25-0-308" class="i">+	}
</a><a href="#h25-0-309" id="h25-0-309" class="i">+
</a><a href="#h25-0-310" id="h25-0-310" class="i">+	if collectStats {
</a><a href="#h25-0-311" id="h25-0-311" class="i">+		stats.Size++
</a><a href="#h25-0-312" id="h25-0-312" class="i">+	}
</a><a href="#h25-0-313" id="h25-0-313" class="i">+
</a><a href="#h25-0-314" id="h25-0-314" class="i">+	return
</a><a href="#h25-0-315" id="h25-0-315" class="i">+}
</a><a href="#h25-0-316" id="h25-0-316" class="i">+
</a><a href="#h25-0-317" id="h25-0-317" class="i">+// Individual type encoders.
</a><a href="#h25-0-318" id="h25-0-318" class="i">+
</a><a href="#h25-0-319" id="h25-0-319" class="i">+// Encode a bool.
</a><a href="#h25-0-320" id="h25-0-320" class="i">+func (o *Buffer) enc_bool(p *Properties, base structPointer) error {
</a><a href="#h25-0-321" id="h25-0-321" class="i">+	v := *structPointer_Bool(base, p.field)
</a><a href="#h25-0-322" id="h25-0-322" class="i">+	if v == nil {
</a><a href="#h25-0-323" id="h25-0-323" class="i">+		return ErrNil
</a><a href="#h25-0-324" id="h25-0-324" class="i">+	}
</a><a href="#h25-0-325" id="h25-0-325" class="i">+	x := 0
</a><a href="#h25-0-326" id="h25-0-326" class="i">+	if *v {
</a><a href="#h25-0-327" id="h25-0-327" class="i">+		x = 1
</a><a href="#h25-0-328" id="h25-0-328" class="i">+	}
</a><a href="#h25-0-329" id="h25-0-329" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-330" id="h25-0-330" class="i">+	p.valEnc(o, uint64(x))
</a><a href="#h25-0-331" id="h25-0-331" class="i">+	return nil
</a><a href="#h25-0-332" id="h25-0-332" class="i">+}
</a><a href="#h25-0-333" id="h25-0-333" class="i">+
</a><a href="#h25-0-334" id="h25-0-334" class="i">+func (o *Buffer) enc_proto3_bool(p *Properties, base structPointer) error {
</a><a href="#h25-0-335" id="h25-0-335" class="i">+	v := *structPointer_BoolVal(base, p.field)
</a><a href="#h25-0-336" id="h25-0-336" class="i">+	if !v {
</a><a href="#h25-0-337" id="h25-0-337" class="i">+		return ErrNil
</a><a href="#h25-0-338" id="h25-0-338" class="i">+	}
</a><a href="#h25-0-339" id="h25-0-339" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-340" id="h25-0-340" class="i">+	p.valEnc(o, 1)
</a><a href="#h25-0-341" id="h25-0-341" class="i">+	return nil
</a><a href="#h25-0-342" id="h25-0-342" class="i">+}
</a><a href="#h25-0-343" id="h25-0-343" class="i">+
</a><a href="#h25-0-344" id="h25-0-344" class="i">+func size_bool(p *Properties, base structPointer) int {
</a><a href="#h25-0-345" id="h25-0-345" class="i">+	v := *structPointer_Bool(base, p.field)
</a><a href="#h25-0-346" id="h25-0-346" class="i">+	if v == nil {
</a><a href="#h25-0-347" id="h25-0-347" class="i">+		return 0
</a><a href="#h25-0-348" id="h25-0-348" class="i">+	}
</a><a href="#h25-0-349" id="h25-0-349" class="i">+	return len(p.tagcode) + 1 // each bool takes exactly one byte
</a><a href="#h25-0-350" id="h25-0-350" class="i">+}
</a><a href="#h25-0-351" id="h25-0-351" class="i">+
</a><a href="#h25-0-352" id="h25-0-352" class="i">+func size_proto3_bool(p *Properties, base structPointer) int {
</a><a href="#h25-0-353" id="h25-0-353" class="i">+	v := *structPointer_BoolVal(base, p.field)
</a><a href="#h25-0-354" id="h25-0-354" class="i">+	if !v &amp;&amp; !p.oneof {
</a><a href="#h25-0-355" id="h25-0-355" class="i">+		return 0
</a><a href="#h25-0-356" id="h25-0-356" class="i">+	}
</a><a href="#h25-0-357" id="h25-0-357" class="i">+	return len(p.tagcode) + 1 // each bool takes exactly one byte
</a><a href="#h25-0-358" id="h25-0-358" class="i">+}
</a><a href="#h25-0-359" id="h25-0-359" class="i">+
</a><a href="#h25-0-360" id="h25-0-360" class="i">+// Encode an int32.
</a><a href="#h25-0-361" id="h25-0-361" class="i">+func (o *Buffer) enc_int32(p *Properties, base structPointer) error {
</a><a href="#h25-0-362" id="h25-0-362" class="i">+	v := structPointer_Word32(base, p.field)
</a><a href="#h25-0-363" id="h25-0-363" class="i">+	if word32_IsNil(v) {
</a><a href="#h25-0-364" id="h25-0-364" class="i">+		return ErrNil
</a><a href="#h25-0-365" id="h25-0-365" class="i">+	}
</a><a href="#h25-0-366" id="h25-0-366" class="i">+	x := int32(word32_Get(v)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-367" id="h25-0-367" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-368" id="h25-0-368" class="i">+	p.valEnc(o, uint64(x))
</a><a href="#h25-0-369" id="h25-0-369" class="i">+	return nil
</a><a href="#h25-0-370" id="h25-0-370" class="i">+}
</a><a href="#h25-0-371" id="h25-0-371" class="i">+
</a><a href="#h25-0-372" id="h25-0-372" class="i">+func (o *Buffer) enc_proto3_int32(p *Properties, base structPointer) error {
</a><a href="#h25-0-373" id="h25-0-373" class="i">+	v := structPointer_Word32Val(base, p.field)
</a><a href="#h25-0-374" id="h25-0-374" class="i">+	x := int32(word32Val_Get(v)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-375" id="h25-0-375" class="i">+	if x == 0 {
</a><a href="#h25-0-376" id="h25-0-376" class="i">+		return ErrNil
</a><a href="#h25-0-377" id="h25-0-377" class="i">+	}
</a><a href="#h25-0-378" id="h25-0-378" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-379" id="h25-0-379" class="i">+	p.valEnc(o, uint64(x))
</a><a href="#h25-0-380" id="h25-0-380" class="i">+	return nil
</a><a href="#h25-0-381" id="h25-0-381" class="i">+}
</a><a href="#h25-0-382" id="h25-0-382" class="i">+
</a><a href="#h25-0-383" id="h25-0-383" class="i">+func size_int32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-384" id="h25-0-384" class="i">+	v := structPointer_Word32(base, p.field)
</a><a href="#h25-0-385" id="h25-0-385" class="i">+	if word32_IsNil(v) {
</a><a href="#h25-0-386" id="h25-0-386" class="i">+		return 0
</a><a href="#h25-0-387" id="h25-0-387" class="i">+	}
</a><a href="#h25-0-388" id="h25-0-388" class="i">+	x := int32(word32_Get(v)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-389" id="h25-0-389" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-390" id="h25-0-390" class="i">+	n += p.valSize(uint64(x))
</a><a href="#h25-0-391" id="h25-0-391" class="i">+	return
</a><a href="#h25-0-392" id="h25-0-392" class="i">+}
</a><a href="#h25-0-393" id="h25-0-393" class="i">+
</a><a href="#h25-0-394" id="h25-0-394" class="i">+func size_proto3_int32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-395" id="h25-0-395" class="i">+	v := structPointer_Word32Val(base, p.field)
</a><a href="#h25-0-396" id="h25-0-396" class="i">+	x := int32(word32Val_Get(v)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-397" id="h25-0-397" class="i">+	if x == 0 &amp;&amp; !p.oneof {
</a><a href="#h25-0-398" id="h25-0-398" class="i">+		return 0
</a><a href="#h25-0-399" id="h25-0-399" class="i">+	}
</a><a href="#h25-0-400" id="h25-0-400" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-401" id="h25-0-401" class="i">+	n += p.valSize(uint64(x))
</a><a href="#h25-0-402" id="h25-0-402" class="i">+	return
</a><a href="#h25-0-403" id="h25-0-403" class="i">+}
</a><a href="#h25-0-404" id="h25-0-404" class="i">+
</a><a href="#h25-0-405" id="h25-0-405" class="i">+// Encode a uint32.
</a><a href="#h25-0-406" id="h25-0-406" class="i">+// Exactly the same as int32, except for no sign extension.
</a><a href="#h25-0-407" id="h25-0-407" class="i">+func (o *Buffer) enc_uint32(p *Properties, base structPointer) error {
</a><a href="#h25-0-408" id="h25-0-408" class="i">+	v := structPointer_Word32(base, p.field)
</a><a href="#h25-0-409" id="h25-0-409" class="i">+	if word32_IsNil(v) {
</a><a href="#h25-0-410" id="h25-0-410" class="i">+		return ErrNil
</a><a href="#h25-0-411" id="h25-0-411" class="i">+	}
</a><a href="#h25-0-412" id="h25-0-412" class="i">+	x := word32_Get(v)
</a><a href="#h25-0-413" id="h25-0-413" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-414" id="h25-0-414" class="i">+	p.valEnc(o, uint64(x))
</a><a href="#h25-0-415" id="h25-0-415" class="i">+	return nil
</a><a href="#h25-0-416" id="h25-0-416" class="i">+}
</a><a href="#h25-0-417" id="h25-0-417" class="i">+
</a><a href="#h25-0-418" id="h25-0-418" class="i">+func (o *Buffer) enc_proto3_uint32(p *Properties, base structPointer) error {
</a><a href="#h25-0-419" id="h25-0-419" class="i">+	v := structPointer_Word32Val(base, p.field)
</a><a href="#h25-0-420" id="h25-0-420" class="i">+	x := word32Val_Get(v)
</a><a href="#h25-0-421" id="h25-0-421" class="i">+	if x == 0 {
</a><a href="#h25-0-422" id="h25-0-422" class="i">+		return ErrNil
</a><a href="#h25-0-423" id="h25-0-423" class="i">+	}
</a><a href="#h25-0-424" id="h25-0-424" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-425" id="h25-0-425" class="i">+	p.valEnc(o, uint64(x))
</a><a href="#h25-0-426" id="h25-0-426" class="i">+	return nil
</a><a href="#h25-0-427" id="h25-0-427" class="i">+}
</a><a href="#h25-0-428" id="h25-0-428" class="i">+
</a><a href="#h25-0-429" id="h25-0-429" class="i">+func size_uint32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-430" id="h25-0-430" class="i">+	v := structPointer_Word32(base, p.field)
</a><a href="#h25-0-431" id="h25-0-431" class="i">+	if word32_IsNil(v) {
</a><a href="#h25-0-432" id="h25-0-432" class="i">+		return 0
</a><a href="#h25-0-433" id="h25-0-433" class="i">+	}
</a><a href="#h25-0-434" id="h25-0-434" class="i">+	x := word32_Get(v)
</a><a href="#h25-0-435" id="h25-0-435" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-436" id="h25-0-436" class="i">+	n += p.valSize(uint64(x))
</a><a href="#h25-0-437" id="h25-0-437" class="i">+	return
</a><a href="#h25-0-438" id="h25-0-438" class="i">+}
</a><a href="#h25-0-439" id="h25-0-439" class="i">+
</a><a href="#h25-0-440" id="h25-0-440" class="i">+func size_proto3_uint32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-441" id="h25-0-441" class="i">+	v := structPointer_Word32Val(base, p.field)
</a><a href="#h25-0-442" id="h25-0-442" class="i">+	x := word32Val_Get(v)
</a><a href="#h25-0-443" id="h25-0-443" class="i">+	if x == 0 &amp;&amp; !p.oneof {
</a><a href="#h25-0-444" id="h25-0-444" class="i">+		return 0
</a><a href="#h25-0-445" id="h25-0-445" class="i">+	}
</a><a href="#h25-0-446" id="h25-0-446" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-447" id="h25-0-447" class="i">+	n += p.valSize(uint64(x))
</a><a href="#h25-0-448" id="h25-0-448" class="i">+	return
</a><a href="#h25-0-449" id="h25-0-449" class="i">+}
</a><a href="#h25-0-450" id="h25-0-450" class="i">+
</a><a href="#h25-0-451" id="h25-0-451" class="i">+// Encode an int64.
</a><a href="#h25-0-452" id="h25-0-452" class="i">+func (o *Buffer) enc_int64(p *Properties, base structPointer) error {
</a><a href="#h25-0-453" id="h25-0-453" class="i">+	v := structPointer_Word64(base, p.field)
</a><a href="#h25-0-454" id="h25-0-454" class="i">+	if word64_IsNil(v) {
</a><a href="#h25-0-455" id="h25-0-455" class="i">+		return ErrNil
</a><a href="#h25-0-456" id="h25-0-456" class="i">+	}
</a><a href="#h25-0-457" id="h25-0-457" class="i">+	x := word64_Get(v)
</a><a href="#h25-0-458" id="h25-0-458" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-459" id="h25-0-459" class="i">+	p.valEnc(o, x)
</a><a href="#h25-0-460" id="h25-0-460" class="i">+	return nil
</a><a href="#h25-0-461" id="h25-0-461" class="i">+}
</a><a href="#h25-0-462" id="h25-0-462" class="i">+
</a><a href="#h25-0-463" id="h25-0-463" class="i">+func (o *Buffer) enc_proto3_int64(p *Properties, base structPointer) error {
</a><a href="#h25-0-464" id="h25-0-464" class="i">+	v := structPointer_Word64Val(base, p.field)
</a><a href="#h25-0-465" id="h25-0-465" class="i">+	x := word64Val_Get(v)
</a><a href="#h25-0-466" id="h25-0-466" class="i">+	if x == 0 {
</a><a href="#h25-0-467" id="h25-0-467" class="i">+		return ErrNil
</a><a href="#h25-0-468" id="h25-0-468" class="i">+	}
</a><a href="#h25-0-469" id="h25-0-469" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-470" id="h25-0-470" class="i">+	p.valEnc(o, x)
</a><a href="#h25-0-471" id="h25-0-471" class="i">+	return nil
</a><a href="#h25-0-472" id="h25-0-472" class="i">+}
</a><a href="#h25-0-473" id="h25-0-473" class="i">+
</a><a href="#h25-0-474" id="h25-0-474" class="i">+func size_int64(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-475" id="h25-0-475" class="i">+	v := structPointer_Word64(base, p.field)
</a><a href="#h25-0-476" id="h25-0-476" class="i">+	if word64_IsNil(v) {
</a><a href="#h25-0-477" id="h25-0-477" class="i">+		return 0
</a><a href="#h25-0-478" id="h25-0-478" class="i">+	}
</a><a href="#h25-0-479" id="h25-0-479" class="i">+	x := word64_Get(v)
</a><a href="#h25-0-480" id="h25-0-480" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-481" id="h25-0-481" class="i">+	n += p.valSize(x)
</a><a href="#h25-0-482" id="h25-0-482" class="i">+	return
</a><a href="#h25-0-483" id="h25-0-483" class="i">+}
</a><a href="#h25-0-484" id="h25-0-484" class="i">+
</a><a href="#h25-0-485" id="h25-0-485" class="i">+func size_proto3_int64(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-486" id="h25-0-486" class="i">+	v := structPointer_Word64Val(base, p.field)
</a><a href="#h25-0-487" id="h25-0-487" class="i">+	x := word64Val_Get(v)
</a><a href="#h25-0-488" id="h25-0-488" class="i">+	if x == 0 &amp;&amp; !p.oneof {
</a><a href="#h25-0-489" id="h25-0-489" class="i">+		return 0
</a><a href="#h25-0-490" id="h25-0-490" class="i">+	}
</a><a href="#h25-0-491" id="h25-0-491" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-492" id="h25-0-492" class="i">+	n += p.valSize(x)
</a><a href="#h25-0-493" id="h25-0-493" class="i">+	return
</a><a href="#h25-0-494" id="h25-0-494" class="i">+}
</a><a href="#h25-0-495" id="h25-0-495" class="i">+
</a><a href="#h25-0-496" id="h25-0-496" class="i">+// Encode a string.
</a><a href="#h25-0-497" id="h25-0-497" class="i">+func (o *Buffer) enc_string(p *Properties, base structPointer) error {
</a><a href="#h25-0-498" id="h25-0-498" class="i">+	v := *structPointer_String(base, p.field)
</a><a href="#h25-0-499" id="h25-0-499" class="i">+	if v == nil {
</a><a href="#h25-0-500" id="h25-0-500" class="i">+		return ErrNil
</a><a href="#h25-0-501" id="h25-0-501" class="i">+	}
</a><a href="#h25-0-502" id="h25-0-502" class="i">+	x := *v
</a><a href="#h25-0-503" id="h25-0-503" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-504" id="h25-0-504" class="i">+	o.EncodeStringBytes(x)
</a><a href="#h25-0-505" id="h25-0-505" class="i">+	return nil
</a><a href="#h25-0-506" id="h25-0-506" class="i">+}
</a><a href="#h25-0-507" id="h25-0-507" class="i">+
</a><a href="#h25-0-508" id="h25-0-508" class="i">+func (o *Buffer) enc_proto3_string(p *Properties, base structPointer) error {
</a><a href="#h25-0-509" id="h25-0-509" class="i">+	v := *structPointer_StringVal(base, p.field)
</a><a href="#h25-0-510" id="h25-0-510" class="i">+	if v == &quot;&quot; {
</a><a href="#h25-0-511" id="h25-0-511" class="i">+		return ErrNil
</a><a href="#h25-0-512" id="h25-0-512" class="i">+	}
</a><a href="#h25-0-513" id="h25-0-513" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-514" id="h25-0-514" class="i">+	o.EncodeStringBytes(v)
</a><a href="#h25-0-515" id="h25-0-515" class="i">+	return nil
</a><a href="#h25-0-516" id="h25-0-516" class="i">+}
</a><a href="#h25-0-517" id="h25-0-517" class="i">+
</a><a href="#h25-0-518" id="h25-0-518" class="i">+func size_string(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-519" id="h25-0-519" class="i">+	v := *structPointer_String(base, p.field)
</a><a href="#h25-0-520" id="h25-0-520" class="i">+	if v == nil {
</a><a href="#h25-0-521" id="h25-0-521" class="i">+		return 0
</a><a href="#h25-0-522" id="h25-0-522" class="i">+	}
</a><a href="#h25-0-523" id="h25-0-523" class="i">+	x := *v
</a><a href="#h25-0-524" id="h25-0-524" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-525" id="h25-0-525" class="i">+	n += sizeStringBytes(x)
</a><a href="#h25-0-526" id="h25-0-526" class="i">+	return
</a><a href="#h25-0-527" id="h25-0-527" class="i">+}
</a><a href="#h25-0-528" id="h25-0-528" class="i">+
</a><a href="#h25-0-529" id="h25-0-529" class="i">+func size_proto3_string(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-530" id="h25-0-530" class="i">+	v := *structPointer_StringVal(base, p.field)
</a><a href="#h25-0-531" id="h25-0-531" class="i">+	if v == &quot;&quot; &amp;&amp; !p.oneof {
</a><a href="#h25-0-532" id="h25-0-532" class="i">+		return 0
</a><a href="#h25-0-533" id="h25-0-533" class="i">+	}
</a><a href="#h25-0-534" id="h25-0-534" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-535" id="h25-0-535" class="i">+	n += sizeStringBytes(v)
</a><a href="#h25-0-536" id="h25-0-536" class="i">+	return
</a><a href="#h25-0-537" id="h25-0-537" class="i">+}
</a><a href="#h25-0-538" id="h25-0-538" class="i">+
</a><a href="#h25-0-539" id="h25-0-539" class="i">+// All protocol buffer fields are nillable, but be careful.
</a><a href="#h25-0-540" id="h25-0-540" class="i">+func isNil(v reflect.Value) bool {
</a><a href="#h25-0-541" id="h25-0-541" class="i">+	switch v.Kind() {
</a><a href="#h25-0-542" id="h25-0-542" class="i">+	case reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
</a><a href="#h25-0-543" id="h25-0-543" class="i">+		return v.IsNil()
</a><a href="#h25-0-544" id="h25-0-544" class="i">+	}
</a><a href="#h25-0-545" id="h25-0-545" class="i">+	return false
</a><a href="#h25-0-546" id="h25-0-546" class="i">+}
</a><a href="#h25-0-547" id="h25-0-547" class="i">+
</a><a href="#h25-0-548" id="h25-0-548" class="i">+// Encode a message struct.
</a><a href="#h25-0-549" id="h25-0-549" class="i">+func (o *Buffer) enc_struct_message(p *Properties, base structPointer) error {
</a><a href="#h25-0-550" id="h25-0-550" class="i">+	var state errorState
</a><a href="#h25-0-551" id="h25-0-551" class="i">+	structp := structPointer_GetStructPointer(base, p.field)
</a><a href="#h25-0-552" id="h25-0-552" class="i">+	if structPointer_IsNil(structp) {
</a><a href="#h25-0-553" id="h25-0-553" class="i">+		return ErrNil
</a><a href="#h25-0-554" id="h25-0-554" class="i">+	}
</a><a href="#h25-0-555" id="h25-0-555" class="i">+
</a><a href="#h25-0-556" id="h25-0-556" class="i">+	// Can the object marshal itself?
</a><a href="#h25-0-557" id="h25-0-557" class="i">+	if p.isMarshaler {
</a><a href="#h25-0-558" id="h25-0-558" class="i">+		m := structPointer_Interface(structp, p.stype).(Marshaler)
</a><a href="#h25-0-559" id="h25-0-559" class="i">+		data, err := m.Marshal()
</a><a href="#h25-0-560" id="h25-0-560" class="i">+		if err != nil &amp;&amp; !state.shouldContinue(err, nil) {
</a><a href="#h25-0-561" id="h25-0-561" class="i">+			return err
</a><a href="#h25-0-562" id="h25-0-562" class="i">+		}
</a><a href="#h25-0-563" id="h25-0-563" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-564" id="h25-0-564" class="i">+		o.EncodeRawBytes(data)
</a><a href="#h25-0-565" id="h25-0-565" class="i">+		return state.err
</a><a href="#h25-0-566" id="h25-0-566" class="i">+	}
</a><a href="#h25-0-567" id="h25-0-567" class="i">+
</a><a href="#h25-0-568" id="h25-0-568" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-569" id="h25-0-569" class="i">+	return o.enc_len_struct(p.sprop, structp, &amp;state)
</a><a href="#h25-0-570" id="h25-0-570" class="i">+}
</a><a href="#h25-0-571" id="h25-0-571" class="i">+
</a><a href="#h25-0-572" id="h25-0-572" class="i">+func size_struct_message(p *Properties, base structPointer) int {
</a><a href="#h25-0-573" id="h25-0-573" class="i">+	structp := structPointer_GetStructPointer(base, p.field)
</a><a href="#h25-0-574" id="h25-0-574" class="i">+	if structPointer_IsNil(structp) {
</a><a href="#h25-0-575" id="h25-0-575" class="i">+		return 0
</a><a href="#h25-0-576" id="h25-0-576" class="i">+	}
</a><a href="#h25-0-577" id="h25-0-577" class="i">+
</a><a href="#h25-0-578" id="h25-0-578" class="i">+	// Can the object marshal itself?
</a><a href="#h25-0-579" id="h25-0-579" class="i">+	if p.isMarshaler {
</a><a href="#h25-0-580" id="h25-0-580" class="i">+		m := structPointer_Interface(structp, p.stype).(Marshaler)
</a><a href="#h25-0-581" id="h25-0-581" class="i">+		data, _ := m.Marshal()
</a><a href="#h25-0-582" id="h25-0-582" class="i">+		n0 := len(p.tagcode)
</a><a href="#h25-0-583" id="h25-0-583" class="i">+		n1 := sizeRawBytes(data)
</a><a href="#h25-0-584" id="h25-0-584" class="i">+		return n0 + n1
</a><a href="#h25-0-585" id="h25-0-585" class="i">+	}
</a><a href="#h25-0-586" id="h25-0-586" class="i">+
</a><a href="#h25-0-587" id="h25-0-587" class="i">+	n0 := len(p.tagcode)
</a><a href="#h25-0-588" id="h25-0-588" class="i">+	n1 := size_struct(p.sprop, structp)
</a><a href="#h25-0-589" id="h25-0-589" class="i">+	n2 := sizeVarint(uint64(n1)) // size of encoded length
</a><a href="#h25-0-590" id="h25-0-590" class="i">+	return n0 + n1 + n2
</a><a href="#h25-0-591" id="h25-0-591" class="i">+}
</a><a href="#h25-0-592" id="h25-0-592" class="i">+
</a><a href="#h25-0-593" id="h25-0-593" class="i">+// Encode a group struct.
</a><a href="#h25-0-594" id="h25-0-594" class="i">+func (o *Buffer) enc_struct_group(p *Properties, base structPointer) error {
</a><a href="#h25-0-595" id="h25-0-595" class="i">+	var state errorState
</a><a href="#h25-0-596" id="h25-0-596" class="i">+	b := structPointer_GetStructPointer(base, p.field)
</a><a href="#h25-0-597" id="h25-0-597" class="i">+	if structPointer_IsNil(b) {
</a><a href="#h25-0-598" id="h25-0-598" class="i">+		return ErrNil
</a><a href="#h25-0-599" id="h25-0-599" class="i">+	}
</a><a href="#h25-0-600" id="h25-0-600" class="i">+
</a><a href="#h25-0-601" id="h25-0-601" class="i">+	o.EncodeVarint(uint64((p.Tag &lt;&lt; 3) | WireStartGroup))
</a><a href="#h25-0-602" id="h25-0-602" class="i">+	err := o.enc_struct(p.sprop, b)
</a><a href="#h25-0-603" id="h25-0-603" class="i">+	if err != nil &amp;&amp; !state.shouldContinue(err, nil) {
</a><a href="#h25-0-604" id="h25-0-604" class="i">+		return err
</a><a href="#h25-0-605" id="h25-0-605" class="i">+	}
</a><a href="#h25-0-606" id="h25-0-606" class="i">+	o.EncodeVarint(uint64((p.Tag &lt;&lt; 3) | WireEndGroup))
</a><a href="#h25-0-607" id="h25-0-607" class="i">+	return state.err
</a><a href="#h25-0-608" id="h25-0-608" class="i">+}
</a><a href="#h25-0-609" id="h25-0-609" class="i">+
</a><a href="#h25-0-610" id="h25-0-610" class="i">+func size_struct_group(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-611" id="h25-0-611" class="i">+	b := structPointer_GetStructPointer(base, p.field)
</a><a href="#h25-0-612" id="h25-0-612" class="i">+	if structPointer_IsNil(b) {
</a><a href="#h25-0-613" id="h25-0-613" class="i">+		return 0
</a><a href="#h25-0-614" id="h25-0-614" class="i">+	}
</a><a href="#h25-0-615" id="h25-0-615" class="i">+
</a><a href="#h25-0-616" id="h25-0-616" class="i">+	n += sizeVarint(uint64((p.Tag &lt;&lt; 3) | WireStartGroup))
</a><a href="#h25-0-617" id="h25-0-617" class="i">+	n += size_struct(p.sprop, b)
</a><a href="#h25-0-618" id="h25-0-618" class="i">+	n += sizeVarint(uint64((p.Tag &lt;&lt; 3) | WireEndGroup))
</a><a href="#h25-0-619" id="h25-0-619" class="i">+	return
</a><a href="#h25-0-620" id="h25-0-620" class="i">+}
</a><a href="#h25-0-621" id="h25-0-621" class="i">+
</a><a href="#h25-0-622" id="h25-0-622" class="i">+// Encode a slice of bools ([]bool).
</a><a href="#h25-0-623" id="h25-0-623" class="i">+func (o *Buffer) enc_slice_bool(p *Properties, base structPointer) error {
</a><a href="#h25-0-624" id="h25-0-624" class="i">+	s := *structPointer_BoolSlice(base, p.field)
</a><a href="#h25-0-625" id="h25-0-625" class="i">+	l := len(s)
</a><a href="#h25-0-626" id="h25-0-626" class="i">+	if l == 0 {
</a><a href="#h25-0-627" id="h25-0-627" class="i">+		return ErrNil
</a><a href="#h25-0-628" id="h25-0-628" class="i">+	}
</a><a href="#h25-0-629" id="h25-0-629" class="i">+	for _, x := range s {
</a><a href="#h25-0-630" id="h25-0-630" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-631" id="h25-0-631" class="i">+		v := uint64(0)
</a><a href="#h25-0-632" id="h25-0-632" class="i">+		if x {
</a><a href="#h25-0-633" id="h25-0-633" class="i">+			v = 1
</a><a href="#h25-0-634" id="h25-0-634" class="i">+		}
</a><a href="#h25-0-635" id="h25-0-635" class="i">+		p.valEnc(o, v)
</a><a href="#h25-0-636" id="h25-0-636" class="i">+	}
</a><a href="#h25-0-637" id="h25-0-637" class="i">+	return nil
</a><a href="#h25-0-638" id="h25-0-638" class="i">+}
</a><a href="#h25-0-639" id="h25-0-639" class="i">+
</a><a href="#h25-0-640" id="h25-0-640" class="i">+func size_slice_bool(p *Properties, base structPointer) int {
</a><a href="#h25-0-641" id="h25-0-641" class="i">+	s := *structPointer_BoolSlice(base, p.field)
</a><a href="#h25-0-642" id="h25-0-642" class="i">+	l := len(s)
</a><a href="#h25-0-643" id="h25-0-643" class="i">+	if l == 0 {
</a><a href="#h25-0-644" id="h25-0-644" class="i">+		return 0
</a><a href="#h25-0-645" id="h25-0-645" class="i">+	}
</a><a href="#h25-0-646" id="h25-0-646" class="i">+	return l * (len(p.tagcode) + 1) // each bool takes exactly one byte
</a><a href="#h25-0-647" id="h25-0-647" class="i">+}
</a><a href="#h25-0-648" id="h25-0-648" class="i">+
</a><a href="#h25-0-649" id="h25-0-649" class="i">+// Encode a slice of bools ([]bool) in packed format.
</a><a href="#h25-0-650" id="h25-0-650" class="i">+func (o *Buffer) enc_slice_packed_bool(p *Properties, base structPointer) error {
</a><a href="#h25-0-651" id="h25-0-651" class="i">+	s := *structPointer_BoolSlice(base, p.field)
</a><a href="#h25-0-652" id="h25-0-652" class="i">+	l := len(s)
</a><a href="#h25-0-653" id="h25-0-653" class="i">+	if l == 0 {
</a><a href="#h25-0-654" id="h25-0-654" class="i">+		return ErrNil
</a><a href="#h25-0-655" id="h25-0-655" class="i">+	}
</a><a href="#h25-0-656" id="h25-0-656" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-657" id="h25-0-657" class="i">+	o.EncodeVarint(uint64(l)) // each bool takes exactly one byte
</a><a href="#h25-0-658" id="h25-0-658" class="i">+	for _, x := range s {
</a><a href="#h25-0-659" id="h25-0-659" class="i">+		v := uint64(0)
</a><a href="#h25-0-660" id="h25-0-660" class="i">+		if x {
</a><a href="#h25-0-661" id="h25-0-661" class="i">+			v = 1
</a><a href="#h25-0-662" id="h25-0-662" class="i">+		}
</a><a href="#h25-0-663" id="h25-0-663" class="i">+		p.valEnc(o, v)
</a><a href="#h25-0-664" id="h25-0-664" class="i">+	}
</a><a href="#h25-0-665" id="h25-0-665" class="i">+	return nil
</a><a href="#h25-0-666" id="h25-0-666" class="i">+}
</a><a href="#h25-0-667" id="h25-0-667" class="i">+
</a><a href="#h25-0-668" id="h25-0-668" class="i">+func size_slice_packed_bool(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-669" id="h25-0-669" class="i">+	s := *structPointer_BoolSlice(base, p.field)
</a><a href="#h25-0-670" id="h25-0-670" class="i">+	l := len(s)
</a><a href="#h25-0-671" id="h25-0-671" class="i">+	if l == 0 {
</a><a href="#h25-0-672" id="h25-0-672" class="i">+		return 0
</a><a href="#h25-0-673" id="h25-0-673" class="i">+	}
</a><a href="#h25-0-674" id="h25-0-674" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-675" id="h25-0-675" class="i">+	n += sizeVarint(uint64(l))
</a><a href="#h25-0-676" id="h25-0-676" class="i">+	n += l // each bool takes exactly one byte
</a><a href="#h25-0-677" id="h25-0-677" class="i">+	return
</a><a href="#h25-0-678" id="h25-0-678" class="i">+}
</a><a href="#h25-0-679" id="h25-0-679" class="i">+
</a><a href="#h25-0-680" id="h25-0-680" class="i">+// Encode a slice of bytes ([]byte).
</a><a href="#h25-0-681" id="h25-0-681" class="i">+func (o *Buffer) enc_slice_byte(p *Properties, base structPointer) error {
</a><a href="#h25-0-682" id="h25-0-682" class="i">+	s := *structPointer_Bytes(base, p.field)
</a><a href="#h25-0-683" id="h25-0-683" class="i">+	if s == nil {
</a><a href="#h25-0-684" id="h25-0-684" class="i">+		return ErrNil
</a><a href="#h25-0-685" id="h25-0-685" class="i">+	}
</a><a href="#h25-0-686" id="h25-0-686" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-687" id="h25-0-687" class="i">+	o.EncodeRawBytes(s)
</a><a href="#h25-0-688" id="h25-0-688" class="i">+	return nil
</a><a href="#h25-0-689" id="h25-0-689" class="i">+}
</a><a href="#h25-0-690" id="h25-0-690" class="i">+
</a><a href="#h25-0-691" id="h25-0-691" class="i">+func (o *Buffer) enc_proto3_slice_byte(p *Properties, base structPointer) error {
</a><a href="#h25-0-692" id="h25-0-692" class="i">+	s := *structPointer_Bytes(base, p.field)
</a><a href="#h25-0-693" id="h25-0-693" class="i">+	if len(s) == 0 {
</a><a href="#h25-0-694" id="h25-0-694" class="i">+		return ErrNil
</a><a href="#h25-0-695" id="h25-0-695" class="i">+	}
</a><a href="#h25-0-696" id="h25-0-696" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-697" id="h25-0-697" class="i">+	o.EncodeRawBytes(s)
</a><a href="#h25-0-698" id="h25-0-698" class="i">+	return nil
</a><a href="#h25-0-699" id="h25-0-699" class="i">+}
</a><a href="#h25-0-700" id="h25-0-700" class="i">+
</a><a href="#h25-0-701" id="h25-0-701" class="i">+func size_slice_byte(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-702" id="h25-0-702" class="i">+	s := *structPointer_Bytes(base, p.field)
</a><a href="#h25-0-703" id="h25-0-703" class="i">+	if s == nil &amp;&amp; !p.oneof {
</a><a href="#h25-0-704" id="h25-0-704" class="i">+		return 0
</a><a href="#h25-0-705" id="h25-0-705" class="i">+	}
</a><a href="#h25-0-706" id="h25-0-706" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-707" id="h25-0-707" class="i">+	n += sizeRawBytes(s)
</a><a href="#h25-0-708" id="h25-0-708" class="i">+	return
</a><a href="#h25-0-709" id="h25-0-709" class="i">+}
</a><a href="#h25-0-710" id="h25-0-710" class="i">+
</a><a href="#h25-0-711" id="h25-0-711" class="i">+func size_proto3_slice_byte(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-712" id="h25-0-712" class="i">+	s := *structPointer_Bytes(base, p.field)
</a><a href="#h25-0-713" id="h25-0-713" class="i">+	if len(s) == 0 &amp;&amp; !p.oneof {
</a><a href="#h25-0-714" id="h25-0-714" class="i">+		return 0
</a><a href="#h25-0-715" id="h25-0-715" class="i">+	}
</a><a href="#h25-0-716" id="h25-0-716" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-717" id="h25-0-717" class="i">+	n += sizeRawBytes(s)
</a><a href="#h25-0-718" id="h25-0-718" class="i">+	return
</a><a href="#h25-0-719" id="h25-0-719" class="i">+}
</a><a href="#h25-0-720" id="h25-0-720" class="i">+
</a><a href="#h25-0-721" id="h25-0-721" class="i">+// Encode a slice of int32s ([]int32).
</a><a href="#h25-0-722" id="h25-0-722" class="i">+func (o *Buffer) enc_slice_int32(p *Properties, base structPointer) error {
</a><a href="#h25-0-723" id="h25-0-723" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-724" id="h25-0-724" class="i">+	l := s.Len()
</a><a href="#h25-0-725" id="h25-0-725" class="i">+	if l == 0 {
</a><a href="#h25-0-726" id="h25-0-726" class="i">+		return ErrNil
</a><a href="#h25-0-727" id="h25-0-727" class="i">+	}
</a><a href="#h25-0-728" id="h25-0-728" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-729" id="h25-0-729" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-730" id="h25-0-730" class="i">+		x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-731" id="h25-0-731" class="i">+		p.valEnc(o, uint64(x))
</a><a href="#h25-0-732" id="h25-0-732" class="i">+	}
</a><a href="#h25-0-733" id="h25-0-733" class="i">+	return nil
</a><a href="#h25-0-734" id="h25-0-734" class="i">+}
</a><a href="#h25-0-735" id="h25-0-735" class="i">+
</a><a href="#h25-0-736" id="h25-0-736" class="i">+func size_slice_int32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-737" id="h25-0-737" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-738" id="h25-0-738" class="i">+	l := s.Len()
</a><a href="#h25-0-739" id="h25-0-739" class="i">+	if l == 0 {
</a><a href="#h25-0-740" id="h25-0-740" class="i">+		return 0
</a><a href="#h25-0-741" id="h25-0-741" class="i">+	}
</a><a href="#h25-0-742" id="h25-0-742" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-743" id="h25-0-743" class="i">+		n += len(p.tagcode)
</a><a href="#h25-0-744" id="h25-0-744" class="i">+		x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-745" id="h25-0-745" class="i">+		n += p.valSize(uint64(x))
</a><a href="#h25-0-746" id="h25-0-746" class="i">+	}
</a><a href="#h25-0-747" id="h25-0-747" class="i">+	return
</a><a href="#h25-0-748" id="h25-0-748" class="i">+}
</a><a href="#h25-0-749" id="h25-0-749" class="i">+
</a><a href="#h25-0-750" id="h25-0-750" class="i">+// Encode a slice of int32s ([]int32) in packed format.
</a><a href="#h25-0-751" id="h25-0-751" class="i">+func (o *Buffer) enc_slice_packed_int32(p *Properties, base structPointer) error {
</a><a href="#h25-0-752" id="h25-0-752" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-753" id="h25-0-753" class="i">+	l := s.Len()
</a><a href="#h25-0-754" id="h25-0-754" class="i">+	if l == 0 {
</a><a href="#h25-0-755" id="h25-0-755" class="i">+		return ErrNil
</a><a href="#h25-0-756" id="h25-0-756" class="i">+	}
</a><a href="#h25-0-757" id="h25-0-757" class="i">+	// TODO: Reuse a Buffer.
</a><a href="#h25-0-758" id="h25-0-758" class="i">+	buf := NewBuffer(nil)
</a><a href="#h25-0-759" id="h25-0-759" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-760" id="h25-0-760" class="i">+		x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-761" id="h25-0-761" class="i">+		p.valEnc(buf, uint64(x))
</a><a href="#h25-0-762" id="h25-0-762" class="i">+	}
</a><a href="#h25-0-763" id="h25-0-763" class="i">+
</a><a href="#h25-0-764" id="h25-0-764" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-765" id="h25-0-765" class="i">+	o.EncodeVarint(uint64(len(buf.buf)))
</a><a href="#h25-0-766" id="h25-0-766" class="i">+	o.buf = append(o.buf, buf.buf...)
</a><a href="#h25-0-767" id="h25-0-767" class="i">+	return nil
</a><a href="#h25-0-768" id="h25-0-768" class="i">+}
</a><a href="#h25-0-769" id="h25-0-769" class="i">+
</a><a href="#h25-0-770" id="h25-0-770" class="i">+func size_slice_packed_int32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-771" id="h25-0-771" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-772" id="h25-0-772" class="i">+	l := s.Len()
</a><a href="#h25-0-773" id="h25-0-773" class="i">+	if l == 0 {
</a><a href="#h25-0-774" id="h25-0-774" class="i">+		return 0
</a><a href="#h25-0-775" id="h25-0-775" class="i">+	}
</a><a href="#h25-0-776" id="h25-0-776" class="i">+	var bufSize int
</a><a href="#h25-0-777" id="h25-0-777" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-778" id="h25-0-778" class="i">+		x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
</a><a href="#h25-0-779" id="h25-0-779" class="i">+		bufSize += p.valSize(uint64(x))
</a><a href="#h25-0-780" id="h25-0-780" class="i">+	}
</a><a href="#h25-0-781" id="h25-0-781" class="i">+
</a><a href="#h25-0-782" id="h25-0-782" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-783" id="h25-0-783" class="i">+	n += sizeVarint(uint64(bufSize))
</a><a href="#h25-0-784" id="h25-0-784" class="i">+	n += bufSize
</a><a href="#h25-0-785" id="h25-0-785" class="i">+	return
</a><a href="#h25-0-786" id="h25-0-786" class="i">+}
</a><a href="#h25-0-787" id="h25-0-787" class="i">+
</a><a href="#h25-0-788" id="h25-0-788" class="i">+// Encode a slice of uint32s ([]uint32).
</a><a href="#h25-0-789" id="h25-0-789" class="i">+// Exactly the same as int32, except for no sign extension.
</a><a href="#h25-0-790" id="h25-0-790" class="i">+func (o *Buffer) enc_slice_uint32(p *Properties, base structPointer) error {
</a><a href="#h25-0-791" id="h25-0-791" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-792" id="h25-0-792" class="i">+	l := s.Len()
</a><a href="#h25-0-793" id="h25-0-793" class="i">+	if l == 0 {
</a><a href="#h25-0-794" id="h25-0-794" class="i">+		return ErrNil
</a><a href="#h25-0-795" id="h25-0-795" class="i">+	}
</a><a href="#h25-0-796" id="h25-0-796" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-797" id="h25-0-797" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-798" id="h25-0-798" class="i">+		x := s.Index(i)
</a><a href="#h25-0-799" id="h25-0-799" class="i">+		p.valEnc(o, uint64(x))
</a><a href="#h25-0-800" id="h25-0-800" class="i">+	}
</a><a href="#h25-0-801" id="h25-0-801" class="i">+	return nil
</a><a href="#h25-0-802" id="h25-0-802" class="i">+}
</a><a href="#h25-0-803" id="h25-0-803" class="i">+
</a><a href="#h25-0-804" id="h25-0-804" class="i">+func size_slice_uint32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-805" id="h25-0-805" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-806" id="h25-0-806" class="i">+	l := s.Len()
</a><a href="#h25-0-807" id="h25-0-807" class="i">+	if l == 0 {
</a><a href="#h25-0-808" id="h25-0-808" class="i">+		return 0
</a><a href="#h25-0-809" id="h25-0-809" class="i">+	}
</a><a href="#h25-0-810" id="h25-0-810" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-811" id="h25-0-811" class="i">+		n += len(p.tagcode)
</a><a href="#h25-0-812" id="h25-0-812" class="i">+		x := s.Index(i)
</a><a href="#h25-0-813" id="h25-0-813" class="i">+		n += p.valSize(uint64(x))
</a><a href="#h25-0-814" id="h25-0-814" class="i">+	}
</a><a href="#h25-0-815" id="h25-0-815" class="i">+	return
</a><a href="#h25-0-816" id="h25-0-816" class="i">+}
</a><a href="#h25-0-817" id="h25-0-817" class="i">+
</a><a href="#h25-0-818" id="h25-0-818" class="i">+// Encode a slice of uint32s ([]uint32) in packed format.
</a><a href="#h25-0-819" id="h25-0-819" class="i">+// Exactly the same as int32, except for no sign extension.
</a><a href="#h25-0-820" id="h25-0-820" class="i">+func (o *Buffer) enc_slice_packed_uint32(p *Properties, base structPointer) error {
</a><a href="#h25-0-821" id="h25-0-821" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-822" id="h25-0-822" class="i">+	l := s.Len()
</a><a href="#h25-0-823" id="h25-0-823" class="i">+	if l == 0 {
</a><a href="#h25-0-824" id="h25-0-824" class="i">+		return ErrNil
</a><a href="#h25-0-825" id="h25-0-825" class="i">+	}
</a><a href="#h25-0-826" id="h25-0-826" class="i">+	// TODO: Reuse a Buffer.
</a><a href="#h25-0-827" id="h25-0-827" class="i">+	buf := NewBuffer(nil)
</a><a href="#h25-0-828" id="h25-0-828" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-829" id="h25-0-829" class="i">+		p.valEnc(buf, uint64(s.Index(i)))
</a><a href="#h25-0-830" id="h25-0-830" class="i">+	}
</a><a href="#h25-0-831" id="h25-0-831" class="i">+
</a><a href="#h25-0-832" id="h25-0-832" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-833" id="h25-0-833" class="i">+	o.EncodeVarint(uint64(len(buf.buf)))
</a><a href="#h25-0-834" id="h25-0-834" class="i">+	o.buf = append(o.buf, buf.buf...)
</a><a href="#h25-0-835" id="h25-0-835" class="i">+	return nil
</a><a href="#h25-0-836" id="h25-0-836" class="i">+}
</a><a href="#h25-0-837" id="h25-0-837" class="i">+
</a><a href="#h25-0-838" id="h25-0-838" class="i">+func size_slice_packed_uint32(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-839" id="h25-0-839" class="i">+	s := structPointer_Word32Slice(base, p.field)
</a><a href="#h25-0-840" id="h25-0-840" class="i">+	l := s.Len()
</a><a href="#h25-0-841" id="h25-0-841" class="i">+	if l == 0 {
</a><a href="#h25-0-842" id="h25-0-842" class="i">+		return 0
</a><a href="#h25-0-843" id="h25-0-843" class="i">+	}
</a><a href="#h25-0-844" id="h25-0-844" class="i">+	var bufSize int
</a><a href="#h25-0-845" id="h25-0-845" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-846" id="h25-0-846" class="i">+		bufSize += p.valSize(uint64(s.Index(i)))
</a><a href="#h25-0-847" id="h25-0-847" class="i">+	}
</a><a href="#h25-0-848" id="h25-0-848" class="i">+
</a><a href="#h25-0-849" id="h25-0-849" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-850" id="h25-0-850" class="i">+	n += sizeVarint(uint64(bufSize))
</a><a href="#h25-0-851" id="h25-0-851" class="i">+	n += bufSize
</a><a href="#h25-0-852" id="h25-0-852" class="i">+	return
</a><a href="#h25-0-853" id="h25-0-853" class="i">+}
</a><a href="#h25-0-854" id="h25-0-854" class="i">+
</a><a href="#h25-0-855" id="h25-0-855" class="i">+// Encode a slice of int64s ([]int64).
</a><a href="#h25-0-856" id="h25-0-856" class="i">+func (o *Buffer) enc_slice_int64(p *Properties, base structPointer) error {
</a><a href="#h25-0-857" id="h25-0-857" class="i">+	s := structPointer_Word64Slice(base, p.field)
</a><a href="#h25-0-858" id="h25-0-858" class="i">+	l := s.Len()
</a><a href="#h25-0-859" id="h25-0-859" class="i">+	if l == 0 {
</a><a href="#h25-0-860" id="h25-0-860" class="i">+		return ErrNil
</a><a href="#h25-0-861" id="h25-0-861" class="i">+	}
</a><a href="#h25-0-862" id="h25-0-862" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-863" id="h25-0-863" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-864" id="h25-0-864" class="i">+		p.valEnc(o, s.Index(i))
</a><a href="#h25-0-865" id="h25-0-865" class="i">+	}
</a><a href="#h25-0-866" id="h25-0-866" class="i">+	return nil
</a><a href="#h25-0-867" id="h25-0-867" class="i">+}
</a><a href="#h25-0-868" id="h25-0-868" class="i">+
</a><a href="#h25-0-869" id="h25-0-869" class="i">+func size_slice_int64(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-870" id="h25-0-870" class="i">+	s := structPointer_Word64Slice(base, p.field)
</a><a href="#h25-0-871" id="h25-0-871" class="i">+	l := s.Len()
</a><a href="#h25-0-872" id="h25-0-872" class="i">+	if l == 0 {
</a><a href="#h25-0-873" id="h25-0-873" class="i">+		return 0
</a><a href="#h25-0-874" id="h25-0-874" class="i">+	}
</a><a href="#h25-0-875" id="h25-0-875" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-876" id="h25-0-876" class="i">+		n += len(p.tagcode)
</a><a href="#h25-0-877" id="h25-0-877" class="i">+		n += p.valSize(s.Index(i))
</a><a href="#h25-0-878" id="h25-0-878" class="i">+	}
</a><a href="#h25-0-879" id="h25-0-879" class="i">+	return
</a><a href="#h25-0-880" id="h25-0-880" class="i">+}
</a><a href="#h25-0-881" id="h25-0-881" class="i">+
</a><a href="#h25-0-882" id="h25-0-882" class="i">+// Encode a slice of int64s ([]int64) in packed format.
</a><a href="#h25-0-883" id="h25-0-883" class="i">+func (o *Buffer) enc_slice_packed_int64(p *Properties, base structPointer) error {
</a><a href="#h25-0-884" id="h25-0-884" class="i">+	s := structPointer_Word64Slice(base, p.field)
</a><a href="#h25-0-885" id="h25-0-885" class="i">+	l := s.Len()
</a><a href="#h25-0-886" id="h25-0-886" class="i">+	if l == 0 {
</a><a href="#h25-0-887" id="h25-0-887" class="i">+		return ErrNil
</a><a href="#h25-0-888" id="h25-0-888" class="i">+	}
</a><a href="#h25-0-889" id="h25-0-889" class="i">+	// TODO: Reuse a Buffer.
</a><a href="#h25-0-890" id="h25-0-890" class="i">+	buf := NewBuffer(nil)
</a><a href="#h25-0-891" id="h25-0-891" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-892" id="h25-0-892" class="i">+		p.valEnc(buf, s.Index(i))
</a><a href="#h25-0-893" id="h25-0-893" class="i">+	}
</a><a href="#h25-0-894" id="h25-0-894" class="i">+
</a><a href="#h25-0-895" id="h25-0-895" class="i">+	o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-896" id="h25-0-896" class="i">+	o.EncodeVarint(uint64(len(buf.buf)))
</a><a href="#h25-0-897" id="h25-0-897" class="i">+	o.buf = append(o.buf, buf.buf...)
</a><a href="#h25-0-898" id="h25-0-898" class="i">+	return nil
</a><a href="#h25-0-899" id="h25-0-899" class="i">+}
</a><a href="#h25-0-900" id="h25-0-900" class="i">+
</a><a href="#h25-0-901" id="h25-0-901" class="i">+func size_slice_packed_int64(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-902" id="h25-0-902" class="i">+	s := structPointer_Word64Slice(base, p.field)
</a><a href="#h25-0-903" id="h25-0-903" class="i">+	l := s.Len()
</a><a href="#h25-0-904" id="h25-0-904" class="i">+	if l == 0 {
</a><a href="#h25-0-905" id="h25-0-905" class="i">+		return 0
</a><a href="#h25-0-906" id="h25-0-906" class="i">+	}
</a><a href="#h25-0-907" id="h25-0-907" class="i">+	var bufSize int
</a><a href="#h25-0-908" id="h25-0-908" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-909" id="h25-0-909" class="i">+		bufSize += p.valSize(s.Index(i))
</a><a href="#h25-0-910" id="h25-0-910" class="i">+	}
</a><a href="#h25-0-911" id="h25-0-911" class="i">+
</a><a href="#h25-0-912" id="h25-0-912" class="i">+	n += len(p.tagcode)
</a><a href="#h25-0-913" id="h25-0-913" class="i">+	n += sizeVarint(uint64(bufSize))
</a><a href="#h25-0-914" id="h25-0-914" class="i">+	n += bufSize
</a><a href="#h25-0-915" id="h25-0-915" class="i">+	return
</a><a href="#h25-0-916" id="h25-0-916" class="i">+}
</a><a href="#h25-0-917" id="h25-0-917" class="i">+
</a><a href="#h25-0-918" id="h25-0-918" class="i">+// Encode a slice of slice of bytes ([][]byte).
</a><a href="#h25-0-919" id="h25-0-919" class="i">+func (o *Buffer) enc_slice_slice_byte(p *Properties, base structPointer) error {
</a><a href="#h25-0-920" id="h25-0-920" class="i">+	ss := *structPointer_BytesSlice(base, p.field)
</a><a href="#h25-0-921" id="h25-0-921" class="i">+	l := len(ss)
</a><a href="#h25-0-922" id="h25-0-922" class="i">+	if l == 0 {
</a><a href="#h25-0-923" id="h25-0-923" class="i">+		return ErrNil
</a><a href="#h25-0-924" id="h25-0-924" class="i">+	}
</a><a href="#h25-0-925" id="h25-0-925" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-926" id="h25-0-926" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-927" id="h25-0-927" class="i">+		o.EncodeRawBytes(ss[i])
</a><a href="#h25-0-928" id="h25-0-928" class="i">+	}
</a><a href="#h25-0-929" id="h25-0-929" class="i">+	return nil
</a><a href="#h25-0-930" id="h25-0-930" class="i">+}
</a><a href="#h25-0-931" id="h25-0-931" class="i">+
</a><a href="#h25-0-932" id="h25-0-932" class="i">+func size_slice_slice_byte(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-933" id="h25-0-933" class="i">+	ss := *structPointer_BytesSlice(base, p.field)
</a><a href="#h25-0-934" id="h25-0-934" class="i">+	l := len(ss)
</a><a href="#h25-0-935" id="h25-0-935" class="i">+	if l == 0 {
</a><a href="#h25-0-936" id="h25-0-936" class="i">+		return 0
</a><a href="#h25-0-937" id="h25-0-937" class="i">+	}
</a><a href="#h25-0-938" id="h25-0-938" class="i">+	n += l * len(p.tagcode)
</a><a href="#h25-0-939" id="h25-0-939" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-940" id="h25-0-940" class="i">+		n += sizeRawBytes(ss[i])
</a><a href="#h25-0-941" id="h25-0-941" class="i">+	}
</a><a href="#h25-0-942" id="h25-0-942" class="i">+	return
</a><a href="#h25-0-943" id="h25-0-943" class="i">+}
</a><a href="#h25-0-944" id="h25-0-944" class="i">+
</a><a href="#h25-0-945" id="h25-0-945" class="i">+// Encode a slice of strings ([]string).
</a><a href="#h25-0-946" id="h25-0-946" class="i">+func (o *Buffer) enc_slice_string(p *Properties, base structPointer) error {
</a><a href="#h25-0-947" id="h25-0-947" class="i">+	ss := *structPointer_StringSlice(base, p.field)
</a><a href="#h25-0-948" id="h25-0-948" class="i">+	l := len(ss)
</a><a href="#h25-0-949" id="h25-0-949" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-950" id="h25-0-950" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-951" id="h25-0-951" class="i">+		o.EncodeStringBytes(ss[i])
</a><a href="#h25-0-952" id="h25-0-952" class="i">+	}
</a><a href="#h25-0-953" id="h25-0-953" class="i">+	return nil
</a><a href="#h25-0-954" id="h25-0-954" class="i">+}
</a><a href="#h25-0-955" id="h25-0-955" class="i">+
</a><a href="#h25-0-956" id="h25-0-956" class="i">+func size_slice_string(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-957" id="h25-0-957" class="i">+	ss := *structPointer_StringSlice(base, p.field)
</a><a href="#h25-0-958" id="h25-0-958" class="i">+	l := len(ss)
</a><a href="#h25-0-959" id="h25-0-959" class="i">+	n += l * len(p.tagcode)
</a><a href="#h25-0-960" id="h25-0-960" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-961" id="h25-0-961" class="i">+		n += sizeStringBytes(ss[i])
</a><a href="#h25-0-962" id="h25-0-962" class="i">+	}
</a><a href="#h25-0-963" id="h25-0-963" class="i">+	return
</a><a href="#h25-0-964" id="h25-0-964" class="i">+}
</a><a href="#h25-0-965" id="h25-0-965" class="i">+
</a><a href="#h25-0-966" id="h25-0-966" class="i">+// Encode a slice of message structs ([]*struct).
</a><a href="#h25-0-967" id="h25-0-967" class="i">+func (o *Buffer) enc_slice_struct_message(p *Properties, base structPointer) error {
</a><a href="#h25-0-968" id="h25-0-968" class="i">+	var state errorState
</a><a href="#h25-0-969" id="h25-0-969" class="i">+	s := structPointer_StructPointerSlice(base, p.field)
</a><a href="#h25-0-970" id="h25-0-970" class="i">+	l := s.Len()
</a><a href="#h25-0-971" id="h25-0-971" class="i">+
</a><a href="#h25-0-972" id="h25-0-972" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-973" id="h25-0-973" class="i">+		structp := s.Index(i)
</a><a href="#h25-0-974" id="h25-0-974" class="i">+		if structPointer_IsNil(structp) {
</a><a href="#h25-0-975" id="h25-0-975" class="i">+			return errRepeatedHasNil
</a><a href="#h25-0-976" id="h25-0-976" class="i">+		}
</a><a href="#h25-0-977" id="h25-0-977" class="i">+
</a><a href="#h25-0-978" id="h25-0-978" class="i">+		// Can the object marshal itself?
</a><a href="#h25-0-979" id="h25-0-979" class="i">+		if p.isMarshaler {
</a><a href="#h25-0-980" id="h25-0-980" class="i">+			m := structPointer_Interface(structp, p.stype).(Marshaler)
</a><a href="#h25-0-981" id="h25-0-981" class="i">+			data, err := m.Marshal()
</a><a href="#h25-0-982" id="h25-0-982" class="i">+			if err != nil &amp;&amp; !state.shouldContinue(err, nil) {
</a><a href="#h25-0-983" id="h25-0-983" class="i">+				return err
</a><a href="#h25-0-984" id="h25-0-984" class="i">+			}
</a><a href="#h25-0-985" id="h25-0-985" class="i">+			o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-986" id="h25-0-986" class="i">+			o.EncodeRawBytes(data)
</a><a href="#h25-0-987" id="h25-0-987" class="i">+			continue
</a><a href="#h25-0-988" id="h25-0-988" class="i">+		}
</a><a href="#h25-0-989" id="h25-0-989" class="i">+
</a><a href="#h25-0-990" id="h25-0-990" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-991" id="h25-0-991" class="i">+		err := o.enc_len_struct(p.sprop, structp, &amp;state)
</a><a href="#h25-0-992" id="h25-0-992" class="i">+		if err != nil &amp;&amp; !state.shouldContinue(err, nil) {
</a><a href="#h25-0-993" id="h25-0-993" class="i">+			if err == ErrNil {
</a><a href="#h25-0-994" id="h25-0-994" class="i">+				return errRepeatedHasNil
</a><a href="#h25-0-995" id="h25-0-995" class="i">+			}
</a><a href="#h25-0-996" id="h25-0-996" class="i">+			return err
</a><a href="#h25-0-997" id="h25-0-997" class="i">+		}
</a><a href="#h25-0-998" id="h25-0-998" class="i">+	}
</a><a href="#h25-0-999" id="h25-0-999" class="i">+	return state.err
</a><a href="#h25-0-1000" id="h25-0-1000" class="i">+}
</a><a href="#h25-0-1001" id="h25-0-1001" class="i">+
</a><a href="#h25-0-1002" id="h25-0-1002" class="i">+func size_slice_struct_message(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-1003" id="h25-0-1003" class="i">+	s := structPointer_StructPointerSlice(base, p.field)
</a><a href="#h25-0-1004" id="h25-0-1004" class="i">+	l := s.Len()
</a><a href="#h25-0-1005" id="h25-0-1005" class="i">+	n += l * len(p.tagcode)
</a><a href="#h25-0-1006" id="h25-0-1006" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-1007" id="h25-0-1007" class="i">+		structp := s.Index(i)
</a><a href="#h25-0-1008" id="h25-0-1008" class="i">+		if structPointer_IsNil(structp) {
</a><a href="#h25-0-1009" id="h25-0-1009" class="i">+			return // return the size up to this point
</a><a href="#h25-0-1010" id="h25-0-1010" class="i">+		}
</a><a href="#h25-0-1011" id="h25-0-1011" class="i">+
</a><a href="#h25-0-1012" id="h25-0-1012" class="i">+		// Can the object marshal itself?
</a><a href="#h25-0-1013" id="h25-0-1013" class="i">+		if p.isMarshaler {
</a><a href="#h25-0-1014" id="h25-0-1014" class="i">+			m := structPointer_Interface(structp, p.stype).(Marshaler)
</a><a href="#h25-0-1015" id="h25-0-1015" class="i">+			data, _ := m.Marshal()
</a><a href="#h25-0-1016" id="h25-0-1016" class="i">+			n += len(p.tagcode)
</a><a href="#h25-0-1017" id="h25-0-1017" class="i">+			n += sizeRawBytes(data)
</a><a href="#h25-0-1018" id="h25-0-1018" class="i">+			continue
</a><a href="#h25-0-1019" id="h25-0-1019" class="i">+		}
</a><a href="#h25-0-1020" id="h25-0-1020" class="i">+
</a><a href="#h25-0-1021" id="h25-0-1021" class="i">+		n0 := size_struct(p.sprop, structp)
</a><a href="#h25-0-1022" id="h25-0-1022" class="i">+		n1 := sizeVarint(uint64(n0)) // size of encoded length
</a><a href="#h25-0-1023" id="h25-0-1023" class="i">+		n += n0 + n1
</a><a href="#h25-0-1024" id="h25-0-1024" class="i">+	}
</a><a href="#h25-0-1025" id="h25-0-1025" class="i">+	return
</a><a href="#h25-0-1026" id="h25-0-1026" class="i">+}
</a><a href="#h25-0-1027" id="h25-0-1027" class="i">+
</a><a href="#h25-0-1028" id="h25-0-1028" class="i">+// Encode a slice of group structs ([]*struct).
</a><a href="#h25-0-1029" id="h25-0-1029" class="i">+func (o *Buffer) enc_slice_struct_group(p *Properties, base structPointer) error {
</a><a href="#h25-0-1030" id="h25-0-1030" class="i">+	var state errorState
</a><a href="#h25-0-1031" id="h25-0-1031" class="i">+	s := structPointer_StructPointerSlice(base, p.field)
</a><a href="#h25-0-1032" id="h25-0-1032" class="i">+	l := s.Len()
</a><a href="#h25-0-1033" id="h25-0-1033" class="i">+
</a><a href="#h25-0-1034" id="h25-0-1034" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-1035" id="h25-0-1035" class="i">+		b := s.Index(i)
</a><a href="#h25-0-1036" id="h25-0-1036" class="i">+		if structPointer_IsNil(b) {
</a><a href="#h25-0-1037" id="h25-0-1037" class="i">+			return errRepeatedHasNil
</a><a href="#h25-0-1038" id="h25-0-1038" class="i">+		}
</a><a href="#h25-0-1039" id="h25-0-1039" class="i">+
</a><a href="#h25-0-1040" id="h25-0-1040" class="i">+		o.EncodeVarint(uint64((p.Tag &lt;&lt; 3) | WireStartGroup))
</a><a href="#h25-0-1041" id="h25-0-1041" class="i">+
</a><a href="#h25-0-1042" id="h25-0-1042" class="i">+		err := o.enc_struct(p.sprop, b)
</a><a href="#h25-0-1043" id="h25-0-1043" class="i">+
</a><a href="#h25-0-1044" id="h25-0-1044" class="i">+		if err != nil &amp;&amp; !state.shouldContinue(err, nil) {
</a><a href="#h25-0-1045" id="h25-0-1045" class="i">+			if err == ErrNil {
</a><a href="#h25-0-1046" id="h25-0-1046" class="i">+				return errRepeatedHasNil
</a><a href="#h25-0-1047" id="h25-0-1047" class="i">+			}
</a><a href="#h25-0-1048" id="h25-0-1048" class="i">+			return err
</a><a href="#h25-0-1049" id="h25-0-1049" class="i">+		}
</a><a href="#h25-0-1050" id="h25-0-1050" class="i">+
</a><a href="#h25-0-1051" id="h25-0-1051" class="i">+		o.EncodeVarint(uint64((p.Tag &lt;&lt; 3) | WireEndGroup))
</a><a href="#h25-0-1052" id="h25-0-1052" class="i">+	}
</a><a href="#h25-0-1053" id="h25-0-1053" class="i">+	return state.err
</a><a href="#h25-0-1054" id="h25-0-1054" class="i">+}
</a><a href="#h25-0-1055" id="h25-0-1055" class="i">+
</a><a href="#h25-0-1056" id="h25-0-1056" class="i">+func size_slice_struct_group(p *Properties, base structPointer) (n int) {
</a><a href="#h25-0-1057" id="h25-0-1057" class="i">+	s := structPointer_StructPointerSlice(base, p.field)
</a><a href="#h25-0-1058" id="h25-0-1058" class="i">+	l := s.Len()
</a><a href="#h25-0-1059" id="h25-0-1059" class="i">+
</a><a href="#h25-0-1060" id="h25-0-1060" class="i">+	n += l * sizeVarint(uint64((p.Tag&lt;&lt;3)|WireStartGroup))
</a><a href="#h25-0-1061" id="h25-0-1061" class="i">+	n += l * sizeVarint(uint64((p.Tag&lt;&lt;3)|WireEndGroup))
</a><a href="#h25-0-1062" id="h25-0-1062" class="i">+	for i := 0; i &lt; l; i++ {
</a><a href="#h25-0-1063" id="h25-0-1063" class="i">+		b := s.Index(i)
</a><a href="#h25-0-1064" id="h25-0-1064" class="i">+		if structPointer_IsNil(b) {
</a><a href="#h25-0-1065" id="h25-0-1065" class="i">+			return // return size up to this point
</a><a href="#h25-0-1066" id="h25-0-1066" class="i">+		}
</a><a href="#h25-0-1067" id="h25-0-1067" class="i">+
</a><a href="#h25-0-1068" id="h25-0-1068" class="i">+		n += size_struct(p.sprop, b)
</a><a href="#h25-0-1069" id="h25-0-1069" class="i">+	}
</a><a href="#h25-0-1070" id="h25-0-1070" class="i">+	return
</a><a href="#h25-0-1071" id="h25-0-1071" class="i">+}
</a><a href="#h25-0-1072" id="h25-0-1072" class="i">+
</a><a href="#h25-0-1073" id="h25-0-1073" class="i">+// Encode an extension map.
</a><a href="#h25-0-1074" id="h25-0-1074" class="i">+func (o *Buffer) enc_map(p *Properties, base structPointer) error {
</a><a href="#h25-0-1075" id="h25-0-1075" class="i">+	exts := structPointer_ExtMap(base, p.field)
</a><a href="#h25-0-1076" id="h25-0-1076" class="i">+	if err := encodeExtensionsMap(*exts); err != nil {
</a><a href="#h25-0-1077" id="h25-0-1077" class="i">+		return err
</a><a href="#h25-0-1078" id="h25-0-1078" class="i">+	}
</a><a href="#h25-0-1079" id="h25-0-1079" class="i">+
</a><a href="#h25-0-1080" id="h25-0-1080" class="i">+	return o.enc_map_body(*exts)
</a><a href="#h25-0-1081" id="h25-0-1081" class="i">+}
</a><a href="#h25-0-1082" id="h25-0-1082" class="i">+
</a><a href="#h25-0-1083" id="h25-0-1083" class="i">+func (o *Buffer) enc_exts(p *Properties, base structPointer) error {
</a><a href="#h25-0-1084" id="h25-0-1084" class="i">+	exts := structPointer_Extensions(base, p.field)
</a><a href="#h25-0-1085" id="h25-0-1085" class="i">+	if err := encodeExtensions(exts); err != nil {
</a><a href="#h25-0-1086" id="h25-0-1086" class="i">+		return err
</a><a href="#h25-0-1087" id="h25-0-1087" class="i">+	}
</a><a href="#h25-0-1088" id="h25-0-1088" class="i">+	v, _ := exts.extensionsRead()
</a><a href="#h25-0-1089" id="h25-0-1089" class="i">+
</a><a href="#h25-0-1090" id="h25-0-1090" class="i">+	return o.enc_map_body(v)
</a><a href="#h25-0-1091" id="h25-0-1091" class="i">+}
</a><a href="#h25-0-1092" id="h25-0-1092" class="i">+
</a><a href="#h25-0-1093" id="h25-0-1093" class="i">+func (o *Buffer) enc_map_body(v map[int32]Extension) error {
</a><a href="#h25-0-1094" id="h25-0-1094" class="i">+	// Fast-path for common cases: zero or one extensions.
</a><a href="#h25-0-1095" id="h25-0-1095" class="i">+	if len(v) &lt;= 1 {
</a><a href="#h25-0-1096" id="h25-0-1096" class="i">+		for _, e := range v {
</a><a href="#h25-0-1097" id="h25-0-1097" class="i">+			o.buf = append(o.buf, e.enc...)
</a><a href="#h25-0-1098" id="h25-0-1098" class="i">+		}
</a><a href="#h25-0-1099" id="h25-0-1099" class="i">+		return nil
</a><a href="#h25-0-1100" id="h25-0-1100" class="i">+	}
</a><a href="#h25-0-1101" id="h25-0-1101" class="i">+
</a><a href="#h25-0-1102" id="h25-0-1102" class="i">+	// Sort keys to provide a deterministic encoding.
</a><a href="#h25-0-1103" id="h25-0-1103" class="i">+	keys := make([]int, 0, len(v))
</a><a href="#h25-0-1104" id="h25-0-1104" class="i">+	for k := range v {
</a><a href="#h25-0-1105" id="h25-0-1105" class="i">+		keys = append(keys, int(k))
</a><a href="#h25-0-1106" id="h25-0-1106" class="i">+	}
</a><a href="#h25-0-1107" id="h25-0-1107" class="i">+	sort.Ints(keys)
</a><a href="#h25-0-1108" id="h25-0-1108" class="i">+
</a><a href="#h25-0-1109" id="h25-0-1109" class="i">+	for _, k := range keys {
</a><a href="#h25-0-1110" id="h25-0-1110" class="i">+		o.buf = append(o.buf, v[int32(k)].enc...)
</a><a href="#h25-0-1111" id="h25-0-1111" class="i">+	}
</a><a href="#h25-0-1112" id="h25-0-1112" class="i">+	return nil
</a><a href="#h25-0-1113" id="h25-0-1113" class="i">+}
</a><a href="#h25-0-1114" id="h25-0-1114" class="i">+
</a><a href="#h25-0-1115" id="h25-0-1115" class="i">+func size_map(p *Properties, base structPointer) int {
</a><a href="#h25-0-1116" id="h25-0-1116" class="i">+	v := structPointer_ExtMap(base, p.field)
</a><a href="#h25-0-1117" id="h25-0-1117" class="i">+	return extensionsMapSize(*v)
</a><a href="#h25-0-1118" id="h25-0-1118" class="i">+}
</a><a href="#h25-0-1119" id="h25-0-1119" class="i">+
</a><a href="#h25-0-1120" id="h25-0-1120" class="i">+func size_exts(p *Properties, base structPointer) int {
</a><a href="#h25-0-1121" id="h25-0-1121" class="i">+	v := structPointer_Extensions(base, p.field)
</a><a href="#h25-0-1122" id="h25-0-1122" class="i">+	return extensionsSize(v)
</a><a href="#h25-0-1123" id="h25-0-1123" class="i">+}
</a><a href="#h25-0-1124" id="h25-0-1124" class="i">+
</a><a href="#h25-0-1125" id="h25-0-1125" class="i">+// Encode a map field.
</a><a href="#h25-0-1126" id="h25-0-1126" class="i">+func (o *Buffer) enc_new_map(p *Properties, base structPointer) error {
</a><a href="#h25-0-1127" id="h25-0-1127" class="i">+	var state errorState // XXX: or do we need to plumb this through?
</a><a href="#h25-0-1128" id="h25-0-1128" class="i">+
</a><a href="#h25-0-1129" id="h25-0-1129" class="i">+	/*
</a><a href="#h25-0-1130" id="h25-0-1130" class="i">+		A map defined as
</a><a href="#h25-0-1131" id="h25-0-1131" class="i">+			map&lt;key_type, value_type&gt; map_field = N;
</a><a href="#h25-0-1132" id="h25-0-1132" class="i">+		is encoded in the same way as
</a><a href="#h25-0-1133" id="h25-0-1133" class="i">+			message MapFieldEntry {
</a><a href="#h25-0-1134" id="h25-0-1134" class="i">+				key_type key = 1;
</a><a href="#h25-0-1135" id="h25-0-1135" class="i">+				value_type value = 2;
</a><a href="#h25-0-1136" id="h25-0-1136" class="i">+			}
</a><a href="#h25-0-1137" id="h25-0-1137" class="i">+			repeated MapFieldEntry map_field = N;
</a><a href="#h25-0-1138" id="h25-0-1138" class="i">+	*/
</a><a href="#h25-0-1139" id="h25-0-1139" class="i">+
</a><a href="#h25-0-1140" id="h25-0-1140" class="i">+	v := structPointer_NewAt(base, p.field, p.mtype).Elem() // map[K]V
</a><a href="#h25-0-1141" id="h25-0-1141" class="i">+	if v.Len() == 0 {
</a><a href="#h25-0-1142" id="h25-0-1142" class="i">+		return nil
</a><a href="#h25-0-1143" id="h25-0-1143" class="i">+	}
</a><a href="#h25-0-1144" id="h25-0-1144" class="i">+
</a><a href="#h25-0-1145" id="h25-0-1145" class="i">+	keycopy, valcopy, keybase, valbase := mapEncodeScratch(p.mtype)
</a><a href="#h25-0-1146" id="h25-0-1146" class="i">+
</a><a href="#h25-0-1147" id="h25-0-1147" class="i">+	enc := func() error {
</a><a href="#h25-0-1148" id="h25-0-1148" class="i">+		if err := p.mkeyprop.enc(o, p.mkeyprop, keybase); err != nil {
</a><a href="#h25-0-1149" id="h25-0-1149" class="i">+			return err
</a><a href="#h25-0-1150" id="h25-0-1150" class="i">+		}
</a><a href="#h25-0-1151" id="h25-0-1151" class="i">+		if err := p.mvalprop.enc(o, p.mvalprop, valbase); err != nil &amp;&amp; err != ErrNil {
</a><a href="#h25-0-1152" id="h25-0-1152" class="i">+			return err
</a><a href="#h25-0-1153" id="h25-0-1153" class="i">+		}
</a><a href="#h25-0-1154" id="h25-0-1154" class="i">+		return nil
</a><a href="#h25-0-1155" id="h25-0-1155" class="i">+	}
</a><a href="#h25-0-1156" id="h25-0-1156" class="i">+
</a><a href="#h25-0-1157" id="h25-0-1157" class="i">+	// Don&#39;t sort map keys. It is not required by the spec, and C++ doesn&#39;t do it.
</a><a href="#h25-0-1158" id="h25-0-1158" class="i">+	for _, key := range v.MapKeys() {
</a><a href="#h25-0-1159" id="h25-0-1159" class="i">+		val := v.MapIndex(key)
</a><a href="#h25-0-1160" id="h25-0-1160" class="i">+
</a><a href="#h25-0-1161" id="h25-0-1161" class="i">+		keycopy.Set(key)
</a><a href="#h25-0-1162" id="h25-0-1162" class="i">+		valcopy.Set(val)
</a><a href="#h25-0-1163" id="h25-0-1163" class="i">+
</a><a href="#h25-0-1164" id="h25-0-1164" class="i">+		o.buf = append(o.buf, p.tagcode...)
</a><a href="#h25-0-1165" id="h25-0-1165" class="i">+		if err := o.enc_len_thing(enc, &amp;state); err != nil {
</a><a href="#h25-0-1166" id="h25-0-1166" class="i">+			return err
</a><a href="#h25-0-1167" id="h25-0-1167" class="i">+		}
</a><a href="#h25-0-1168" id="h25-0-1168" class="i">+	}
</a><a href="#h25-0-1169" id="h25-0-1169" class="i">+	return nil
</a><a href="#h25-0-1170" id="h25-0-1170" class="i">+}
</a><a href="#h25-0-1171" id="h25-0-1171" class="i">+
</a><a href="#h25-0-1172" id="h25-0-1172" class="i">+func size_new_map(p *Properties, base structPointer) int {
</a><a href="#h25-0-1173" id="h25-0-1173" class="i">+	v := structPointer_NewAt(base, p.field, p.mtype).Elem() // map[K]V
</a><a href="#h25-0-1174" id="h25-0-1174" class="i">+
</a><a href="#h25-0-1175" id="h25-0-1175" class="i">+	keycopy, valcopy, keybase, valbase := mapEncodeScratch(p.mtype)
</a><a href="#h25-0-1176" id="h25-0-1176" class="i">+
</a><a href="#h25-0-1177" id="h25-0-1177" class="i">+	n := 0
</a><a href="#h25-0-1178" id="h25-0-1178" class="i">+	for _, key := range v.MapKeys() {
</a><a href="#h25-0-1179" id="h25-0-1179" class="i">+		val := v.MapIndex(key)
</a><a href="#h25-0-1180" id="h25-0-1180" class="i">+		keycopy.Set(key)
</a><a href="#h25-0-1181" id="h25-0-1181" class="i">+		valcopy.Set(val)
</a><a href="#h25-0-1182" id="h25-0-1182" class="i">+
</a><a href="#h25-0-1183" id="h25-0-1183" class="i">+		// Tag codes for key and val are the responsibility of the sub-sizer.
</a><a href="#h25-0-1184" id="h25-0-1184" class="i">+		keysize := p.mkeyprop.size(p.mkeyprop, keybase)
</a><a href="#h25-0-1185" id="h25-0-1185" class="i">+		valsize := p.mvalprop.size(p.mvalprop, valbase)
</a><a href="#h25-0-1186" id="h25-0-1186" class="i">+		entry := keysize + valsize
</a><a href="#h25-0-1187" id="h25-0-1187" class="i">+		// Add on tag code and length of map entry itself.
</a><a href="#h25-0-1188" id="h25-0-1188" class="i">+		n += len(p.tagcode) + sizeVarint(uint64(entry)) + entry
</a><a href="#h25-0-1189" id="h25-0-1189" class="i">+	}
</a><a href="#h25-0-1190" id="h25-0-1190" class="i">+	return n
</a><a href="#h25-0-1191" id="h25-0-1191" class="i">+}
</a><a href="#h25-0-1192" id="h25-0-1192" class="i">+
</a><a href="#h25-0-1193" id="h25-0-1193" class="i">+// mapEncodeScratch returns a new reflect.Value matching the map&#39;s value type,
</a><a href="#h25-0-1194" id="h25-0-1194" class="i">+// and a structPointer suitable for passing to an encoder or sizer.
</a><a href="#h25-0-1195" id="h25-0-1195" class="i">+func mapEncodeScratch(mapType reflect.Type) (keycopy, valcopy reflect.Value, keybase, valbase structPointer) {
</a><a href="#h25-0-1196" id="h25-0-1196" class="i">+	// Prepare addressable doubly-indirect placeholders for the key and value types.
</a><a href="#h25-0-1197" id="h25-0-1197" class="i">+	// This is needed because the element-type encoders expect **T, but the map iteration produces T.
</a><a href="#h25-0-1198" id="h25-0-1198" class="i">+
</a><a href="#h25-0-1199" id="h25-0-1199" class="i">+	keycopy = reflect.New(mapType.Key()).Elem()                 // addressable K
</a><a href="#h25-0-1200" id="h25-0-1200" class="i">+	keyptr := reflect.New(reflect.PtrTo(keycopy.Type())).Elem() // addressable *K
</a><a href="#h25-0-1201" id="h25-0-1201" class="i">+	keyptr.Set(keycopy.Addr())                                  //
</a><a href="#h25-0-1202" id="h25-0-1202" class="i">+	keybase = toStructPointer(keyptr.Addr())                    // **K
</a><a href="#h25-0-1203" id="h25-0-1203" class="i">+
</a><a href="#h25-0-1204" id="h25-0-1204" class="i">+	// Value types are more varied and require special handling.
</a><a href="#h25-0-1205" id="h25-0-1205" class="i">+	switch mapType.Elem().Kind() {
</a><a href="#h25-0-1206" id="h25-0-1206" class="i">+	case reflect.Slice:
</a><a href="#h25-0-1207" id="h25-0-1207" class="i">+		// []byte
</a><a href="#h25-0-1208" id="h25-0-1208" class="i">+		var dummy []byte
</a><a href="#h25-0-1209" id="h25-0-1209" class="i">+		valcopy = reflect.ValueOf(&amp;dummy).Elem() // addressable []byte
</a><a href="#h25-0-1210" id="h25-0-1210" class="i">+		valbase = toStructPointer(valcopy.Addr())
</a><a href="#h25-0-1211" id="h25-0-1211" class="i">+	case reflect.Ptr:
</a><a href="#h25-0-1212" id="h25-0-1212" class="i">+		// message; the generated field type is map[K]*Msg (so V is *Msg),
</a><a href="#h25-0-1213" id="h25-0-1213" class="i">+		// so we only need one level of indirection.
</a><a href="#h25-0-1214" id="h25-0-1214" class="i">+		valcopy = reflect.New(mapType.Elem()).Elem() // addressable V
</a><a href="#h25-0-1215" id="h25-0-1215" class="i">+		valbase = toStructPointer(valcopy.Addr())
</a><a href="#h25-0-1216" id="h25-0-1216" class="i">+	default:
</a><a href="#h25-0-1217" id="h25-0-1217" class="i">+		// everything else
</a><a href="#h25-0-1218" id="h25-0-1218" class="i">+		valcopy = reflect.New(mapType.Elem()).Elem()                // addressable V
</a><a href="#h25-0-1219" id="h25-0-1219" class="i">+		valptr := reflect.New(reflect.PtrTo(valcopy.Type())).Elem() // addressable *V
</a><a href="#h25-0-1220" id="h25-0-1220" class="i">+		valptr.Set(valcopy.Addr())                                  //
</a><a href="#h25-0-1221" id="h25-0-1221" class="i">+		valbase = toStructPointer(valptr.Addr())                    // **V
</a><a href="#h25-0-1222" id="h25-0-1222" class="i">+	}
</a><a href="#h25-0-1223" id="h25-0-1223" class="i">+	return
</a><a href="#h25-0-1224" id="h25-0-1224" class="i">+}
</a><a href="#h25-0-1225" id="h25-0-1225" class="i">+
</a><a href="#h25-0-1226" id="h25-0-1226" class="i">+// Encode a struct.
</a><a href="#h25-0-1227" id="h25-0-1227" class="i">+func (o *Buffer) enc_struct(prop *StructProperties, base structPointer) error {
</a><a href="#h25-0-1228" id="h25-0-1228" class="i">+	var state errorState
</a><a href="#h25-0-1229" id="h25-0-1229" class="i">+	// Encode fields in tag order so that decoders may use optimizations
</a><a href="#h25-0-1230" id="h25-0-1230" class="i">+	// that depend on the ordering.
</a><a href="#h25-0-1231" id="h25-0-1231" class="i">+	// https://developers.google.com/protocol-buffers/docs/encoding#order
</a><a href="#h25-0-1232" id="h25-0-1232" class="i">+	for _, i := range prop.order {
</a><a href="#h25-0-1233" id="h25-0-1233" class="i">+		p := prop.Prop[i]
</a><a href="#h25-0-1234" id="h25-0-1234" class="i">+		if p.enc != nil {
</a><a href="#h25-0-1235" id="h25-0-1235" class="i">+			err := p.enc(o, p, base)
</a><a href="#h25-0-1236" id="h25-0-1236" class="i">+			if err != nil {
</a><a href="#h25-0-1237" id="h25-0-1237" class="i">+				if err == ErrNil {
</a><a href="#h25-0-1238" id="h25-0-1238" class="i">+					if p.Required &amp;&amp; state.err == nil {
</a><a href="#h25-0-1239" id="h25-0-1239" class="i">+						state.err = &amp;RequiredNotSetError{p.Name}
</a><a href="#h25-0-1240" id="h25-0-1240" class="i">+					}
</a><a href="#h25-0-1241" id="h25-0-1241" class="i">+				} else if err == errRepeatedHasNil {
</a><a href="#h25-0-1242" id="h25-0-1242" class="i">+					// Give more context to nil values in repeated fields.
</a><a href="#h25-0-1243" id="h25-0-1243" class="i">+					return errors.New(&quot;repeated field &quot; + p.OrigName + &quot; has nil element&quot;)
</a><a href="#h25-0-1244" id="h25-0-1244" class="i">+				} else if !state.shouldContinue(err, p) {
</a><a href="#h25-0-1245" id="h25-0-1245" class="i">+					return err
</a><a href="#h25-0-1246" id="h25-0-1246" class="i">+				}
</a><a href="#h25-0-1247" id="h25-0-1247" class="i">+			}
</a><a href="#h25-0-1248" id="h25-0-1248" class="i">+			if len(o.buf) &gt; maxMarshalSize {
</a><a href="#h25-0-1249" id="h25-0-1249" class="i">+				return ErrTooLarge
</a><a href="#h25-0-1250" id="h25-0-1250" class="i">+			}
</a><a href="#h25-0-1251" id="h25-0-1251" class="i">+		}
</a><a href="#h25-0-1252" id="h25-0-1252" class="i">+	}
</a><a href="#h25-0-1253" id="h25-0-1253" class="i">+
</a><a href="#h25-0-1254" id="h25-0-1254" class="i">+	// Do oneof fields.
</a><a href="#h25-0-1255" id="h25-0-1255" class="i">+	if prop.oneofMarshaler != nil {
</a><a href="#h25-0-1256" id="h25-0-1256" class="i">+		m := structPointer_Interface(base, prop.stype).(Message)
</a><a href="#h25-0-1257" id="h25-0-1257" class="i">+		if err := prop.oneofMarshaler(m, o); err == ErrNil {
</a><a href="#h25-0-1258" id="h25-0-1258" class="i">+			return errOneofHasNil
</a><a href="#h25-0-1259" id="h25-0-1259" class="i">+		} else if err != nil {
</a><a href="#h25-0-1260" id="h25-0-1260" class="i">+			return err
</a><a href="#h25-0-1261" id="h25-0-1261" class="i">+		}
</a><a href="#h25-0-1262" id="h25-0-1262" class="i">+	}
</a><a href="#h25-0-1263" id="h25-0-1263" class="i">+
</a><a href="#h25-0-1264" id="h25-0-1264" class="i">+	// Add unrecognized fields at the end.
</a><a href="#h25-0-1265" id="h25-0-1265" class="i">+	if prop.unrecField.IsValid() {
</a><a href="#h25-0-1266" id="h25-0-1266" class="i">+		v := *structPointer_Bytes(base, prop.unrecField)
</a><a href="#h25-0-1267" id="h25-0-1267" class="i">+		if len(o.buf)+len(v) &gt; maxMarshalSize {
</a><a href="#h25-0-1268" id="h25-0-1268" class="i">+			return ErrTooLarge
</a><a href="#h25-0-1269" id="h25-0-1269" class="i">+		}
</a><a href="#h25-0-1270" id="h25-0-1270" class="i">+		if len(v) &gt; 0 {
</a><a href="#h25-0-1271" id="h25-0-1271" class="i">+			o.buf = append(o.buf, v...)
</a><a href="#h25-0-1272" id="h25-0-1272" class="i">+		}
</a><a href="#h25-0-1273" id="h25-0-1273" class="i">+	}
</a><a href="#h25-0-1274" id="h25-0-1274" class="i">+
</a><a href="#h25-0-1275" id="h25-0-1275" class="i">+	return state.err
</a><a href="#h25-0-1276" id="h25-0-1276" class="i">+}
</a><a href="#h25-0-1277" id="h25-0-1277" class="i">+
</a><a href="#h25-0-1278" id="h25-0-1278" class="i">+func size_struct(prop *StructProperties, base structPointer) (n int) {
</a><a href="#h25-0-1279" id="h25-0-1279" class="i">+	for _, i := range prop.order {
</a><a href="#h25-0-1280" id="h25-0-1280" class="i">+		p := prop.Prop[i]
</a><a href="#h25-0-1281" id="h25-0-1281" class="i">+		if p.size != nil {
</a><a href="#h25-0-1282" id="h25-0-1282" class="i">+			n += p.size(p, base)
</a><a href="#h25-0-1283" id="h25-0-1283" class="i">+		}
</a><a href="#h25-0-1284" id="h25-0-1284" class="i">+	}
</a><a href="#h25-0-1285" id="h25-0-1285" class="i">+
</a><a href="#h25-0-1286" id="h25-0-1286" class="i">+	// Add unrecognized fields at the end.
</a><a href="#h25-0-1287" id="h25-0-1287" class="i">+	if prop.unrecField.IsValid() {
</a><a href="#h25-0-1288" id="h25-0-1288" class="i">+		v := *structPointer_Bytes(base, prop.unrecField)
</a><a href="#h25-0-1289" id="h25-0-1289" class="i">+		n += len(v)
</a><a href="#h25-0-1290" id="h25-0-1290" class="i">+	}
</a><a href="#h25-0-1291" id="h25-0-1291" class="i">+
</a><a href="#h25-0-1292" id="h25-0-1292" class="i">+	// Factor in any oneof fields.
</a><a href="#h25-0-1293" id="h25-0-1293" class="i">+	if prop.oneofSizer != nil {
</a><a href="#h25-0-1294" id="h25-0-1294" class="i">+		m := structPointer_Interface(base, prop.stype).(Message)
</a><a href="#h25-0-1295" id="h25-0-1295" class="i">+		n += prop.oneofSizer(m)
</a><a href="#h25-0-1296" id="h25-0-1296" class="i">+	}
</a><a href="#h25-0-1297" id="h25-0-1297" class="i">+
</a><a href="#h25-0-1298" id="h25-0-1298" class="i">+	return
</a><a href="#h25-0-1299" id="h25-0-1299" class="i">+}
</a><a href="#h25-0-1300" id="h25-0-1300" class="i">+
</a><a href="#h25-0-1301" id="h25-0-1301" class="i">+var zeroes [20]byte // longer than any conceivable sizeVarint
</a><a href="#h25-0-1302" id="h25-0-1302" class="i">+
</a><a href="#h25-0-1303" id="h25-0-1303" class="i">+// Encode a struct, preceded by its encoded length (as a varint).
</a><a href="#h25-0-1304" id="h25-0-1304" class="i">+func (o *Buffer) enc_len_struct(prop *StructProperties, base structPointer, state *errorState) error {
</a><a href="#h25-0-1305" id="h25-0-1305" class="i">+	return o.enc_len_thing(func() error { return o.enc_struct(prop, base) }, state)
</a><a href="#h25-0-1306" id="h25-0-1306" class="i">+}
</a><a href="#h25-0-1307" id="h25-0-1307" class="i">+
</a><a href="#h25-0-1308" id="h25-0-1308" class="i">+// Encode something, preceded by its encoded length (as a varint).
</a><a href="#h25-0-1309" id="h25-0-1309" class="i">+func (o *Buffer) enc_len_thing(enc func() error, state *errorState) error {
</a><a href="#h25-0-1310" id="h25-0-1310" class="i">+	iLen := len(o.buf)
</a><a href="#h25-0-1311" id="h25-0-1311" class="i">+	o.buf = append(o.buf, 0, 0, 0, 0) // reserve four bytes for length
</a><a href="#h25-0-1312" id="h25-0-1312" class="i">+	iMsg := len(o.buf)
</a><a href="#h25-0-1313" id="h25-0-1313" class="i">+	err := enc()
</a><a href="#h25-0-1314" id="h25-0-1314" class="i">+	if err != nil &amp;&amp; !state.shouldContinue(err, nil) {
</a><a href="#h25-0-1315" id="h25-0-1315" class="i">+		return err
</a><a href="#h25-0-1316" id="h25-0-1316" class="i">+	}
</a><a href="#h25-0-1317" id="h25-0-1317" class="i">+	lMsg := len(o.buf) - iMsg
</a><a href="#h25-0-1318" id="h25-0-1318" class="i">+	lLen := sizeVarint(uint64(lMsg))
</a><a href="#h25-0-1319" id="h25-0-1319" class="i">+	switch x := lLen - (iMsg - iLen); {
</a><a href="#h25-0-1320" id="h25-0-1320" class="i">+	case x &gt; 0: // actual length is x bytes larger than the space we reserved
</a><a href="#h25-0-1321" id="h25-0-1321" class="i">+		// Move msg x bytes right.
</a><a href="#h25-0-1322" id="h25-0-1322" class="i">+		o.buf = append(o.buf, zeroes[:x]...)
</a><a href="#h25-0-1323" id="h25-0-1323" class="i">+		copy(o.buf[iMsg+x:], o.buf[iMsg:iMsg+lMsg])
</a><a href="#h25-0-1324" id="h25-0-1324" class="i">+	case x &lt; 0: // actual length is x bytes smaller than the space we reserved
</a><a href="#h25-0-1325" id="h25-0-1325" class="i">+		// Move msg x bytes left.
</a><a href="#h25-0-1326" id="h25-0-1326" class="i">+		copy(o.buf[iMsg+x:], o.buf[iMsg:iMsg+lMsg])
</a><a href="#h25-0-1327" id="h25-0-1327" class="i">+		o.buf = o.buf[:len(o.buf)+x] // x is negative
</a><a href="#h25-0-1328" id="h25-0-1328" class="i">+	}
</a><a href="#h25-0-1329" id="h25-0-1329" class="i">+	// Encode the length in the reserved space.
</a><a href="#h25-0-1330" id="h25-0-1330" class="i">+	o.buf = o.buf[:iLen]
</a><a href="#h25-0-1331" id="h25-0-1331" class="i">+	o.EncodeVarint(uint64(lMsg))
</a><a href="#h25-0-1332" id="h25-0-1332" class="i">+	o.buf = o.buf[:len(o.buf)+lMsg]
</a><a href="#h25-0-1333" id="h25-0-1333" class="i">+	return state.err
</a><a href="#h25-0-1334" id="h25-0-1334" class="i">+}
</a><a href="#h25-0-1335" id="h25-0-1335" class="i">+
</a><a href="#h25-0-1336" id="h25-0-1336" class="i">+// errorState maintains the first error that occurs and updates that error
</a><a href="#h25-0-1337" id="h25-0-1337" class="i">+// with additional context.
</a><a href="#h25-0-1338" id="h25-0-1338" class="i">+type errorState struct {
</a><a href="#h25-0-1339" id="h25-0-1339" class="i">+	err error
</a><a href="#h25-0-1340" id="h25-0-1340" class="i">+}
</a><a href="#h25-0-1341" id="h25-0-1341" class="i">+
</a><a href="#h25-0-1342" id="h25-0-1342" class="i">+// shouldContinue reports whether encoding should continue upon encountering the
</a><a href="#h25-0-1343" id="h25-0-1343" class="i">+// given error. If the error is RequiredNotSetError, shouldContinue returns true
</a><a href="#h25-0-1344" id="h25-0-1344" class="i">+// and, if this is the first appearance of that error, remembers it for future
</a><a href="#h25-0-1345" id="h25-0-1345" class="i">+// reporting.
</a><a href="#h25-0-1346" id="h25-0-1346" class="i">+//
</a><a href="#h25-0-1347" id="h25-0-1347" class="i">+// If prop is not nil, it may update any error with additional context about the
</a><a href="#h25-0-1348" id="h25-0-1348" class="i">+// field with the error.
</a><a href="#h25-0-1349" id="h25-0-1349" class="i">+func (s *errorState) shouldContinue(err error, prop *Properties) bool {
</a><a href="#h25-0-1350" id="h25-0-1350" class="i">+	// Ignore unset required fields.
</a><a href="#h25-0-1351" id="h25-0-1351" class="i">+	reqNotSet, ok := err.(*RequiredNotSetError)
</a><a href="#h25-0-1352" id="h25-0-1352" class="i">+	if !ok {
</a><a href="#h25-0-1353" id="h25-0-1353" class="i">+		return false
</a><a href="#h25-0-1354" id="h25-0-1354" class="i">+	}
</a><a href="#h25-0-1355" id="h25-0-1355" class="i">+	if s.err == nil {
</a><a href="#h25-0-1356" id="h25-0-1356" class="i">+		if prop != nil {
</a><a href="#h25-0-1357" id="h25-0-1357" class="i">+			err = &amp;RequiredNotSetError{prop.Name + &quot;.&quot; + reqNotSet.field}
</a><a href="#h25-0-1358" id="h25-0-1358" class="i">+		}
</a><a href="#h25-0-1359" id="h25-0-1359" class="i">+		s.err = err
</a><a href="#h25-0-1360" id="h25-0-1360" class="i">+	}
</a><a href="#h25-0-1361" id="h25-0-1361" class="i">+	return true
</a><a href="#h25-0-1362" id="h25-0-1362" class="i">+}
</a><b>diff --git a/<a id="h26" href="../file/vendor/github.com/golang/protobuf/proto/equal.go">vendor/github.com/golang/protobuf/proto/equal.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/equal.go">vendor/github.com/golang/protobuf/proto/equal.go</a></b>
<a href="#h26-0" id="h26-0" class="h">@@ -0,0 +1,296 @@
</a><a href="#h26-0-0" id="h26-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h26-0-1" id="h26-0-1" class="i">+//
</a><a href="#h26-0-2" id="h26-0-2" class="i">+// Copyright 2011 The Go Authors.  All rights reserved.
</a><a href="#h26-0-3" id="h26-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h26-0-4" id="h26-0-4" class="i">+//
</a><a href="#h26-0-5" id="h26-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h26-0-6" id="h26-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h26-0-7" id="h26-0-7" class="i">+// met:
</a><a href="#h26-0-8" id="h26-0-8" class="i">+//
</a><a href="#h26-0-9" id="h26-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h26-0-10" id="h26-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h26-0-11" id="h26-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h26-0-12" id="h26-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h26-0-13" id="h26-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h26-0-14" id="h26-0-14" class="i">+// distribution.
</a><a href="#h26-0-15" id="h26-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h26-0-16" id="h26-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h26-0-17" id="h26-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h26-0-18" id="h26-0-18" class="i">+//
</a><a href="#h26-0-19" id="h26-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h26-0-20" id="h26-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h26-0-21" id="h26-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h26-0-22" id="h26-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h26-0-23" id="h26-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h26-0-24" id="h26-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h26-0-25" id="h26-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h26-0-26" id="h26-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h26-0-27" id="h26-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h26-0-28" id="h26-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h26-0-29" id="h26-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h26-0-30" id="h26-0-30" class="i">+
</a><a href="#h26-0-31" id="h26-0-31" class="i">+// Protocol buffer comparison.
</a><a href="#h26-0-32" id="h26-0-32" class="i">+
</a><a href="#h26-0-33" id="h26-0-33" class="i">+package proto
</a><a href="#h26-0-34" id="h26-0-34" class="i">+
</a><a href="#h26-0-35" id="h26-0-35" class="i">+import (
</a><a href="#h26-0-36" id="h26-0-36" class="i">+	&quot;bytes&quot;
</a><a href="#h26-0-37" id="h26-0-37" class="i">+	&quot;log&quot;
</a><a href="#h26-0-38" id="h26-0-38" class="i">+	&quot;reflect&quot;
</a><a href="#h26-0-39" id="h26-0-39" class="i">+	&quot;strings&quot;
</a><a href="#h26-0-40" id="h26-0-40" class="i">+)
</a><a href="#h26-0-41" id="h26-0-41" class="i">+
</a><a href="#h26-0-42" id="h26-0-42" class="i">+/*
</a><a href="#h26-0-43" id="h26-0-43" class="i">+Equal returns true iff protocol buffers a and b are equal.
</a><a href="#h26-0-44" id="h26-0-44" class="i">+The arguments must both be pointers to protocol buffer structs.
</a><a href="#h26-0-45" id="h26-0-45" class="i">+
</a><a href="#h26-0-46" id="h26-0-46" class="i">+Equality is defined in this way:
</a><a href="#h26-0-47" id="h26-0-47" class="i">+  - Two messages are equal iff they are the same type,
</a><a href="#h26-0-48" id="h26-0-48" class="i">+    corresponding fields are equal, unknown field sets
</a><a href="#h26-0-49" id="h26-0-49" class="i">+    are equal, and extensions sets are equal.
</a><a href="#h26-0-50" id="h26-0-50" class="i">+  - Two set scalar fields are equal iff their values are equal.
</a><a href="#h26-0-51" id="h26-0-51" class="i">+    If the fields are of a floating-point type, remember that
</a><a href="#h26-0-52" id="h26-0-52" class="i">+    NaN != x for all x, including NaN. If the message is defined
</a><a href="#h26-0-53" id="h26-0-53" class="i">+    in a proto3 .proto file, fields are not &quot;set&quot;; specifically,
</a><a href="#h26-0-54" id="h26-0-54" class="i">+    zero length proto3 &quot;bytes&quot; fields are equal (nil == {}).
</a><a href="#h26-0-55" id="h26-0-55" class="i">+  - Two repeated fields are equal iff their lengths are the same,
</a><a href="#h26-0-56" id="h26-0-56" class="i">+    and their corresponding elements are equal (a &quot;bytes&quot; field,
</a><a href="#h26-0-57" id="h26-0-57" class="i">+    although represented by []byte, is not a repeated field)
</a><a href="#h26-0-58" id="h26-0-58" class="i">+  - Two unset fields are equal.
</a><a href="#h26-0-59" id="h26-0-59" class="i">+  - Two unknown field sets are equal if their current
</a><a href="#h26-0-60" id="h26-0-60" class="i">+    encoded state is equal.
</a><a href="#h26-0-61" id="h26-0-61" class="i">+  - Two extension sets are equal iff they have corresponding
</a><a href="#h26-0-62" id="h26-0-62" class="i">+    elements that are pairwise equal.
</a><a href="#h26-0-63" id="h26-0-63" class="i">+  - Every other combination of things are not equal.
</a><a href="#h26-0-64" id="h26-0-64" class="i">+
</a><a href="#h26-0-65" id="h26-0-65" class="i">+The return value is undefined if a and b are not protocol buffers.
</a><a href="#h26-0-66" id="h26-0-66" class="i">+*/
</a><a href="#h26-0-67" id="h26-0-67" class="i">+func Equal(a, b Message) bool {
</a><a href="#h26-0-68" id="h26-0-68" class="i">+	if a == nil || b == nil {
</a><a href="#h26-0-69" id="h26-0-69" class="i">+		return a == b
</a><a href="#h26-0-70" id="h26-0-70" class="i">+	}
</a><a href="#h26-0-71" id="h26-0-71" class="i">+	v1, v2 := reflect.ValueOf(a), reflect.ValueOf(b)
</a><a href="#h26-0-72" id="h26-0-72" class="i">+	if v1.Type() != v2.Type() {
</a><a href="#h26-0-73" id="h26-0-73" class="i">+		return false
</a><a href="#h26-0-74" id="h26-0-74" class="i">+	}
</a><a href="#h26-0-75" id="h26-0-75" class="i">+	if v1.Kind() == reflect.Ptr {
</a><a href="#h26-0-76" id="h26-0-76" class="i">+		if v1.IsNil() {
</a><a href="#h26-0-77" id="h26-0-77" class="i">+			return v2.IsNil()
</a><a href="#h26-0-78" id="h26-0-78" class="i">+		}
</a><a href="#h26-0-79" id="h26-0-79" class="i">+		if v2.IsNil() {
</a><a href="#h26-0-80" id="h26-0-80" class="i">+			return false
</a><a href="#h26-0-81" id="h26-0-81" class="i">+		}
</a><a href="#h26-0-82" id="h26-0-82" class="i">+		v1, v2 = v1.Elem(), v2.Elem()
</a><a href="#h26-0-83" id="h26-0-83" class="i">+	}
</a><a href="#h26-0-84" id="h26-0-84" class="i">+	if v1.Kind() != reflect.Struct {
</a><a href="#h26-0-85" id="h26-0-85" class="i">+		return false
</a><a href="#h26-0-86" id="h26-0-86" class="i">+	}
</a><a href="#h26-0-87" id="h26-0-87" class="i">+	return equalStruct(v1, v2)
</a><a href="#h26-0-88" id="h26-0-88" class="i">+}
</a><a href="#h26-0-89" id="h26-0-89" class="i">+
</a><a href="#h26-0-90" id="h26-0-90" class="i">+// v1 and v2 are known to have the same type.
</a><a href="#h26-0-91" id="h26-0-91" class="i">+func equalStruct(v1, v2 reflect.Value) bool {
</a><a href="#h26-0-92" id="h26-0-92" class="i">+	sprop := GetProperties(v1.Type())
</a><a href="#h26-0-93" id="h26-0-93" class="i">+	for i := 0; i &lt; v1.NumField(); i++ {
</a><a href="#h26-0-94" id="h26-0-94" class="i">+		f := v1.Type().Field(i)
</a><a href="#h26-0-95" id="h26-0-95" class="i">+		if strings.HasPrefix(f.Name, &quot;XXX_&quot;) {
</a><a href="#h26-0-96" id="h26-0-96" class="i">+			continue
</a><a href="#h26-0-97" id="h26-0-97" class="i">+		}
</a><a href="#h26-0-98" id="h26-0-98" class="i">+		f1, f2 := v1.Field(i), v2.Field(i)
</a><a href="#h26-0-99" id="h26-0-99" class="i">+		if f.Type.Kind() == reflect.Ptr {
</a><a href="#h26-0-100" id="h26-0-100" class="i">+			if n1, n2 := f1.IsNil(), f2.IsNil(); n1 &amp;&amp; n2 {
</a><a href="#h26-0-101" id="h26-0-101" class="i">+				// both unset
</a><a href="#h26-0-102" id="h26-0-102" class="i">+				continue
</a><a href="#h26-0-103" id="h26-0-103" class="i">+			} else if n1 != n2 {
</a><a href="#h26-0-104" id="h26-0-104" class="i">+				// set/unset mismatch
</a><a href="#h26-0-105" id="h26-0-105" class="i">+				return false
</a><a href="#h26-0-106" id="h26-0-106" class="i">+			}
</a><a href="#h26-0-107" id="h26-0-107" class="i">+			b1, ok := f1.Interface().(raw)
</a><a href="#h26-0-108" id="h26-0-108" class="i">+			if ok {
</a><a href="#h26-0-109" id="h26-0-109" class="i">+				b2 := f2.Interface().(raw)
</a><a href="#h26-0-110" id="h26-0-110" class="i">+				// RawMessage
</a><a href="#h26-0-111" id="h26-0-111" class="i">+				if !bytes.Equal(b1.Bytes(), b2.Bytes()) {
</a><a href="#h26-0-112" id="h26-0-112" class="i">+					return false
</a><a href="#h26-0-113" id="h26-0-113" class="i">+				}
</a><a href="#h26-0-114" id="h26-0-114" class="i">+				continue
</a><a href="#h26-0-115" id="h26-0-115" class="i">+			}
</a><a href="#h26-0-116" id="h26-0-116" class="i">+			f1, f2 = f1.Elem(), f2.Elem()
</a><a href="#h26-0-117" id="h26-0-117" class="i">+		}
</a><a href="#h26-0-118" id="h26-0-118" class="i">+		if !equalAny(f1, f2, sprop.Prop[i]) {
</a><a href="#h26-0-119" id="h26-0-119" class="i">+			return false
</a><a href="#h26-0-120" id="h26-0-120" class="i">+		}
</a><a href="#h26-0-121" id="h26-0-121" class="i">+	}
</a><a href="#h26-0-122" id="h26-0-122" class="i">+
</a><a href="#h26-0-123" id="h26-0-123" class="i">+	if em1 := v1.FieldByName(&quot;XXX_InternalExtensions&quot;); em1.IsValid() {
</a><a href="#h26-0-124" id="h26-0-124" class="i">+		em2 := v2.FieldByName(&quot;XXX_InternalExtensions&quot;)
</a><a href="#h26-0-125" id="h26-0-125" class="i">+		if !equalExtensions(v1.Type(), em1.Interface().(XXX_InternalExtensions), em2.Interface().(XXX_InternalExtensions)) {
</a><a href="#h26-0-126" id="h26-0-126" class="i">+			return false
</a><a href="#h26-0-127" id="h26-0-127" class="i">+		}
</a><a href="#h26-0-128" id="h26-0-128" class="i">+	}
</a><a href="#h26-0-129" id="h26-0-129" class="i">+
</a><a href="#h26-0-130" id="h26-0-130" class="i">+	if em1 := v1.FieldByName(&quot;XXX_extensions&quot;); em1.IsValid() {
</a><a href="#h26-0-131" id="h26-0-131" class="i">+		em2 := v2.FieldByName(&quot;XXX_extensions&quot;)
</a><a href="#h26-0-132" id="h26-0-132" class="i">+		if !equalExtMap(v1.Type(), em1.Interface().(map[int32]Extension), em2.Interface().(map[int32]Extension)) {
</a><a href="#h26-0-133" id="h26-0-133" class="i">+			return false
</a><a href="#h26-0-134" id="h26-0-134" class="i">+		}
</a><a href="#h26-0-135" id="h26-0-135" class="i">+	}
</a><a href="#h26-0-136" id="h26-0-136" class="i">+
</a><a href="#h26-0-137" id="h26-0-137" class="i">+	uf := v1.FieldByName(&quot;XXX_unrecognized&quot;)
</a><a href="#h26-0-138" id="h26-0-138" class="i">+	if !uf.IsValid() {
</a><a href="#h26-0-139" id="h26-0-139" class="i">+		return true
</a><a href="#h26-0-140" id="h26-0-140" class="i">+	}
</a><a href="#h26-0-141" id="h26-0-141" class="i">+
</a><a href="#h26-0-142" id="h26-0-142" class="i">+	u1 := uf.Bytes()
</a><a href="#h26-0-143" id="h26-0-143" class="i">+	u2 := v2.FieldByName(&quot;XXX_unrecognized&quot;).Bytes()
</a><a href="#h26-0-144" id="h26-0-144" class="i">+	if !bytes.Equal(u1, u2) {
</a><a href="#h26-0-145" id="h26-0-145" class="i">+		return false
</a><a href="#h26-0-146" id="h26-0-146" class="i">+	}
</a><a href="#h26-0-147" id="h26-0-147" class="i">+
</a><a href="#h26-0-148" id="h26-0-148" class="i">+	return true
</a><a href="#h26-0-149" id="h26-0-149" class="i">+}
</a><a href="#h26-0-150" id="h26-0-150" class="i">+
</a><a href="#h26-0-151" id="h26-0-151" class="i">+// v1 and v2 are known to have the same type.
</a><a href="#h26-0-152" id="h26-0-152" class="i">+// prop may be nil.
</a><a href="#h26-0-153" id="h26-0-153" class="i">+func equalAny(v1, v2 reflect.Value, prop *Properties) bool {
</a><a href="#h26-0-154" id="h26-0-154" class="i">+	if v1.Type() == protoMessageType {
</a><a href="#h26-0-155" id="h26-0-155" class="i">+		m1, _ := v1.Interface().(Message)
</a><a href="#h26-0-156" id="h26-0-156" class="i">+		m2, _ := v2.Interface().(Message)
</a><a href="#h26-0-157" id="h26-0-157" class="i">+		return Equal(m1, m2)
</a><a href="#h26-0-158" id="h26-0-158" class="i">+	}
</a><a href="#h26-0-159" id="h26-0-159" class="i">+	switch v1.Kind() {
</a><a href="#h26-0-160" id="h26-0-160" class="i">+	case reflect.Bool:
</a><a href="#h26-0-161" id="h26-0-161" class="i">+		return v1.Bool() == v2.Bool()
</a><a href="#h26-0-162" id="h26-0-162" class="i">+	case reflect.Float32, reflect.Float64:
</a><a href="#h26-0-163" id="h26-0-163" class="i">+		return v1.Float() == v2.Float()
</a><a href="#h26-0-164" id="h26-0-164" class="i">+	case reflect.Int32, reflect.Int64:
</a><a href="#h26-0-165" id="h26-0-165" class="i">+		return v1.Int() == v2.Int()
</a><a href="#h26-0-166" id="h26-0-166" class="i">+	case reflect.Interface:
</a><a href="#h26-0-167" id="h26-0-167" class="i">+		// Probably a oneof field; compare the inner values.
</a><a href="#h26-0-168" id="h26-0-168" class="i">+		n1, n2 := v1.IsNil(), v2.IsNil()
</a><a href="#h26-0-169" id="h26-0-169" class="i">+		if n1 || n2 {
</a><a href="#h26-0-170" id="h26-0-170" class="i">+			return n1 == n2
</a><a href="#h26-0-171" id="h26-0-171" class="i">+		}
</a><a href="#h26-0-172" id="h26-0-172" class="i">+		e1, e2 := v1.Elem(), v2.Elem()
</a><a href="#h26-0-173" id="h26-0-173" class="i">+		if e1.Type() != e2.Type() {
</a><a href="#h26-0-174" id="h26-0-174" class="i">+			return false
</a><a href="#h26-0-175" id="h26-0-175" class="i">+		}
</a><a href="#h26-0-176" id="h26-0-176" class="i">+		return equalAny(e1, e2, nil)
</a><a href="#h26-0-177" id="h26-0-177" class="i">+	case reflect.Map:
</a><a href="#h26-0-178" id="h26-0-178" class="i">+		if v1.Len() != v2.Len() {
</a><a href="#h26-0-179" id="h26-0-179" class="i">+			return false
</a><a href="#h26-0-180" id="h26-0-180" class="i">+		}
</a><a href="#h26-0-181" id="h26-0-181" class="i">+		for _, key := range v1.MapKeys() {
</a><a href="#h26-0-182" id="h26-0-182" class="i">+			val2 := v2.MapIndex(key)
</a><a href="#h26-0-183" id="h26-0-183" class="i">+			if !val2.IsValid() {
</a><a href="#h26-0-184" id="h26-0-184" class="i">+				// This key was not found in the second map.
</a><a href="#h26-0-185" id="h26-0-185" class="i">+				return false
</a><a href="#h26-0-186" id="h26-0-186" class="i">+			}
</a><a href="#h26-0-187" id="h26-0-187" class="i">+			if !equalAny(v1.MapIndex(key), val2, nil) {
</a><a href="#h26-0-188" id="h26-0-188" class="i">+				return false
</a><a href="#h26-0-189" id="h26-0-189" class="i">+			}
</a><a href="#h26-0-190" id="h26-0-190" class="i">+		}
</a><a href="#h26-0-191" id="h26-0-191" class="i">+		return true
</a><a href="#h26-0-192" id="h26-0-192" class="i">+	case reflect.Ptr:
</a><a href="#h26-0-193" id="h26-0-193" class="i">+		// Maps may have nil values in them, so check for nil.
</a><a href="#h26-0-194" id="h26-0-194" class="i">+		if v1.IsNil() &amp;&amp; v2.IsNil() {
</a><a href="#h26-0-195" id="h26-0-195" class="i">+			return true
</a><a href="#h26-0-196" id="h26-0-196" class="i">+		}
</a><a href="#h26-0-197" id="h26-0-197" class="i">+		if v1.IsNil() != v2.IsNil() {
</a><a href="#h26-0-198" id="h26-0-198" class="i">+			return false
</a><a href="#h26-0-199" id="h26-0-199" class="i">+		}
</a><a href="#h26-0-200" id="h26-0-200" class="i">+		return equalAny(v1.Elem(), v2.Elem(), prop)
</a><a href="#h26-0-201" id="h26-0-201" class="i">+	case reflect.Slice:
</a><a href="#h26-0-202" id="h26-0-202" class="i">+		if v1.Type().Elem().Kind() == reflect.Uint8 {
</a><a href="#h26-0-203" id="h26-0-203" class="i">+			// short circuit: []byte
</a><a href="#h26-0-204" id="h26-0-204" class="i">+
</a><a href="#h26-0-205" id="h26-0-205" class="i">+			// Edge case: if this is in a proto3 message, a zero length
</a><a href="#h26-0-206" id="h26-0-206" class="i">+			// bytes field is considered the zero value.
</a><a href="#h26-0-207" id="h26-0-207" class="i">+			if prop != nil &amp;&amp; prop.proto3 &amp;&amp; v1.Len() == 0 &amp;&amp; v2.Len() == 0 {
</a><a href="#h26-0-208" id="h26-0-208" class="i">+				return true
</a><a href="#h26-0-209" id="h26-0-209" class="i">+			}
</a><a href="#h26-0-210" id="h26-0-210" class="i">+			if v1.IsNil() != v2.IsNil() {
</a><a href="#h26-0-211" id="h26-0-211" class="i">+				return false
</a><a href="#h26-0-212" id="h26-0-212" class="i">+			}
</a><a href="#h26-0-213" id="h26-0-213" class="i">+			return bytes.Equal(v1.Interface().([]byte), v2.Interface().([]byte))
</a><a href="#h26-0-214" id="h26-0-214" class="i">+		}
</a><a href="#h26-0-215" id="h26-0-215" class="i">+
</a><a href="#h26-0-216" id="h26-0-216" class="i">+		if v1.Len() != v2.Len() {
</a><a href="#h26-0-217" id="h26-0-217" class="i">+			return false
</a><a href="#h26-0-218" id="h26-0-218" class="i">+		}
</a><a href="#h26-0-219" id="h26-0-219" class="i">+		for i := 0; i &lt; v1.Len(); i++ {
</a><a href="#h26-0-220" id="h26-0-220" class="i">+			if !equalAny(v1.Index(i), v2.Index(i), prop) {
</a><a href="#h26-0-221" id="h26-0-221" class="i">+				return false
</a><a href="#h26-0-222" id="h26-0-222" class="i">+			}
</a><a href="#h26-0-223" id="h26-0-223" class="i">+		}
</a><a href="#h26-0-224" id="h26-0-224" class="i">+		return true
</a><a href="#h26-0-225" id="h26-0-225" class="i">+	case reflect.String:
</a><a href="#h26-0-226" id="h26-0-226" class="i">+		return v1.Interface().(string) == v2.Interface().(string)
</a><a href="#h26-0-227" id="h26-0-227" class="i">+	case reflect.Struct:
</a><a href="#h26-0-228" id="h26-0-228" class="i">+		return equalStruct(v1, v2)
</a><a href="#h26-0-229" id="h26-0-229" class="i">+	case reflect.Uint32, reflect.Uint64:
</a><a href="#h26-0-230" id="h26-0-230" class="i">+		return v1.Uint() == v2.Uint()
</a><a href="#h26-0-231" id="h26-0-231" class="i">+	}
</a><a href="#h26-0-232" id="h26-0-232" class="i">+
</a><a href="#h26-0-233" id="h26-0-233" class="i">+	// unknown type, so not a protocol buffer
</a><a href="#h26-0-234" id="h26-0-234" class="i">+	log.Printf(&quot;proto: don&#39;t know how to compare %v&quot;, v1)
</a><a href="#h26-0-235" id="h26-0-235" class="i">+	return false
</a><a href="#h26-0-236" id="h26-0-236" class="i">+}
</a><a href="#h26-0-237" id="h26-0-237" class="i">+
</a><a href="#h26-0-238" id="h26-0-238" class="i">+// base is the struct type that the extensions are based on.
</a><a href="#h26-0-239" id="h26-0-239" class="i">+// x1 and x2 are InternalExtensions.
</a><a href="#h26-0-240" id="h26-0-240" class="i">+func equalExtensions(base reflect.Type, x1, x2 XXX_InternalExtensions) bool {
</a><a href="#h26-0-241" id="h26-0-241" class="i">+	em1, _ := x1.extensionsRead()
</a><a href="#h26-0-242" id="h26-0-242" class="i">+	em2, _ := x2.extensionsRead()
</a><a href="#h26-0-243" id="h26-0-243" class="i">+	return equalExtMap(base, em1, em2)
</a><a href="#h26-0-244" id="h26-0-244" class="i">+}
</a><a href="#h26-0-245" id="h26-0-245" class="i">+
</a><a href="#h26-0-246" id="h26-0-246" class="i">+func equalExtMap(base reflect.Type, em1, em2 map[int32]Extension) bool {
</a><a href="#h26-0-247" id="h26-0-247" class="i">+	if len(em1) != len(em2) {
</a><a href="#h26-0-248" id="h26-0-248" class="i">+		return false
</a><a href="#h26-0-249" id="h26-0-249" class="i">+	}
</a><a href="#h26-0-250" id="h26-0-250" class="i">+
</a><a href="#h26-0-251" id="h26-0-251" class="i">+	for extNum, e1 := range em1 {
</a><a href="#h26-0-252" id="h26-0-252" class="i">+		e2, ok := em2[extNum]
</a><a href="#h26-0-253" id="h26-0-253" class="i">+		if !ok {
</a><a href="#h26-0-254" id="h26-0-254" class="i">+			return false
</a><a href="#h26-0-255" id="h26-0-255" class="i">+		}
</a><a href="#h26-0-256" id="h26-0-256" class="i">+
</a><a href="#h26-0-257" id="h26-0-257" class="i">+		m1, m2 := e1.value, e2.value
</a><a href="#h26-0-258" id="h26-0-258" class="i">+
</a><a href="#h26-0-259" id="h26-0-259" class="i">+		if m1 != nil &amp;&amp; m2 != nil {
</a><a href="#h26-0-260" id="h26-0-260" class="i">+			// Both are unencoded.
</a><a href="#h26-0-261" id="h26-0-261" class="i">+			if !equalAny(reflect.ValueOf(m1), reflect.ValueOf(m2), nil) {
</a><a href="#h26-0-262" id="h26-0-262" class="i">+				return false
</a><a href="#h26-0-263" id="h26-0-263" class="i">+			}
</a><a href="#h26-0-264" id="h26-0-264" class="i">+			continue
</a><a href="#h26-0-265" id="h26-0-265" class="i">+		}
</a><a href="#h26-0-266" id="h26-0-266" class="i">+
</a><a href="#h26-0-267" id="h26-0-267" class="i">+		// At least one is encoded. To do a semantically correct comparison
</a><a href="#h26-0-268" id="h26-0-268" class="i">+		// we need to unmarshal them first.
</a><a href="#h26-0-269" id="h26-0-269" class="i">+		var desc *ExtensionDesc
</a><a href="#h26-0-270" id="h26-0-270" class="i">+		if m := extensionMaps[base]; m != nil {
</a><a href="#h26-0-271" id="h26-0-271" class="i">+			desc = m[extNum]
</a><a href="#h26-0-272" id="h26-0-272" class="i">+		}
</a><a href="#h26-0-273" id="h26-0-273" class="i">+		if desc == nil {
</a><a href="#h26-0-274" id="h26-0-274" class="i">+			log.Printf(&quot;proto: don&#39;t know how to compare extension %d of %v&quot;, extNum, base)
</a><a href="#h26-0-275" id="h26-0-275" class="i">+			continue
</a><a href="#h26-0-276" id="h26-0-276" class="i">+		}
</a><a href="#h26-0-277" id="h26-0-277" class="i">+		var err error
</a><a href="#h26-0-278" id="h26-0-278" class="i">+		if m1 == nil {
</a><a href="#h26-0-279" id="h26-0-279" class="i">+			m1, err = decodeExtension(e1.enc, desc)
</a><a href="#h26-0-280" id="h26-0-280" class="i">+		}
</a><a href="#h26-0-281" id="h26-0-281" class="i">+		if m2 == nil &amp;&amp; err == nil {
</a><a href="#h26-0-282" id="h26-0-282" class="i">+			m2, err = decodeExtension(e2.enc, desc)
</a><a href="#h26-0-283" id="h26-0-283" class="i">+		}
</a><a href="#h26-0-284" id="h26-0-284" class="i">+		if err != nil {
</a><a href="#h26-0-285" id="h26-0-285" class="i">+			// The encoded form is invalid.
</a><a href="#h26-0-286" id="h26-0-286" class="i">+			log.Printf(&quot;proto: badly encoded extension %d of %v: %v&quot;, extNum, base, err)
</a><a href="#h26-0-287" id="h26-0-287" class="i">+			return false
</a><a href="#h26-0-288" id="h26-0-288" class="i">+		}
</a><a href="#h26-0-289" id="h26-0-289" class="i">+		if !equalAny(reflect.ValueOf(m1), reflect.ValueOf(m2), nil) {
</a><a href="#h26-0-290" id="h26-0-290" class="i">+			return false
</a><a href="#h26-0-291" id="h26-0-291" class="i">+		}
</a><a href="#h26-0-292" id="h26-0-292" class="i">+	}
</a><a href="#h26-0-293" id="h26-0-293" class="i">+
</a><a href="#h26-0-294" id="h26-0-294" class="i">+	return true
</a><a href="#h26-0-295" id="h26-0-295" class="i">+}
</a><b>diff --git a/<a id="h27" href="../file/vendor/github.com/golang/protobuf/proto/extensions.go">vendor/github.com/golang/protobuf/proto/extensions.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/extensions.go">vendor/github.com/golang/protobuf/proto/extensions.go</a></b>
<a href="#h27-0" id="h27-0" class="h">@@ -0,0 +1,586 @@
</a><a href="#h27-0-0" id="h27-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h27-0-1" id="h27-0-1" class="i">+//
</a><a href="#h27-0-2" id="h27-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h27-0-3" id="h27-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h27-0-4" id="h27-0-4" class="i">+//
</a><a href="#h27-0-5" id="h27-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h27-0-6" id="h27-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h27-0-7" id="h27-0-7" class="i">+// met:
</a><a href="#h27-0-8" id="h27-0-8" class="i">+//
</a><a href="#h27-0-9" id="h27-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h27-0-10" id="h27-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h27-0-11" id="h27-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h27-0-12" id="h27-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h27-0-13" id="h27-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h27-0-14" id="h27-0-14" class="i">+// distribution.
</a><a href="#h27-0-15" id="h27-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h27-0-16" id="h27-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h27-0-17" id="h27-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h27-0-18" id="h27-0-18" class="i">+//
</a><a href="#h27-0-19" id="h27-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h27-0-20" id="h27-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h27-0-21" id="h27-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h27-0-22" id="h27-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h27-0-23" id="h27-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h27-0-24" id="h27-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h27-0-25" id="h27-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h27-0-26" id="h27-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h27-0-27" id="h27-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h27-0-28" id="h27-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h27-0-29" id="h27-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h27-0-30" id="h27-0-30" class="i">+
</a><a href="#h27-0-31" id="h27-0-31" class="i">+package proto
</a><a href="#h27-0-32" id="h27-0-32" class="i">+
</a><a href="#h27-0-33" id="h27-0-33" class="i">+/*
</a><a href="#h27-0-34" id="h27-0-34" class="i">+ * Types and routines for supporting protocol buffer extensions.
</a><a href="#h27-0-35" id="h27-0-35" class="i">+ */
</a><a href="#h27-0-36" id="h27-0-36" class="i">+
</a><a href="#h27-0-37" id="h27-0-37" class="i">+import (
</a><a href="#h27-0-38" id="h27-0-38" class="i">+	&quot;errors&quot;
</a><a href="#h27-0-39" id="h27-0-39" class="i">+	&quot;fmt&quot;
</a><a href="#h27-0-40" id="h27-0-40" class="i">+	&quot;reflect&quot;
</a><a href="#h27-0-41" id="h27-0-41" class="i">+	&quot;strconv&quot;
</a><a href="#h27-0-42" id="h27-0-42" class="i">+	&quot;sync&quot;
</a><a href="#h27-0-43" id="h27-0-43" class="i">+)
</a><a href="#h27-0-44" id="h27-0-44" class="i">+
</a><a href="#h27-0-45" id="h27-0-45" class="i">+// ErrMissingExtension is the error returned by GetExtension if the named extension is not in the message.
</a><a href="#h27-0-46" id="h27-0-46" class="i">+var ErrMissingExtension = errors.New(&quot;proto: missing extension&quot;)
</a><a href="#h27-0-47" id="h27-0-47" class="i">+
</a><a href="#h27-0-48" id="h27-0-48" class="i">+// ExtensionRange represents a range of message extensions for a protocol buffer.
</a><a href="#h27-0-49" id="h27-0-49" class="i">+// Used in code generated by the protocol compiler.
</a><a href="#h27-0-50" id="h27-0-50" class="i">+type ExtensionRange struct {
</a><a href="#h27-0-51" id="h27-0-51" class="i">+	Start, End int32 // both inclusive
</a><a href="#h27-0-52" id="h27-0-52" class="i">+}
</a><a href="#h27-0-53" id="h27-0-53" class="i">+
</a><a href="#h27-0-54" id="h27-0-54" class="i">+// extendableProto is an interface implemented by any protocol buffer generated by the current
</a><a href="#h27-0-55" id="h27-0-55" class="i">+// proto compiler that may be extended.
</a><a href="#h27-0-56" id="h27-0-56" class="i">+type extendableProto interface {
</a><a href="#h27-0-57" id="h27-0-57" class="i">+	Message
</a><a href="#h27-0-58" id="h27-0-58" class="i">+	ExtensionRangeArray() []ExtensionRange
</a><a href="#h27-0-59" id="h27-0-59" class="i">+	extensionsWrite() map[int32]Extension
</a><a href="#h27-0-60" id="h27-0-60" class="i">+	extensionsRead() (map[int32]Extension, sync.Locker)
</a><a href="#h27-0-61" id="h27-0-61" class="i">+}
</a><a href="#h27-0-62" id="h27-0-62" class="i">+
</a><a href="#h27-0-63" id="h27-0-63" class="i">+// extendableProtoV1 is an interface implemented by a protocol buffer generated by the previous
</a><a href="#h27-0-64" id="h27-0-64" class="i">+// version of the proto compiler that may be extended.
</a><a href="#h27-0-65" id="h27-0-65" class="i">+type extendableProtoV1 interface {
</a><a href="#h27-0-66" id="h27-0-66" class="i">+	Message
</a><a href="#h27-0-67" id="h27-0-67" class="i">+	ExtensionRangeArray() []ExtensionRange
</a><a href="#h27-0-68" id="h27-0-68" class="i">+	ExtensionMap() map[int32]Extension
</a><a href="#h27-0-69" id="h27-0-69" class="i">+}
</a><a href="#h27-0-70" id="h27-0-70" class="i">+
</a><a href="#h27-0-71" id="h27-0-71" class="i">+// extensionAdapter is a wrapper around extendableProtoV1 that implements extendableProto.
</a><a href="#h27-0-72" id="h27-0-72" class="i">+type extensionAdapter struct {
</a><a href="#h27-0-73" id="h27-0-73" class="i">+	extendableProtoV1
</a><a href="#h27-0-74" id="h27-0-74" class="i">+}
</a><a href="#h27-0-75" id="h27-0-75" class="i">+
</a><a href="#h27-0-76" id="h27-0-76" class="i">+func (e extensionAdapter) extensionsWrite() map[int32]Extension {
</a><a href="#h27-0-77" id="h27-0-77" class="i">+	return e.ExtensionMap()
</a><a href="#h27-0-78" id="h27-0-78" class="i">+}
</a><a href="#h27-0-79" id="h27-0-79" class="i">+
</a><a href="#h27-0-80" id="h27-0-80" class="i">+func (e extensionAdapter) extensionsRead() (map[int32]Extension, sync.Locker) {
</a><a href="#h27-0-81" id="h27-0-81" class="i">+	return e.ExtensionMap(), notLocker{}
</a><a href="#h27-0-82" id="h27-0-82" class="i">+}
</a><a href="#h27-0-83" id="h27-0-83" class="i">+
</a><a href="#h27-0-84" id="h27-0-84" class="i">+// notLocker is a sync.Locker whose Lock and Unlock methods are nops.
</a><a href="#h27-0-85" id="h27-0-85" class="i">+type notLocker struct{}
</a><a href="#h27-0-86" id="h27-0-86" class="i">+
</a><a href="#h27-0-87" id="h27-0-87" class="i">+func (n notLocker) Lock()   {}
</a><a href="#h27-0-88" id="h27-0-88" class="i">+func (n notLocker) Unlock() {}
</a><a href="#h27-0-89" id="h27-0-89" class="i">+
</a><a href="#h27-0-90" id="h27-0-90" class="i">+// extendable returns the extendableProto interface for the given generated proto message.
</a><a href="#h27-0-91" id="h27-0-91" class="i">+// If the proto message has the old extension format, it returns a wrapper that implements
</a><a href="#h27-0-92" id="h27-0-92" class="i">+// the extendableProto interface.
</a><a href="#h27-0-93" id="h27-0-93" class="i">+func extendable(p interface{}) (extendableProto, bool) {
</a><a href="#h27-0-94" id="h27-0-94" class="i">+	if ep, ok := p.(extendableProto); ok {
</a><a href="#h27-0-95" id="h27-0-95" class="i">+		return ep, ok
</a><a href="#h27-0-96" id="h27-0-96" class="i">+	}
</a><a href="#h27-0-97" id="h27-0-97" class="i">+	if ep, ok := p.(extendableProtoV1); ok {
</a><a href="#h27-0-98" id="h27-0-98" class="i">+		return extensionAdapter{ep}, ok
</a><a href="#h27-0-99" id="h27-0-99" class="i">+	}
</a><a href="#h27-0-100" id="h27-0-100" class="i">+	return nil, false
</a><a href="#h27-0-101" id="h27-0-101" class="i">+}
</a><a href="#h27-0-102" id="h27-0-102" class="i">+
</a><a href="#h27-0-103" id="h27-0-103" class="i">+// XXX_InternalExtensions is an internal representation of proto extensions.
</a><a href="#h27-0-104" id="h27-0-104" class="i">+//
</a><a href="#h27-0-105" id="h27-0-105" class="i">+// Each generated message struct type embeds an anonymous XXX_InternalExtensions field,
</a><a href="#h27-0-106" id="h27-0-106" class="i">+// thus gaining the unexported &#39;extensions&#39; method, which can be called only from the proto package.
</a><a href="#h27-0-107" id="h27-0-107" class="i">+//
</a><a href="#h27-0-108" id="h27-0-108" class="i">+// The methods of XXX_InternalExtensions are not concurrency safe in general,
</a><a href="#h27-0-109" id="h27-0-109" class="i">+// but calls to logically read-only methods such as has and get may be executed concurrently.
</a><a href="#h27-0-110" id="h27-0-110" class="i">+type XXX_InternalExtensions struct {
</a><a href="#h27-0-111" id="h27-0-111" class="i">+	// The struct must be indirect so that if a user inadvertently copies a
</a><a href="#h27-0-112" id="h27-0-112" class="i">+	// generated message and its embedded XXX_InternalExtensions, they
</a><a href="#h27-0-113" id="h27-0-113" class="i">+	// avoid the mayhem of a copied mutex.
</a><a href="#h27-0-114" id="h27-0-114" class="i">+	//
</a><a href="#h27-0-115" id="h27-0-115" class="i">+	// The mutex serializes all logically read-only operations to p.extensionMap.
</a><a href="#h27-0-116" id="h27-0-116" class="i">+	// It is up to the client to ensure that write operations to p.extensionMap are
</a><a href="#h27-0-117" id="h27-0-117" class="i">+	// mutually exclusive with other accesses.
</a><a href="#h27-0-118" id="h27-0-118" class="i">+	p *struct {
</a><a href="#h27-0-119" id="h27-0-119" class="i">+		mu           sync.Mutex
</a><a href="#h27-0-120" id="h27-0-120" class="i">+		extensionMap map[int32]Extension
</a><a href="#h27-0-121" id="h27-0-121" class="i">+	}
</a><a href="#h27-0-122" id="h27-0-122" class="i">+}
</a><a href="#h27-0-123" id="h27-0-123" class="i">+
</a><a href="#h27-0-124" id="h27-0-124" class="i">+// extensionsWrite returns the extension map, creating it on first use.
</a><a href="#h27-0-125" id="h27-0-125" class="i">+func (e *XXX_InternalExtensions) extensionsWrite() map[int32]Extension {
</a><a href="#h27-0-126" id="h27-0-126" class="i">+	if e.p == nil {
</a><a href="#h27-0-127" id="h27-0-127" class="i">+		e.p = new(struct {
</a><a href="#h27-0-128" id="h27-0-128" class="i">+			mu           sync.Mutex
</a><a href="#h27-0-129" id="h27-0-129" class="i">+			extensionMap map[int32]Extension
</a><a href="#h27-0-130" id="h27-0-130" class="i">+		})
</a><a href="#h27-0-131" id="h27-0-131" class="i">+		e.p.extensionMap = make(map[int32]Extension)
</a><a href="#h27-0-132" id="h27-0-132" class="i">+	}
</a><a href="#h27-0-133" id="h27-0-133" class="i">+	return e.p.extensionMap
</a><a href="#h27-0-134" id="h27-0-134" class="i">+}
</a><a href="#h27-0-135" id="h27-0-135" class="i">+
</a><a href="#h27-0-136" id="h27-0-136" class="i">+// extensionsRead returns the extensions map for read-only use.  It may be nil.
</a><a href="#h27-0-137" id="h27-0-137" class="i">+// The caller must hold the returned mutex&#39;s lock when accessing Elements within the map.
</a><a href="#h27-0-138" id="h27-0-138" class="i">+func (e *XXX_InternalExtensions) extensionsRead() (map[int32]Extension, sync.Locker) {
</a><a href="#h27-0-139" id="h27-0-139" class="i">+	if e.p == nil {
</a><a href="#h27-0-140" id="h27-0-140" class="i">+		return nil, nil
</a><a href="#h27-0-141" id="h27-0-141" class="i">+	}
</a><a href="#h27-0-142" id="h27-0-142" class="i">+	return e.p.extensionMap, &amp;e.p.mu
</a><a href="#h27-0-143" id="h27-0-143" class="i">+}
</a><a href="#h27-0-144" id="h27-0-144" class="i">+
</a><a href="#h27-0-145" id="h27-0-145" class="i">+var extendableProtoType = reflect.TypeOf((*extendableProto)(nil)).Elem()
</a><a href="#h27-0-146" id="h27-0-146" class="i">+var extendableProtoV1Type = reflect.TypeOf((*extendableProtoV1)(nil)).Elem()
</a><a href="#h27-0-147" id="h27-0-147" class="i">+
</a><a href="#h27-0-148" id="h27-0-148" class="i">+// ExtensionDesc represents an extension specification.
</a><a href="#h27-0-149" id="h27-0-149" class="i">+// Used in generated code from the protocol compiler.
</a><a href="#h27-0-150" id="h27-0-150" class="i">+type ExtensionDesc struct {
</a><a href="#h27-0-151" id="h27-0-151" class="i">+	ExtendedType  Message     // nil pointer to the type that is being extended
</a><a href="#h27-0-152" id="h27-0-152" class="i">+	ExtensionType interface{} // nil pointer to the extension type
</a><a href="#h27-0-153" id="h27-0-153" class="i">+	Field         int32       // field number
</a><a href="#h27-0-154" id="h27-0-154" class="i">+	Name          string      // fully-qualified name of extension, for text formatting
</a><a href="#h27-0-155" id="h27-0-155" class="i">+	Tag           string      // protobuf tag style
</a><a href="#h27-0-156" id="h27-0-156" class="i">+}
</a><a href="#h27-0-157" id="h27-0-157" class="i">+
</a><a href="#h27-0-158" id="h27-0-158" class="i">+func (ed *ExtensionDesc) repeated() bool {
</a><a href="#h27-0-159" id="h27-0-159" class="i">+	t := reflect.TypeOf(ed.ExtensionType)
</a><a href="#h27-0-160" id="h27-0-160" class="i">+	return t.Kind() == reflect.Slice &amp;&amp; t.Elem().Kind() != reflect.Uint8
</a><a href="#h27-0-161" id="h27-0-161" class="i">+}
</a><a href="#h27-0-162" id="h27-0-162" class="i">+
</a><a href="#h27-0-163" id="h27-0-163" class="i">+// Extension represents an extension in a message.
</a><a href="#h27-0-164" id="h27-0-164" class="i">+type Extension struct {
</a><a href="#h27-0-165" id="h27-0-165" class="i">+	// When an extension is stored in a message using SetExtension
</a><a href="#h27-0-166" id="h27-0-166" class="i">+	// only desc and value are set. When the message is marshaled
</a><a href="#h27-0-167" id="h27-0-167" class="i">+	// enc will be set to the encoded form of the message.
</a><a href="#h27-0-168" id="h27-0-168" class="i">+	//
</a><a href="#h27-0-169" id="h27-0-169" class="i">+	// When a message is unmarshaled and contains extensions, each
</a><a href="#h27-0-170" id="h27-0-170" class="i">+	// extension will have only enc set. When such an extension is
</a><a href="#h27-0-171" id="h27-0-171" class="i">+	// accessed using GetExtension (or GetExtensions) desc and value
</a><a href="#h27-0-172" id="h27-0-172" class="i">+	// will be set.
</a><a href="#h27-0-173" id="h27-0-173" class="i">+	desc  *ExtensionDesc
</a><a href="#h27-0-174" id="h27-0-174" class="i">+	value interface{}
</a><a href="#h27-0-175" id="h27-0-175" class="i">+	enc   []byte
</a><a href="#h27-0-176" id="h27-0-176" class="i">+}
</a><a href="#h27-0-177" id="h27-0-177" class="i">+
</a><a href="#h27-0-178" id="h27-0-178" class="i">+// SetRawExtension is for testing only.
</a><a href="#h27-0-179" id="h27-0-179" class="i">+func SetRawExtension(base Message, id int32, b []byte) {
</a><a href="#h27-0-180" id="h27-0-180" class="i">+	epb, ok := extendable(base)
</a><a href="#h27-0-181" id="h27-0-181" class="i">+	if !ok {
</a><a href="#h27-0-182" id="h27-0-182" class="i">+		return
</a><a href="#h27-0-183" id="h27-0-183" class="i">+	}
</a><a href="#h27-0-184" id="h27-0-184" class="i">+	extmap := epb.extensionsWrite()
</a><a href="#h27-0-185" id="h27-0-185" class="i">+	extmap[id] = Extension{enc: b}
</a><a href="#h27-0-186" id="h27-0-186" class="i">+}
</a><a href="#h27-0-187" id="h27-0-187" class="i">+
</a><a href="#h27-0-188" id="h27-0-188" class="i">+// isExtensionField returns true iff the given field number is in an extension range.
</a><a href="#h27-0-189" id="h27-0-189" class="i">+func isExtensionField(pb extendableProto, field int32) bool {
</a><a href="#h27-0-190" id="h27-0-190" class="i">+	for _, er := range pb.ExtensionRangeArray() {
</a><a href="#h27-0-191" id="h27-0-191" class="i">+		if er.Start &lt;= field &amp;&amp; field &lt;= er.End {
</a><a href="#h27-0-192" id="h27-0-192" class="i">+			return true
</a><a href="#h27-0-193" id="h27-0-193" class="i">+		}
</a><a href="#h27-0-194" id="h27-0-194" class="i">+	}
</a><a href="#h27-0-195" id="h27-0-195" class="i">+	return false
</a><a href="#h27-0-196" id="h27-0-196" class="i">+}
</a><a href="#h27-0-197" id="h27-0-197" class="i">+
</a><a href="#h27-0-198" id="h27-0-198" class="i">+// checkExtensionTypes checks that the given extension is valid for pb.
</a><a href="#h27-0-199" id="h27-0-199" class="i">+func checkExtensionTypes(pb extendableProto, extension *ExtensionDesc) error {
</a><a href="#h27-0-200" id="h27-0-200" class="i">+	var pbi interface{} = pb
</a><a href="#h27-0-201" id="h27-0-201" class="i">+	// Check the extended type.
</a><a href="#h27-0-202" id="h27-0-202" class="i">+	if ea, ok := pbi.(extensionAdapter); ok {
</a><a href="#h27-0-203" id="h27-0-203" class="i">+		pbi = ea.extendableProtoV1
</a><a href="#h27-0-204" id="h27-0-204" class="i">+	}
</a><a href="#h27-0-205" id="h27-0-205" class="i">+	if a, b := reflect.TypeOf(pbi), reflect.TypeOf(extension.ExtendedType); a != b {
</a><a href="#h27-0-206" id="h27-0-206" class="i">+		return errors.New(&quot;proto: bad extended type; &quot; + b.String() + &quot; does not extend &quot; + a.String())
</a><a href="#h27-0-207" id="h27-0-207" class="i">+	}
</a><a href="#h27-0-208" id="h27-0-208" class="i">+	// Check the range.
</a><a href="#h27-0-209" id="h27-0-209" class="i">+	if !isExtensionField(pb, extension.Field) {
</a><a href="#h27-0-210" id="h27-0-210" class="i">+		return errors.New(&quot;proto: bad extension number; not in declared ranges&quot;)
</a><a href="#h27-0-211" id="h27-0-211" class="i">+	}
</a><a href="#h27-0-212" id="h27-0-212" class="i">+	return nil
</a><a href="#h27-0-213" id="h27-0-213" class="i">+}
</a><a href="#h27-0-214" id="h27-0-214" class="i">+
</a><a href="#h27-0-215" id="h27-0-215" class="i">+// extPropKey is sufficient to uniquely identify an extension.
</a><a href="#h27-0-216" id="h27-0-216" class="i">+type extPropKey struct {
</a><a href="#h27-0-217" id="h27-0-217" class="i">+	base  reflect.Type
</a><a href="#h27-0-218" id="h27-0-218" class="i">+	field int32
</a><a href="#h27-0-219" id="h27-0-219" class="i">+}
</a><a href="#h27-0-220" id="h27-0-220" class="i">+
</a><a href="#h27-0-221" id="h27-0-221" class="i">+var extProp = struct {
</a><a href="#h27-0-222" id="h27-0-222" class="i">+	sync.RWMutex
</a><a href="#h27-0-223" id="h27-0-223" class="i">+	m map[extPropKey]*Properties
</a><a href="#h27-0-224" id="h27-0-224" class="i">+}{
</a><a href="#h27-0-225" id="h27-0-225" class="i">+	m: make(map[extPropKey]*Properties),
</a><a href="#h27-0-226" id="h27-0-226" class="i">+}
</a><a href="#h27-0-227" id="h27-0-227" class="i">+
</a><a href="#h27-0-228" id="h27-0-228" class="i">+func extensionProperties(ed *ExtensionDesc) *Properties {
</a><a href="#h27-0-229" id="h27-0-229" class="i">+	key := extPropKey{base: reflect.TypeOf(ed.ExtendedType), field: ed.Field}
</a><a href="#h27-0-230" id="h27-0-230" class="i">+
</a><a href="#h27-0-231" id="h27-0-231" class="i">+	extProp.RLock()
</a><a href="#h27-0-232" id="h27-0-232" class="i">+	if prop, ok := extProp.m[key]; ok {
</a><a href="#h27-0-233" id="h27-0-233" class="i">+		extProp.RUnlock()
</a><a href="#h27-0-234" id="h27-0-234" class="i">+		return prop
</a><a href="#h27-0-235" id="h27-0-235" class="i">+	}
</a><a href="#h27-0-236" id="h27-0-236" class="i">+	extProp.RUnlock()
</a><a href="#h27-0-237" id="h27-0-237" class="i">+
</a><a href="#h27-0-238" id="h27-0-238" class="i">+	extProp.Lock()
</a><a href="#h27-0-239" id="h27-0-239" class="i">+	defer extProp.Unlock()
</a><a href="#h27-0-240" id="h27-0-240" class="i">+	// Check again.
</a><a href="#h27-0-241" id="h27-0-241" class="i">+	if prop, ok := extProp.m[key]; ok {
</a><a href="#h27-0-242" id="h27-0-242" class="i">+		return prop
</a><a href="#h27-0-243" id="h27-0-243" class="i">+	}
</a><a href="#h27-0-244" id="h27-0-244" class="i">+
</a><a href="#h27-0-245" id="h27-0-245" class="i">+	prop := new(Properties)
</a><a href="#h27-0-246" id="h27-0-246" class="i">+	prop.Init(reflect.TypeOf(ed.ExtensionType), &quot;unknown_name&quot;, ed.Tag, nil)
</a><a href="#h27-0-247" id="h27-0-247" class="i">+	extProp.m[key] = prop
</a><a href="#h27-0-248" id="h27-0-248" class="i">+	return prop
</a><a href="#h27-0-249" id="h27-0-249" class="i">+}
</a><a href="#h27-0-250" id="h27-0-250" class="i">+
</a><a href="#h27-0-251" id="h27-0-251" class="i">+// encode encodes any unmarshaled (unencoded) extensions in e.
</a><a href="#h27-0-252" id="h27-0-252" class="i">+func encodeExtensions(e *XXX_InternalExtensions) error {
</a><a href="#h27-0-253" id="h27-0-253" class="i">+	m, mu := e.extensionsRead()
</a><a href="#h27-0-254" id="h27-0-254" class="i">+	if m == nil {
</a><a href="#h27-0-255" id="h27-0-255" class="i">+		return nil // fast path
</a><a href="#h27-0-256" id="h27-0-256" class="i">+	}
</a><a href="#h27-0-257" id="h27-0-257" class="i">+	mu.Lock()
</a><a href="#h27-0-258" id="h27-0-258" class="i">+	defer mu.Unlock()
</a><a href="#h27-0-259" id="h27-0-259" class="i">+	return encodeExtensionsMap(m)
</a><a href="#h27-0-260" id="h27-0-260" class="i">+}
</a><a href="#h27-0-261" id="h27-0-261" class="i">+
</a><a href="#h27-0-262" id="h27-0-262" class="i">+// encode encodes any unmarshaled (unencoded) extensions in e.
</a><a href="#h27-0-263" id="h27-0-263" class="i">+func encodeExtensionsMap(m map[int32]Extension) error {
</a><a href="#h27-0-264" id="h27-0-264" class="i">+	for k, e := range m {
</a><a href="#h27-0-265" id="h27-0-265" class="i">+		if e.value == nil || e.desc == nil {
</a><a href="#h27-0-266" id="h27-0-266" class="i">+			// Extension is only in its encoded form.
</a><a href="#h27-0-267" id="h27-0-267" class="i">+			continue
</a><a href="#h27-0-268" id="h27-0-268" class="i">+		}
</a><a href="#h27-0-269" id="h27-0-269" class="i">+
</a><a href="#h27-0-270" id="h27-0-270" class="i">+		// We don&#39;t skip extensions that have an encoded form set,
</a><a href="#h27-0-271" id="h27-0-271" class="i">+		// because the extension value may have been mutated after
</a><a href="#h27-0-272" id="h27-0-272" class="i">+		// the last time this function was called.
</a><a href="#h27-0-273" id="h27-0-273" class="i">+
</a><a href="#h27-0-274" id="h27-0-274" class="i">+		et := reflect.TypeOf(e.desc.ExtensionType)
</a><a href="#h27-0-275" id="h27-0-275" class="i">+		props := extensionProperties(e.desc)
</a><a href="#h27-0-276" id="h27-0-276" class="i">+
</a><a href="#h27-0-277" id="h27-0-277" class="i">+		p := NewBuffer(nil)
</a><a href="#h27-0-278" id="h27-0-278" class="i">+		// If e.value has type T, the encoder expects a *struct{ X T }.
</a><a href="#h27-0-279" id="h27-0-279" class="i">+		// Pass a *T with a zero field and hope it all works out.
</a><a href="#h27-0-280" id="h27-0-280" class="i">+		x := reflect.New(et)
</a><a href="#h27-0-281" id="h27-0-281" class="i">+		x.Elem().Set(reflect.ValueOf(e.value))
</a><a href="#h27-0-282" id="h27-0-282" class="i">+		if err := props.enc(p, props, toStructPointer(x)); err != nil {
</a><a href="#h27-0-283" id="h27-0-283" class="i">+			return err
</a><a href="#h27-0-284" id="h27-0-284" class="i">+		}
</a><a href="#h27-0-285" id="h27-0-285" class="i">+		e.enc = p.buf
</a><a href="#h27-0-286" id="h27-0-286" class="i">+		m[k] = e
</a><a href="#h27-0-287" id="h27-0-287" class="i">+	}
</a><a href="#h27-0-288" id="h27-0-288" class="i">+	return nil
</a><a href="#h27-0-289" id="h27-0-289" class="i">+}
</a><a href="#h27-0-290" id="h27-0-290" class="i">+
</a><a href="#h27-0-291" id="h27-0-291" class="i">+func extensionsSize(e *XXX_InternalExtensions) (n int) {
</a><a href="#h27-0-292" id="h27-0-292" class="i">+	m, mu := e.extensionsRead()
</a><a href="#h27-0-293" id="h27-0-293" class="i">+	if m == nil {
</a><a href="#h27-0-294" id="h27-0-294" class="i">+		return 0
</a><a href="#h27-0-295" id="h27-0-295" class="i">+	}
</a><a href="#h27-0-296" id="h27-0-296" class="i">+	mu.Lock()
</a><a href="#h27-0-297" id="h27-0-297" class="i">+	defer mu.Unlock()
</a><a href="#h27-0-298" id="h27-0-298" class="i">+	return extensionsMapSize(m)
</a><a href="#h27-0-299" id="h27-0-299" class="i">+}
</a><a href="#h27-0-300" id="h27-0-300" class="i">+
</a><a href="#h27-0-301" id="h27-0-301" class="i">+func extensionsMapSize(m map[int32]Extension) (n int) {
</a><a href="#h27-0-302" id="h27-0-302" class="i">+	for _, e := range m {
</a><a href="#h27-0-303" id="h27-0-303" class="i">+		if e.value == nil || e.desc == nil {
</a><a href="#h27-0-304" id="h27-0-304" class="i">+			// Extension is only in its encoded form.
</a><a href="#h27-0-305" id="h27-0-305" class="i">+			n += len(e.enc)
</a><a href="#h27-0-306" id="h27-0-306" class="i">+			continue
</a><a href="#h27-0-307" id="h27-0-307" class="i">+		}
</a><a href="#h27-0-308" id="h27-0-308" class="i">+
</a><a href="#h27-0-309" id="h27-0-309" class="i">+		// We don&#39;t skip extensions that have an encoded form set,
</a><a href="#h27-0-310" id="h27-0-310" class="i">+		// because the extension value may have been mutated after
</a><a href="#h27-0-311" id="h27-0-311" class="i">+		// the last time this function was called.
</a><a href="#h27-0-312" id="h27-0-312" class="i">+
</a><a href="#h27-0-313" id="h27-0-313" class="i">+		et := reflect.TypeOf(e.desc.ExtensionType)
</a><a href="#h27-0-314" id="h27-0-314" class="i">+		props := extensionProperties(e.desc)
</a><a href="#h27-0-315" id="h27-0-315" class="i">+
</a><a href="#h27-0-316" id="h27-0-316" class="i">+		// If e.value has type T, the encoder expects a *struct{ X T }.
</a><a href="#h27-0-317" id="h27-0-317" class="i">+		// Pass a *T with a zero field and hope it all works out.
</a><a href="#h27-0-318" id="h27-0-318" class="i">+		x := reflect.New(et)
</a><a href="#h27-0-319" id="h27-0-319" class="i">+		x.Elem().Set(reflect.ValueOf(e.value))
</a><a href="#h27-0-320" id="h27-0-320" class="i">+		n += props.size(props, toStructPointer(x))
</a><a href="#h27-0-321" id="h27-0-321" class="i">+	}
</a><a href="#h27-0-322" id="h27-0-322" class="i">+	return
</a><a href="#h27-0-323" id="h27-0-323" class="i">+}
</a><a href="#h27-0-324" id="h27-0-324" class="i">+
</a><a href="#h27-0-325" id="h27-0-325" class="i">+// HasExtension returns whether the given extension is present in pb.
</a><a href="#h27-0-326" id="h27-0-326" class="i">+func HasExtension(pb Message, extension *ExtensionDesc) bool {
</a><a href="#h27-0-327" id="h27-0-327" class="i">+	// TODO: Check types, field numbers, etc.?
</a><a href="#h27-0-328" id="h27-0-328" class="i">+	epb, ok := extendable(pb)
</a><a href="#h27-0-329" id="h27-0-329" class="i">+	if !ok {
</a><a href="#h27-0-330" id="h27-0-330" class="i">+		return false
</a><a href="#h27-0-331" id="h27-0-331" class="i">+	}
</a><a href="#h27-0-332" id="h27-0-332" class="i">+	extmap, mu := epb.extensionsRead()
</a><a href="#h27-0-333" id="h27-0-333" class="i">+	if extmap == nil {
</a><a href="#h27-0-334" id="h27-0-334" class="i">+		return false
</a><a href="#h27-0-335" id="h27-0-335" class="i">+	}
</a><a href="#h27-0-336" id="h27-0-336" class="i">+	mu.Lock()
</a><a href="#h27-0-337" id="h27-0-337" class="i">+	_, ok = extmap[extension.Field]
</a><a href="#h27-0-338" id="h27-0-338" class="i">+	mu.Unlock()
</a><a href="#h27-0-339" id="h27-0-339" class="i">+	return ok
</a><a href="#h27-0-340" id="h27-0-340" class="i">+}
</a><a href="#h27-0-341" id="h27-0-341" class="i">+
</a><a href="#h27-0-342" id="h27-0-342" class="i">+// ClearExtension removes the given extension from pb.
</a><a href="#h27-0-343" id="h27-0-343" class="i">+func ClearExtension(pb Message, extension *ExtensionDesc) {
</a><a href="#h27-0-344" id="h27-0-344" class="i">+	epb, ok := extendable(pb)
</a><a href="#h27-0-345" id="h27-0-345" class="i">+	if !ok {
</a><a href="#h27-0-346" id="h27-0-346" class="i">+		return
</a><a href="#h27-0-347" id="h27-0-347" class="i">+	}
</a><a href="#h27-0-348" id="h27-0-348" class="i">+	// TODO: Check types, field numbers, etc.?
</a><a href="#h27-0-349" id="h27-0-349" class="i">+	extmap := epb.extensionsWrite()
</a><a href="#h27-0-350" id="h27-0-350" class="i">+	delete(extmap, extension.Field)
</a><a href="#h27-0-351" id="h27-0-351" class="i">+}
</a><a href="#h27-0-352" id="h27-0-352" class="i">+
</a><a href="#h27-0-353" id="h27-0-353" class="i">+// GetExtension parses and returns the given extension of pb.
</a><a href="#h27-0-354" id="h27-0-354" class="i">+// If the extension is not present and has no default value it returns ErrMissingExtension.
</a><a href="#h27-0-355" id="h27-0-355" class="i">+func GetExtension(pb Message, extension *ExtensionDesc) (interface{}, error) {
</a><a href="#h27-0-356" id="h27-0-356" class="i">+	epb, ok := extendable(pb)
</a><a href="#h27-0-357" id="h27-0-357" class="i">+	if !ok {
</a><a href="#h27-0-358" id="h27-0-358" class="i">+		return nil, errors.New(&quot;proto: not an extendable proto&quot;)
</a><a href="#h27-0-359" id="h27-0-359" class="i">+	}
</a><a href="#h27-0-360" id="h27-0-360" class="i">+
</a><a href="#h27-0-361" id="h27-0-361" class="i">+	if err := checkExtensionTypes(epb, extension); err != nil {
</a><a href="#h27-0-362" id="h27-0-362" class="i">+		return nil, err
</a><a href="#h27-0-363" id="h27-0-363" class="i">+	}
</a><a href="#h27-0-364" id="h27-0-364" class="i">+
</a><a href="#h27-0-365" id="h27-0-365" class="i">+	emap, mu := epb.extensionsRead()
</a><a href="#h27-0-366" id="h27-0-366" class="i">+	if emap == nil {
</a><a href="#h27-0-367" id="h27-0-367" class="i">+		return defaultExtensionValue(extension)
</a><a href="#h27-0-368" id="h27-0-368" class="i">+	}
</a><a href="#h27-0-369" id="h27-0-369" class="i">+	mu.Lock()
</a><a href="#h27-0-370" id="h27-0-370" class="i">+	defer mu.Unlock()
</a><a href="#h27-0-371" id="h27-0-371" class="i">+	e, ok := emap[extension.Field]
</a><a href="#h27-0-372" id="h27-0-372" class="i">+	if !ok {
</a><a href="#h27-0-373" id="h27-0-373" class="i">+		// defaultExtensionValue returns the default value or
</a><a href="#h27-0-374" id="h27-0-374" class="i">+		// ErrMissingExtension if there is no default.
</a><a href="#h27-0-375" id="h27-0-375" class="i">+		return defaultExtensionValue(extension)
</a><a href="#h27-0-376" id="h27-0-376" class="i">+	}
</a><a href="#h27-0-377" id="h27-0-377" class="i">+
</a><a href="#h27-0-378" id="h27-0-378" class="i">+	if e.value != nil {
</a><a href="#h27-0-379" id="h27-0-379" class="i">+		// Already decoded. Check the descriptor, though.
</a><a href="#h27-0-380" id="h27-0-380" class="i">+		if e.desc != extension {
</a><a href="#h27-0-381" id="h27-0-381" class="i">+			// This shouldn&#39;t happen. If it does, it means that
</a><a href="#h27-0-382" id="h27-0-382" class="i">+			// GetExtension was called twice with two different
</a><a href="#h27-0-383" id="h27-0-383" class="i">+			// descriptors with the same field number.
</a><a href="#h27-0-384" id="h27-0-384" class="i">+			return nil, errors.New(&quot;proto: descriptor conflict&quot;)
</a><a href="#h27-0-385" id="h27-0-385" class="i">+		}
</a><a href="#h27-0-386" id="h27-0-386" class="i">+		return e.value, nil
</a><a href="#h27-0-387" id="h27-0-387" class="i">+	}
</a><a href="#h27-0-388" id="h27-0-388" class="i">+
</a><a href="#h27-0-389" id="h27-0-389" class="i">+	v, err := decodeExtension(e.enc, extension)
</a><a href="#h27-0-390" id="h27-0-390" class="i">+	if err != nil {
</a><a href="#h27-0-391" id="h27-0-391" class="i">+		return nil, err
</a><a href="#h27-0-392" id="h27-0-392" class="i">+	}
</a><a href="#h27-0-393" id="h27-0-393" class="i">+
</a><a href="#h27-0-394" id="h27-0-394" class="i">+	// Remember the decoded version and drop the encoded version.
</a><a href="#h27-0-395" id="h27-0-395" class="i">+	// That way it is safe to mutate what we return.
</a><a href="#h27-0-396" id="h27-0-396" class="i">+	e.value = v
</a><a href="#h27-0-397" id="h27-0-397" class="i">+	e.desc = extension
</a><a href="#h27-0-398" id="h27-0-398" class="i">+	e.enc = nil
</a><a href="#h27-0-399" id="h27-0-399" class="i">+	emap[extension.Field] = e
</a><a href="#h27-0-400" id="h27-0-400" class="i">+	return e.value, nil
</a><a href="#h27-0-401" id="h27-0-401" class="i">+}
</a><a href="#h27-0-402" id="h27-0-402" class="i">+
</a><a href="#h27-0-403" id="h27-0-403" class="i">+// defaultExtensionValue returns the default value for extension.
</a><a href="#h27-0-404" id="h27-0-404" class="i">+// If no default for an extension is defined ErrMissingExtension is returned.
</a><a href="#h27-0-405" id="h27-0-405" class="i">+func defaultExtensionValue(extension *ExtensionDesc) (interface{}, error) {
</a><a href="#h27-0-406" id="h27-0-406" class="i">+	t := reflect.TypeOf(extension.ExtensionType)
</a><a href="#h27-0-407" id="h27-0-407" class="i">+	props := extensionProperties(extension)
</a><a href="#h27-0-408" id="h27-0-408" class="i">+
</a><a href="#h27-0-409" id="h27-0-409" class="i">+	sf, _, err := fieldDefault(t, props)
</a><a href="#h27-0-410" id="h27-0-410" class="i">+	if err != nil {
</a><a href="#h27-0-411" id="h27-0-411" class="i">+		return nil, err
</a><a href="#h27-0-412" id="h27-0-412" class="i">+	}
</a><a href="#h27-0-413" id="h27-0-413" class="i">+
</a><a href="#h27-0-414" id="h27-0-414" class="i">+	if sf == nil || sf.value == nil {
</a><a href="#h27-0-415" id="h27-0-415" class="i">+		// There is no default value.
</a><a href="#h27-0-416" id="h27-0-416" class="i">+		return nil, ErrMissingExtension
</a><a href="#h27-0-417" id="h27-0-417" class="i">+	}
</a><a href="#h27-0-418" id="h27-0-418" class="i">+
</a><a href="#h27-0-419" id="h27-0-419" class="i">+	if t.Kind() != reflect.Ptr {
</a><a href="#h27-0-420" id="h27-0-420" class="i">+		// We do not need to return a Ptr, we can directly return sf.value.
</a><a href="#h27-0-421" id="h27-0-421" class="i">+		return sf.value, nil
</a><a href="#h27-0-422" id="h27-0-422" class="i">+	}
</a><a href="#h27-0-423" id="h27-0-423" class="i">+
</a><a href="#h27-0-424" id="h27-0-424" class="i">+	// We need to return an interface{} that is a pointer to sf.value.
</a><a href="#h27-0-425" id="h27-0-425" class="i">+	value := reflect.New(t).Elem()
</a><a href="#h27-0-426" id="h27-0-426" class="i">+	value.Set(reflect.New(value.Type().Elem()))
</a><a href="#h27-0-427" id="h27-0-427" class="i">+	if sf.kind == reflect.Int32 {
</a><a href="#h27-0-428" id="h27-0-428" class="i">+		// We may have an int32 or an enum, but the underlying data is int32.
</a><a href="#h27-0-429" id="h27-0-429" class="i">+		// Since we can&#39;t set an int32 into a non int32 reflect.value directly
</a><a href="#h27-0-430" id="h27-0-430" class="i">+		// set it as a int32.
</a><a href="#h27-0-431" id="h27-0-431" class="i">+		value.Elem().SetInt(int64(sf.value.(int32)))
</a><a href="#h27-0-432" id="h27-0-432" class="i">+	} else {
</a><a href="#h27-0-433" id="h27-0-433" class="i">+		value.Elem().Set(reflect.ValueOf(sf.value))
</a><a href="#h27-0-434" id="h27-0-434" class="i">+	}
</a><a href="#h27-0-435" id="h27-0-435" class="i">+	return value.Interface(), nil
</a><a href="#h27-0-436" id="h27-0-436" class="i">+}
</a><a href="#h27-0-437" id="h27-0-437" class="i">+
</a><a href="#h27-0-438" id="h27-0-438" class="i">+// decodeExtension decodes an extension encoded in b.
</a><a href="#h27-0-439" id="h27-0-439" class="i">+func decodeExtension(b []byte, extension *ExtensionDesc) (interface{}, error) {
</a><a href="#h27-0-440" id="h27-0-440" class="i">+	o := NewBuffer(b)
</a><a href="#h27-0-441" id="h27-0-441" class="i">+
</a><a href="#h27-0-442" id="h27-0-442" class="i">+	t := reflect.TypeOf(extension.ExtensionType)
</a><a href="#h27-0-443" id="h27-0-443" class="i">+
</a><a href="#h27-0-444" id="h27-0-444" class="i">+	props := extensionProperties(extension)
</a><a href="#h27-0-445" id="h27-0-445" class="i">+
</a><a href="#h27-0-446" id="h27-0-446" class="i">+	// t is a pointer to a struct, pointer to basic type or a slice.
</a><a href="#h27-0-447" id="h27-0-447" class="i">+	// Allocate a &quot;field&quot; to store the pointer/slice itself; the
</a><a href="#h27-0-448" id="h27-0-448" class="i">+	// pointer/slice will be stored here. We pass
</a><a href="#h27-0-449" id="h27-0-449" class="i">+	// the address of this field to props.dec.
</a><a href="#h27-0-450" id="h27-0-450" class="i">+	// This passes a zero field and a *t and lets props.dec
</a><a href="#h27-0-451" id="h27-0-451" class="i">+	// interpret it as a *struct{ x t }.
</a><a href="#h27-0-452" id="h27-0-452" class="i">+	value := reflect.New(t).Elem()
</a><a href="#h27-0-453" id="h27-0-453" class="i">+
</a><a href="#h27-0-454" id="h27-0-454" class="i">+	for {
</a><a href="#h27-0-455" id="h27-0-455" class="i">+		// Discard wire type and field number varint. It isn&#39;t needed.
</a><a href="#h27-0-456" id="h27-0-456" class="i">+		if _, err := o.DecodeVarint(); err != nil {
</a><a href="#h27-0-457" id="h27-0-457" class="i">+			return nil, err
</a><a href="#h27-0-458" id="h27-0-458" class="i">+		}
</a><a href="#h27-0-459" id="h27-0-459" class="i">+
</a><a href="#h27-0-460" id="h27-0-460" class="i">+		if err := props.dec(o, props, toStructPointer(value.Addr())); err != nil {
</a><a href="#h27-0-461" id="h27-0-461" class="i">+			return nil, err
</a><a href="#h27-0-462" id="h27-0-462" class="i">+		}
</a><a href="#h27-0-463" id="h27-0-463" class="i">+
</a><a href="#h27-0-464" id="h27-0-464" class="i">+		if o.index &gt;= len(o.buf) {
</a><a href="#h27-0-465" id="h27-0-465" class="i">+			break
</a><a href="#h27-0-466" id="h27-0-466" class="i">+		}
</a><a href="#h27-0-467" id="h27-0-467" class="i">+	}
</a><a href="#h27-0-468" id="h27-0-468" class="i">+	return value.Interface(), nil
</a><a href="#h27-0-469" id="h27-0-469" class="i">+}
</a><a href="#h27-0-470" id="h27-0-470" class="i">+
</a><a href="#h27-0-471" id="h27-0-471" class="i">+// GetExtensions returns a slice of the extensions present in pb that are also listed in es.
</a><a href="#h27-0-472" id="h27-0-472" class="i">+// The returned slice has the same length as es; missing extensions will appear as nil elements.
</a><a href="#h27-0-473" id="h27-0-473" class="i">+func GetExtensions(pb Message, es []*ExtensionDesc) (extensions []interface{}, err error) {
</a><a href="#h27-0-474" id="h27-0-474" class="i">+	epb, ok := extendable(pb)
</a><a href="#h27-0-475" id="h27-0-475" class="i">+	if !ok {
</a><a href="#h27-0-476" id="h27-0-476" class="i">+		return nil, errors.New(&quot;proto: not an extendable proto&quot;)
</a><a href="#h27-0-477" id="h27-0-477" class="i">+	}
</a><a href="#h27-0-478" id="h27-0-478" class="i">+	extensions = make([]interface{}, len(es))
</a><a href="#h27-0-479" id="h27-0-479" class="i">+	for i, e := range es {
</a><a href="#h27-0-480" id="h27-0-480" class="i">+		extensions[i], err = GetExtension(epb, e)
</a><a href="#h27-0-481" id="h27-0-481" class="i">+		if err == ErrMissingExtension {
</a><a href="#h27-0-482" id="h27-0-482" class="i">+			err = nil
</a><a href="#h27-0-483" id="h27-0-483" class="i">+		}
</a><a href="#h27-0-484" id="h27-0-484" class="i">+		if err != nil {
</a><a href="#h27-0-485" id="h27-0-485" class="i">+			return
</a><a href="#h27-0-486" id="h27-0-486" class="i">+		}
</a><a href="#h27-0-487" id="h27-0-487" class="i">+	}
</a><a href="#h27-0-488" id="h27-0-488" class="i">+	return
</a><a href="#h27-0-489" id="h27-0-489" class="i">+}
</a><a href="#h27-0-490" id="h27-0-490" class="i">+
</a><a href="#h27-0-491" id="h27-0-491" class="i">+// ExtensionDescs returns a new slice containing pb&#39;s extension descriptors, in undefined order.
</a><a href="#h27-0-492" id="h27-0-492" class="i">+// For non-registered extensions, ExtensionDescs returns an incomplete descriptor containing
</a><a href="#h27-0-493" id="h27-0-493" class="i">+// just the Field field, which defines the extension&#39;s field number.
</a><a href="#h27-0-494" id="h27-0-494" class="i">+func ExtensionDescs(pb Message) ([]*ExtensionDesc, error) {
</a><a href="#h27-0-495" id="h27-0-495" class="i">+	epb, ok := extendable(pb)
</a><a href="#h27-0-496" id="h27-0-496" class="i">+	if !ok {
</a><a href="#h27-0-497" id="h27-0-497" class="i">+		return nil, fmt.Errorf(&quot;proto: %T is not an extendable proto.Message&quot;, pb)
</a><a href="#h27-0-498" id="h27-0-498" class="i">+	}
</a><a href="#h27-0-499" id="h27-0-499" class="i">+	registeredExtensions := RegisteredExtensions(pb)
</a><a href="#h27-0-500" id="h27-0-500" class="i">+
</a><a href="#h27-0-501" id="h27-0-501" class="i">+	emap, mu := epb.extensionsRead()
</a><a href="#h27-0-502" id="h27-0-502" class="i">+	if emap == nil {
</a><a href="#h27-0-503" id="h27-0-503" class="i">+		return nil, nil
</a><a href="#h27-0-504" id="h27-0-504" class="i">+	}
</a><a href="#h27-0-505" id="h27-0-505" class="i">+	mu.Lock()
</a><a href="#h27-0-506" id="h27-0-506" class="i">+	defer mu.Unlock()
</a><a href="#h27-0-507" id="h27-0-507" class="i">+	extensions := make([]*ExtensionDesc, 0, len(emap))
</a><a href="#h27-0-508" id="h27-0-508" class="i">+	for extid, e := range emap {
</a><a href="#h27-0-509" id="h27-0-509" class="i">+		desc := e.desc
</a><a href="#h27-0-510" id="h27-0-510" class="i">+		if desc == nil {
</a><a href="#h27-0-511" id="h27-0-511" class="i">+			desc = registeredExtensions[extid]
</a><a href="#h27-0-512" id="h27-0-512" class="i">+			if desc == nil {
</a><a href="#h27-0-513" id="h27-0-513" class="i">+				desc = &amp;ExtensionDesc{Field: extid}
</a><a href="#h27-0-514" id="h27-0-514" class="i">+			}
</a><a href="#h27-0-515" id="h27-0-515" class="i">+		}
</a><a href="#h27-0-516" id="h27-0-516" class="i">+
</a><a href="#h27-0-517" id="h27-0-517" class="i">+		extensions = append(extensions, desc)
</a><a href="#h27-0-518" id="h27-0-518" class="i">+	}
</a><a href="#h27-0-519" id="h27-0-519" class="i">+	return extensions, nil
</a><a href="#h27-0-520" id="h27-0-520" class="i">+}
</a><a href="#h27-0-521" id="h27-0-521" class="i">+
</a><a href="#h27-0-522" id="h27-0-522" class="i">+// SetExtension sets the specified extension of pb to the specified value.
</a><a href="#h27-0-523" id="h27-0-523" class="i">+func SetExtension(pb Message, extension *ExtensionDesc, value interface{}) error {
</a><a href="#h27-0-524" id="h27-0-524" class="i">+	epb, ok := extendable(pb)
</a><a href="#h27-0-525" id="h27-0-525" class="i">+	if !ok {
</a><a href="#h27-0-526" id="h27-0-526" class="i">+		return errors.New(&quot;proto: not an extendable proto&quot;)
</a><a href="#h27-0-527" id="h27-0-527" class="i">+	}
</a><a href="#h27-0-528" id="h27-0-528" class="i">+	if err := checkExtensionTypes(epb, extension); err != nil {
</a><a href="#h27-0-529" id="h27-0-529" class="i">+		return err
</a><a href="#h27-0-530" id="h27-0-530" class="i">+	}
</a><a href="#h27-0-531" id="h27-0-531" class="i">+	typ := reflect.TypeOf(extension.ExtensionType)
</a><a href="#h27-0-532" id="h27-0-532" class="i">+	if typ != reflect.TypeOf(value) {
</a><a href="#h27-0-533" id="h27-0-533" class="i">+		return errors.New(&quot;proto: bad extension value type&quot;)
</a><a href="#h27-0-534" id="h27-0-534" class="i">+	}
</a><a href="#h27-0-535" id="h27-0-535" class="i">+	// nil extension values need to be caught early, because the
</a><a href="#h27-0-536" id="h27-0-536" class="i">+	// encoder can&#39;t distinguish an ErrNil due to a nil extension
</a><a href="#h27-0-537" id="h27-0-537" class="i">+	// from an ErrNil due to a missing field. Extensions are
</a><a href="#h27-0-538" id="h27-0-538" class="i">+	// always optional, so the encoder would just swallow the error
</a><a href="#h27-0-539" id="h27-0-539" class="i">+	// and drop all the extensions from the encoded message.
</a><a href="#h27-0-540" id="h27-0-540" class="i">+	if reflect.ValueOf(value).IsNil() {
</a><a href="#h27-0-541" id="h27-0-541" class="i">+		return fmt.Errorf(&quot;proto: SetExtension called with nil value of type %T&quot;, value)
</a><a href="#h27-0-542" id="h27-0-542" class="i">+	}
</a><a href="#h27-0-543" id="h27-0-543" class="i">+
</a><a href="#h27-0-544" id="h27-0-544" class="i">+	extmap := epb.extensionsWrite()
</a><a href="#h27-0-545" id="h27-0-545" class="i">+	extmap[extension.Field] = Extension{desc: extension, value: value}
</a><a href="#h27-0-546" id="h27-0-546" class="i">+	return nil
</a><a href="#h27-0-547" id="h27-0-547" class="i">+}
</a><a href="#h27-0-548" id="h27-0-548" class="i">+
</a><a href="#h27-0-549" id="h27-0-549" class="i">+// ClearAllExtensions clears all extensions from pb.
</a><a href="#h27-0-550" id="h27-0-550" class="i">+func ClearAllExtensions(pb Message) {
</a><a href="#h27-0-551" id="h27-0-551" class="i">+	epb, ok := extendable(pb)
</a><a href="#h27-0-552" id="h27-0-552" class="i">+	if !ok {
</a><a href="#h27-0-553" id="h27-0-553" class="i">+		return
</a><a href="#h27-0-554" id="h27-0-554" class="i">+	}
</a><a href="#h27-0-555" id="h27-0-555" class="i">+	m := epb.extensionsWrite()
</a><a href="#h27-0-556" id="h27-0-556" class="i">+	for k := range m {
</a><a href="#h27-0-557" id="h27-0-557" class="i">+		delete(m, k)
</a><a href="#h27-0-558" id="h27-0-558" class="i">+	}
</a><a href="#h27-0-559" id="h27-0-559" class="i">+}
</a><a href="#h27-0-560" id="h27-0-560" class="i">+
</a><a href="#h27-0-561" id="h27-0-561" class="i">+// A global registry of extensions.
</a><a href="#h27-0-562" id="h27-0-562" class="i">+// The generated code will register the generated descriptors by calling RegisterExtension.
</a><a href="#h27-0-563" id="h27-0-563" class="i">+
</a><a href="#h27-0-564" id="h27-0-564" class="i">+var extensionMaps = make(map[reflect.Type]map[int32]*ExtensionDesc)
</a><a href="#h27-0-565" id="h27-0-565" class="i">+
</a><a href="#h27-0-566" id="h27-0-566" class="i">+// RegisterExtension is called from the generated code.
</a><a href="#h27-0-567" id="h27-0-567" class="i">+func RegisterExtension(desc *ExtensionDesc) {
</a><a href="#h27-0-568" id="h27-0-568" class="i">+	st := reflect.TypeOf(desc.ExtendedType).Elem()
</a><a href="#h27-0-569" id="h27-0-569" class="i">+	m := extensionMaps[st]
</a><a href="#h27-0-570" id="h27-0-570" class="i">+	if m == nil {
</a><a href="#h27-0-571" id="h27-0-571" class="i">+		m = make(map[int32]*ExtensionDesc)
</a><a href="#h27-0-572" id="h27-0-572" class="i">+		extensionMaps[st] = m
</a><a href="#h27-0-573" id="h27-0-573" class="i">+	}
</a><a href="#h27-0-574" id="h27-0-574" class="i">+	if _, ok := m[desc.Field]; ok {
</a><a href="#h27-0-575" id="h27-0-575" class="i">+		panic(&quot;proto: duplicate extension registered: &quot; + st.String() + &quot; &quot; + strconv.Itoa(int(desc.Field)))
</a><a href="#h27-0-576" id="h27-0-576" class="i">+	}
</a><a href="#h27-0-577" id="h27-0-577" class="i">+	m[desc.Field] = desc
</a><a href="#h27-0-578" id="h27-0-578" class="i">+}
</a><a href="#h27-0-579" id="h27-0-579" class="i">+
</a><a href="#h27-0-580" id="h27-0-580" class="i">+// RegisteredExtensions returns a map of the registered extensions of a
</a><a href="#h27-0-581" id="h27-0-581" class="i">+// protocol buffer struct, indexed by the extension number.
</a><a href="#h27-0-582" id="h27-0-582" class="i">+// The argument pb should be a nil pointer to the struct type.
</a><a href="#h27-0-583" id="h27-0-583" class="i">+func RegisteredExtensions(pb Message) map[int32]*ExtensionDesc {
</a><a href="#h27-0-584" id="h27-0-584" class="i">+	return extensionMaps[reflect.TypeOf(pb).Elem()]
</a><a href="#h27-0-585" id="h27-0-585" class="i">+}
</a><b>diff --git a/<a id="h28" href="../file/vendor/github.com/golang/protobuf/proto/lib.go">vendor/github.com/golang/protobuf/proto/lib.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/lib.go">vendor/github.com/golang/protobuf/proto/lib.go</a></b>
<a href="#h28-0" id="h28-0" class="h">@@ -0,0 +1,898 @@
</a><a href="#h28-0-0" id="h28-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h28-0-1" id="h28-0-1" class="i">+//
</a><a href="#h28-0-2" id="h28-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h28-0-3" id="h28-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h28-0-4" id="h28-0-4" class="i">+//
</a><a href="#h28-0-5" id="h28-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h28-0-6" id="h28-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h28-0-7" id="h28-0-7" class="i">+// met:
</a><a href="#h28-0-8" id="h28-0-8" class="i">+//
</a><a href="#h28-0-9" id="h28-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h28-0-10" id="h28-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h28-0-11" id="h28-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h28-0-12" id="h28-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h28-0-13" id="h28-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h28-0-14" id="h28-0-14" class="i">+// distribution.
</a><a href="#h28-0-15" id="h28-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h28-0-16" id="h28-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h28-0-17" id="h28-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h28-0-18" id="h28-0-18" class="i">+//
</a><a href="#h28-0-19" id="h28-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h28-0-20" id="h28-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h28-0-21" id="h28-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h28-0-22" id="h28-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h28-0-23" id="h28-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h28-0-24" id="h28-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h28-0-25" id="h28-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h28-0-26" id="h28-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h28-0-27" id="h28-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h28-0-28" id="h28-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h28-0-29" id="h28-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h28-0-30" id="h28-0-30" class="i">+
</a><a href="#h28-0-31" id="h28-0-31" class="i">+/*
</a><a href="#h28-0-32" id="h28-0-32" class="i">+Package proto converts data structures to and from the wire format of
</a><a href="#h28-0-33" id="h28-0-33" class="i">+protocol buffers.  It works in concert with the Go source code generated
</a><a href="#h28-0-34" id="h28-0-34" class="i">+for .proto files by the protocol compiler.
</a><a href="#h28-0-35" id="h28-0-35" class="i">+
</a><a href="#h28-0-36" id="h28-0-36" class="i">+A summary of the properties of the protocol buffer interface
</a><a href="#h28-0-37" id="h28-0-37" class="i">+for a protocol buffer variable v:
</a><a href="#h28-0-38" id="h28-0-38" class="i">+
</a><a href="#h28-0-39" id="h28-0-39" class="i">+  - Names are turned from camel_case to CamelCase for export.
</a><a href="#h28-0-40" id="h28-0-40" class="i">+  - There are no methods on v to set fields; just treat
</a><a href="#h28-0-41" id="h28-0-41" class="i">+	them as structure fields.
</a><a href="#h28-0-42" id="h28-0-42" class="i">+  - There are getters that return a field&#39;s value if set,
</a><a href="#h28-0-43" id="h28-0-43" class="i">+	and return the field&#39;s default value if unset.
</a><a href="#h28-0-44" id="h28-0-44" class="i">+	The getters work even if the receiver is a nil message.
</a><a href="#h28-0-45" id="h28-0-45" class="i">+  - The zero value for a struct is its correct initialization state.
</a><a href="#h28-0-46" id="h28-0-46" class="i">+	All desired fields must be set before marshaling.
</a><a href="#h28-0-47" id="h28-0-47" class="i">+  - A Reset() method will restore a protobuf struct to its zero state.
</a><a href="#h28-0-48" id="h28-0-48" class="i">+  - Non-repeated fields are pointers to the values; nil means unset.
</a><a href="#h28-0-49" id="h28-0-49" class="i">+	That is, optional or required field int32 f becomes F *int32.
</a><a href="#h28-0-50" id="h28-0-50" class="i">+  - Repeated fields are slices.
</a><a href="#h28-0-51" id="h28-0-51" class="i">+  - Helper functions are available to aid the setting of fields.
</a><a href="#h28-0-52" id="h28-0-52" class="i">+	msg.Foo = proto.String(&quot;hello&quot;) // set field
</a><a href="#h28-0-53" id="h28-0-53" class="i">+  - Constants are defined to hold the default values of all fields that
</a><a href="#h28-0-54" id="h28-0-54" class="i">+	have them.  They have the form Default_StructName_FieldName.
</a><a href="#h28-0-55" id="h28-0-55" class="i">+	Because the getter methods handle defaulted values,
</a><a href="#h28-0-56" id="h28-0-56" class="i">+	direct use of these constants should be rare.
</a><a href="#h28-0-57" id="h28-0-57" class="i">+  - Enums are given type names and maps from names to values.
</a><a href="#h28-0-58" id="h28-0-58" class="i">+	Enum values are prefixed by the enclosing message&#39;s name, or by the
</a><a href="#h28-0-59" id="h28-0-59" class="i">+	enum&#39;s type name if it is a top-level enum. Enum types have a String
</a><a href="#h28-0-60" id="h28-0-60" class="i">+	method, and a Enum method to assist in message construction.
</a><a href="#h28-0-61" id="h28-0-61" class="i">+  - Nested messages, groups and enums have type names prefixed with the name of
</a><a href="#h28-0-62" id="h28-0-62" class="i">+	the surrounding message type.
</a><a href="#h28-0-63" id="h28-0-63" class="i">+  - Extensions are given descriptor names that start with E_,
</a><a href="#h28-0-64" id="h28-0-64" class="i">+	followed by an underscore-delimited list of the nested messages
</a><a href="#h28-0-65" id="h28-0-65" class="i">+	that contain it (if any) followed by the CamelCased name of the
</a><a href="#h28-0-66" id="h28-0-66" class="i">+	extension field itself.  HasExtension, ClearExtension, GetExtension
</a><a href="#h28-0-67" id="h28-0-67" class="i">+	and SetExtension are functions for manipulating extensions.
</a><a href="#h28-0-68" id="h28-0-68" class="i">+  - Oneof field sets are given a single field in their message,
</a><a href="#h28-0-69" id="h28-0-69" class="i">+	with distinguished wrapper types for each possible field value.
</a><a href="#h28-0-70" id="h28-0-70" class="i">+  - Marshal and Unmarshal are functions to encode and decode the wire format.
</a><a href="#h28-0-71" id="h28-0-71" class="i">+
</a><a href="#h28-0-72" id="h28-0-72" class="i">+When the .proto file specifies `syntax=&quot;proto3&quot;`, there are some differences:
</a><a href="#h28-0-73" id="h28-0-73" class="i">+
</a><a href="#h28-0-74" id="h28-0-74" class="i">+  - Non-repeated fields of non-message type are values instead of pointers.
</a><a href="#h28-0-75" id="h28-0-75" class="i">+  - Getters are only generated for message and oneof fields.
</a><a href="#h28-0-76" id="h28-0-76" class="i">+  - Enum types do not get an Enum method.
</a><a href="#h28-0-77" id="h28-0-77" class="i">+
</a><a href="#h28-0-78" id="h28-0-78" class="i">+The simplest way to describe this is to see an example.
</a><a href="#h28-0-79" id="h28-0-79" class="i">+Given file test.proto, containing
</a><a href="#h28-0-80" id="h28-0-80" class="i">+
</a><a href="#h28-0-81" id="h28-0-81" class="i">+	package example;
</a><a href="#h28-0-82" id="h28-0-82" class="i">+
</a><a href="#h28-0-83" id="h28-0-83" class="i">+	enum FOO { X = 17; }
</a><a href="#h28-0-84" id="h28-0-84" class="i">+
</a><a href="#h28-0-85" id="h28-0-85" class="i">+	message Test {
</a><a href="#h28-0-86" id="h28-0-86" class="i">+	  required string label = 1;
</a><a href="#h28-0-87" id="h28-0-87" class="i">+	  optional int32 type = 2 [default=77];
</a><a href="#h28-0-88" id="h28-0-88" class="i">+	  repeated int64 reps = 3;
</a><a href="#h28-0-89" id="h28-0-89" class="i">+	  optional group OptionalGroup = 4 {
</a><a href="#h28-0-90" id="h28-0-90" class="i">+	    required string RequiredField = 5;
</a><a href="#h28-0-91" id="h28-0-91" class="i">+	  }
</a><a href="#h28-0-92" id="h28-0-92" class="i">+	  oneof union {
</a><a href="#h28-0-93" id="h28-0-93" class="i">+	    int32 number = 6;
</a><a href="#h28-0-94" id="h28-0-94" class="i">+	    string name = 7;
</a><a href="#h28-0-95" id="h28-0-95" class="i">+	  }
</a><a href="#h28-0-96" id="h28-0-96" class="i">+	}
</a><a href="#h28-0-97" id="h28-0-97" class="i">+
</a><a href="#h28-0-98" id="h28-0-98" class="i">+The resulting file, test.pb.go, is:
</a><a href="#h28-0-99" id="h28-0-99" class="i">+
</a><a href="#h28-0-100" id="h28-0-100" class="i">+	package example
</a><a href="#h28-0-101" id="h28-0-101" class="i">+
</a><a href="#h28-0-102" id="h28-0-102" class="i">+	import proto &quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h28-0-103" id="h28-0-103" class="i">+	import math &quot;math&quot;
</a><a href="#h28-0-104" id="h28-0-104" class="i">+
</a><a href="#h28-0-105" id="h28-0-105" class="i">+	type FOO int32
</a><a href="#h28-0-106" id="h28-0-106" class="i">+	const (
</a><a href="#h28-0-107" id="h28-0-107" class="i">+		FOO_X FOO = 17
</a><a href="#h28-0-108" id="h28-0-108" class="i">+	)
</a><a href="#h28-0-109" id="h28-0-109" class="i">+	var FOO_name = map[int32]string{
</a><a href="#h28-0-110" id="h28-0-110" class="i">+		17: &quot;X&quot;,
</a><a href="#h28-0-111" id="h28-0-111" class="i">+	}
</a><a href="#h28-0-112" id="h28-0-112" class="i">+	var FOO_value = map[string]int32{
</a><a href="#h28-0-113" id="h28-0-113" class="i">+		&quot;X&quot;: 17,
</a><a href="#h28-0-114" id="h28-0-114" class="i">+	}
</a><a href="#h28-0-115" id="h28-0-115" class="i">+
</a><a href="#h28-0-116" id="h28-0-116" class="i">+	func (x FOO) Enum() *FOO {
</a><a href="#h28-0-117" id="h28-0-117" class="i">+		p := new(FOO)
</a><a href="#h28-0-118" id="h28-0-118" class="i">+		*p = x
</a><a href="#h28-0-119" id="h28-0-119" class="i">+		return p
</a><a href="#h28-0-120" id="h28-0-120" class="i">+	}
</a><a href="#h28-0-121" id="h28-0-121" class="i">+	func (x FOO) String() string {
</a><a href="#h28-0-122" id="h28-0-122" class="i">+		return proto.EnumName(FOO_name, int32(x))
</a><a href="#h28-0-123" id="h28-0-123" class="i">+	}
</a><a href="#h28-0-124" id="h28-0-124" class="i">+	func (x *FOO) UnmarshalJSON(data []byte) error {
</a><a href="#h28-0-125" id="h28-0-125" class="i">+		value, err := proto.UnmarshalJSONEnum(FOO_value, data)
</a><a href="#h28-0-126" id="h28-0-126" class="i">+		if err != nil {
</a><a href="#h28-0-127" id="h28-0-127" class="i">+			return err
</a><a href="#h28-0-128" id="h28-0-128" class="i">+		}
</a><a href="#h28-0-129" id="h28-0-129" class="i">+		*x = FOO(value)
</a><a href="#h28-0-130" id="h28-0-130" class="i">+		return nil
</a><a href="#h28-0-131" id="h28-0-131" class="i">+	}
</a><a href="#h28-0-132" id="h28-0-132" class="i">+
</a><a href="#h28-0-133" id="h28-0-133" class="i">+	type Test struct {
</a><a href="#h28-0-134" id="h28-0-134" class="i">+		Label         *string             `protobuf:&quot;bytes,1,req,name=label&quot; json:&quot;label,omitempty&quot;`
</a><a href="#h28-0-135" id="h28-0-135" class="i">+		Type          *int32              `protobuf:&quot;varint,2,opt,name=type,def=77&quot; json:&quot;type,omitempty&quot;`
</a><a href="#h28-0-136" id="h28-0-136" class="i">+		Reps          []int64             `protobuf:&quot;varint,3,rep,name=reps&quot; json:&quot;reps,omitempty&quot;`
</a><a href="#h28-0-137" id="h28-0-137" class="i">+		Optionalgroup *Test_OptionalGroup `protobuf:&quot;group,4,opt,name=OptionalGroup&quot; json:&quot;optionalgroup,omitempty&quot;`
</a><a href="#h28-0-138" id="h28-0-138" class="i">+		// Types that are valid to be assigned to Union:
</a><a href="#h28-0-139" id="h28-0-139" class="i">+		//	*Test_Number
</a><a href="#h28-0-140" id="h28-0-140" class="i">+		//	*Test_Name
</a><a href="#h28-0-141" id="h28-0-141" class="i">+		Union            isTest_Union `protobuf_oneof:&quot;union&quot;`
</a><a href="#h28-0-142" id="h28-0-142" class="i">+		XXX_unrecognized []byte       `json:&quot;-&quot;`
</a><a href="#h28-0-143" id="h28-0-143" class="i">+	}
</a><a href="#h28-0-144" id="h28-0-144" class="i">+	func (m *Test) Reset()         { *m = Test{} }
</a><a href="#h28-0-145" id="h28-0-145" class="i">+	func (m *Test) String() string { return proto.CompactTextString(m) }
</a><a href="#h28-0-146" id="h28-0-146" class="i">+	func (*Test) ProtoMessage() {}
</a><a href="#h28-0-147" id="h28-0-147" class="i">+
</a><a href="#h28-0-148" id="h28-0-148" class="i">+	type isTest_Union interface {
</a><a href="#h28-0-149" id="h28-0-149" class="i">+		isTest_Union()
</a><a href="#h28-0-150" id="h28-0-150" class="i">+	}
</a><a href="#h28-0-151" id="h28-0-151" class="i">+
</a><a href="#h28-0-152" id="h28-0-152" class="i">+	type Test_Number struct {
</a><a href="#h28-0-153" id="h28-0-153" class="i">+		Number int32 `protobuf:&quot;varint,6,opt,name=number&quot;`
</a><a href="#h28-0-154" id="h28-0-154" class="i">+	}
</a><a href="#h28-0-155" id="h28-0-155" class="i">+	type Test_Name struct {
</a><a href="#h28-0-156" id="h28-0-156" class="i">+		Name string `protobuf:&quot;bytes,7,opt,name=name&quot;`
</a><a href="#h28-0-157" id="h28-0-157" class="i">+	}
</a><a href="#h28-0-158" id="h28-0-158" class="i">+
</a><a href="#h28-0-159" id="h28-0-159" class="i">+	func (*Test_Number) isTest_Union() {}
</a><a href="#h28-0-160" id="h28-0-160" class="i">+	func (*Test_Name) isTest_Union()   {}
</a><a href="#h28-0-161" id="h28-0-161" class="i">+
</a><a href="#h28-0-162" id="h28-0-162" class="i">+	func (m *Test) GetUnion() isTest_Union {
</a><a href="#h28-0-163" id="h28-0-163" class="i">+		if m != nil {
</a><a href="#h28-0-164" id="h28-0-164" class="i">+			return m.Union
</a><a href="#h28-0-165" id="h28-0-165" class="i">+		}
</a><a href="#h28-0-166" id="h28-0-166" class="i">+		return nil
</a><a href="#h28-0-167" id="h28-0-167" class="i">+	}
</a><a href="#h28-0-168" id="h28-0-168" class="i">+	const Default_Test_Type int32 = 77
</a><a href="#h28-0-169" id="h28-0-169" class="i">+
</a><a href="#h28-0-170" id="h28-0-170" class="i">+	func (m *Test) GetLabel() string {
</a><a href="#h28-0-171" id="h28-0-171" class="i">+		if m != nil &amp;&amp; m.Label != nil {
</a><a href="#h28-0-172" id="h28-0-172" class="i">+			return *m.Label
</a><a href="#h28-0-173" id="h28-0-173" class="i">+		}
</a><a href="#h28-0-174" id="h28-0-174" class="i">+		return &quot;&quot;
</a><a href="#h28-0-175" id="h28-0-175" class="i">+	}
</a><a href="#h28-0-176" id="h28-0-176" class="i">+
</a><a href="#h28-0-177" id="h28-0-177" class="i">+	func (m *Test) GetType() int32 {
</a><a href="#h28-0-178" id="h28-0-178" class="i">+		if m != nil &amp;&amp; m.Type != nil {
</a><a href="#h28-0-179" id="h28-0-179" class="i">+			return *m.Type
</a><a href="#h28-0-180" id="h28-0-180" class="i">+		}
</a><a href="#h28-0-181" id="h28-0-181" class="i">+		return Default_Test_Type
</a><a href="#h28-0-182" id="h28-0-182" class="i">+	}
</a><a href="#h28-0-183" id="h28-0-183" class="i">+
</a><a href="#h28-0-184" id="h28-0-184" class="i">+	func (m *Test) GetOptionalgroup() *Test_OptionalGroup {
</a><a href="#h28-0-185" id="h28-0-185" class="i">+		if m != nil {
</a><a href="#h28-0-186" id="h28-0-186" class="i">+			return m.Optionalgroup
</a><a href="#h28-0-187" id="h28-0-187" class="i">+		}
</a><a href="#h28-0-188" id="h28-0-188" class="i">+		return nil
</a><a href="#h28-0-189" id="h28-0-189" class="i">+	}
</a><a href="#h28-0-190" id="h28-0-190" class="i">+
</a><a href="#h28-0-191" id="h28-0-191" class="i">+	type Test_OptionalGroup struct {
</a><a href="#h28-0-192" id="h28-0-192" class="i">+		RequiredField *string `protobuf:&quot;bytes,5,req&quot; json:&quot;RequiredField,omitempty&quot;`
</a><a href="#h28-0-193" id="h28-0-193" class="i">+	}
</a><a href="#h28-0-194" id="h28-0-194" class="i">+	func (m *Test_OptionalGroup) Reset()         { *m = Test_OptionalGroup{} }
</a><a href="#h28-0-195" id="h28-0-195" class="i">+	func (m *Test_OptionalGroup) String() string { return proto.CompactTextString(m) }
</a><a href="#h28-0-196" id="h28-0-196" class="i">+
</a><a href="#h28-0-197" id="h28-0-197" class="i">+	func (m *Test_OptionalGroup) GetRequiredField() string {
</a><a href="#h28-0-198" id="h28-0-198" class="i">+		if m != nil &amp;&amp; m.RequiredField != nil {
</a><a href="#h28-0-199" id="h28-0-199" class="i">+			return *m.RequiredField
</a><a href="#h28-0-200" id="h28-0-200" class="i">+		}
</a><a href="#h28-0-201" id="h28-0-201" class="i">+		return &quot;&quot;
</a><a href="#h28-0-202" id="h28-0-202" class="i">+	}
</a><a href="#h28-0-203" id="h28-0-203" class="i">+
</a><a href="#h28-0-204" id="h28-0-204" class="i">+	func (m *Test) GetNumber() int32 {
</a><a href="#h28-0-205" id="h28-0-205" class="i">+		if x, ok := m.GetUnion().(*Test_Number); ok {
</a><a href="#h28-0-206" id="h28-0-206" class="i">+			return x.Number
</a><a href="#h28-0-207" id="h28-0-207" class="i">+		}
</a><a href="#h28-0-208" id="h28-0-208" class="i">+		return 0
</a><a href="#h28-0-209" id="h28-0-209" class="i">+	}
</a><a href="#h28-0-210" id="h28-0-210" class="i">+
</a><a href="#h28-0-211" id="h28-0-211" class="i">+	func (m *Test) GetName() string {
</a><a href="#h28-0-212" id="h28-0-212" class="i">+		if x, ok := m.GetUnion().(*Test_Name); ok {
</a><a href="#h28-0-213" id="h28-0-213" class="i">+			return x.Name
</a><a href="#h28-0-214" id="h28-0-214" class="i">+		}
</a><a href="#h28-0-215" id="h28-0-215" class="i">+		return &quot;&quot;
</a><a href="#h28-0-216" id="h28-0-216" class="i">+	}
</a><a href="#h28-0-217" id="h28-0-217" class="i">+
</a><a href="#h28-0-218" id="h28-0-218" class="i">+	func init() {
</a><a href="#h28-0-219" id="h28-0-219" class="i">+		proto.RegisterEnum(&quot;example.FOO&quot;, FOO_name, FOO_value)
</a><a href="#h28-0-220" id="h28-0-220" class="i">+	}
</a><a href="#h28-0-221" id="h28-0-221" class="i">+
</a><a href="#h28-0-222" id="h28-0-222" class="i">+To create and play with a Test object:
</a><a href="#h28-0-223" id="h28-0-223" class="i">+
</a><a href="#h28-0-224" id="h28-0-224" class="i">+	package main
</a><a href="#h28-0-225" id="h28-0-225" class="i">+
</a><a href="#h28-0-226" id="h28-0-226" class="i">+	import (
</a><a href="#h28-0-227" id="h28-0-227" class="i">+		&quot;log&quot;
</a><a href="#h28-0-228" id="h28-0-228" class="i">+
</a><a href="#h28-0-229" id="h28-0-229" class="i">+		&quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h28-0-230" id="h28-0-230" class="i">+		pb &quot;./example.pb&quot;
</a><a href="#h28-0-231" id="h28-0-231" class="i">+	)
</a><a href="#h28-0-232" id="h28-0-232" class="i">+
</a><a href="#h28-0-233" id="h28-0-233" class="i">+	func main() {
</a><a href="#h28-0-234" id="h28-0-234" class="i">+		test := &amp;pb.Test{
</a><a href="#h28-0-235" id="h28-0-235" class="i">+			Label: proto.String(&quot;hello&quot;),
</a><a href="#h28-0-236" id="h28-0-236" class="i">+			Type:  proto.Int32(17),
</a><a href="#h28-0-237" id="h28-0-237" class="i">+			Reps:  []int64{1, 2, 3},
</a><a href="#h28-0-238" id="h28-0-238" class="i">+			Optionalgroup: &amp;pb.Test_OptionalGroup{
</a><a href="#h28-0-239" id="h28-0-239" class="i">+				RequiredField: proto.String(&quot;good bye&quot;),
</a><a href="#h28-0-240" id="h28-0-240" class="i">+			},
</a><a href="#h28-0-241" id="h28-0-241" class="i">+			Union: &amp;pb.Test_Name{&quot;fred&quot;},
</a><a href="#h28-0-242" id="h28-0-242" class="i">+		}
</a><a href="#h28-0-243" id="h28-0-243" class="i">+		data, err := proto.Marshal(test)
</a><a href="#h28-0-244" id="h28-0-244" class="i">+		if err != nil {
</a><a href="#h28-0-245" id="h28-0-245" class="i">+			log.Fatal(&quot;marshaling error: &quot;, err)
</a><a href="#h28-0-246" id="h28-0-246" class="i">+		}
</a><a href="#h28-0-247" id="h28-0-247" class="i">+		newTest := &amp;pb.Test{}
</a><a href="#h28-0-248" id="h28-0-248" class="i">+		err = proto.Unmarshal(data, newTest)
</a><a href="#h28-0-249" id="h28-0-249" class="i">+		if err != nil {
</a><a href="#h28-0-250" id="h28-0-250" class="i">+			log.Fatal(&quot;unmarshaling error: &quot;, err)
</a><a href="#h28-0-251" id="h28-0-251" class="i">+		}
</a><a href="#h28-0-252" id="h28-0-252" class="i">+		// Now test and newTest contain the same data.
</a><a href="#h28-0-253" id="h28-0-253" class="i">+		if test.GetLabel() != newTest.GetLabel() {
</a><a href="#h28-0-254" id="h28-0-254" class="i">+			log.Fatalf(&quot;data mismatch %q != %q&quot;, test.GetLabel(), newTest.GetLabel())
</a><a href="#h28-0-255" id="h28-0-255" class="i">+		}
</a><a href="#h28-0-256" id="h28-0-256" class="i">+		// Use a type switch to determine which oneof was set.
</a><a href="#h28-0-257" id="h28-0-257" class="i">+		switch u := test.Union.(type) {
</a><a href="#h28-0-258" id="h28-0-258" class="i">+		case *pb.Test_Number: // u.Number contains the number.
</a><a href="#h28-0-259" id="h28-0-259" class="i">+		case *pb.Test_Name: // u.Name contains the string.
</a><a href="#h28-0-260" id="h28-0-260" class="i">+		}
</a><a href="#h28-0-261" id="h28-0-261" class="i">+		// etc.
</a><a href="#h28-0-262" id="h28-0-262" class="i">+	}
</a><a href="#h28-0-263" id="h28-0-263" class="i">+*/
</a><a href="#h28-0-264" id="h28-0-264" class="i">+package proto
</a><a href="#h28-0-265" id="h28-0-265" class="i">+
</a><a href="#h28-0-266" id="h28-0-266" class="i">+import (
</a><a href="#h28-0-267" id="h28-0-267" class="i">+	&quot;encoding/json&quot;
</a><a href="#h28-0-268" id="h28-0-268" class="i">+	&quot;fmt&quot;
</a><a href="#h28-0-269" id="h28-0-269" class="i">+	&quot;log&quot;
</a><a href="#h28-0-270" id="h28-0-270" class="i">+	&quot;reflect&quot;
</a><a href="#h28-0-271" id="h28-0-271" class="i">+	&quot;sort&quot;
</a><a href="#h28-0-272" id="h28-0-272" class="i">+	&quot;strconv&quot;
</a><a href="#h28-0-273" id="h28-0-273" class="i">+	&quot;sync&quot;
</a><a href="#h28-0-274" id="h28-0-274" class="i">+)
</a><a href="#h28-0-275" id="h28-0-275" class="i">+
</a><a href="#h28-0-276" id="h28-0-276" class="i">+// Message is implemented by generated protocol buffer messages.
</a><a href="#h28-0-277" id="h28-0-277" class="i">+type Message interface {
</a><a href="#h28-0-278" id="h28-0-278" class="i">+	Reset()
</a><a href="#h28-0-279" id="h28-0-279" class="i">+	String() string
</a><a href="#h28-0-280" id="h28-0-280" class="i">+	ProtoMessage()
</a><a href="#h28-0-281" id="h28-0-281" class="i">+}
</a><a href="#h28-0-282" id="h28-0-282" class="i">+
</a><a href="#h28-0-283" id="h28-0-283" class="i">+// Stats records allocation details about the protocol buffer encoders
</a><a href="#h28-0-284" id="h28-0-284" class="i">+// and decoders.  Useful for tuning the library itself.
</a><a href="#h28-0-285" id="h28-0-285" class="i">+type Stats struct {
</a><a href="#h28-0-286" id="h28-0-286" class="i">+	Emalloc uint64 // mallocs in encode
</a><a href="#h28-0-287" id="h28-0-287" class="i">+	Dmalloc uint64 // mallocs in decode
</a><a href="#h28-0-288" id="h28-0-288" class="i">+	Encode  uint64 // number of encodes
</a><a href="#h28-0-289" id="h28-0-289" class="i">+	Decode  uint64 // number of decodes
</a><a href="#h28-0-290" id="h28-0-290" class="i">+	Chit    uint64 // number of cache hits
</a><a href="#h28-0-291" id="h28-0-291" class="i">+	Cmiss   uint64 // number of cache misses
</a><a href="#h28-0-292" id="h28-0-292" class="i">+	Size    uint64 // number of sizes
</a><a href="#h28-0-293" id="h28-0-293" class="i">+}
</a><a href="#h28-0-294" id="h28-0-294" class="i">+
</a><a href="#h28-0-295" id="h28-0-295" class="i">+// Set to true to enable stats collection.
</a><a href="#h28-0-296" id="h28-0-296" class="i">+const collectStats = false
</a><a href="#h28-0-297" id="h28-0-297" class="i">+
</a><a href="#h28-0-298" id="h28-0-298" class="i">+var stats Stats
</a><a href="#h28-0-299" id="h28-0-299" class="i">+
</a><a href="#h28-0-300" id="h28-0-300" class="i">+// GetStats returns a copy of the global Stats structure.
</a><a href="#h28-0-301" id="h28-0-301" class="i">+func GetStats() Stats { return stats }
</a><a href="#h28-0-302" id="h28-0-302" class="i">+
</a><a href="#h28-0-303" id="h28-0-303" class="i">+// A Buffer is a buffer manager for marshaling and unmarshaling
</a><a href="#h28-0-304" id="h28-0-304" class="i">+// protocol buffers.  It may be reused between invocations to
</a><a href="#h28-0-305" id="h28-0-305" class="i">+// reduce memory usage.  It is not necessary to use a Buffer;
</a><a href="#h28-0-306" id="h28-0-306" class="i">+// the global functions Marshal and Unmarshal create a
</a><a href="#h28-0-307" id="h28-0-307" class="i">+// temporary Buffer and are fine for most applications.
</a><a href="#h28-0-308" id="h28-0-308" class="i">+type Buffer struct {
</a><a href="#h28-0-309" id="h28-0-309" class="i">+	buf   []byte // encode/decode byte stream
</a><a href="#h28-0-310" id="h28-0-310" class="i">+	index int    // read point
</a><a href="#h28-0-311" id="h28-0-311" class="i">+
</a><a href="#h28-0-312" id="h28-0-312" class="i">+	// pools of basic types to amortize allocation.
</a><a href="#h28-0-313" id="h28-0-313" class="i">+	bools   []bool
</a><a href="#h28-0-314" id="h28-0-314" class="i">+	uint32s []uint32
</a><a href="#h28-0-315" id="h28-0-315" class="i">+	uint64s []uint64
</a><a href="#h28-0-316" id="h28-0-316" class="i">+
</a><a href="#h28-0-317" id="h28-0-317" class="i">+	// extra pools, only used with pointer_reflect.go
</a><a href="#h28-0-318" id="h28-0-318" class="i">+	int32s   []int32
</a><a href="#h28-0-319" id="h28-0-319" class="i">+	int64s   []int64
</a><a href="#h28-0-320" id="h28-0-320" class="i">+	float32s []float32
</a><a href="#h28-0-321" id="h28-0-321" class="i">+	float64s []float64
</a><a href="#h28-0-322" id="h28-0-322" class="i">+}
</a><a href="#h28-0-323" id="h28-0-323" class="i">+
</a><a href="#h28-0-324" id="h28-0-324" class="i">+// NewBuffer allocates a new Buffer and initializes its internal data to
</a><a href="#h28-0-325" id="h28-0-325" class="i">+// the contents of the argument slice.
</a><a href="#h28-0-326" id="h28-0-326" class="i">+func NewBuffer(e []byte) *Buffer {
</a><a href="#h28-0-327" id="h28-0-327" class="i">+	return &amp;Buffer{buf: e}
</a><a href="#h28-0-328" id="h28-0-328" class="i">+}
</a><a href="#h28-0-329" id="h28-0-329" class="i">+
</a><a href="#h28-0-330" id="h28-0-330" class="i">+// Reset resets the Buffer, ready for marshaling a new protocol buffer.
</a><a href="#h28-0-331" id="h28-0-331" class="i">+func (p *Buffer) Reset() {
</a><a href="#h28-0-332" id="h28-0-332" class="i">+	p.buf = p.buf[0:0] // for reading/writing
</a><a href="#h28-0-333" id="h28-0-333" class="i">+	p.index = 0        // for reading
</a><a href="#h28-0-334" id="h28-0-334" class="i">+}
</a><a href="#h28-0-335" id="h28-0-335" class="i">+
</a><a href="#h28-0-336" id="h28-0-336" class="i">+// SetBuf replaces the internal buffer with the slice,
</a><a href="#h28-0-337" id="h28-0-337" class="i">+// ready for unmarshaling the contents of the slice.
</a><a href="#h28-0-338" id="h28-0-338" class="i">+func (p *Buffer) SetBuf(s []byte) {
</a><a href="#h28-0-339" id="h28-0-339" class="i">+	p.buf = s
</a><a href="#h28-0-340" id="h28-0-340" class="i">+	p.index = 0
</a><a href="#h28-0-341" id="h28-0-341" class="i">+}
</a><a href="#h28-0-342" id="h28-0-342" class="i">+
</a><a href="#h28-0-343" id="h28-0-343" class="i">+// Bytes returns the contents of the Buffer.
</a><a href="#h28-0-344" id="h28-0-344" class="i">+func (p *Buffer) Bytes() []byte { return p.buf }
</a><a href="#h28-0-345" id="h28-0-345" class="i">+
</a><a href="#h28-0-346" id="h28-0-346" class="i">+/*
</a><a href="#h28-0-347" id="h28-0-347" class="i">+ * Helper routines for simplifying the creation of optional fields of basic type.
</a><a href="#h28-0-348" id="h28-0-348" class="i">+ */
</a><a href="#h28-0-349" id="h28-0-349" class="i">+
</a><a href="#h28-0-350" id="h28-0-350" class="i">+// Bool is a helper routine that allocates a new bool value
</a><a href="#h28-0-351" id="h28-0-351" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-352" id="h28-0-352" class="i">+func Bool(v bool) *bool {
</a><a href="#h28-0-353" id="h28-0-353" class="i">+	return &amp;v
</a><a href="#h28-0-354" id="h28-0-354" class="i">+}
</a><a href="#h28-0-355" id="h28-0-355" class="i">+
</a><a href="#h28-0-356" id="h28-0-356" class="i">+// Int32 is a helper routine that allocates a new int32 value
</a><a href="#h28-0-357" id="h28-0-357" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-358" id="h28-0-358" class="i">+func Int32(v int32) *int32 {
</a><a href="#h28-0-359" id="h28-0-359" class="i">+	return &amp;v
</a><a href="#h28-0-360" id="h28-0-360" class="i">+}
</a><a href="#h28-0-361" id="h28-0-361" class="i">+
</a><a href="#h28-0-362" id="h28-0-362" class="i">+// Int is a helper routine that allocates a new int32 value
</a><a href="#h28-0-363" id="h28-0-363" class="i">+// to store v and returns a pointer to it, but unlike Int32
</a><a href="#h28-0-364" id="h28-0-364" class="i">+// its argument value is an int.
</a><a href="#h28-0-365" id="h28-0-365" class="i">+func Int(v int) *int32 {
</a><a href="#h28-0-366" id="h28-0-366" class="i">+	p := new(int32)
</a><a href="#h28-0-367" id="h28-0-367" class="i">+	*p = int32(v)
</a><a href="#h28-0-368" id="h28-0-368" class="i">+	return p
</a><a href="#h28-0-369" id="h28-0-369" class="i">+}
</a><a href="#h28-0-370" id="h28-0-370" class="i">+
</a><a href="#h28-0-371" id="h28-0-371" class="i">+// Int64 is a helper routine that allocates a new int64 value
</a><a href="#h28-0-372" id="h28-0-372" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-373" id="h28-0-373" class="i">+func Int64(v int64) *int64 {
</a><a href="#h28-0-374" id="h28-0-374" class="i">+	return &amp;v
</a><a href="#h28-0-375" id="h28-0-375" class="i">+}
</a><a href="#h28-0-376" id="h28-0-376" class="i">+
</a><a href="#h28-0-377" id="h28-0-377" class="i">+// Float32 is a helper routine that allocates a new float32 value
</a><a href="#h28-0-378" id="h28-0-378" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-379" id="h28-0-379" class="i">+func Float32(v float32) *float32 {
</a><a href="#h28-0-380" id="h28-0-380" class="i">+	return &amp;v
</a><a href="#h28-0-381" id="h28-0-381" class="i">+}
</a><a href="#h28-0-382" id="h28-0-382" class="i">+
</a><a href="#h28-0-383" id="h28-0-383" class="i">+// Float64 is a helper routine that allocates a new float64 value
</a><a href="#h28-0-384" id="h28-0-384" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-385" id="h28-0-385" class="i">+func Float64(v float64) *float64 {
</a><a href="#h28-0-386" id="h28-0-386" class="i">+	return &amp;v
</a><a href="#h28-0-387" id="h28-0-387" class="i">+}
</a><a href="#h28-0-388" id="h28-0-388" class="i">+
</a><a href="#h28-0-389" id="h28-0-389" class="i">+// Uint32 is a helper routine that allocates a new uint32 value
</a><a href="#h28-0-390" id="h28-0-390" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-391" id="h28-0-391" class="i">+func Uint32(v uint32) *uint32 {
</a><a href="#h28-0-392" id="h28-0-392" class="i">+	return &amp;v
</a><a href="#h28-0-393" id="h28-0-393" class="i">+}
</a><a href="#h28-0-394" id="h28-0-394" class="i">+
</a><a href="#h28-0-395" id="h28-0-395" class="i">+// Uint64 is a helper routine that allocates a new uint64 value
</a><a href="#h28-0-396" id="h28-0-396" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-397" id="h28-0-397" class="i">+func Uint64(v uint64) *uint64 {
</a><a href="#h28-0-398" id="h28-0-398" class="i">+	return &amp;v
</a><a href="#h28-0-399" id="h28-0-399" class="i">+}
</a><a href="#h28-0-400" id="h28-0-400" class="i">+
</a><a href="#h28-0-401" id="h28-0-401" class="i">+// String is a helper routine that allocates a new string value
</a><a href="#h28-0-402" id="h28-0-402" class="i">+// to store v and returns a pointer to it.
</a><a href="#h28-0-403" id="h28-0-403" class="i">+func String(v string) *string {
</a><a href="#h28-0-404" id="h28-0-404" class="i">+	return &amp;v
</a><a href="#h28-0-405" id="h28-0-405" class="i">+}
</a><a href="#h28-0-406" id="h28-0-406" class="i">+
</a><a href="#h28-0-407" id="h28-0-407" class="i">+// EnumName is a helper function to simplify printing protocol buffer enums
</a><a href="#h28-0-408" id="h28-0-408" class="i">+// by name.  Given an enum map and a value, it returns a useful string.
</a><a href="#h28-0-409" id="h28-0-409" class="i">+func EnumName(m map[int32]string, v int32) string {
</a><a href="#h28-0-410" id="h28-0-410" class="i">+	s, ok := m[v]
</a><a href="#h28-0-411" id="h28-0-411" class="i">+	if ok {
</a><a href="#h28-0-412" id="h28-0-412" class="i">+		return s
</a><a href="#h28-0-413" id="h28-0-413" class="i">+	}
</a><a href="#h28-0-414" id="h28-0-414" class="i">+	return strconv.Itoa(int(v))
</a><a href="#h28-0-415" id="h28-0-415" class="i">+}
</a><a href="#h28-0-416" id="h28-0-416" class="i">+
</a><a href="#h28-0-417" id="h28-0-417" class="i">+// UnmarshalJSONEnum is a helper function to simplify recovering enum int values
</a><a href="#h28-0-418" id="h28-0-418" class="i">+// from their JSON-encoded representation. Given a map from the enum&#39;s symbolic
</a><a href="#h28-0-419" id="h28-0-419" class="i">+// names to its int values, and a byte buffer containing the JSON-encoded
</a><a href="#h28-0-420" id="h28-0-420" class="i">+// value, it returns an int32 that can be cast to the enum type by the caller.
</a><a href="#h28-0-421" id="h28-0-421" class="i">+//
</a><a href="#h28-0-422" id="h28-0-422" class="i">+// The function can deal with both JSON representations, numeric and symbolic.
</a><a href="#h28-0-423" id="h28-0-423" class="i">+func UnmarshalJSONEnum(m map[string]int32, data []byte, enumName string) (int32, error) {
</a><a href="#h28-0-424" id="h28-0-424" class="i">+	if data[0] == &#39;&quot;&#39; {
</a><a href="#h28-0-425" id="h28-0-425" class="i">+		// New style: enums are strings.
</a><a href="#h28-0-426" id="h28-0-426" class="i">+		var repr string
</a><a href="#h28-0-427" id="h28-0-427" class="i">+		if err := json.Unmarshal(data, &amp;repr); err != nil {
</a><a href="#h28-0-428" id="h28-0-428" class="i">+			return -1, err
</a><a href="#h28-0-429" id="h28-0-429" class="i">+		}
</a><a href="#h28-0-430" id="h28-0-430" class="i">+		val, ok := m[repr]
</a><a href="#h28-0-431" id="h28-0-431" class="i">+		if !ok {
</a><a href="#h28-0-432" id="h28-0-432" class="i">+			return 0, fmt.Errorf(&quot;unrecognized enum %s value %q&quot;, enumName, repr)
</a><a href="#h28-0-433" id="h28-0-433" class="i">+		}
</a><a href="#h28-0-434" id="h28-0-434" class="i">+		return val, nil
</a><a href="#h28-0-435" id="h28-0-435" class="i">+	}
</a><a href="#h28-0-436" id="h28-0-436" class="i">+	// Old style: enums are ints.
</a><a href="#h28-0-437" id="h28-0-437" class="i">+	var val int32
</a><a href="#h28-0-438" id="h28-0-438" class="i">+	if err := json.Unmarshal(data, &amp;val); err != nil {
</a><a href="#h28-0-439" id="h28-0-439" class="i">+		return 0, fmt.Errorf(&quot;cannot unmarshal %#q into enum %s&quot;, data, enumName)
</a><a href="#h28-0-440" id="h28-0-440" class="i">+	}
</a><a href="#h28-0-441" id="h28-0-441" class="i">+	return val, nil
</a><a href="#h28-0-442" id="h28-0-442" class="i">+}
</a><a href="#h28-0-443" id="h28-0-443" class="i">+
</a><a href="#h28-0-444" id="h28-0-444" class="i">+// DebugPrint dumps the encoded data in b in a debugging format with a header
</a><a href="#h28-0-445" id="h28-0-445" class="i">+// including the string s. Used in testing but made available for general debugging.
</a><a href="#h28-0-446" id="h28-0-446" class="i">+func (p *Buffer) DebugPrint(s string, b []byte) {
</a><a href="#h28-0-447" id="h28-0-447" class="i">+	var u uint64
</a><a href="#h28-0-448" id="h28-0-448" class="i">+
</a><a href="#h28-0-449" id="h28-0-449" class="i">+	obuf := p.buf
</a><a href="#h28-0-450" id="h28-0-450" class="i">+	index := p.index
</a><a href="#h28-0-451" id="h28-0-451" class="i">+	p.buf = b
</a><a href="#h28-0-452" id="h28-0-452" class="i">+	p.index = 0
</a><a href="#h28-0-453" id="h28-0-453" class="i">+	depth := 0
</a><a href="#h28-0-454" id="h28-0-454" class="i">+
</a><a href="#h28-0-455" id="h28-0-455" class="i">+	fmt.Printf(&quot;\n--- %s ---\n&quot;, s)
</a><a href="#h28-0-456" id="h28-0-456" class="i">+
</a><a href="#h28-0-457" id="h28-0-457" class="i">+out:
</a><a href="#h28-0-458" id="h28-0-458" class="i">+	for {
</a><a href="#h28-0-459" id="h28-0-459" class="i">+		for i := 0; i &lt; depth; i++ {
</a><a href="#h28-0-460" id="h28-0-460" class="i">+			fmt.Print(&quot;  &quot;)
</a><a href="#h28-0-461" id="h28-0-461" class="i">+		}
</a><a href="#h28-0-462" id="h28-0-462" class="i">+
</a><a href="#h28-0-463" id="h28-0-463" class="i">+		index := p.index
</a><a href="#h28-0-464" id="h28-0-464" class="i">+		if index == len(p.buf) {
</a><a href="#h28-0-465" id="h28-0-465" class="i">+			break
</a><a href="#h28-0-466" id="h28-0-466" class="i">+		}
</a><a href="#h28-0-467" id="h28-0-467" class="i">+
</a><a href="#h28-0-468" id="h28-0-468" class="i">+		op, err := p.DecodeVarint()
</a><a href="#h28-0-469" id="h28-0-469" class="i">+		if err != nil {
</a><a href="#h28-0-470" id="h28-0-470" class="i">+			fmt.Printf(&quot;%3d: fetching op err %v\n&quot;, index, err)
</a><a href="#h28-0-471" id="h28-0-471" class="i">+			break out
</a><a href="#h28-0-472" id="h28-0-472" class="i">+		}
</a><a href="#h28-0-473" id="h28-0-473" class="i">+		tag := op &gt;&gt; 3
</a><a href="#h28-0-474" id="h28-0-474" class="i">+		wire := op &amp; 7
</a><a href="#h28-0-475" id="h28-0-475" class="i">+
</a><a href="#h28-0-476" id="h28-0-476" class="i">+		switch wire {
</a><a href="#h28-0-477" id="h28-0-477" class="i">+		default:
</a><a href="#h28-0-478" id="h28-0-478" class="i">+			fmt.Printf(&quot;%3d: t=%3d unknown wire=%d\n&quot;,
</a><a href="#h28-0-479" id="h28-0-479" class="i">+				index, tag, wire)
</a><a href="#h28-0-480" id="h28-0-480" class="i">+			break out
</a><a href="#h28-0-481" id="h28-0-481" class="i">+
</a><a href="#h28-0-482" id="h28-0-482" class="i">+		case WireBytes:
</a><a href="#h28-0-483" id="h28-0-483" class="i">+			var r []byte
</a><a href="#h28-0-484" id="h28-0-484" class="i">+
</a><a href="#h28-0-485" id="h28-0-485" class="i">+			r, err = p.DecodeRawBytes(false)
</a><a href="#h28-0-486" id="h28-0-486" class="i">+			if err != nil {
</a><a href="#h28-0-487" id="h28-0-487" class="i">+				break out
</a><a href="#h28-0-488" id="h28-0-488" class="i">+			}
</a><a href="#h28-0-489" id="h28-0-489" class="i">+			fmt.Printf(&quot;%3d: t=%3d bytes [%d]&quot;, index, tag, len(r))
</a><a href="#h28-0-490" id="h28-0-490" class="i">+			if len(r) &lt;= 6 {
</a><a href="#h28-0-491" id="h28-0-491" class="i">+				for i := 0; i &lt; len(r); i++ {
</a><a href="#h28-0-492" id="h28-0-492" class="i">+					fmt.Printf(&quot; %.2x&quot;, r[i])
</a><a href="#h28-0-493" id="h28-0-493" class="i">+				}
</a><a href="#h28-0-494" id="h28-0-494" class="i">+			} else {
</a><a href="#h28-0-495" id="h28-0-495" class="i">+				for i := 0; i &lt; 3; i++ {
</a><a href="#h28-0-496" id="h28-0-496" class="i">+					fmt.Printf(&quot; %.2x&quot;, r[i])
</a><a href="#h28-0-497" id="h28-0-497" class="i">+				}
</a><a href="#h28-0-498" id="h28-0-498" class="i">+				fmt.Printf(&quot; ..&quot;)
</a><a href="#h28-0-499" id="h28-0-499" class="i">+				for i := len(r) - 3; i &lt; len(r); i++ {
</a><a href="#h28-0-500" id="h28-0-500" class="i">+					fmt.Printf(&quot; %.2x&quot;, r[i])
</a><a href="#h28-0-501" id="h28-0-501" class="i">+				}
</a><a href="#h28-0-502" id="h28-0-502" class="i">+			}
</a><a href="#h28-0-503" id="h28-0-503" class="i">+			fmt.Printf(&quot;\n&quot;)
</a><a href="#h28-0-504" id="h28-0-504" class="i">+
</a><a href="#h28-0-505" id="h28-0-505" class="i">+		case WireFixed32:
</a><a href="#h28-0-506" id="h28-0-506" class="i">+			u, err = p.DecodeFixed32()
</a><a href="#h28-0-507" id="h28-0-507" class="i">+			if err != nil {
</a><a href="#h28-0-508" id="h28-0-508" class="i">+				fmt.Printf(&quot;%3d: t=%3d fix32 err %v\n&quot;, index, tag, err)
</a><a href="#h28-0-509" id="h28-0-509" class="i">+				break out
</a><a href="#h28-0-510" id="h28-0-510" class="i">+			}
</a><a href="#h28-0-511" id="h28-0-511" class="i">+			fmt.Printf(&quot;%3d: t=%3d fix32 %d\n&quot;, index, tag, u)
</a><a href="#h28-0-512" id="h28-0-512" class="i">+
</a><a href="#h28-0-513" id="h28-0-513" class="i">+		case WireFixed64:
</a><a href="#h28-0-514" id="h28-0-514" class="i">+			u, err = p.DecodeFixed64()
</a><a href="#h28-0-515" id="h28-0-515" class="i">+			if err != nil {
</a><a href="#h28-0-516" id="h28-0-516" class="i">+				fmt.Printf(&quot;%3d: t=%3d fix64 err %v\n&quot;, index, tag, err)
</a><a href="#h28-0-517" id="h28-0-517" class="i">+				break out
</a><a href="#h28-0-518" id="h28-0-518" class="i">+			}
</a><a href="#h28-0-519" id="h28-0-519" class="i">+			fmt.Printf(&quot;%3d: t=%3d fix64 %d\n&quot;, index, tag, u)
</a><a href="#h28-0-520" id="h28-0-520" class="i">+
</a><a href="#h28-0-521" id="h28-0-521" class="i">+		case WireVarint:
</a><a href="#h28-0-522" id="h28-0-522" class="i">+			u, err = p.DecodeVarint()
</a><a href="#h28-0-523" id="h28-0-523" class="i">+			if err != nil {
</a><a href="#h28-0-524" id="h28-0-524" class="i">+				fmt.Printf(&quot;%3d: t=%3d varint err %v\n&quot;, index, tag, err)
</a><a href="#h28-0-525" id="h28-0-525" class="i">+				break out
</a><a href="#h28-0-526" id="h28-0-526" class="i">+			}
</a><a href="#h28-0-527" id="h28-0-527" class="i">+			fmt.Printf(&quot;%3d: t=%3d varint %d\n&quot;, index, tag, u)
</a><a href="#h28-0-528" id="h28-0-528" class="i">+
</a><a href="#h28-0-529" id="h28-0-529" class="i">+		case WireStartGroup:
</a><a href="#h28-0-530" id="h28-0-530" class="i">+			fmt.Printf(&quot;%3d: t=%3d start\n&quot;, index, tag)
</a><a href="#h28-0-531" id="h28-0-531" class="i">+			depth++
</a><a href="#h28-0-532" id="h28-0-532" class="i">+
</a><a href="#h28-0-533" id="h28-0-533" class="i">+		case WireEndGroup:
</a><a href="#h28-0-534" id="h28-0-534" class="i">+			depth--
</a><a href="#h28-0-535" id="h28-0-535" class="i">+			fmt.Printf(&quot;%3d: t=%3d end\n&quot;, index, tag)
</a><a href="#h28-0-536" id="h28-0-536" class="i">+		}
</a><a href="#h28-0-537" id="h28-0-537" class="i">+	}
</a><a href="#h28-0-538" id="h28-0-538" class="i">+
</a><a href="#h28-0-539" id="h28-0-539" class="i">+	if depth != 0 {
</a><a href="#h28-0-540" id="h28-0-540" class="i">+		fmt.Printf(&quot;%3d: start-end not balanced %d\n&quot;, p.index, depth)
</a><a href="#h28-0-541" id="h28-0-541" class="i">+	}
</a><a href="#h28-0-542" id="h28-0-542" class="i">+	fmt.Printf(&quot;\n&quot;)
</a><a href="#h28-0-543" id="h28-0-543" class="i">+
</a><a href="#h28-0-544" id="h28-0-544" class="i">+	p.buf = obuf
</a><a href="#h28-0-545" id="h28-0-545" class="i">+	p.index = index
</a><a href="#h28-0-546" id="h28-0-546" class="i">+}
</a><a href="#h28-0-547" id="h28-0-547" class="i">+
</a><a href="#h28-0-548" id="h28-0-548" class="i">+// SetDefaults sets unset protocol buffer fields to their default values.
</a><a href="#h28-0-549" id="h28-0-549" class="i">+// It only modifies fields that are both unset and have defined defaults.
</a><a href="#h28-0-550" id="h28-0-550" class="i">+// It recursively sets default values in any non-nil sub-messages.
</a><a href="#h28-0-551" id="h28-0-551" class="i">+func SetDefaults(pb Message) {
</a><a href="#h28-0-552" id="h28-0-552" class="i">+	setDefaults(reflect.ValueOf(pb), true, false)
</a><a href="#h28-0-553" id="h28-0-553" class="i">+}
</a><a href="#h28-0-554" id="h28-0-554" class="i">+
</a><a href="#h28-0-555" id="h28-0-555" class="i">+// v is a pointer to a struct.
</a><a href="#h28-0-556" id="h28-0-556" class="i">+func setDefaults(v reflect.Value, recur, zeros bool) {
</a><a href="#h28-0-557" id="h28-0-557" class="i">+	v = v.Elem()
</a><a href="#h28-0-558" id="h28-0-558" class="i">+
</a><a href="#h28-0-559" id="h28-0-559" class="i">+	defaultMu.RLock()
</a><a href="#h28-0-560" id="h28-0-560" class="i">+	dm, ok := defaults[v.Type()]
</a><a href="#h28-0-561" id="h28-0-561" class="i">+	defaultMu.RUnlock()
</a><a href="#h28-0-562" id="h28-0-562" class="i">+	if !ok {
</a><a href="#h28-0-563" id="h28-0-563" class="i">+		dm = buildDefaultMessage(v.Type())
</a><a href="#h28-0-564" id="h28-0-564" class="i">+		defaultMu.Lock()
</a><a href="#h28-0-565" id="h28-0-565" class="i">+		defaults[v.Type()] = dm
</a><a href="#h28-0-566" id="h28-0-566" class="i">+		defaultMu.Unlock()
</a><a href="#h28-0-567" id="h28-0-567" class="i">+	}
</a><a href="#h28-0-568" id="h28-0-568" class="i">+
</a><a href="#h28-0-569" id="h28-0-569" class="i">+	for _, sf := range dm.scalars {
</a><a href="#h28-0-570" id="h28-0-570" class="i">+		f := v.Field(sf.index)
</a><a href="#h28-0-571" id="h28-0-571" class="i">+		if !f.IsNil() {
</a><a href="#h28-0-572" id="h28-0-572" class="i">+			// field already set
</a><a href="#h28-0-573" id="h28-0-573" class="i">+			continue
</a><a href="#h28-0-574" id="h28-0-574" class="i">+		}
</a><a href="#h28-0-575" id="h28-0-575" class="i">+		dv := sf.value
</a><a href="#h28-0-576" id="h28-0-576" class="i">+		if dv == nil &amp;&amp; !zeros {
</a><a href="#h28-0-577" id="h28-0-577" class="i">+			// no explicit default, and don&#39;t want to set zeros
</a><a href="#h28-0-578" id="h28-0-578" class="i">+			continue
</a><a href="#h28-0-579" id="h28-0-579" class="i">+		}
</a><a href="#h28-0-580" id="h28-0-580" class="i">+		fptr := f.Addr().Interface() // **T
</a><a href="#h28-0-581" id="h28-0-581" class="i">+		// TODO: Consider batching the allocations we do here.
</a><a href="#h28-0-582" id="h28-0-582" class="i">+		switch sf.kind {
</a><a href="#h28-0-583" id="h28-0-583" class="i">+		case reflect.Bool:
</a><a href="#h28-0-584" id="h28-0-584" class="i">+			b := new(bool)
</a><a href="#h28-0-585" id="h28-0-585" class="i">+			if dv != nil {
</a><a href="#h28-0-586" id="h28-0-586" class="i">+				*b = dv.(bool)
</a><a href="#h28-0-587" id="h28-0-587" class="i">+			}
</a><a href="#h28-0-588" id="h28-0-588" class="i">+			*(fptr.(**bool)) = b
</a><a href="#h28-0-589" id="h28-0-589" class="i">+		case reflect.Float32:
</a><a href="#h28-0-590" id="h28-0-590" class="i">+			f := new(float32)
</a><a href="#h28-0-591" id="h28-0-591" class="i">+			if dv != nil {
</a><a href="#h28-0-592" id="h28-0-592" class="i">+				*f = dv.(float32)
</a><a href="#h28-0-593" id="h28-0-593" class="i">+			}
</a><a href="#h28-0-594" id="h28-0-594" class="i">+			*(fptr.(**float32)) = f
</a><a href="#h28-0-595" id="h28-0-595" class="i">+		case reflect.Float64:
</a><a href="#h28-0-596" id="h28-0-596" class="i">+			f := new(float64)
</a><a href="#h28-0-597" id="h28-0-597" class="i">+			if dv != nil {
</a><a href="#h28-0-598" id="h28-0-598" class="i">+				*f = dv.(float64)
</a><a href="#h28-0-599" id="h28-0-599" class="i">+			}
</a><a href="#h28-0-600" id="h28-0-600" class="i">+			*(fptr.(**float64)) = f
</a><a href="#h28-0-601" id="h28-0-601" class="i">+		case reflect.Int32:
</a><a href="#h28-0-602" id="h28-0-602" class="i">+			// might be an enum
</a><a href="#h28-0-603" id="h28-0-603" class="i">+			if ft := f.Type(); ft != int32PtrType {
</a><a href="#h28-0-604" id="h28-0-604" class="i">+				// enum
</a><a href="#h28-0-605" id="h28-0-605" class="i">+				f.Set(reflect.New(ft.Elem()))
</a><a href="#h28-0-606" id="h28-0-606" class="i">+				if dv != nil {
</a><a href="#h28-0-607" id="h28-0-607" class="i">+					f.Elem().SetInt(int64(dv.(int32)))
</a><a href="#h28-0-608" id="h28-0-608" class="i">+				}
</a><a href="#h28-0-609" id="h28-0-609" class="i">+			} else {
</a><a href="#h28-0-610" id="h28-0-610" class="i">+				// int32 field
</a><a href="#h28-0-611" id="h28-0-611" class="i">+				i := new(int32)
</a><a href="#h28-0-612" id="h28-0-612" class="i">+				if dv != nil {
</a><a href="#h28-0-613" id="h28-0-613" class="i">+					*i = dv.(int32)
</a><a href="#h28-0-614" id="h28-0-614" class="i">+				}
</a><a href="#h28-0-615" id="h28-0-615" class="i">+				*(fptr.(**int32)) = i
</a><a href="#h28-0-616" id="h28-0-616" class="i">+			}
</a><a href="#h28-0-617" id="h28-0-617" class="i">+		case reflect.Int64:
</a><a href="#h28-0-618" id="h28-0-618" class="i">+			i := new(int64)
</a><a href="#h28-0-619" id="h28-0-619" class="i">+			if dv != nil {
</a><a href="#h28-0-620" id="h28-0-620" class="i">+				*i = dv.(int64)
</a><a href="#h28-0-621" id="h28-0-621" class="i">+			}
</a><a href="#h28-0-622" id="h28-0-622" class="i">+			*(fptr.(**int64)) = i
</a><a href="#h28-0-623" id="h28-0-623" class="i">+		case reflect.String:
</a><a href="#h28-0-624" id="h28-0-624" class="i">+			s := new(string)
</a><a href="#h28-0-625" id="h28-0-625" class="i">+			if dv != nil {
</a><a href="#h28-0-626" id="h28-0-626" class="i">+				*s = dv.(string)
</a><a href="#h28-0-627" id="h28-0-627" class="i">+			}
</a><a href="#h28-0-628" id="h28-0-628" class="i">+			*(fptr.(**string)) = s
</a><a href="#h28-0-629" id="h28-0-629" class="i">+		case reflect.Uint8:
</a><a href="#h28-0-630" id="h28-0-630" class="i">+			// exceptional case: []byte
</a><a href="#h28-0-631" id="h28-0-631" class="i">+			var b []byte
</a><a href="#h28-0-632" id="h28-0-632" class="i">+			if dv != nil {
</a><a href="#h28-0-633" id="h28-0-633" class="i">+				db := dv.([]byte)
</a><a href="#h28-0-634" id="h28-0-634" class="i">+				b = make([]byte, len(db))
</a><a href="#h28-0-635" id="h28-0-635" class="i">+				copy(b, db)
</a><a href="#h28-0-636" id="h28-0-636" class="i">+			} else {
</a><a href="#h28-0-637" id="h28-0-637" class="i">+				b = []byte{}
</a><a href="#h28-0-638" id="h28-0-638" class="i">+			}
</a><a href="#h28-0-639" id="h28-0-639" class="i">+			*(fptr.(*[]byte)) = b
</a><a href="#h28-0-640" id="h28-0-640" class="i">+		case reflect.Uint32:
</a><a href="#h28-0-641" id="h28-0-641" class="i">+			u := new(uint32)
</a><a href="#h28-0-642" id="h28-0-642" class="i">+			if dv != nil {
</a><a href="#h28-0-643" id="h28-0-643" class="i">+				*u = dv.(uint32)
</a><a href="#h28-0-644" id="h28-0-644" class="i">+			}
</a><a href="#h28-0-645" id="h28-0-645" class="i">+			*(fptr.(**uint32)) = u
</a><a href="#h28-0-646" id="h28-0-646" class="i">+		case reflect.Uint64:
</a><a href="#h28-0-647" id="h28-0-647" class="i">+			u := new(uint64)
</a><a href="#h28-0-648" id="h28-0-648" class="i">+			if dv != nil {
</a><a href="#h28-0-649" id="h28-0-649" class="i">+				*u = dv.(uint64)
</a><a href="#h28-0-650" id="h28-0-650" class="i">+			}
</a><a href="#h28-0-651" id="h28-0-651" class="i">+			*(fptr.(**uint64)) = u
</a><a href="#h28-0-652" id="h28-0-652" class="i">+		default:
</a><a href="#h28-0-653" id="h28-0-653" class="i">+			log.Printf(&quot;proto: can&#39;t set default for field %v (sf.kind=%v)&quot;, f, sf.kind)
</a><a href="#h28-0-654" id="h28-0-654" class="i">+		}
</a><a href="#h28-0-655" id="h28-0-655" class="i">+	}
</a><a href="#h28-0-656" id="h28-0-656" class="i">+
</a><a href="#h28-0-657" id="h28-0-657" class="i">+	for _, ni := range dm.nested {
</a><a href="#h28-0-658" id="h28-0-658" class="i">+		f := v.Field(ni)
</a><a href="#h28-0-659" id="h28-0-659" class="i">+		// f is *T or []*T or map[T]*T
</a><a href="#h28-0-660" id="h28-0-660" class="i">+		switch f.Kind() {
</a><a href="#h28-0-661" id="h28-0-661" class="i">+		case reflect.Ptr:
</a><a href="#h28-0-662" id="h28-0-662" class="i">+			if f.IsNil() {
</a><a href="#h28-0-663" id="h28-0-663" class="i">+				continue
</a><a href="#h28-0-664" id="h28-0-664" class="i">+			}
</a><a href="#h28-0-665" id="h28-0-665" class="i">+			setDefaults(f, recur, zeros)
</a><a href="#h28-0-666" id="h28-0-666" class="i">+
</a><a href="#h28-0-667" id="h28-0-667" class="i">+		case reflect.Slice:
</a><a href="#h28-0-668" id="h28-0-668" class="i">+			for i := 0; i &lt; f.Len(); i++ {
</a><a href="#h28-0-669" id="h28-0-669" class="i">+				e := f.Index(i)
</a><a href="#h28-0-670" id="h28-0-670" class="i">+				if e.IsNil() {
</a><a href="#h28-0-671" id="h28-0-671" class="i">+					continue
</a><a href="#h28-0-672" id="h28-0-672" class="i">+				}
</a><a href="#h28-0-673" id="h28-0-673" class="i">+				setDefaults(e, recur, zeros)
</a><a href="#h28-0-674" id="h28-0-674" class="i">+			}
</a><a href="#h28-0-675" id="h28-0-675" class="i">+
</a><a href="#h28-0-676" id="h28-0-676" class="i">+		case reflect.Map:
</a><a href="#h28-0-677" id="h28-0-677" class="i">+			for _, k := range f.MapKeys() {
</a><a href="#h28-0-678" id="h28-0-678" class="i">+				e := f.MapIndex(k)
</a><a href="#h28-0-679" id="h28-0-679" class="i">+				if e.IsNil() {
</a><a href="#h28-0-680" id="h28-0-680" class="i">+					continue
</a><a href="#h28-0-681" id="h28-0-681" class="i">+				}
</a><a href="#h28-0-682" id="h28-0-682" class="i">+				setDefaults(e, recur, zeros)
</a><a href="#h28-0-683" id="h28-0-683" class="i">+			}
</a><a href="#h28-0-684" id="h28-0-684" class="i">+		}
</a><a href="#h28-0-685" id="h28-0-685" class="i">+	}
</a><a href="#h28-0-686" id="h28-0-686" class="i">+}
</a><a href="#h28-0-687" id="h28-0-687" class="i">+
</a><a href="#h28-0-688" id="h28-0-688" class="i">+var (
</a><a href="#h28-0-689" id="h28-0-689" class="i">+	// defaults maps a protocol buffer struct type to a slice of the fields,
</a><a href="#h28-0-690" id="h28-0-690" class="i">+	// with its scalar fields set to their proto-declared non-zero default values.
</a><a href="#h28-0-691" id="h28-0-691" class="i">+	defaultMu sync.RWMutex
</a><a href="#h28-0-692" id="h28-0-692" class="i">+	defaults  = make(map[reflect.Type]defaultMessage)
</a><a href="#h28-0-693" id="h28-0-693" class="i">+
</a><a href="#h28-0-694" id="h28-0-694" class="i">+	int32PtrType = reflect.TypeOf((*int32)(nil))
</a><a href="#h28-0-695" id="h28-0-695" class="i">+)
</a><a href="#h28-0-696" id="h28-0-696" class="i">+
</a><a href="#h28-0-697" id="h28-0-697" class="i">+// defaultMessage represents information about the default values of a message.
</a><a href="#h28-0-698" id="h28-0-698" class="i">+type defaultMessage struct {
</a><a href="#h28-0-699" id="h28-0-699" class="i">+	scalars []scalarField
</a><a href="#h28-0-700" id="h28-0-700" class="i">+	nested  []int // struct field index of nested messages
</a><a href="#h28-0-701" id="h28-0-701" class="i">+}
</a><a href="#h28-0-702" id="h28-0-702" class="i">+
</a><a href="#h28-0-703" id="h28-0-703" class="i">+type scalarField struct {
</a><a href="#h28-0-704" id="h28-0-704" class="i">+	index int          // struct field index
</a><a href="#h28-0-705" id="h28-0-705" class="i">+	kind  reflect.Kind // element type (the T in *T or []T)
</a><a href="#h28-0-706" id="h28-0-706" class="i">+	value interface{}  // the proto-declared default value, or nil
</a><a href="#h28-0-707" id="h28-0-707" class="i">+}
</a><a href="#h28-0-708" id="h28-0-708" class="i">+
</a><a href="#h28-0-709" id="h28-0-709" class="i">+// t is a struct type.
</a><a href="#h28-0-710" id="h28-0-710" class="i">+func buildDefaultMessage(t reflect.Type) (dm defaultMessage) {
</a><a href="#h28-0-711" id="h28-0-711" class="i">+	sprop := GetProperties(t)
</a><a href="#h28-0-712" id="h28-0-712" class="i">+	for _, prop := range sprop.Prop {
</a><a href="#h28-0-713" id="h28-0-713" class="i">+		fi, ok := sprop.decoderTags.get(prop.Tag)
</a><a href="#h28-0-714" id="h28-0-714" class="i">+		if !ok {
</a><a href="#h28-0-715" id="h28-0-715" class="i">+			// XXX_unrecognized
</a><a href="#h28-0-716" id="h28-0-716" class="i">+			continue
</a><a href="#h28-0-717" id="h28-0-717" class="i">+		}
</a><a href="#h28-0-718" id="h28-0-718" class="i">+		ft := t.Field(fi).Type
</a><a href="#h28-0-719" id="h28-0-719" class="i">+
</a><a href="#h28-0-720" id="h28-0-720" class="i">+		sf, nested, err := fieldDefault(ft, prop)
</a><a href="#h28-0-721" id="h28-0-721" class="i">+		switch {
</a><a href="#h28-0-722" id="h28-0-722" class="i">+		case err != nil:
</a><a href="#h28-0-723" id="h28-0-723" class="i">+			log.Print(err)
</a><a href="#h28-0-724" id="h28-0-724" class="i">+		case nested:
</a><a href="#h28-0-725" id="h28-0-725" class="i">+			dm.nested = append(dm.nested, fi)
</a><a href="#h28-0-726" id="h28-0-726" class="i">+		case sf != nil:
</a><a href="#h28-0-727" id="h28-0-727" class="i">+			sf.index = fi
</a><a href="#h28-0-728" id="h28-0-728" class="i">+			dm.scalars = append(dm.scalars, *sf)
</a><a href="#h28-0-729" id="h28-0-729" class="i">+		}
</a><a href="#h28-0-730" id="h28-0-730" class="i">+	}
</a><a href="#h28-0-731" id="h28-0-731" class="i">+
</a><a href="#h28-0-732" id="h28-0-732" class="i">+	return dm
</a><a href="#h28-0-733" id="h28-0-733" class="i">+}
</a><a href="#h28-0-734" id="h28-0-734" class="i">+
</a><a href="#h28-0-735" id="h28-0-735" class="i">+// fieldDefault returns the scalarField for field type ft.
</a><a href="#h28-0-736" id="h28-0-736" class="i">+// sf will be nil if the field can not have a default.
</a><a href="#h28-0-737" id="h28-0-737" class="i">+// nestedMessage will be true if this is a nested message.
</a><a href="#h28-0-738" id="h28-0-738" class="i">+// Note that sf.index is not set on return.
</a><a href="#h28-0-739" id="h28-0-739" class="i">+func fieldDefault(ft reflect.Type, prop *Properties) (sf *scalarField, nestedMessage bool, err error) {
</a><a href="#h28-0-740" id="h28-0-740" class="i">+	var canHaveDefault bool
</a><a href="#h28-0-741" id="h28-0-741" class="i">+	switch ft.Kind() {
</a><a href="#h28-0-742" id="h28-0-742" class="i">+	case reflect.Ptr:
</a><a href="#h28-0-743" id="h28-0-743" class="i">+		if ft.Elem().Kind() == reflect.Struct {
</a><a href="#h28-0-744" id="h28-0-744" class="i">+			nestedMessage = true
</a><a href="#h28-0-745" id="h28-0-745" class="i">+		} else {
</a><a href="#h28-0-746" id="h28-0-746" class="i">+			canHaveDefault = true // proto2 scalar field
</a><a href="#h28-0-747" id="h28-0-747" class="i">+		}
</a><a href="#h28-0-748" id="h28-0-748" class="i">+
</a><a href="#h28-0-749" id="h28-0-749" class="i">+	case reflect.Slice:
</a><a href="#h28-0-750" id="h28-0-750" class="i">+		switch ft.Elem().Kind() {
</a><a href="#h28-0-751" id="h28-0-751" class="i">+		case reflect.Ptr:
</a><a href="#h28-0-752" id="h28-0-752" class="i">+			nestedMessage = true // repeated message
</a><a href="#h28-0-753" id="h28-0-753" class="i">+		case reflect.Uint8:
</a><a href="#h28-0-754" id="h28-0-754" class="i">+			canHaveDefault = true // bytes field
</a><a href="#h28-0-755" id="h28-0-755" class="i">+		}
</a><a href="#h28-0-756" id="h28-0-756" class="i">+
</a><a href="#h28-0-757" id="h28-0-757" class="i">+	case reflect.Map:
</a><a href="#h28-0-758" id="h28-0-758" class="i">+		if ft.Elem().Kind() == reflect.Ptr {
</a><a href="#h28-0-759" id="h28-0-759" class="i">+			nestedMessage = true // map with message values
</a><a href="#h28-0-760" id="h28-0-760" class="i">+		}
</a><a href="#h28-0-761" id="h28-0-761" class="i">+	}
</a><a href="#h28-0-762" id="h28-0-762" class="i">+
</a><a href="#h28-0-763" id="h28-0-763" class="i">+	if !canHaveDefault {
</a><a href="#h28-0-764" id="h28-0-764" class="i">+		if nestedMessage {
</a><a href="#h28-0-765" id="h28-0-765" class="i">+			return nil, true, nil
</a><a href="#h28-0-766" id="h28-0-766" class="i">+		}
</a><a href="#h28-0-767" id="h28-0-767" class="i">+		return nil, false, nil
</a><a href="#h28-0-768" id="h28-0-768" class="i">+	}
</a><a href="#h28-0-769" id="h28-0-769" class="i">+
</a><a href="#h28-0-770" id="h28-0-770" class="i">+	// We now know that ft is a pointer or slice.
</a><a href="#h28-0-771" id="h28-0-771" class="i">+	sf = &amp;scalarField{kind: ft.Elem().Kind()}
</a><a href="#h28-0-772" id="h28-0-772" class="i">+
</a><a href="#h28-0-773" id="h28-0-773" class="i">+	// scalar fields without defaults
</a><a href="#h28-0-774" id="h28-0-774" class="i">+	if !prop.HasDefault {
</a><a href="#h28-0-775" id="h28-0-775" class="i">+		return sf, false, nil
</a><a href="#h28-0-776" id="h28-0-776" class="i">+	}
</a><a href="#h28-0-777" id="h28-0-777" class="i">+
</a><a href="#h28-0-778" id="h28-0-778" class="i">+	// a scalar field: either *T or []byte
</a><a href="#h28-0-779" id="h28-0-779" class="i">+	switch ft.Elem().Kind() {
</a><a href="#h28-0-780" id="h28-0-780" class="i">+	case reflect.Bool:
</a><a href="#h28-0-781" id="h28-0-781" class="i">+		x, err := strconv.ParseBool(prop.Default)
</a><a href="#h28-0-782" id="h28-0-782" class="i">+		if err != nil {
</a><a href="#h28-0-783" id="h28-0-783" class="i">+			return nil, false, fmt.Errorf(&quot;proto: bad default bool %q: %v&quot;, prop.Default, err)
</a><a href="#h28-0-784" id="h28-0-784" class="i">+		}
</a><a href="#h28-0-785" id="h28-0-785" class="i">+		sf.value = x
</a><a href="#h28-0-786" id="h28-0-786" class="i">+	case reflect.Float32:
</a><a href="#h28-0-787" id="h28-0-787" class="i">+		x, err := strconv.ParseFloat(prop.Default, 32)
</a><a href="#h28-0-788" id="h28-0-788" class="i">+		if err != nil {
</a><a href="#h28-0-789" id="h28-0-789" class="i">+			return nil, false, fmt.Errorf(&quot;proto: bad default float32 %q: %v&quot;, prop.Default, err)
</a><a href="#h28-0-790" id="h28-0-790" class="i">+		}
</a><a href="#h28-0-791" id="h28-0-791" class="i">+		sf.value = float32(x)
</a><a href="#h28-0-792" id="h28-0-792" class="i">+	case reflect.Float64:
</a><a href="#h28-0-793" id="h28-0-793" class="i">+		x, err := strconv.ParseFloat(prop.Default, 64)
</a><a href="#h28-0-794" id="h28-0-794" class="i">+		if err != nil {
</a><a href="#h28-0-795" id="h28-0-795" class="i">+			return nil, false, fmt.Errorf(&quot;proto: bad default float64 %q: %v&quot;, prop.Default, err)
</a><a href="#h28-0-796" id="h28-0-796" class="i">+		}
</a><a href="#h28-0-797" id="h28-0-797" class="i">+		sf.value = x
</a><a href="#h28-0-798" id="h28-0-798" class="i">+	case reflect.Int32:
</a><a href="#h28-0-799" id="h28-0-799" class="i">+		x, err := strconv.ParseInt(prop.Default, 10, 32)
</a><a href="#h28-0-800" id="h28-0-800" class="i">+		if err != nil {
</a><a href="#h28-0-801" id="h28-0-801" class="i">+			return nil, false, fmt.Errorf(&quot;proto: bad default int32 %q: %v&quot;, prop.Default, err)
</a><a href="#h28-0-802" id="h28-0-802" class="i">+		}
</a><a href="#h28-0-803" id="h28-0-803" class="i">+		sf.value = int32(x)
</a><a href="#h28-0-804" id="h28-0-804" class="i">+	case reflect.Int64:
</a><a href="#h28-0-805" id="h28-0-805" class="i">+		x, err := strconv.ParseInt(prop.Default, 10, 64)
</a><a href="#h28-0-806" id="h28-0-806" class="i">+		if err != nil {
</a><a href="#h28-0-807" id="h28-0-807" class="i">+			return nil, false, fmt.Errorf(&quot;proto: bad default int64 %q: %v&quot;, prop.Default, err)
</a><a href="#h28-0-808" id="h28-0-808" class="i">+		}
</a><a href="#h28-0-809" id="h28-0-809" class="i">+		sf.value = x
</a><a href="#h28-0-810" id="h28-0-810" class="i">+	case reflect.String:
</a><a href="#h28-0-811" id="h28-0-811" class="i">+		sf.value = prop.Default
</a><a href="#h28-0-812" id="h28-0-812" class="i">+	case reflect.Uint8:
</a><a href="#h28-0-813" id="h28-0-813" class="i">+		// []byte (not *uint8)
</a><a href="#h28-0-814" id="h28-0-814" class="i">+		sf.value = []byte(prop.Default)
</a><a href="#h28-0-815" id="h28-0-815" class="i">+	case reflect.Uint32:
</a><a href="#h28-0-816" id="h28-0-816" class="i">+		x, err := strconv.ParseUint(prop.Default, 10, 32)
</a><a href="#h28-0-817" id="h28-0-817" class="i">+		if err != nil {
</a><a href="#h28-0-818" id="h28-0-818" class="i">+			return nil, false, fmt.Errorf(&quot;proto: bad default uint32 %q: %v&quot;, prop.Default, err)
</a><a href="#h28-0-819" id="h28-0-819" class="i">+		}
</a><a href="#h28-0-820" id="h28-0-820" class="i">+		sf.value = uint32(x)
</a><a href="#h28-0-821" id="h28-0-821" class="i">+	case reflect.Uint64:
</a><a href="#h28-0-822" id="h28-0-822" class="i">+		x, err := strconv.ParseUint(prop.Default, 10, 64)
</a><a href="#h28-0-823" id="h28-0-823" class="i">+		if err != nil {
</a><a href="#h28-0-824" id="h28-0-824" class="i">+			return nil, false, fmt.Errorf(&quot;proto: bad default uint64 %q: %v&quot;, prop.Default, err)
</a><a href="#h28-0-825" id="h28-0-825" class="i">+		}
</a><a href="#h28-0-826" id="h28-0-826" class="i">+		sf.value = x
</a><a href="#h28-0-827" id="h28-0-827" class="i">+	default:
</a><a href="#h28-0-828" id="h28-0-828" class="i">+		return nil, false, fmt.Errorf(&quot;proto: unhandled def kind %v&quot;, ft.Elem().Kind())
</a><a href="#h28-0-829" id="h28-0-829" class="i">+	}
</a><a href="#h28-0-830" id="h28-0-830" class="i">+
</a><a href="#h28-0-831" id="h28-0-831" class="i">+	return sf, false, nil
</a><a href="#h28-0-832" id="h28-0-832" class="i">+}
</a><a href="#h28-0-833" id="h28-0-833" class="i">+
</a><a href="#h28-0-834" id="h28-0-834" class="i">+// Map fields may have key types of non-float scalars, strings and enums.
</a><a href="#h28-0-835" id="h28-0-835" class="i">+// The easiest way to sort them in some deterministic order is to use fmt.
</a><a href="#h28-0-836" id="h28-0-836" class="i">+// If this turns out to be inefficient we can always consider other options,
</a><a href="#h28-0-837" id="h28-0-837" class="i">+// such as doing a Schwartzian transform.
</a><a href="#h28-0-838" id="h28-0-838" class="i">+
</a><a href="#h28-0-839" id="h28-0-839" class="i">+func mapKeys(vs []reflect.Value) sort.Interface {
</a><a href="#h28-0-840" id="h28-0-840" class="i">+	s := mapKeySorter{
</a><a href="#h28-0-841" id="h28-0-841" class="i">+		vs: vs,
</a><a href="#h28-0-842" id="h28-0-842" class="i">+		// default Less function: textual comparison
</a><a href="#h28-0-843" id="h28-0-843" class="i">+		less: func(a, b reflect.Value) bool {
</a><a href="#h28-0-844" id="h28-0-844" class="i">+			return fmt.Sprint(a.Interface()) &lt; fmt.Sprint(b.Interface())
</a><a href="#h28-0-845" id="h28-0-845" class="i">+		},
</a><a href="#h28-0-846" id="h28-0-846" class="i">+	}
</a><a href="#h28-0-847" id="h28-0-847" class="i">+
</a><a href="#h28-0-848" id="h28-0-848" class="i">+	// Type specialization per https://developers.google.com/protocol-buffers/docs/proto#maps;
</a><a href="#h28-0-849" id="h28-0-849" class="i">+	// numeric keys are sorted numerically.
</a><a href="#h28-0-850" id="h28-0-850" class="i">+	if len(vs) == 0 {
</a><a href="#h28-0-851" id="h28-0-851" class="i">+		return s
</a><a href="#h28-0-852" id="h28-0-852" class="i">+	}
</a><a href="#h28-0-853" id="h28-0-853" class="i">+	switch vs[0].Kind() {
</a><a href="#h28-0-854" id="h28-0-854" class="i">+	case reflect.Int32, reflect.Int64:
</a><a href="#h28-0-855" id="h28-0-855" class="i">+		s.less = func(a, b reflect.Value) bool { return a.Int() &lt; b.Int() }
</a><a href="#h28-0-856" id="h28-0-856" class="i">+	case reflect.Uint32, reflect.Uint64:
</a><a href="#h28-0-857" id="h28-0-857" class="i">+		s.less = func(a, b reflect.Value) bool { return a.Uint() &lt; b.Uint() }
</a><a href="#h28-0-858" id="h28-0-858" class="i">+	}
</a><a href="#h28-0-859" id="h28-0-859" class="i">+
</a><a href="#h28-0-860" id="h28-0-860" class="i">+	return s
</a><a href="#h28-0-861" id="h28-0-861" class="i">+}
</a><a href="#h28-0-862" id="h28-0-862" class="i">+
</a><a href="#h28-0-863" id="h28-0-863" class="i">+type mapKeySorter struct {
</a><a href="#h28-0-864" id="h28-0-864" class="i">+	vs   []reflect.Value
</a><a href="#h28-0-865" id="h28-0-865" class="i">+	less func(a, b reflect.Value) bool
</a><a href="#h28-0-866" id="h28-0-866" class="i">+}
</a><a href="#h28-0-867" id="h28-0-867" class="i">+
</a><a href="#h28-0-868" id="h28-0-868" class="i">+func (s mapKeySorter) Len() int      { return len(s.vs) }
</a><a href="#h28-0-869" id="h28-0-869" class="i">+func (s mapKeySorter) Swap(i, j int) { s.vs[i], s.vs[j] = s.vs[j], s.vs[i] }
</a><a href="#h28-0-870" id="h28-0-870" class="i">+func (s mapKeySorter) Less(i, j int) bool {
</a><a href="#h28-0-871" id="h28-0-871" class="i">+	return s.less(s.vs[i], s.vs[j])
</a><a href="#h28-0-872" id="h28-0-872" class="i">+}
</a><a href="#h28-0-873" id="h28-0-873" class="i">+
</a><a href="#h28-0-874" id="h28-0-874" class="i">+// isProto3Zero reports whether v is a zero proto3 value.
</a><a href="#h28-0-875" id="h28-0-875" class="i">+func isProto3Zero(v reflect.Value) bool {
</a><a href="#h28-0-876" id="h28-0-876" class="i">+	switch v.Kind() {
</a><a href="#h28-0-877" id="h28-0-877" class="i">+	case reflect.Bool:
</a><a href="#h28-0-878" id="h28-0-878" class="i">+		return !v.Bool()
</a><a href="#h28-0-879" id="h28-0-879" class="i">+	case reflect.Int32, reflect.Int64:
</a><a href="#h28-0-880" id="h28-0-880" class="i">+		return v.Int() == 0
</a><a href="#h28-0-881" id="h28-0-881" class="i">+	case reflect.Uint32, reflect.Uint64:
</a><a href="#h28-0-882" id="h28-0-882" class="i">+		return v.Uint() == 0
</a><a href="#h28-0-883" id="h28-0-883" class="i">+	case reflect.Float32, reflect.Float64:
</a><a href="#h28-0-884" id="h28-0-884" class="i">+		return v.Float() == 0
</a><a href="#h28-0-885" id="h28-0-885" class="i">+	case reflect.String:
</a><a href="#h28-0-886" id="h28-0-886" class="i">+		return v.String() == &quot;&quot;
</a><a href="#h28-0-887" id="h28-0-887" class="i">+	}
</a><a href="#h28-0-888" id="h28-0-888" class="i">+	return false
</a><a href="#h28-0-889" id="h28-0-889" class="i">+}
</a><a href="#h28-0-890" id="h28-0-890" class="i">+
</a><a href="#h28-0-891" id="h28-0-891" class="i">+// ProtoPackageIsVersion2 is referenced from generated protocol buffer files
</a><a href="#h28-0-892" id="h28-0-892" class="i">+// to assert that that code is compatible with this version of the proto package.
</a><a href="#h28-0-893" id="h28-0-893" class="i">+const ProtoPackageIsVersion2 = true
</a><a href="#h28-0-894" id="h28-0-894" class="i">+
</a><a href="#h28-0-895" id="h28-0-895" class="i">+// ProtoPackageIsVersion1 is referenced from generated protocol buffer files
</a><a href="#h28-0-896" id="h28-0-896" class="i">+// to assert that that code is compatible with this version of the proto package.
</a><a href="#h28-0-897" id="h28-0-897" class="i">+const ProtoPackageIsVersion1 = true
</a><b>diff --git a/<a id="h29" href="../file/vendor/github.com/golang/protobuf/proto/message_set.go">vendor/github.com/golang/protobuf/proto/message_set.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/message_set.go">vendor/github.com/golang/protobuf/proto/message_set.go</a></b>
<a href="#h29-0" id="h29-0" class="h">@@ -0,0 +1,311 @@
</a><a href="#h29-0-0" id="h29-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h29-0-1" id="h29-0-1" class="i">+//
</a><a href="#h29-0-2" id="h29-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h29-0-3" id="h29-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h29-0-4" id="h29-0-4" class="i">+//
</a><a href="#h29-0-5" id="h29-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h29-0-6" id="h29-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h29-0-7" id="h29-0-7" class="i">+// met:
</a><a href="#h29-0-8" id="h29-0-8" class="i">+//
</a><a href="#h29-0-9" id="h29-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h29-0-10" id="h29-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h29-0-11" id="h29-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h29-0-12" id="h29-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h29-0-13" id="h29-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h29-0-14" id="h29-0-14" class="i">+// distribution.
</a><a href="#h29-0-15" id="h29-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h29-0-16" id="h29-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h29-0-17" id="h29-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h29-0-18" id="h29-0-18" class="i">+//
</a><a href="#h29-0-19" id="h29-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h29-0-20" id="h29-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h29-0-21" id="h29-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h29-0-22" id="h29-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h29-0-23" id="h29-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h29-0-24" id="h29-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h29-0-25" id="h29-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h29-0-26" id="h29-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h29-0-27" id="h29-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h29-0-28" id="h29-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h29-0-29" id="h29-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h29-0-30" id="h29-0-30" class="i">+
</a><a href="#h29-0-31" id="h29-0-31" class="i">+package proto
</a><a href="#h29-0-32" id="h29-0-32" class="i">+
</a><a href="#h29-0-33" id="h29-0-33" class="i">+/*
</a><a href="#h29-0-34" id="h29-0-34" class="i">+ * Support for message sets.
</a><a href="#h29-0-35" id="h29-0-35" class="i">+ */
</a><a href="#h29-0-36" id="h29-0-36" class="i">+
</a><a href="#h29-0-37" id="h29-0-37" class="i">+import (
</a><a href="#h29-0-38" id="h29-0-38" class="i">+	&quot;bytes&quot;
</a><a href="#h29-0-39" id="h29-0-39" class="i">+	&quot;encoding/json&quot;
</a><a href="#h29-0-40" id="h29-0-40" class="i">+	&quot;errors&quot;
</a><a href="#h29-0-41" id="h29-0-41" class="i">+	&quot;fmt&quot;
</a><a href="#h29-0-42" id="h29-0-42" class="i">+	&quot;reflect&quot;
</a><a href="#h29-0-43" id="h29-0-43" class="i">+	&quot;sort&quot;
</a><a href="#h29-0-44" id="h29-0-44" class="i">+)
</a><a href="#h29-0-45" id="h29-0-45" class="i">+
</a><a href="#h29-0-46" id="h29-0-46" class="i">+// errNoMessageTypeID occurs when a protocol buffer does not have a message type ID.
</a><a href="#h29-0-47" id="h29-0-47" class="i">+// A message type ID is required for storing a protocol buffer in a message set.
</a><a href="#h29-0-48" id="h29-0-48" class="i">+var errNoMessageTypeID = errors.New(&quot;proto does not have a message type ID&quot;)
</a><a href="#h29-0-49" id="h29-0-49" class="i">+
</a><a href="#h29-0-50" id="h29-0-50" class="i">+// The first two types (_MessageSet_Item and messageSet)
</a><a href="#h29-0-51" id="h29-0-51" class="i">+// model what the protocol compiler produces for the following protocol message:
</a><a href="#h29-0-52" id="h29-0-52" class="i">+//   message MessageSet {
</a><a href="#h29-0-53" id="h29-0-53" class="i">+//     repeated group Item = 1 {
</a><a href="#h29-0-54" id="h29-0-54" class="i">+//       required int32 type_id = 2;
</a><a href="#h29-0-55" id="h29-0-55" class="i">+//       required string message = 3;
</a><a href="#h29-0-56" id="h29-0-56" class="i">+//     };
</a><a href="#h29-0-57" id="h29-0-57" class="i">+//   }
</a><a href="#h29-0-58" id="h29-0-58" class="i">+// That is the MessageSet wire format. We can&#39;t use a proto to generate these
</a><a href="#h29-0-59" id="h29-0-59" class="i">+// because that would introduce a circular dependency between it and this package.
</a><a href="#h29-0-60" id="h29-0-60" class="i">+
</a><a href="#h29-0-61" id="h29-0-61" class="i">+type _MessageSet_Item struct {
</a><a href="#h29-0-62" id="h29-0-62" class="i">+	TypeId  *int32 `protobuf:&quot;varint,2,req,name=type_id&quot;`
</a><a href="#h29-0-63" id="h29-0-63" class="i">+	Message []byte `protobuf:&quot;bytes,3,req,name=message&quot;`
</a><a href="#h29-0-64" id="h29-0-64" class="i">+}
</a><a href="#h29-0-65" id="h29-0-65" class="i">+
</a><a href="#h29-0-66" id="h29-0-66" class="i">+type messageSet struct {
</a><a href="#h29-0-67" id="h29-0-67" class="i">+	Item             []*_MessageSet_Item `protobuf:&quot;group,1,rep&quot;`
</a><a href="#h29-0-68" id="h29-0-68" class="i">+	XXX_unrecognized []byte
</a><a href="#h29-0-69" id="h29-0-69" class="i">+	// TODO: caching?
</a><a href="#h29-0-70" id="h29-0-70" class="i">+}
</a><a href="#h29-0-71" id="h29-0-71" class="i">+
</a><a href="#h29-0-72" id="h29-0-72" class="i">+// Make sure messageSet is a Message.
</a><a href="#h29-0-73" id="h29-0-73" class="i">+var _ Message = (*messageSet)(nil)
</a><a href="#h29-0-74" id="h29-0-74" class="i">+
</a><a href="#h29-0-75" id="h29-0-75" class="i">+// messageTypeIder is an interface satisfied by a protocol buffer type
</a><a href="#h29-0-76" id="h29-0-76" class="i">+// that may be stored in a MessageSet.
</a><a href="#h29-0-77" id="h29-0-77" class="i">+type messageTypeIder interface {
</a><a href="#h29-0-78" id="h29-0-78" class="i">+	MessageTypeId() int32
</a><a href="#h29-0-79" id="h29-0-79" class="i">+}
</a><a href="#h29-0-80" id="h29-0-80" class="i">+
</a><a href="#h29-0-81" id="h29-0-81" class="i">+func (ms *messageSet) find(pb Message) *_MessageSet_Item {
</a><a href="#h29-0-82" id="h29-0-82" class="i">+	mti, ok := pb.(messageTypeIder)
</a><a href="#h29-0-83" id="h29-0-83" class="i">+	if !ok {
</a><a href="#h29-0-84" id="h29-0-84" class="i">+		return nil
</a><a href="#h29-0-85" id="h29-0-85" class="i">+	}
</a><a href="#h29-0-86" id="h29-0-86" class="i">+	id := mti.MessageTypeId()
</a><a href="#h29-0-87" id="h29-0-87" class="i">+	for _, item := range ms.Item {
</a><a href="#h29-0-88" id="h29-0-88" class="i">+		if *item.TypeId == id {
</a><a href="#h29-0-89" id="h29-0-89" class="i">+			return item
</a><a href="#h29-0-90" id="h29-0-90" class="i">+		}
</a><a href="#h29-0-91" id="h29-0-91" class="i">+	}
</a><a href="#h29-0-92" id="h29-0-92" class="i">+	return nil
</a><a href="#h29-0-93" id="h29-0-93" class="i">+}
</a><a href="#h29-0-94" id="h29-0-94" class="i">+
</a><a href="#h29-0-95" id="h29-0-95" class="i">+func (ms *messageSet) Has(pb Message) bool {
</a><a href="#h29-0-96" id="h29-0-96" class="i">+	if ms.find(pb) != nil {
</a><a href="#h29-0-97" id="h29-0-97" class="i">+		return true
</a><a href="#h29-0-98" id="h29-0-98" class="i">+	}
</a><a href="#h29-0-99" id="h29-0-99" class="i">+	return false
</a><a href="#h29-0-100" id="h29-0-100" class="i">+}
</a><a href="#h29-0-101" id="h29-0-101" class="i">+
</a><a href="#h29-0-102" id="h29-0-102" class="i">+func (ms *messageSet) Unmarshal(pb Message) error {
</a><a href="#h29-0-103" id="h29-0-103" class="i">+	if item := ms.find(pb); item != nil {
</a><a href="#h29-0-104" id="h29-0-104" class="i">+		return Unmarshal(item.Message, pb)
</a><a href="#h29-0-105" id="h29-0-105" class="i">+	}
</a><a href="#h29-0-106" id="h29-0-106" class="i">+	if _, ok := pb.(messageTypeIder); !ok {
</a><a href="#h29-0-107" id="h29-0-107" class="i">+		return errNoMessageTypeID
</a><a href="#h29-0-108" id="h29-0-108" class="i">+	}
</a><a href="#h29-0-109" id="h29-0-109" class="i">+	return nil // TODO: return error instead?
</a><a href="#h29-0-110" id="h29-0-110" class="i">+}
</a><a href="#h29-0-111" id="h29-0-111" class="i">+
</a><a href="#h29-0-112" id="h29-0-112" class="i">+func (ms *messageSet) Marshal(pb Message) error {
</a><a href="#h29-0-113" id="h29-0-113" class="i">+	msg, err := Marshal(pb)
</a><a href="#h29-0-114" id="h29-0-114" class="i">+	if err != nil {
</a><a href="#h29-0-115" id="h29-0-115" class="i">+		return err
</a><a href="#h29-0-116" id="h29-0-116" class="i">+	}
</a><a href="#h29-0-117" id="h29-0-117" class="i">+	if item := ms.find(pb); item != nil {
</a><a href="#h29-0-118" id="h29-0-118" class="i">+		// reuse existing item
</a><a href="#h29-0-119" id="h29-0-119" class="i">+		item.Message = msg
</a><a href="#h29-0-120" id="h29-0-120" class="i">+		return nil
</a><a href="#h29-0-121" id="h29-0-121" class="i">+	}
</a><a href="#h29-0-122" id="h29-0-122" class="i">+
</a><a href="#h29-0-123" id="h29-0-123" class="i">+	mti, ok := pb.(messageTypeIder)
</a><a href="#h29-0-124" id="h29-0-124" class="i">+	if !ok {
</a><a href="#h29-0-125" id="h29-0-125" class="i">+		return errNoMessageTypeID
</a><a href="#h29-0-126" id="h29-0-126" class="i">+	}
</a><a href="#h29-0-127" id="h29-0-127" class="i">+
</a><a href="#h29-0-128" id="h29-0-128" class="i">+	mtid := mti.MessageTypeId()
</a><a href="#h29-0-129" id="h29-0-129" class="i">+	ms.Item = append(ms.Item, &amp;_MessageSet_Item{
</a><a href="#h29-0-130" id="h29-0-130" class="i">+		TypeId:  &amp;mtid,
</a><a href="#h29-0-131" id="h29-0-131" class="i">+		Message: msg,
</a><a href="#h29-0-132" id="h29-0-132" class="i">+	})
</a><a href="#h29-0-133" id="h29-0-133" class="i">+	return nil
</a><a href="#h29-0-134" id="h29-0-134" class="i">+}
</a><a href="#h29-0-135" id="h29-0-135" class="i">+
</a><a href="#h29-0-136" id="h29-0-136" class="i">+func (ms *messageSet) Reset()         { *ms = messageSet{} }
</a><a href="#h29-0-137" id="h29-0-137" class="i">+func (ms *messageSet) String() string { return CompactTextString(ms) }
</a><a href="#h29-0-138" id="h29-0-138" class="i">+func (*messageSet) ProtoMessage()     {}
</a><a href="#h29-0-139" id="h29-0-139" class="i">+
</a><a href="#h29-0-140" id="h29-0-140" class="i">+// Support for the message_set_wire_format message option.
</a><a href="#h29-0-141" id="h29-0-141" class="i">+
</a><a href="#h29-0-142" id="h29-0-142" class="i">+func skipVarint(buf []byte) []byte {
</a><a href="#h29-0-143" id="h29-0-143" class="i">+	i := 0
</a><a href="#h29-0-144" id="h29-0-144" class="i">+	for ; buf[i]&amp;0x80 != 0; i++ {
</a><a href="#h29-0-145" id="h29-0-145" class="i">+	}
</a><a href="#h29-0-146" id="h29-0-146" class="i">+	return buf[i+1:]
</a><a href="#h29-0-147" id="h29-0-147" class="i">+}
</a><a href="#h29-0-148" id="h29-0-148" class="i">+
</a><a href="#h29-0-149" id="h29-0-149" class="i">+// MarshalMessageSet encodes the extension map represented by m in the message set wire format.
</a><a href="#h29-0-150" id="h29-0-150" class="i">+// It is called by generated Marshal methods on protocol buffer messages with the message_set_wire_format option.
</a><a href="#h29-0-151" id="h29-0-151" class="i">+func MarshalMessageSet(exts interface{}) ([]byte, error) {
</a><a href="#h29-0-152" id="h29-0-152" class="i">+	var m map[int32]Extension
</a><a href="#h29-0-153" id="h29-0-153" class="i">+	switch exts := exts.(type) {
</a><a href="#h29-0-154" id="h29-0-154" class="i">+	case *XXX_InternalExtensions:
</a><a href="#h29-0-155" id="h29-0-155" class="i">+		if err := encodeExtensions(exts); err != nil {
</a><a href="#h29-0-156" id="h29-0-156" class="i">+			return nil, err
</a><a href="#h29-0-157" id="h29-0-157" class="i">+		}
</a><a href="#h29-0-158" id="h29-0-158" class="i">+		m, _ = exts.extensionsRead()
</a><a href="#h29-0-159" id="h29-0-159" class="i">+	case map[int32]Extension:
</a><a href="#h29-0-160" id="h29-0-160" class="i">+		if err := encodeExtensionsMap(exts); err != nil {
</a><a href="#h29-0-161" id="h29-0-161" class="i">+			return nil, err
</a><a href="#h29-0-162" id="h29-0-162" class="i">+		}
</a><a href="#h29-0-163" id="h29-0-163" class="i">+		m = exts
</a><a href="#h29-0-164" id="h29-0-164" class="i">+	default:
</a><a href="#h29-0-165" id="h29-0-165" class="i">+		return nil, errors.New(&quot;proto: not an extension map&quot;)
</a><a href="#h29-0-166" id="h29-0-166" class="i">+	}
</a><a href="#h29-0-167" id="h29-0-167" class="i">+
</a><a href="#h29-0-168" id="h29-0-168" class="i">+	// Sort extension IDs to provide a deterministic encoding.
</a><a href="#h29-0-169" id="h29-0-169" class="i">+	// See also enc_map in encode.go.
</a><a href="#h29-0-170" id="h29-0-170" class="i">+	ids := make([]int, 0, len(m))
</a><a href="#h29-0-171" id="h29-0-171" class="i">+	for id := range m {
</a><a href="#h29-0-172" id="h29-0-172" class="i">+		ids = append(ids, int(id))
</a><a href="#h29-0-173" id="h29-0-173" class="i">+	}
</a><a href="#h29-0-174" id="h29-0-174" class="i">+	sort.Ints(ids)
</a><a href="#h29-0-175" id="h29-0-175" class="i">+
</a><a href="#h29-0-176" id="h29-0-176" class="i">+	ms := &amp;messageSet{Item: make([]*_MessageSet_Item, 0, len(m))}
</a><a href="#h29-0-177" id="h29-0-177" class="i">+	for _, id := range ids {
</a><a href="#h29-0-178" id="h29-0-178" class="i">+		e := m[int32(id)]
</a><a href="#h29-0-179" id="h29-0-179" class="i">+		// Remove the wire type and field number varint, as well as the length varint.
</a><a href="#h29-0-180" id="h29-0-180" class="i">+		msg := skipVarint(skipVarint(e.enc))
</a><a href="#h29-0-181" id="h29-0-181" class="i">+
</a><a href="#h29-0-182" id="h29-0-182" class="i">+		ms.Item = append(ms.Item, &amp;_MessageSet_Item{
</a><a href="#h29-0-183" id="h29-0-183" class="i">+			TypeId:  Int32(int32(id)),
</a><a href="#h29-0-184" id="h29-0-184" class="i">+			Message: msg,
</a><a href="#h29-0-185" id="h29-0-185" class="i">+		})
</a><a href="#h29-0-186" id="h29-0-186" class="i">+	}
</a><a href="#h29-0-187" id="h29-0-187" class="i">+	return Marshal(ms)
</a><a href="#h29-0-188" id="h29-0-188" class="i">+}
</a><a href="#h29-0-189" id="h29-0-189" class="i">+
</a><a href="#h29-0-190" id="h29-0-190" class="i">+// UnmarshalMessageSet decodes the extension map encoded in buf in the message set wire format.
</a><a href="#h29-0-191" id="h29-0-191" class="i">+// It is called by generated Unmarshal methods on protocol buffer messages with the message_set_wire_format option.
</a><a href="#h29-0-192" id="h29-0-192" class="i">+func UnmarshalMessageSet(buf []byte, exts interface{}) error {
</a><a href="#h29-0-193" id="h29-0-193" class="i">+	var m map[int32]Extension
</a><a href="#h29-0-194" id="h29-0-194" class="i">+	switch exts := exts.(type) {
</a><a href="#h29-0-195" id="h29-0-195" class="i">+	case *XXX_InternalExtensions:
</a><a href="#h29-0-196" id="h29-0-196" class="i">+		m = exts.extensionsWrite()
</a><a href="#h29-0-197" id="h29-0-197" class="i">+	case map[int32]Extension:
</a><a href="#h29-0-198" id="h29-0-198" class="i">+		m = exts
</a><a href="#h29-0-199" id="h29-0-199" class="i">+	default:
</a><a href="#h29-0-200" id="h29-0-200" class="i">+		return errors.New(&quot;proto: not an extension map&quot;)
</a><a href="#h29-0-201" id="h29-0-201" class="i">+	}
</a><a href="#h29-0-202" id="h29-0-202" class="i">+
</a><a href="#h29-0-203" id="h29-0-203" class="i">+	ms := new(messageSet)
</a><a href="#h29-0-204" id="h29-0-204" class="i">+	if err := Unmarshal(buf, ms); err != nil {
</a><a href="#h29-0-205" id="h29-0-205" class="i">+		return err
</a><a href="#h29-0-206" id="h29-0-206" class="i">+	}
</a><a href="#h29-0-207" id="h29-0-207" class="i">+	for _, item := range ms.Item {
</a><a href="#h29-0-208" id="h29-0-208" class="i">+		id := *item.TypeId
</a><a href="#h29-0-209" id="h29-0-209" class="i">+		msg := item.Message
</a><a href="#h29-0-210" id="h29-0-210" class="i">+
</a><a href="#h29-0-211" id="h29-0-211" class="i">+		// Restore wire type and field number varint, plus length varint.
</a><a href="#h29-0-212" id="h29-0-212" class="i">+		// Be careful to preserve duplicate items.
</a><a href="#h29-0-213" id="h29-0-213" class="i">+		b := EncodeVarint(uint64(id)&lt;&lt;3 | WireBytes)
</a><a href="#h29-0-214" id="h29-0-214" class="i">+		if ext, ok := m[id]; ok {
</a><a href="#h29-0-215" id="h29-0-215" class="i">+			// Existing data; rip off the tag and length varint
</a><a href="#h29-0-216" id="h29-0-216" class="i">+			// so we join the new data correctly.
</a><a href="#h29-0-217" id="h29-0-217" class="i">+			// We can assume that ext.enc is set because we are unmarshaling.
</a><a href="#h29-0-218" id="h29-0-218" class="i">+			o := ext.enc[len(b):]   // skip wire type and field number
</a><a href="#h29-0-219" id="h29-0-219" class="i">+			_, n := DecodeVarint(o) // calculate length of length varint
</a><a href="#h29-0-220" id="h29-0-220" class="i">+			o = o[n:]               // skip length varint
</a><a href="#h29-0-221" id="h29-0-221" class="i">+			msg = append(o, msg...) // join old data and new data
</a><a href="#h29-0-222" id="h29-0-222" class="i">+		}
</a><a href="#h29-0-223" id="h29-0-223" class="i">+		b = append(b, EncodeVarint(uint64(len(msg)))...)
</a><a href="#h29-0-224" id="h29-0-224" class="i">+		b = append(b, msg...)
</a><a href="#h29-0-225" id="h29-0-225" class="i">+
</a><a href="#h29-0-226" id="h29-0-226" class="i">+		m[id] = Extension{enc: b}
</a><a href="#h29-0-227" id="h29-0-227" class="i">+	}
</a><a href="#h29-0-228" id="h29-0-228" class="i">+	return nil
</a><a href="#h29-0-229" id="h29-0-229" class="i">+}
</a><a href="#h29-0-230" id="h29-0-230" class="i">+
</a><a href="#h29-0-231" id="h29-0-231" class="i">+// MarshalMessageSetJSON encodes the extension map represented by m in JSON format.
</a><a href="#h29-0-232" id="h29-0-232" class="i">+// It is called by generated MarshalJSON methods on protocol buffer messages with the message_set_wire_format option.
</a><a href="#h29-0-233" id="h29-0-233" class="i">+func MarshalMessageSetJSON(exts interface{}) ([]byte, error) {
</a><a href="#h29-0-234" id="h29-0-234" class="i">+	var m map[int32]Extension
</a><a href="#h29-0-235" id="h29-0-235" class="i">+	switch exts := exts.(type) {
</a><a href="#h29-0-236" id="h29-0-236" class="i">+	case *XXX_InternalExtensions:
</a><a href="#h29-0-237" id="h29-0-237" class="i">+		m, _ = exts.extensionsRead()
</a><a href="#h29-0-238" id="h29-0-238" class="i">+	case map[int32]Extension:
</a><a href="#h29-0-239" id="h29-0-239" class="i">+		m = exts
</a><a href="#h29-0-240" id="h29-0-240" class="i">+	default:
</a><a href="#h29-0-241" id="h29-0-241" class="i">+		return nil, errors.New(&quot;proto: not an extension map&quot;)
</a><a href="#h29-0-242" id="h29-0-242" class="i">+	}
</a><a href="#h29-0-243" id="h29-0-243" class="i">+	var b bytes.Buffer
</a><a href="#h29-0-244" id="h29-0-244" class="i">+	b.WriteByte(&#39;{&#39;)
</a><a href="#h29-0-245" id="h29-0-245" class="i">+
</a><a href="#h29-0-246" id="h29-0-246" class="i">+	// Process the map in key order for deterministic output.
</a><a href="#h29-0-247" id="h29-0-247" class="i">+	ids := make([]int32, 0, len(m))
</a><a href="#h29-0-248" id="h29-0-248" class="i">+	for id := range m {
</a><a href="#h29-0-249" id="h29-0-249" class="i">+		ids = append(ids, id)
</a><a href="#h29-0-250" id="h29-0-250" class="i">+	}
</a><a href="#h29-0-251" id="h29-0-251" class="i">+	sort.Sort(int32Slice(ids)) // int32Slice defined in text.go
</a><a href="#h29-0-252" id="h29-0-252" class="i">+
</a><a href="#h29-0-253" id="h29-0-253" class="i">+	for i, id := range ids {
</a><a href="#h29-0-254" id="h29-0-254" class="i">+		ext := m[id]
</a><a href="#h29-0-255" id="h29-0-255" class="i">+		if i &gt; 0 {
</a><a href="#h29-0-256" id="h29-0-256" class="i">+			b.WriteByte(&#39;,&#39;)
</a><a href="#h29-0-257" id="h29-0-257" class="i">+		}
</a><a href="#h29-0-258" id="h29-0-258" class="i">+
</a><a href="#h29-0-259" id="h29-0-259" class="i">+		msd, ok := messageSetMap[id]
</a><a href="#h29-0-260" id="h29-0-260" class="i">+		if !ok {
</a><a href="#h29-0-261" id="h29-0-261" class="i">+			// Unknown type; we can&#39;t render it, so skip it.
</a><a href="#h29-0-262" id="h29-0-262" class="i">+			continue
</a><a href="#h29-0-263" id="h29-0-263" class="i">+		}
</a><a href="#h29-0-264" id="h29-0-264" class="i">+		fmt.Fprintf(&amp;b, `&quot;[%s]&quot;:`, msd.name)
</a><a href="#h29-0-265" id="h29-0-265" class="i">+
</a><a href="#h29-0-266" id="h29-0-266" class="i">+		x := ext.value
</a><a href="#h29-0-267" id="h29-0-267" class="i">+		if x == nil {
</a><a href="#h29-0-268" id="h29-0-268" class="i">+			x = reflect.New(msd.t.Elem()).Interface()
</a><a href="#h29-0-269" id="h29-0-269" class="i">+			if err := Unmarshal(ext.enc, x.(Message)); err != nil {
</a><a href="#h29-0-270" id="h29-0-270" class="i">+				return nil, err
</a><a href="#h29-0-271" id="h29-0-271" class="i">+			}
</a><a href="#h29-0-272" id="h29-0-272" class="i">+		}
</a><a href="#h29-0-273" id="h29-0-273" class="i">+		d, err := json.Marshal(x)
</a><a href="#h29-0-274" id="h29-0-274" class="i">+		if err != nil {
</a><a href="#h29-0-275" id="h29-0-275" class="i">+			return nil, err
</a><a href="#h29-0-276" id="h29-0-276" class="i">+		}
</a><a href="#h29-0-277" id="h29-0-277" class="i">+		b.Write(d)
</a><a href="#h29-0-278" id="h29-0-278" class="i">+	}
</a><a href="#h29-0-279" id="h29-0-279" class="i">+	b.WriteByte(&#39;}&#39;)
</a><a href="#h29-0-280" id="h29-0-280" class="i">+	return b.Bytes(), nil
</a><a href="#h29-0-281" id="h29-0-281" class="i">+}
</a><a href="#h29-0-282" id="h29-0-282" class="i">+
</a><a href="#h29-0-283" id="h29-0-283" class="i">+// UnmarshalMessageSetJSON decodes the extension map encoded in buf in JSON format.
</a><a href="#h29-0-284" id="h29-0-284" class="i">+// It is called by generated UnmarshalJSON methods on protocol buffer messages with the message_set_wire_format option.
</a><a href="#h29-0-285" id="h29-0-285" class="i">+func UnmarshalMessageSetJSON(buf []byte, exts interface{}) error {
</a><a href="#h29-0-286" id="h29-0-286" class="i">+	// Common-case fast path.
</a><a href="#h29-0-287" id="h29-0-287" class="i">+	if len(buf) == 0 || bytes.Equal(buf, []byte(&quot;{}&quot;)) {
</a><a href="#h29-0-288" id="h29-0-288" class="i">+		return nil
</a><a href="#h29-0-289" id="h29-0-289" class="i">+	}
</a><a href="#h29-0-290" id="h29-0-290" class="i">+
</a><a href="#h29-0-291" id="h29-0-291" class="i">+	// This is fairly tricky, and it&#39;s not clear that it is needed.
</a><a href="#h29-0-292" id="h29-0-292" class="i">+	return errors.New(&quot;TODO: UnmarshalMessageSetJSON not yet implemented&quot;)
</a><a href="#h29-0-293" id="h29-0-293" class="i">+}
</a><a href="#h29-0-294" id="h29-0-294" class="i">+
</a><a href="#h29-0-295" id="h29-0-295" class="i">+// A global registry of types that can be used in a MessageSet.
</a><a href="#h29-0-296" id="h29-0-296" class="i">+
</a><a href="#h29-0-297" id="h29-0-297" class="i">+var messageSetMap = make(map[int32]messageSetDesc)
</a><a href="#h29-0-298" id="h29-0-298" class="i">+
</a><a href="#h29-0-299" id="h29-0-299" class="i">+type messageSetDesc struct {
</a><a href="#h29-0-300" id="h29-0-300" class="i">+	t    reflect.Type // pointer to struct
</a><a href="#h29-0-301" id="h29-0-301" class="i">+	name string
</a><a href="#h29-0-302" id="h29-0-302" class="i">+}
</a><a href="#h29-0-303" id="h29-0-303" class="i">+
</a><a href="#h29-0-304" id="h29-0-304" class="i">+// RegisterMessageSetType is called from the generated code.
</a><a href="#h29-0-305" id="h29-0-305" class="i">+func RegisterMessageSetType(m Message, fieldNum int32, name string) {
</a><a href="#h29-0-306" id="h29-0-306" class="i">+	messageSetMap[fieldNum] = messageSetDesc{
</a><a href="#h29-0-307" id="h29-0-307" class="i">+		t:    reflect.TypeOf(m),
</a><a href="#h29-0-308" id="h29-0-308" class="i">+		name: name,
</a><a href="#h29-0-309" id="h29-0-309" class="i">+	}
</a><a href="#h29-0-310" id="h29-0-310" class="i">+}
</a><b>diff --git a/<a id="h30" href="../file/vendor/github.com/golang/protobuf/proto/pointer_reflect.go">vendor/github.com/golang/protobuf/proto/pointer_reflect.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/pointer_reflect.go">vendor/github.com/golang/protobuf/proto/pointer_reflect.go</a></b>
<a href="#h30-0" id="h30-0" class="h">@@ -0,0 +1,484 @@
</a><a href="#h30-0-0" id="h30-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h30-0-1" id="h30-0-1" class="i">+//
</a><a href="#h30-0-2" id="h30-0-2" class="i">+// Copyright 2012 The Go Authors.  All rights reserved.
</a><a href="#h30-0-3" id="h30-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h30-0-4" id="h30-0-4" class="i">+//
</a><a href="#h30-0-5" id="h30-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h30-0-6" id="h30-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h30-0-7" id="h30-0-7" class="i">+// met:
</a><a href="#h30-0-8" id="h30-0-8" class="i">+//
</a><a href="#h30-0-9" id="h30-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h30-0-10" id="h30-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h30-0-11" id="h30-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h30-0-12" id="h30-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h30-0-13" id="h30-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h30-0-14" id="h30-0-14" class="i">+// distribution.
</a><a href="#h30-0-15" id="h30-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h30-0-16" id="h30-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h30-0-17" id="h30-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h30-0-18" id="h30-0-18" class="i">+//
</a><a href="#h30-0-19" id="h30-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h30-0-20" id="h30-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h30-0-21" id="h30-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h30-0-22" id="h30-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h30-0-23" id="h30-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h30-0-24" id="h30-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h30-0-25" id="h30-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h30-0-26" id="h30-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h30-0-27" id="h30-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h30-0-28" id="h30-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h30-0-29" id="h30-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h30-0-30" id="h30-0-30" class="i">+
</a><a href="#h30-0-31" id="h30-0-31" class="i">+// +build appengine js
</a><a href="#h30-0-32" id="h30-0-32" class="i">+
</a><a href="#h30-0-33" id="h30-0-33" class="i">+// This file contains an implementation of proto field accesses using package reflect.
</a><a href="#h30-0-34" id="h30-0-34" class="i">+// It is slower than the code in pointer_unsafe.go but it avoids package unsafe and can
</a><a href="#h30-0-35" id="h30-0-35" class="i">+// be used on App Engine.
</a><a href="#h30-0-36" id="h30-0-36" class="i">+
</a><a href="#h30-0-37" id="h30-0-37" class="i">+package proto
</a><a href="#h30-0-38" id="h30-0-38" class="i">+
</a><a href="#h30-0-39" id="h30-0-39" class="i">+import (
</a><a href="#h30-0-40" id="h30-0-40" class="i">+	&quot;math&quot;
</a><a href="#h30-0-41" id="h30-0-41" class="i">+	&quot;reflect&quot;
</a><a href="#h30-0-42" id="h30-0-42" class="i">+)
</a><a href="#h30-0-43" id="h30-0-43" class="i">+
</a><a href="#h30-0-44" id="h30-0-44" class="i">+// A structPointer is a pointer to a struct.
</a><a href="#h30-0-45" id="h30-0-45" class="i">+type structPointer struct {
</a><a href="#h30-0-46" id="h30-0-46" class="i">+	v reflect.Value
</a><a href="#h30-0-47" id="h30-0-47" class="i">+}
</a><a href="#h30-0-48" id="h30-0-48" class="i">+
</a><a href="#h30-0-49" id="h30-0-49" class="i">+// toStructPointer returns a structPointer equivalent to the given reflect value.
</a><a href="#h30-0-50" id="h30-0-50" class="i">+// The reflect value must itself be a pointer to a struct.
</a><a href="#h30-0-51" id="h30-0-51" class="i">+func toStructPointer(v reflect.Value) structPointer {
</a><a href="#h30-0-52" id="h30-0-52" class="i">+	return structPointer{v}
</a><a href="#h30-0-53" id="h30-0-53" class="i">+}
</a><a href="#h30-0-54" id="h30-0-54" class="i">+
</a><a href="#h30-0-55" id="h30-0-55" class="i">+// IsNil reports whether p is nil.
</a><a href="#h30-0-56" id="h30-0-56" class="i">+func structPointer_IsNil(p structPointer) bool {
</a><a href="#h30-0-57" id="h30-0-57" class="i">+	return p.v.IsNil()
</a><a href="#h30-0-58" id="h30-0-58" class="i">+}
</a><a href="#h30-0-59" id="h30-0-59" class="i">+
</a><a href="#h30-0-60" id="h30-0-60" class="i">+// Interface returns the struct pointer as an interface value.
</a><a href="#h30-0-61" id="h30-0-61" class="i">+func structPointer_Interface(p structPointer, _ reflect.Type) interface{} {
</a><a href="#h30-0-62" id="h30-0-62" class="i">+	return p.v.Interface()
</a><a href="#h30-0-63" id="h30-0-63" class="i">+}
</a><a href="#h30-0-64" id="h30-0-64" class="i">+
</a><a href="#h30-0-65" id="h30-0-65" class="i">+// A field identifies a field in a struct, accessible from a structPointer.
</a><a href="#h30-0-66" id="h30-0-66" class="i">+// In this implementation, a field is identified by the sequence of field indices
</a><a href="#h30-0-67" id="h30-0-67" class="i">+// passed to reflect&#39;s FieldByIndex.
</a><a href="#h30-0-68" id="h30-0-68" class="i">+type field []int
</a><a href="#h30-0-69" id="h30-0-69" class="i">+
</a><a href="#h30-0-70" id="h30-0-70" class="i">+// toField returns a field equivalent to the given reflect field.
</a><a href="#h30-0-71" id="h30-0-71" class="i">+func toField(f *reflect.StructField) field {
</a><a href="#h30-0-72" id="h30-0-72" class="i">+	return f.Index
</a><a href="#h30-0-73" id="h30-0-73" class="i">+}
</a><a href="#h30-0-74" id="h30-0-74" class="i">+
</a><a href="#h30-0-75" id="h30-0-75" class="i">+// invalidField is an invalid field identifier.
</a><a href="#h30-0-76" id="h30-0-76" class="i">+var invalidField = field(nil)
</a><a href="#h30-0-77" id="h30-0-77" class="i">+
</a><a href="#h30-0-78" id="h30-0-78" class="i">+// IsValid reports whether the field identifier is valid.
</a><a href="#h30-0-79" id="h30-0-79" class="i">+func (f field) IsValid() bool { return f != nil }
</a><a href="#h30-0-80" id="h30-0-80" class="i">+
</a><a href="#h30-0-81" id="h30-0-81" class="i">+// field returns the given field in the struct as a reflect value.
</a><a href="#h30-0-82" id="h30-0-82" class="i">+func structPointer_field(p structPointer, f field) reflect.Value {
</a><a href="#h30-0-83" id="h30-0-83" class="i">+	// Special case: an extension map entry with a value of type T
</a><a href="#h30-0-84" id="h30-0-84" class="i">+	// passes a *T to the struct-handling code with a zero field,
</a><a href="#h30-0-85" id="h30-0-85" class="i">+	// expecting that it will be treated as equivalent to *struct{ X T },
</a><a href="#h30-0-86" id="h30-0-86" class="i">+	// which has the same memory layout. We have to handle that case
</a><a href="#h30-0-87" id="h30-0-87" class="i">+	// specially, because reflect will panic if we call FieldByIndex on a
</a><a href="#h30-0-88" id="h30-0-88" class="i">+	// non-struct.
</a><a href="#h30-0-89" id="h30-0-89" class="i">+	if f == nil {
</a><a href="#h30-0-90" id="h30-0-90" class="i">+		return p.v.Elem()
</a><a href="#h30-0-91" id="h30-0-91" class="i">+	}
</a><a href="#h30-0-92" id="h30-0-92" class="i">+
</a><a href="#h30-0-93" id="h30-0-93" class="i">+	return p.v.Elem().FieldByIndex(f)
</a><a href="#h30-0-94" id="h30-0-94" class="i">+}
</a><a href="#h30-0-95" id="h30-0-95" class="i">+
</a><a href="#h30-0-96" id="h30-0-96" class="i">+// ifield returns the given field in the struct as an interface value.
</a><a href="#h30-0-97" id="h30-0-97" class="i">+func structPointer_ifield(p structPointer, f field) interface{} {
</a><a href="#h30-0-98" id="h30-0-98" class="i">+	return structPointer_field(p, f).Addr().Interface()
</a><a href="#h30-0-99" id="h30-0-99" class="i">+}
</a><a href="#h30-0-100" id="h30-0-100" class="i">+
</a><a href="#h30-0-101" id="h30-0-101" class="i">+// Bytes returns the address of a []byte field in the struct.
</a><a href="#h30-0-102" id="h30-0-102" class="i">+func structPointer_Bytes(p structPointer, f field) *[]byte {
</a><a href="#h30-0-103" id="h30-0-103" class="i">+	return structPointer_ifield(p, f).(*[]byte)
</a><a href="#h30-0-104" id="h30-0-104" class="i">+}
</a><a href="#h30-0-105" id="h30-0-105" class="i">+
</a><a href="#h30-0-106" id="h30-0-106" class="i">+// BytesSlice returns the address of a [][]byte field in the struct.
</a><a href="#h30-0-107" id="h30-0-107" class="i">+func structPointer_BytesSlice(p structPointer, f field) *[][]byte {
</a><a href="#h30-0-108" id="h30-0-108" class="i">+	return structPointer_ifield(p, f).(*[][]byte)
</a><a href="#h30-0-109" id="h30-0-109" class="i">+}
</a><a href="#h30-0-110" id="h30-0-110" class="i">+
</a><a href="#h30-0-111" id="h30-0-111" class="i">+// Bool returns the address of a *bool field in the struct.
</a><a href="#h30-0-112" id="h30-0-112" class="i">+func structPointer_Bool(p structPointer, f field) **bool {
</a><a href="#h30-0-113" id="h30-0-113" class="i">+	return structPointer_ifield(p, f).(**bool)
</a><a href="#h30-0-114" id="h30-0-114" class="i">+}
</a><a href="#h30-0-115" id="h30-0-115" class="i">+
</a><a href="#h30-0-116" id="h30-0-116" class="i">+// BoolVal returns the address of a bool field in the struct.
</a><a href="#h30-0-117" id="h30-0-117" class="i">+func structPointer_BoolVal(p structPointer, f field) *bool {
</a><a href="#h30-0-118" id="h30-0-118" class="i">+	return structPointer_ifield(p, f).(*bool)
</a><a href="#h30-0-119" id="h30-0-119" class="i">+}
</a><a href="#h30-0-120" id="h30-0-120" class="i">+
</a><a href="#h30-0-121" id="h30-0-121" class="i">+// BoolSlice returns the address of a []bool field in the struct.
</a><a href="#h30-0-122" id="h30-0-122" class="i">+func structPointer_BoolSlice(p structPointer, f field) *[]bool {
</a><a href="#h30-0-123" id="h30-0-123" class="i">+	return structPointer_ifield(p, f).(*[]bool)
</a><a href="#h30-0-124" id="h30-0-124" class="i">+}
</a><a href="#h30-0-125" id="h30-0-125" class="i">+
</a><a href="#h30-0-126" id="h30-0-126" class="i">+// String returns the address of a *string field in the struct.
</a><a href="#h30-0-127" id="h30-0-127" class="i">+func structPointer_String(p structPointer, f field) **string {
</a><a href="#h30-0-128" id="h30-0-128" class="i">+	return structPointer_ifield(p, f).(**string)
</a><a href="#h30-0-129" id="h30-0-129" class="i">+}
</a><a href="#h30-0-130" id="h30-0-130" class="i">+
</a><a href="#h30-0-131" id="h30-0-131" class="i">+// StringVal returns the address of a string field in the struct.
</a><a href="#h30-0-132" id="h30-0-132" class="i">+func structPointer_StringVal(p structPointer, f field) *string {
</a><a href="#h30-0-133" id="h30-0-133" class="i">+	return structPointer_ifield(p, f).(*string)
</a><a href="#h30-0-134" id="h30-0-134" class="i">+}
</a><a href="#h30-0-135" id="h30-0-135" class="i">+
</a><a href="#h30-0-136" id="h30-0-136" class="i">+// StringSlice returns the address of a []string field in the struct.
</a><a href="#h30-0-137" id="h30-0-137" class="i">+func structPointer_StringSlice(p structPointer, f field) *[]string {
</a><a href="#h30-0-138" id="h30-0-138" class="i">+	return structPointer_ifield(p, f).(*[]string)
</a><a href="#h30-0-139" id="h30-0-139" class="i">+}
</a><a href="#h30-0-140" id="h30-0-140" class="i">+
</a><a href="#h30-0-141" id="h30-0-141" class="i">+// Extensions returns the address of an extension map field in the struct.
</a><a href="#h30-0-142" id="h30-0-142" class="i">+func structPointer_Extensions(p structPointer, f field) *XXX_InternalExtensions {
</a><a href="#h30-0-143" id="h30-0-143" class="i">+	return structPointer_ifield(p, f).(*XXX_InternalExtensions)
</a><a href="#h30-0-144" id="h30-0-144" class="i">+}
</a><a href="#h30-0-145" id="h30-0-145" class="i">+
</a><a href="#h30-0-146" id="h30-0-146" class="i">+// ExtMap returns the address of an extension map field in the struct.
</a><a href="#h30-0-147" id="h30-0-147" class="i">+func structPointer_ExtMap(p structPointer, f field) *map[int32]Extension {
</a><a href="#h30-0-148" id="h30-0-148" class="i">+	return structPointer_ifield(p, f).(*map[int32]Extension)
</a><a href="#h30-0-149" id="h30-0-149" class="i">+}
</a><a href="#h30-0-150" id="h30-0-150" class="i">+
</a><a href="#h30-0-151" id="h30-0-151" class="i">+// NewAt returns the reflect.Value for a pointer to a field in the struct.
</a><a href="#h30-0-152" id="h30-0-152" class="i">+func structPointer_NewAt(p structPointer, f field, typ reflect.Type) reflect.Value {
</a><a href="#h30-0-153" id="h30-0-153" class="i">+	return structPointer_field(p, f).Addr()
</a><a href="#h30-0-154" id="h30-0-154" class="i">+}
</a><a href="#h30-0-155" id="h30-0-155" class="i">+
</a><a href="#h30-0-156" id="h30-0-156" class="i">+// SetStructPointer writes a *struct field in the struct.
</a><a href="#h30-0-157" id="h30-0-157" class="i">+func structPointer_SetStructPointer(p structPointer, f field, q structPointer) {
</a><a href="#h30-0-158" id="h30-0-158" class="i">+	structPointer_field(p, f).Set(q.v)
</a><a href="#h30-0-159" id="h30-0-159" class="i">+}
</a><a href="#h30-0-160" id="h30-0-160" class="i">+
</a><a href="#h30-0-161" id="h30-0-161" class="i">+// GetStructPointer reads a *struct field in the struct.
</a><a href="#h30-0-162" id="h30-0-162" class="i">+func structPointer_GetStructPointer(p structPointer, f field) structPointer {
</a><a href="#h30-0-163" id="h30-0-163" class="i">+	return structPointer{structPointer_field(p, f)}
</a><a href="#h30-0-164" id="h30-0-164" class="i">+}
</a><a href="#h30-0-165" id="h30-0-165" class="i">+
</a><a href="#h30-0-166" id="h30-0-166" class="i">+// StructPointerSlice the address of a []*struct field in the struct.
</a><a href="#h30-0-167" id="h30-0-167" class="i">+func structPointer_StructPointerSlice(p structPointer, f field) structPointerSlice {
</a><a href="#h30-0-168" id="h30-0-168" class="i">+	return structPointerSlice{structPointer_field(p, f)}
</a><a href="#h30-0-169" id="h30-0-169" class="i">+}
</a><a href="#h30-0-170" id="h30-0-170" class="i">+
</a><a href="#h30-0-171" id="h30-0-171" class="i">+// A structPointerSlice represents the address of a slice of pointers to structs
</a><a href="#h30-0-172" id="h30-0-172" class="i">+// (themselves messages or groups). That is, v.Type() is *[]*struct{...}.
</a><a href="#h30-0-173" id="h30-0-173" class="i">+type structPointerSlice struct {
</a><a href="#h30-0-174" id="h30-0-174" class="i">+	v reflect.Value
</a><a href="#h30-0-175" id="h30-0-175" class="i">+}
</a><a href="#h30-0-176" id="h30-0-176" class="i">+
</a><a href="#h30-0-177" id="h30-0-177" class="i">+func (p structPointerSlice) Len() int                  { return p.v.Len() }
</a><a href="#h30-0-178" id="h30-0-178" class="i">+func (p structPointerSlice) Index(i int) structPointer { return structPointer{p.v.Index(i)} }
</a><a href="#h30-0-179" id="h30-0-179" class="i">+func (p structPointerSlice) Append(q structPointer) {
</a><a href="#h30-0-180" id="h30-0-180" class="i">+	p.v.Set(reflect.Append(p.v, q.v))
</a><a href="#h30-0-181" id="h30-0-181" class="i">+}
</a><a href="#h30-0-182" id="h30-0-182" class="i">+
</a><a href="#h30-0-183" id="h30-0-183" class="i">+var (
</a><a href="#h30-0-184" id="h30-0-184" class="i">+	int32Type   = reflect.TypeOf(int32(0))
</a><a href="#h30-0-185" id="h30-0-185" class="i">+	uint32Type  = reflect.TypeOf(uint32(0))
</a><a href="#h30-0-186" id="h30-0-186" class="i">+	float32Type = reflect.TypeOf(float32(0))
</a><a href="#h30-0-187" id="h30-0-187" class="i">+	int64Type   = reflect.TypeOf(int64(0))
</a><a href="#h30-0-188" id="h30-0-188" class="i">+	uint64Type  = reflect.TypeOf(uint64(0))
</a><a href="#h30-0-189" id="h30-0-189" class="i">+	float64Type = reflect.TypeOf(float64(0))
</a><a href="#h30-0-190" id="h30-0-190" class="i">+)
</a><a href="#h30-0-191" id="h30-0-191" class="i">+
</a><a href="#h30-0-192" id="h30-0-192" class="i">+// A word32 represents a field of type *int32, *uint32, *float32, or *enum.
</a><a href="#h30-0-193" id="h30-0-193" class="i">+// That is, v.Type() is *int32, *uint32, *float32, or *enum and v is assignable.
</a><a href="#h30-0-194" id="h30-0-194" class="i">+type word32 struct {
</a><a href="#h30-0-195" id="h30-0-195" class="i">+	v reflect.Value
</a><a href="#h30-0-196" id="h30-0-196" class="i">+}
</a><a href="#h30-0-197" id="h30-0-197" class="i">+
</a><a href="#h30-0-198" id="h30-0-198" class="i">+// IsNil reports whether p is nil.
</a><a href="#h30-0-199" id="h30-0-199" class="i">+func word32_IsNil(p word32) bool {
</a><a href="#h30-0-200" id="h30-0-200" class="i">+	return p.v.IsNil()
</a><a href="#h30-0-201" id="h30-0-201" class="i">+}
</a><a href="#h30-0-202" id="h30-0-202" class="i">+
</a><a href="#h30-0-203" id="h30-0-203" class="i">+// Set sets p to point at a newly allocated word with bits set to x.
</a><a href="#h30-0-204" id="h30-0-204" class="i">+func word32_Set(p word32, o *Buffer, x uint32) {
</a><a href="#h30-0-205" id="h30-0-205" class="i">+	t := p.v.Type().Elem()
</a><a href="#h30-0-206" id="h30-0-206" class="i">+	switch t {
</a><a href="#h30-0-207" id="h30-0-207" class="i">+	case int32Type:
</a><a href="#h30-0-208" id="h30-0-208" class="i">+		if len(o.int32s) == 0 {
</a><a href="#h30-0-209" id="h30-0-209" class="i">+			o.int32s = make([]int32, uint32PoolSize)
</a><a href="#h30-0-210" id="h30-0-210" class="i">+		}
</a><a href="#h30-0-211" id="h30-0-211" class="i">+		o.int32s[0] = int32(x)
</a><a href="#h30-0-212" id="h30-0-212" class="i">+		p.v.Set(reflect.ValueOf(&amp;o.int32s[0]))
</a><a href="#h30-0-213" id="h30-0-213" class="i">+		o.int32s = o.int32s[1:]
</a><a href="#h30-0-214" id="h30-0-214" class="i">+		return
</a><a href="#h30-0-215" id="h30-0-215" class="i">+	case uint32Type:
</a><a href="#h30-0-216" id="h30-0-216" class="i">+		if len(o.uint32s) == 0 {
</a><a href="#h30-0-217" id="h30-0-217" class="i">+			o.uint32s = make([]uint32, uint32PoolSize)
</a><a href="#h30-0-218" id="h30-0-218" class="i">+		}
</a><a href="#h30-0-219" id="h30-0-219" class="i">+		o.uint32s[0] = x
</a><a href="#h30-0-220" id="h30-0-220" class="i">+		p.v.Set(reflect.ValueOf(&amp;o.uint32s[0]))
</a><a href="#h30-0-221" id="h30-0-221" class="i">+		o.uint32s = o.uint32s[1:]
</a><a href="#h30-0-222" id="h30-0-222" class="i">+		return
</a><a href="#h30-0-223" id="h30-0-223" class="i">+	case float32Type:
</a><a href="#h30-0-224" id="h30-0-224" class="i">+		if len(o.float32s) == 0 {
</a><a href="#h30-0-225" id="h30-0-225" class="i">+			o.float32s = make([]float32, uint32PoolSize)
</a><a href="#h30-0-226" id="h30-0-226" class="i">+		}
</a><a href="#h30-0-227" id="h30-0-227" class="i">+		o.float32s[0] = math.Float32frombits(x)
</a><a href="#h30-0-228" id="h30-0-228" class="i">+		p.v.Set(reflect.ValueOf(&amp;o.float32s[0]))
</a><a href="#h30-0-229" id="h30-0-229" class="i">+		o.float32s = o.float32s[1:]
</a><a href="#h30-0-230" id="h30-0-230" class="i">+		return
</a><a href="#h30-0-231" id="h30-0-231" class="i">+	}
</a><a href="#h30-0-232" id="h30-0-232" class="i">+
</a><a href="#h30-0-233" id="h30-0-233" class="i">+	// must be enum
</a><a href="#h30-0-234" id="h30-0-234" class="i">+	p.v.Set(reflect.New(t))
</a><a href="#h30-0-235" id="h30-0-235" class="i">+	p.v.Elem().SetInt(int64(int32(x)))
</a><a href="#h30-0-236" id="h30-0-236" class="i">+}
</a><a href="#h30-0-237" id="h30-0-237" class="i">+
</a><a href="#h30-0-238" id="h30-0-238" class="i">+// Get gets the bits pointed at by p, as a uint32.
</a><a href="#h30-0-239" id="h30-0-239" class="i">+func word32_Get(p word32) uint32 {
</a><a href="#h30-0-240" id="h30-0-240" class="i">+	elem := p.v.Elem()
</a><a href="#h30-0-241" id="h30-0-241" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-242" id="h30-0-242" class="i">+	case reflect.Int32:
</a><a href="#h30-0-243" id="h30-0-243" class="i">+		return uint32(elem.Int())
</a><a href="#h30-0-244" id="h30-0-244" class="i">+	case reflect.Uint32:
</a><a href="#h30-0-245" id="h30-0-245" class="i">+		return uint32(elem.Uint())
</a><a href="#h30-0-246" id="h30-0-246" class="i">+	case reflect.Float32:
</a><a href="#h30-0-247" id="h30-0-247" class="i">+		return math.Float32bits(float32(elem.Float()))
</a><a href="#h30-0-248" id="h30-0-248" class="i">+	}
</a><a href="#h30-0-249" id="h30-0-249" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-250" id="h30-0-250" class="i">+}
</a><a href="#h30-0-251" id="h30-0-251" class="i">+
</a><a href="#h30-0-252" id="h30-0-252" class="i">+// Word32 returns a reference to a *int32, *uint32, *float32, or *enum field in the struct.
</a><a href="#h30-0-253" id="h30-0-253" class="i">+func structPointer_Word32(p structPointer, f field) word32 {
</a><a href="#h30-0-254" id="h30-0-254" class="i">+	return word32{structPointer_field(p, f)}
</a><a href="#h30-0-255" id="h30-0-255" class="i">+}
</a><a href="#h30-0-256" id="h30-0-256" class="i">+
</a><a href="#h30-0-257" id="h30-0-257" class="i">+// A word32Val represents a field of type int32, uint32, float32, or enum.
</a><a href="#h30-0-258" id="h30-0-258" class="i">+// That is, v.Type() is int32, uint32, float32, or enum and v is assignable.
</a><a href="#h30-0-259" id="h30-0-259" class="i">+type word32Val struct {
</a><a href="#h30-0-260" id="h30-0-260" class="i">+	v reflect.Value
</a><a href="#h30-0-261" id="h30-0-261" class="i">+}
</a><a href="#h30-0-262" id="h30-0-262" class="i">+
</a><a href="#h30-0-263" id="h30-0-263" class="i">+// Set sets *p to x.
</a><a href="#h30-0-264" id="h30-0-264" class="i">+func word32Val_Set(p word32Val, x uint32) {
</a><a href="#h30-0-265" id="h30-0-265" class="i">+	switch p.v.Type() {
</a><a href="#h30-0-266" id="h30-0-266" class="i">+	case int32Type:
</a><a href="#h30-0-267" id="h30-0-267" class="i">+		p.v.SetInt(int64(x))
</a><a href="#h30-0-268" id="h30-0-268" class="i">+		return
</a><a href="#h30-0-269" id="h30-0-269" class="i">+	case uint32Type:
</a><a href="#h30-0-270" id="h30-0-270" class="i">+		p.v.SetUint(uint64(x))
</a><a href="#h30-0-271" id="h30-0-271" class="i">+		return
</a><a href="#h30-0-272" id="h30-0-272" class="i">+	case float32Type:
</a><a href="#h30-0-273" id="h30-0-273" class="i">+		p.v.SetFloat(float64(math.Float32frombits(x)))
</a><a href="#h30-0-274" id="h30-0-274" class="i">+		return
</a><a href="#h30-0-275" id="h30-0-275" class="i">+	}
</a><a href="#h30-0-276" id="h30-0-276" class="i">+
</a><a href="#h30-0-277" id="h30-0-277" class="i">+	// must be enum
</a><a href="#h30-0-278" id="h30-0-278" class="i">+	p.v.SetInt(int64(int32(x)))
</a><a href="#h30-0-279" id="h30-0-279" class="i">+}
</a><a href="#h30-0-280" id="h30-0-280" class="i">+
</a><a href="#h30-0-281" id="h30-0-281" class="i">+// Get gets the bits pointed at by p, as a uint32.
</a><a href="#h30-0-282" id="h30-0-282" class="i">+func word32Val_Get(p word32Val) uint32 {
</a><a href="#h30-0-283" id="h30-0-283" class="i">+	elem := p.v
</a><a href="#h30-0-284" id="h30-0-284" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-285" id="h30-0-285" class="i">+	case reflect.Int32:
</a><a href="#h30-0-286" id="h30-0-286" class="i">+		return uint32(elem.Int())
</a><a href="#h30-0-287" id="h30-0-287" class="i">+	case reflect.Uint32:
</a><a href="#h30-0-288" id="h30-0-288" class="i">+		return uint32(elem.Uint())
</a><a href="#h30-0-289" id="h30-0-289" class="i">+	case reflect.Float32:
</a><a href="#h30-0-290" id="h30-0-290" class="i">+		return math.Float32bits(float32(elem.Float()))
</a><a href="#h30-0-291" id="h30-0-291" class="i">+	}
</a><a href="#h30-0-292" id="h30-0-292" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-293" id="h30-0-293" class="i">+}
</a><a href="#h30-0-294" id="h30-0-294" class="i">+
</a><a href="#h30-0-295" id="h30-0-295" class="i">+// Word32Val returns a reference to a int32, uint32, float32, or enum field in the struct.
</a><a href="#h30-0-296" id="h30-0-296" class="i">+func structPointer_Word32Val(p structPointer, f field) word32Val {
</a><a href="#h30-0-297" id="h30-0-297" class="i">+	return word32Val{structPointer_field(p, f)}
</a><a href="#h30-0-298" id="h30-0-298" class="i">+}
</a><a href="#h30-0-299" id="h30-0-299" class="i">+
</a><a href="#h30-0-300" id="h30-0-300" class="i">+// A word32Slice is a slice of 32-bit values.
</a><a href="#h30-0-301" id="h30-0-301" class="i">+// That is, v.Type() is []int32, []uint32, []float32, or []enum.
</a><a href="#h30-0-302" id="h30-0-302" class="i">+type word32Slice struct {
</a><a href="#h30-0-303" id="h30-0-303" class="i">+	v reflect.Value
</a><a href="#h30-0-304" id="h30-0-304" class="i">+}
</a><a href="#h30-0-305" id="h30-0-305" class="i">+
</a><a href="#h30-0-306" id="h30-0-306" class="i">+func (p word32Slice) Append(x uint32) {
</a><a href="#h30-0-307" id="h30-0-307" class="i">+	n, m := p.v.Len(), p.v.Cap()
</a><a href="#h30-0-308" id="h30-0-308" class="i">+	if n &lt; m {
</a><a href="#h30-0-309" id="h30-0-309" class="i">+		p.v.SetLen(n + 1)
</a><a href="#h30-0-310" id="h30-0-310" class="i">+	} else {
</a><a href="#h30-0-311" id="h30-0-311" class="i">+		t := p.v.Type().Elem()
</a><a href="#h30-0-312" id="h30-0-312" class="i">+		p.v.Set(reflect.Append(p.v, reflect.Zero(t)))
</a><a href="#h30-0-313" id="h30-0-313" class="i">+	}
</a><a href="#h30-0-314" id="h30-0-314" class="i">+	elem := p.v.Index(n)
</a><a href="#h30-0-315" id="h30-0-315" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-316" id="h30-0-316" class="i">+	case reflect.Int32:
</a><a href="#h30-0-317" id="h30-0-317" class="i">+		elem.SetInt(int64(int32(x)))
</a><a href="#h30-0-318" id="h30-0-318" class="i">+	case reflect.Uint32:
</a><a href="#h30-0-319" id="h30-0-319" class="i">+		elem.SetUint(uint64(x))
</a><a href="#h30-0-320" id="h30-0-320" class="i">+	case reflect.Float32:
</a><a href="#h30-0-321" id="h30-0-321" class="i">+		elem.SetFloat(float64(math.Float32frombits(x)))
</a><a href="#h30-0-322" id="h30-0-322" class="i">+	}
</a><a href="#h30-0-323" id="h30-0-323" class="i">+}
</a><a href="#h30-0-324" id="h30-0-324" class="i">+
</a><a href="#h30-0-325" id="h30-0-325" class="i">+func (p word32Slice) Len() int {
</a><a href="#h30-0-326" id="h30-0-326" class="i">+	return p.v.Len()
</a><a href="#h30-0-327" id="h30-0-327" class="i">+}
</a><a href="#h30-0-328" id="h30-0-328" class="i">+
</a><a href="#h30-0-329" id="h30-0-329" class="i">+func (p word32Slice) Index(i int) uint32 {
</a><a href="#h30-0-330" id="h30-0-330" class="i">+	elem := p.v.Index(i)
</a><a href="#h30-0-331" id="h30-0-331" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-332" id="h30-0-332" class="i">+	case reflect.Int32:
</a><a href="#h30-0-333" id="h30-0-333" class="i">+		return uint32(elem.Int())
</a><a href="#h30-0-334" id="h30-0-334" class="i">+	case reflect.Uint32:
</a><a href="#h30-0-335" id="h30-0-335" class="i">+		return uint32(elem.Uint())
</a><a href="#h30-0-336" id="h30-0-336" class="i">+	case reflect.Float32:
</a><a href="#h30-0-337" id="h30-0-337" class="i">+		return math.Float32bits(float32(elem.Float()))
</a><a href="#h30-0-338" id="h30-0-338" class="i">+	}
</a><a href="#h30-0-339" id="h30-0-339" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-340" id="h30-0-340" class="i">+}
</a><a href="#h30-0-341" id="h30-0-341" class="i">+
</a><a href="#h30-0-342" id="h30-0-342" class="i">+// Word32Slice returns a reference to a []int32, []uint32, []float32, or []enum field in the struct.
</a><a href="#h30-0-343" id="h30-0-343" class="i">+func structPointer_Word32Slice(p structPointer, f field) word32Slice {
</a><a href="#h30-0-344" id="h30-0-344" class="i">+	return word32Slice{structPointer_field(p, f)}
</a><a href="#h30-0-345" id="h30-0-345" class="i">+}
</a><a href="#h30-0-346" id="h30-0-346" class="i">+
</a><a href="#h30-0-347" id="h30-0-347" class="i">+// word64 is like word32 but for 64-bit values.
</a><a href="#h30-0-348" id="h30-0-348" class="i">+type word64 struct {
</a><a href="#h30-0-349" id="h30-0-349" class="i">+	v reflect.Value
</a><a href="#h30-0-350" id="h30-0-350" class="i">+}
</a><a href="#h30-0-351" id="h30-0-351" class="i">+
</a><a href="#h30-0-352" id="h30-0-352" class="i">+func word64_Set(p word64, o *Buffer, x uint64) {
</a><a href="#h30-0-353" id="h30-0-353" class="i">+	t := p.v.Type().Elem()
</a><a href="#h30-0-354" id="h30-0-354" class="i">+	switch t {
</a><a href="#h30-0-355" id="h30-0-355" class="i">+	case int64Type:
</a><a href="#h30-0-356" id="h30-0-356" class="i">+		if len(o.int64s) == 0 {
</a><a href="#h30-0-357" id="h30-0-357" class="i">+			o.int64s = make([]int64, uint64PoolSize)
</a><a href="#h30-0-358" id="h30-0-358" class="i">+		}
</a><a href="#h30-0-359" id="h30-0-359" class="i">+		o.int64s[0] = int64(x)
</a><a href="#h30-0-360" id="h30-0-360" class="i">+		p.v.Set(reflect.ValueOf(&amp;o.int64s[0]))
</a><a href="#h30-0-361" id="h30-0-361" class="i">+		o.int64s = o.int64s[1:]
</a><a href="#h30-0-362" id="h30-0-362" class="i">+		return
</a><a href="#h30-0-363" id="h30-0-363" class="i">+	case uint64Type:
</a><a href="#h30-0-364" id="h30-0-364" class="i">+		if len(o.uint64s) == 0 {
</a><a href="#h30-0-365" id="h30-0-365" class="i">+			o.uint64s = make([]uint64, uint64PoolSize)
</a><a href="#h30-0-366" id="h30-0-366" class="i">+		}
</a><a href="#h30-0-367" id="h30-0-367" class="i">+		o.uint64s[0] = x
</a><a href="#h30-0-368" id="h30-0-368" class="i">+		p.v.Set(reflect.ValueOf(&amp;o.uint64s[0]))
</a><a href="#h30-0-369" id="h30-0-369" class="i">+		o.uint64s = o.uint64s[1:]
</a><a href="#h30-0-370" id="h30-0-370" class="i">+		return
</a><a href="#h30-0-371" id="h30-0-371" class="i">+	case float64Type:
</a><a href="#h30-0-372" id="h30-0-372" class="i">+		if len(o.float64s) == 0 {
</a><a href="#h30-0-373" id="h30-0-373" class="i">+			o.float64s = make([]float64, uint64PoolSize)
</a><a href="#h30-0-374" id="h30-0-374" class="i">+		}
</a><a href="#h30-0-375" id="h30-0-375" class="i">+		o.float64s[0] = math.Float64frombits(x)
</a><a href="#h30-0-376" id="h30-0-376" class="i">+		p.v.Set(reflect.ValueOf(&amp;o.float64s[0]))
</a><a href="#h30-0-377" id="h30-0-377" class="i">+		o.float64s = o.float64s[1:]
</a><a href="#h30-0-378" id="h30-0-378" class="i">+		return
</a><a href="#h30-0-379" id="h30-0-379" class="i">+	}
</a><a href="#h30-0-380" id="h30-0-380" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-381" id="h30-0-381" class="i">+}
</a><a href="#h30-0-382" id="h30-0-382" class="i">+
</a><a href="#h30-0-383" id="h30-0-383" class="i">+func word64_IsNil(p word64) bool {
</a><a href="#h30-0-384" id="h30-0-384" class="i">+	return p.v.IsNil()
</a><a href="#h30-0-385" id="h30-0-385" class="i">+}
</a><a href="#h30-0-386" id="h30-0-386" class="i">+
</a><a href="#h30-0-387" id="h30-0-387" class="i">+func word64_Get(p word64) uint64 {
</a><a href="#h30-0-388" id="h30-0-388" class="i">+	elem := p.v.Elem()
</a><a href="#h30-0-389" id="h30-0-389" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-390" id="h30-0-390" class="i">+	case reflect.Int64:
</a><a href="#h30-0-391" id="h30-0-391" class="i">+		return uint64(elem.Int())
</a><a href="#h30-0-392" id="h30-0-392" class="i">+	case reflect.Uint64:
</a><a href="#h30-0-393" id="h30-0-393" class="i">+		return elem.Uint()
</a><a href="#h30-0-394" id="h30-0-394" class="i">+	case reflect.Float64:
</a><a href="#h30-0-395" id="h30-0-395" class="i">+		return math.Float64bits(elem.Float())
</a><a href="#h30-0-396" id="h30-0-396" class="i">+	}
</a><a href="#h30-0-397" id="h30-0-397" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-398" id="h30-0-398" class="i">+}
</a><a href="#h30-0-399" id="h30-0-399" class="i">+
</a><a href="#h30-0-400" id="h30-0-400" class="i">+func structPointer_Word64(p structPointer, f field) word64 {
</a><a href="#h30-0-401" id="h30-0-401" class="i">+	return word64{structPointer_field(p, f)}
</a><a href="#h30-0-402" id="h30-0-402" class="i">+}
</a><a href="#h30-0-403" id="h30-0-403" class="i">+
</a><a href="#h30-0-404" id="h30-0-404" class="i">+// word64Val is like word32Val but for 64-bit values.
</a><a href="#h30-0-405" id="h30-0-405" class="i">+type word64Val struct {
</a><a href="#h30-0-406" id="h30-0-406" class="i">+	v reflect.Value
</a><a href="#h30-0-407" id="h30-0-407" class="i">+}
</a><a href="#h30-0-408" id="h30-0-408" class="i">+
</a><a href="#h30-0-409" id="h30-0-409" class="i">+func word64Val_Set(p word64Val, o *Buffer, x uint64) {
</a><a href="#h30-0-410" id="h30-0-410" class="i">+	switch p.v.Type() {
</a><a href="#h30-0-411" id="h30-0-411" class="i">+	case int64Type:
</a><a href="#h30-0-412" id="h30-0-412" class="i">+		p.v.SetInt(int64(x))
</a><a href="#h30-0-413" id="h30-0-413" class="i">+		return
</a><a href="#h30-0-414" id="h30-0-414" class="i">+	case uint64Type:
</a><a href="#h30-0-415" id="h30-0-415" class="i">+		p.v.SetUint(x)
</a><a href="#h30-0-416" id="h30-0-416" class="i">+		return
</a><a href="#h30-0-417" id="h30-0-417" class="i">+	case float64Type:
</a><a href="#h30-0-418" id="h30-0-418" class="i">+		p.v.SetFloat(math.Float64frombits(x))
</a><a href="#h30-0-419" id="h30-0-419" class="i">+		return
</a><a href="#h30-0-420" id="h30-0-420" class="i">+	}
</a><a href="#h30-0-421" id="h30-0-421" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-422" id="h30-0-422" class="i">+}
</a><a href="#h30-0-423" id="h30-0-423" class="i">+
</a><a href="#h30-0-424" id="h30-0-424" class="i">+func word64Val_Get(p word64Val) uint64 {
</a><a href="#h30-0-425" id="h30-0-425" class="i">+	elem := p.v
</a><a href="#h30-0-426" id="h30-0-426" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-427" id="h30-0-427" class="i">+	case reflect.Int64:
</a><a href="#h30-0-428" id="h30-0-428" class="i">+		return uint64(elem.Int())
</a><a href="#h30-0-429" id="h30-0-429" class="i">+	case reflect.Uint64:
</a><a href="#h30-0-430" id="h30-0-430" class="i">+		return elem.Uint()
</a><a href="#h30-0-431" id="h30-0-431" class="i">+	case reflect.Float64:
</a><a href="#h30-0-432" id="h30-0-432" class="i">+		return math.Float64bits(elem.Float())
</a><a href="#h30-0-433" id="h30-0-433" class="i">+	}
</a><a href="#h30-0-434" id="h30-0-434" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-435" id="h30-0-435" class="i">+}
</a><a href="#h30-0-436" id="h30-0-436" class="i">+
</a><a href="#h30-0-437" id="h30-0-437" class="i">+func structPointer_Word64Val(p structPointer, f field) word64Val {
</a><a href="#h30-0-438" id="h30-0-438" class="i">+	return word64Val{structPointer_field(p, f)}
</a><a href="#h30-0-439" id="h30-0-439" class="i">+}
</a><a href="#h30-0-440" id="h30-0-440" class="i">+
</a><a href="#h30-0-441" id="h30-0-441" class="i">+type word64Slice struct {
</a><a href="#h30-0-442" id="h30-0-442" class="i">+	v reflect.Value
</a><a href="#h30-0-443" id="h30-0-443" class="i">+}
</a><a href="#h30-0-444" id="h30-0-444" class="i">+
</a><a href="#h30-0-445" id="h30-0-445" class="i">+func (p word64Slice) Append(x uint64) {
</a><a href="#h30-0-446" id="h30-0-446" class="i">+	n, m := p.v.Len(), p.v.Cap()
</a><a href="#h30-0-447" id="h30-0-447" class="i">+	if n &lt; m {
</a><a href="#h30-0-448" id="h30-0-448" class="i">+		p.v.SetLen(n + 1)
</a><a href="#h30-0-449" id="h30-0-449" class="i">+	} else {
</a><a href="#h30-0-450" id="h30-0-450" class="i">+		t := p.v.Type().Elem()
</a><a href="#h30-0-451" id="h30-0-451" class="i">+		p.v.Set(reflect.Append(p.v, reflect.Zero(t)))
</a><a href="#h30-0-452" id="h30-0-452" class="i">+	}
</a><a href="#h30-0-453" id="h30-0-453" class="i">+	elem := p.v.Index(n)
</a><a href="#h30-0-454" id="h30-0-454" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-455" id="h30-0-455" class="i">+	case reflect.Int64:
</a><a href="#h30-0-456" id="h30-0-456" class="i">+		elem.SetInt(int64(int64(x)))
</a><a href="#h30-0-457" id="h30-0-457" class="i">+	case reflect.Uint64:
</a><a href="#h30-0-458" id="h30-0-458" class="i">+		elem.SetUint(uint64(x))
</a><a href="#h30-0-459" id="h30-0-459" class="i">+	case reflect.Float64:
</a><a href="#h30-0-460" id="h30-0-460" class="i">+		elem.SetFloat(float64(math.Float64frombits(x)))
</a><a href="#h30-0-461" id="h30-0-461" class="i">+	}
</a><a href="#h30-0-462" id="h30-0-462" class="i">+}
</a><a href="#h30-0-463" id="h30-0-463" class="i">+
</a><a href="#h30-0-464" id="h30-0-464" class="i">+func (p word64Slice) Len() int {
</a><a href="#h30-0-465" id="h30-0-465" class="i">+	return p.v.Len()
</a><a href="#h30-0-466" id="h30-0-466" class="i">+}
</a><a href="#h30-0-467" id="h30-0-467" class="i">+
</a><a href="#h30-0-468" id="h30-0-468" class="i">+func (p word64Slice) Index(i int) uint64 {
</a><a href="#h30-0-469" id="h30-0-469" class="i">+	elem := p.v.Index(i)
</a><a href="#h30-0-470" id="h30-0-470" class="i">+	switch elem.Kind() {
</a><a href="#h30-0-471" id="h30-0-471" class="i">+	case reflect.Int64:
</a><a href="#h30-0-472" id="h30-0-472" class="i">+		return uint64(elem.Int())
</a><a href="#h30-0-473" id="h30-0-473" class="i">+	case reflect.Uint64:
</a><a href="#h30-0-474" id="h30-0-474" class="i">+		return uint64(elem.Uint())
</a><a href="#h30-0-475" id="h30-0-475" class="i">+	case reflect.Float64:
</a><a href="#h30-0-476" id="h30-0-476" class="i">+		return math.Float64bits(float64(elem.Float()))
</a><a href="#h30-0-477" id="h30-0-477" class="i">+	}
</a><a href="#h30-0-478" id="h30-0-478" class="i">+	panic(&quot;unreachable&quot;)
</a><a href="#h30-0-479" id="h30-0-479" class="i">+}
</a><a href="#h30-0-480" id="h30-0-480" class="i">+
</a><a href="#h30-0-481" id="h30-0-481" class="i">+func structPointer_Word64Slice(p structPointer, f field) word64Slice {
</a><a href="#h30-0-482" id="h30-0-482" class="i">+	return word64Slice{structPointer_field(p, f)}
</a><a href="#h30-0-483" id="h30-0-483" class="i">+}
</a><b>diff --git a/<a id="h31" href="../file/vendor/github.com/golang/protobuf/proto/pointer_unsafe.go">vendor/github.com/golang/protobuf/proto/pointer_unsafe.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/pointer_unsafe.go">vendor/github.com/golang/protobuf/proto/pointer_unsafe.go</a></b>
<a href="#h31-0" id="h31-0" class="h">@@ -0,0 +1,270 @@
</a><a href="#h31-0-0" id="h31-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h31-0-1" id="h31-0-1" class="i">+//
</a><a href="#h31-0-2" id="h31-0-2" class="i">+// Copyright 2012 The Go Authors.  All rights reserved.
</a><a href="#h31-0-3" id="h31-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h31-0-4" id="h31-0-4" class="i">+//
</a><a href="#h31-0-5" id="h31-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h31-0-6" id="h31-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h31-0-7" id="h31-0-7" class="i">+// met:
</a><a href="#h31-0-8" id="h31-0-8" class="i">+//
</a><a href="#h31-0-9" id="h31-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h31-0-10" id="h31-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h31-0-11" id="h31-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h31-0-12" id="h31-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h31-0-13" id="h31-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h31-0-14" id="h31-0-14" class="i">+// distribution.
</a><a href="#h31-0-15" id="h31-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h31-0-16" id="h31-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h31-0-17" id="h31-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h31-0-18" id="h31-0-18" class="i">+//
</a><a href="#h31-0-19" id="h31-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h31-0-20" id="h31-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h31-0-21" id="h31-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h31-0-22" id="h31-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h31-0-23" id="h31-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h31-0-24" id="h31-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h31-0-25" id="h31-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h31-0-26" id="h31-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h31-0-27" id="h31-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h31-0-28" id="h31-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h31-0-29" id="h31-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h31-0-30" id="h31-0-30" class="i">+
</a><a href="#h31-0-31" id="h31-0-31" class="i">+// +build !appengine,!js
</a><a href="#h31-0-32" id="h31-0-32" class="i">+
</a><a href="#h31-0-33" id="h31-0-33" class="i">+// This file contains the implementation of the proto field accesses using package unsafe.
</a><a href="#h31-0-34" id="h31-0-34" class="i">+
</a><a href="#h31-0-35" id="h31-0-35" class="i">+package proto
</a><a href="#h31-0-36" id="h31-0-36" class="i">+
</a><a href="#h31-0-37" id="h31-0-37" class="i">+import (
</a><a href="#h31-0-38" id="h31-0-38" class="i">+	&quot;reflect&quot;
</a><a href="#h31-0-39" id="h31-0-39" class="i">+	&quot;unsafe&quot;
</a><a href="#h31-0-40" id="h31-0-40" class="i">+)
</a><a href="#h31-0-41" id="h31-0-41" class="i">+
</a><a href="#h31-0-42" id="h31-0-42" class="i">+// NOTE: These type_Foo functions would more idiomatically be methods,
</a><a href="#h31-0-43" id="h31-0-43" class="i">+// but Go does not allow methods on pointer types, and we must preserve
</a><a href="#h31-0-44" id="h31-0-44" class="i">+// some pointer type for the garbage collector. We use these
</a><a href="#h31-0-45" id="h31-0-45" class="i">+// funcs with clunky names as our poor approximation to methods.
</a><a href="#h31-0-46" id="h31-0-46" class="i">+//
</a><a href="#h31-0-47" id="h31-0-47" class="i">+// An alternative would be
</a><a href="#h31-0-48" id="h31-0-48" class="i">+//	type structPointer struct { p unsafe.Pointer }
</a><a href="#h31-0-49" id="h31-0-49" class="i">+// but that does not registerize as well.
</a><a href="#h31-0-50" id="h31-0-50" class="i">+
</a><a href="#h31-0-51" id="h31-0-51" class="i">+// A structPointer is a pointer to a struct.
</a><a href="#h31-0-52" id="h31-0-52" class="i">+type structPointer unsafe.Pointer
</a><a href="#h31-0-53" id="h31-0-53" class="i">+
</a><a href="#h31-0-54" id="h31-0-54" class="i">+// toStructPointer returns a structPointer equivalent to the given reflect value.
</a><a href="#h31-0-55" id="h31-0-55" class="i">+func toStructPointer(v reflect.Value) structPointer {
</a><a href="#h31-0-56" id="h31-0-56" class="i">+	return structPointer(unsafe.Pointer(v.Pointer()))
</a><a href="#h31-0-57" id="h31-0-57" class="i">+}
</a><a href="#h31-0-58" id="h31-0-58" class="i">+
</a><a href="#h31-0-59" id="h31-0-59" class="i">+// IsNil reports whether p is nil.
</a><a href="#h31-0-60" id="h31-0-60" class="i">+func structPointer_IsNil(p structPointer) bool {
</a><a href="#h31-0-61" id="h31-0-61" class="i">+	return p == nil
</a><a href="#h31-0-62" id="h31-0-62" class="i">+}
</a><a href="#h31-0-63" id="h31-0-63" class="i">+
</a><a href="#h31-0-64" id="h31-0-64" class="i">+// Interface returns the struct pointer, assumed to have element type t,
</a><a href="#h31-0-65" id="h31-0-65" class="i">+// as an interface value.
</a><a href="#h31-0-66" id="h31-0-66" class="i">+func structPointer_Interface(p structPointer, t reflect.Type) interface{} {
</a><a href="#h31-0-67" id="h31-0-67" class="i">+	return reflect.NewAt(t, unsafe.Pointer(p)).Interface()
</a><a href="#h31-0-68" id="h31-0-68" class="i">+}
</a><a href="#h31-0-69" id="h31-0-69" class="i">+
</a><a href="#h31-0-70" id="h31-0-70" class="i">+// A field identifies a field in a struct, accessible from a structPointer.
</a><a href="#h31-0-71" id="h31-0-71" class="i">+// In this implementation, a field is identified by its byte offset from the start of the struct.
</a><a href="#h31-0-72" id="h31-0-72" class="i">+type field uintptr
</a><a href="#h31-0-73" id="h31-0-73" class="i">+
</a><a href="#h31-0-74" id="h31-0-74" class="i">+// toField returns a field equivalent to the given reflect field.
</a><a href="#h31-0-75" id="h31-0-75" class="i">+func toField(f *reflect.StructField) field {
</a><a href="#h31-0-76" id="h31-0-76" class="i">+	return field(f.Offset)
</a><a href="#h31-0-77" id="h31-0-77" class="i">+}
</a><a href="#h31-0-78" id="h31-0-78" class="i">+
</a><a href="#h31-0-79" id="h31-0-79" class="i">+// invalidField is an invalid field identifier.
</a><a href="#h31-0-80" id="h31-0-80" class="i">+const invalidField = ^field(0)
</a><a href="#h31-0-81" id="h31-0-81" class="i">+
</a><a href="#h31-0-82" id="h31-0-82" class="i">+// IsValid reports whether the field identifier is valid.
</a><a href="#h31-0-83" id="h31-0-83" class="i">+func (f field) IsValid() bool {
</a><a href="#h31-0-84" id="h31-0-84" class="i">+	return f != ^field(0)
</a><a href="#h31-0-85" id="h31-0-85" class="i">+}
</a><a href="#h31-0-86" id="h31-0-86" class="i">+
</a><a href="#h31-0-87" id="h31-0-87" class="i">+// Bytes returns the address of a []byte field in the struct.
</a><a href="#h31-0-88" id="h31-0-88" class="i">+func structPointer_Bytes(p structPointer, f field) *[]byte {
</a><a href="#h31-0-89" id="h31-0-89" class="i">+	return (*[]byte)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-90" id="h31-0-90" class="i">+}
</a><a href="#h31-0-91" id="h31-0-91" class="i">+
</a><a href="#h31-0-92" id="h31-0-92" class="i">+// BytesSlice returns the address of a [][]byte field in the struct.
</a><a href="#h31-0-93" id="h31-0-93" class="i">+func structPointer_BytesSlice(p structPointer, f field) *[][]byte {
</a><a href="#h31-0-94" id="h31-0-94" class="i">+	return (*[][]byte)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-95" id="h31-0-95" class="i">+}
</a><a href="#h31-0-96" id="h31-0-96" class="i">+
</a><a href="#h31-0-97" id="h31-0-97" class="i">+// Bool returns the address of a *bool field in the struct.
</a><a href="#h31-0-98" id="h31-0-98" class="i">+func structPointer_Bool(p structPointer, f field) **bool {
</a><a href="#h31-0-99" id="h31-0-99" class="i">+	return (**bool)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-100" id="h31-0-100" class="i">+}
</a><a href="#h31-0-101" id="h31-0-101" class="i">+
</a><a href="#h31-0-102" id="h31-0-102" class="i">+// BoolVal returns the address of a bool field in the struct.
</a><a href="#h31-0-103" id="h31-0-103" class="i">+func structPointer_BoolVal(p structPointer, f field) *bool {
</a><a href="#h31-0-104" id="h31-0-104" class="i">+	return (*bool)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-105" id="h31-0-105" class="i">+}
</a><a href="#h31-0-106" id="h31-0-106" class="i">+
</a><a href="#h31-0-107" id="h31-0-107" class="i">+// BoolSlice returns the address of a []bool field in the struct.
</a><a href="#h31-0-108" id="h31-0-108" class="i">+func structPointer_BoolSlice(p structPointer, f field) *[]bool {
</a><a href="#h31-0-109" id="h31-0-109" class="i">+	return (*[]bool)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-110" id="h31-0-110" class="i">+}
</a><a href="#h31-0-111" id="h31-0-111" class="i">+
</a><a href="#h31-0-112" id="h31-0-112" class="i">+// String returns the address of a *string field in the struct.
</a><a href="#h31-0-113" id="h31-0-113" class="i">+func structPointer_String(p structPointer, f field) **string {
</a><a href="#h31-0-114" id="h31-0-114" class="i">+	return (**string)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-115" id="h31-0-115" class="i">+}
</a><a href="#h31-0-116" id="h31-0-116" class="i">+
</a><a href="#h31-0-117" id="h31-0-117" class="i">+// StringVal returns the address of a string field in the struct.
</a><a href="#h31-0-118" id="h31-0-118" class="i">+func structPointer_StringVal(p structPointer, f field) *string {
</a><a href="#h31-0-119" id="h31-0-119" class="i">+	return (*string)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-120" id="h31-0-120" class="i">+}
</a><a href="#h31-0-121" id="h31-0-121" class="i">+
</a><a href="#h31-0-122" id="h31-0-122" class="i">+// StringSlice returns the address of a []string field in the struct.
</a><a href="#h31-0-123" id="h31-0-123" class="i">+func structPointer_StringSlice(p structPointer, f field) *[]string {
</a><a href="#h31-0-124" id="h31-0-124" class="i">+	return (*[]string)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-125" id="h31-0-125" class="i">+}
</a><a href="#h31-0-126" id="h31-0-126" class="i">+
</a><a href="#h31-0-127" id="h31-0-127" class="i">+// ExtMap returns the address of an extension map field in the struct.
</a><a href="#h31-0-128" id="h31-0-128" class="i">+func structPointer_Extensions(p structPointer, f field) *XXX_InternalExtensions {
</a><a href="#h31-0-129" id="h31-0-129" class="i">+	return (*XXX_InternalExtensions)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-130" id="h31-0-130" class="i">+}
</a><a href="#h31-0-131" id="h31-0-131" class="i">+
</a><a href="#h31-0-132" id="h31-0-132" class="i">+func structPointer_ExtMap(p structPointer, f field) *map[int32]Extension {
</a><a href="#h31-0-133" id="h31-0-133" class="i">+	return (*map[int32]Extension)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-134" id="h31-0-134" class="i">+}
</a><a href="#h31-0-135" id="h31-0-135" class="i">+
</a><a href="#h31-0-136" id="h31-0-136" class="i">+// NewAt returns the reflect.Value for a pointer to a field in the struct.
</a><a href="#h31-0-137" id="h31-0-137" class="i">+func structPointer_NewAt(p structPointer, f field, typ reflect.Type) reflect.Value {
</a><a href="#h31-0-138" id="h31-0-138" class="i">+	return reflect.NewAt(typ, unsafe.Pointer(uintptr(p)+uintptr(f)))
</a><a href="#h31-0-139" id="h31-0-139" class="i">+}
</a><a href="#h31-0-140" id="h31-0-140" class="i">+
</a><a href="#h31-0-141" id="h31-0-141" class="i">+// SetStructPointer writes a *struct field in the struct.
</a><a href="#h31-0-142" id="h31-0-142" class="i">+func structPointer_SetStructPointer(p structPointer, f field, q structPointer) {
</a><a href="#h31-0-143" id="h31-0-143" class="i">+	*(*structPointer)(unsafe.Pointer(uintptr(p) + uintptr(f))) = q
</a><a href="#h31-0-144" id="h31-0-144" class="i">+}
</a><a href="#h31-0-145" id="h31-0-145" class="i">+
</a><a href="#h31-0-146" id="h31-0-146" class="i">+// GetStructPointer reads a *struct field in the struct.
</a><a href="#h31-0-147" id="h31-0-147" class="i">+func structPointer_GetStructPointer(p structPointer, f field) structPointer {
</a><a href="#h31-0-148" id="h31-0-148" class="i">+	return *(*structPointer)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-149" id="h31-0-149" class="i">+}
</a><a href="#h31-0-150" id="h31-0-150" class="i">+
</a><a href="#h31-0-151" id="h31-0-151" class="i">+// StructPointerSlice the address of a []*struct field in the struct.
</a><a href="#h31-0-152" id="h31-0-152" class="i">+func structPointer_StructPointerSlice(p structPointer, f field) *structPointerSlice {
</a><a href="#h31-0-153" id="h31-0-153" class="i">+	return (*structPointerSlice)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-154" id="h31-0-154" class="i">+}
</a><a href="#h31-0-155" id="h31-0-155" class="i">+
</a><a href="#h31-0-156" id="h31-0-156" class="i">+// A structPointerSlice represents a slice of pointers to structs (themselves submessages or groups).
</a><a href="#h31-0-157" id="h31-0-157" class="i">+type structPointerSlice []structPointer
</a><a href="#h31-0-158" id="h31-0-158" class="i">+
</a><a href="#h31-0-159" id="h31-0-159" class="i">+func (v *structPointerSlice) Len() int                  { return len(*v) }
</a><a href="#h31-0-160" id="h31-0-160" class="i">+func (v *structPointerSlice) Index(i int) structPointer { return (*v)[i] }
</a><a href="#h31-0-161" id="h31-0-161" class="i">+func (v *structPointerSlice) Append(p structPointer)    { *v = append(*v, p) }
</a><a href="#h31-0-162" id="h31-0-162" class="i">+
</a><a href="#h31-0-163" id="h31-0-163" class="i">+// A word32 is the address of a &quot;pointer to 32-bit value&quot; field.
</a><a href="#h31-0-164" id="h31-0-164" class="i">+type word32 **uint32
</a><a href="#h31-0-165" id="h31-0-165" class="i">+
</a><a href="#h31-0-166" id="h31-0-166" class="i">+// IsNil reports whether *v is nil.
</a><a href="#h31-0-167" id="h31-0-167" class="i">+func word32_IsNil(p word32) bool {
</a><a href="#h31-0-168" id="h31-0-168" class="i">+	return *p == nil
</a><a href="#h31-0-169" id="h31-0-169" class="i">+}
</a><a href="#h31-0-170" id="h31-0-170" class="i">+
</a><a href="#h31-0-171" id="h31-0-171" class="i">+// Set sets *v to point at a newly allocated word set to x.
</a><a href="#h31-0-172" id="h31-0-172" class="i">+func word32_Set(p word32, o *Buffer, x uint32) {
</a><a href="#h31-0-173" id="h31-0-173" class="i">+	if len(o.uint32s) == 0 {
</a><a href="#h31-0-174" id="h31-0-174" class="i">+		o.uint32s = make([]uint32, uint32PoolSize)
</a><a href="#h31-0-175" id="h31-0-175" class="i">+	}
</a><a href="#h31-0-176" id="h31-0-176" class="i">+	o.uint32s[0] = x
</a><a href="#h31-0-177" id="h31-0-177" class="i">+	*p = &amp;o.uint32s[0]
</a><a href="#h31-0-178" id="h31-0-178" class="i">+	o.uint32s = o.uint32s[1:]
</a><a href="#h31-0-179" id="h31-0-179" class="i">+}
</a><a href="#h31-0-180" id="h31-0-180" class="i">+
</a><a href="#h31-0-181" id="h31-0-181" class="i">+// Get gets the value pointed at by *v.
</a><a href="#h31-0-182" id="h31-0-182" class="i">+func word32_Get(p word32) uint32 {
</a><a href="#h31-0-183" id="h31-0-183" class="i">+	return **p
</a><a href="#h31-0-184" id="h31-0-184" class="i">+}
</a><a href="#h31-0-185" id="h31-0-185" class="i">+
</a><a href="#h31-0-186" id="h31-0-186" class="i">+// Word32 returns the address of a *int32, *uint32, *float32, or *enum field in the struct.
</a><a href="#h31-0-187" id="h31-0-187" class="i">+func structPointer_Word32(p structPointer, f field) word32 {
</a><a href="#h31-0-188" id="h31-0-188" class="i">+	return word32((**uint32)(unsafe.Pointer(uintptr(p) + uintptr(f))))
</a><a href="#h31-0-189" id="h31-0-189" class="i">+}
</a><a href="#h31-0-190" id="h31-0-190" class="i">+
</a><a href="#h31-0-191" id="h31-0-191" class="i">+// A word32Val is the address of a 32-bit value field.
</a><a href="#h31-0-192" id="h31-0-192" class="i">+type word32Val *uint32
</a><a href="#h31-0-193" id="h31-0-193" class="i">+
</a><a href="#h31-0-194" id="h31-0-194" class="i">+// Set sets *p to x.
</a><a href="#h31-0-195" id="h31-0-195" class="i">+func word32Val_Set(p word32Val, x uint32) {
</a><a href="#h31-0-196" id="h31-0-196" class="i">+	*p = x
</a><a href="#h31-0-197" id="h31-0-197" class="i">+}
</a><a href="#h31-0-198" id="h31-0-198" class="i">+
</a><a href="#h31-0-199" id="h31-0-199" class="i">+// Get gets the value pointed at by p.
</a><a href="#h31-0-200" id="h31-0-200" class="i">+func word32Val_Get(p word32Val) uint32 {
</a><a href="#h31-0-201" id="h31-0-201" class="i">+	return *p
</a><a href="#h31-0-202" id="h31-0-202" class="i">+}
</a><a href="#h31-0-203" id="h31-0-203" class="i">+
</a><a href="#h31-0-204" id="h31-0-204" class="i">+// Word32Val returns the address of a *int32, *uint32, *float32, or *enum field in the struct.
</a><a href="#h31-0-205" id="h31-0-205" class="i">+func structPointer_Word32Val(p structPointer, f field) word32Val {
</a><a href="#h31-0-206" id="h31-0-206" class="i">+	return word32Val((*uint32)(unsafe.Pointer(uintptr(p) + uintptr(f))))
</a><a href="#h31-0-207" id="h31-0-207" class="i">+}
</a><a href="#h31-0-208" id="h31-0-208" class="i">+
</a><a href="#h31-0-209" id="h31-0-209" class="i">+// A word32Slice is a slice of 32-bit values.
</a><a href="#h31-0-210" id="h31-0-210" class="i">+type word32Slice []uint32
</a><a href="#h31-0-211" id="h31-0-211" class="i">+
</a><a href="#h31-0-212" id="h31-0-212" class="i">+func (v *word32Slice) Append(x uint32)    { *v = append(*v, x) }
</a><a href="#h31-0-213" id="h31-0-213" class="i">+func (v *word32Slice) Len() int           { return len(*v) }
</a><a href="#h31-0-214" id="h31-0-214" class="i">+func (v *word32Slice) Index(i int) uint32 { return (*v)[i] }
</a><a href="#h31-0-215" id="h31-0-215" class="i">+
</a><a href="#h31-0-216" id="h31-0-216" class="i">+// Word32Slice returns the address of a []int32, []uint32, []float32, or []enum field in the struct.
</a><a href="#h31-0-217" id="h31-0-217" class="i">+func structPointer_Word32Slice(p structPointer, f field) *word32Slice {
</a><a href="#h31-0-218" id="h31-0-218" class="i">+	return (*word32Slice)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-219" id="h31-0-219" class="i">+}
</a><a href="#h31-0-220" id="h31-0-220" class="i">+
</a><a href="#h31-0-221" id="h31-0-221" class="i">+// word64 is like word32 but for 64-bit values.
</a><a href="#h31-0-222" id="h31-0-222" class="i">+type word64 **uint64
</a><a href="#h31-0-223" id="h31-0-223" class="i">+
</a><a href="#h31-0-224" id="h31-0-224" class="i">+func word64_Set(p word64, o *Buffer, x uint64) {
</a><a href="#h31-0-225" id="h31-0-225" class="i">+	if len(o.uint64s) == 0 {
</a><a href="#h31-0-226" id="h31-0-226" class="i">+		o.uint64s = make([]uint64, uint64PoolSize)
</a><a href="#h31-0-227" id="h31-0-227" class="i">+	}
</a><a href="#h31-0-228" id="h31-0-228" class="i">+	o.uint64s[0] = x
</a><a href="#h31-0-229" id="h31-0-229" class="i">+	*p = &amp;o.uint64s[0]
</a><a href="#h31-0-230" id="h31-0-230" class="i">+	o.uint64s = o.uint64s[1:]
</a><a href="#h31-0-231" id="h31-0-231" class="i">+}
</a><a href="#h31-0-232" id="h31-0-232" class="i">+
</a><a href="#h31-0-233" id="h31-0-233" class="i">+func word64_IsNil(p word64) bool {
</a><a href="#h31-0-234" id="h31-0-234" class="i">+	return *p == nil
</a><a href="#h31-0-235" id="h31-0-235" class="i">+}
</a><a href="#h31-0-236" id="h31-0-236" class="i">+
</a><a href="#h31-0-237" id="h31-0-237" class="i">+func word64_Get(p word64) uint64 {
</a><a href="#h31-0-238" id="h31-0-238" class="i">+	return **p
</a><a href="#h31-0-239" id="h31-0-239" class="i">+}
</a><a href="#h31-0-240" id="h31-0-240" class="i">+
</a><a href="#h31-0-241" id="h31-0-241" class="i">+func structPointer_Word64(p structPointer, f field) word64 {
</a><a href="#h31-0-242" id="h31-0-242" class="i">+	return word64((**uint64)(unsafe.Pointer(uintptr(p) + uintptr(f))))
</a><a href="#h31-0-243" id="h31-0-243" class="i">+}
</a><a href="#h31-0-244" id="h31-0-244" class="i">+
</a><a href="#h31-0-245" id="h31-0-245" class="i">+// word64Val is like word32Val but for 64-bit values.
</a><a href="#h31-0-246" id="h31-0-246" class="i">+type word64Val *uint64
</a><a href="#h31-0-247" id="h31-0-247" class="i">+
</a><a href="#h31-0-248" id="h31-0-248" class="i">+func word64Val_Set(p word64Val, o *Buffer, x uint64) {
</a><a href="#h31-0-249" id="h31-0-249" class="i">+	*p = x
</a><a href="#h31-0-250" id="h31-0-250" class="i">+}
</a><a href="#h31-0-251" id="h31-0-251" class="i">+
</a><a href="#h31-0-252" id="h31-0-252" class="i">+func word64Val_Get(p word64Val) uint64 {
</a><a href="#h31-0-253" id="h31-0-253" class="i">+	return *p
</a><a href="#h31-0-254" id="h31-0-254" class="i">+}
</a><a href="#h31-0-255" id="h31-0-255" class="i">+
</a><a href="#h31-0-256" id="h31-0-256" class="i">+func structPointer_Word64Val(p structPointer, f field) word64Val {
</a><a href="#h31-0-257" id="h31-0-257" class="i">+	return word64Val((*uint64)(unsafe.Pointer(uintptr(p) + uintptr(f))))
</a><a href="#h31-0-258" id="h31-0-258" class="i">+}
</a><a href="#h31-0-259" id="h31-0-259" class="i">+
</a><a href="#h31-0-260" id="h31-0-260" class="i">+// word64Slice is like word32Slice but for 64-bit values.
</a><a href="#h31-0-261" id="h31-0-261" class="i">+type word64Slice []uint64
</a><a href="#h31-0-262" id="h31-0-262" class="i">+
</a><a href="#h31-0-263" id="h31-0-263" class="i">+func (v *word64Slice) Append(x uint64)    { *v = append(*v, x) }
</a><a href="#h31-0-264" id="h31-0-264" class="i">+func (v *word64Slice) Len() int           { return len(*v) }
</a><a href="#h31-0-265" id="h31-0-265" class="i">+func (v *word64Slice) Index(i int) uint64 { return (*v)[i] }
</a><a href="#h31-0-266" id="h31-0-266" class="i">+
</a><a href="#h31-0-267" id="h31-0-267" class="i">+func structPointer_Word64Slice(p structPointer, f field) *word64Slice {
</a><a href="#h31-0-268" id="h31-0-268" class="i">+	return (*word64Slice)(unsafe.Pointer(uintptr(p) + uintptr(f)))
</a><a href="#h31-0-269" id="h31-0-269" class="i">+}
</a><b>diff --git a/<a id="h32" href="../file/vendor/github.com/golang/protobuf/proto/properties.go">vendor/github.com/golang/protobuf/proto/properties.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/properties.go">vendor/github.com/golang/protobuf/proto/properties.go</a></b>
<a href="#h32-0" id="h32-0" class="h">@@ -0,0 +1,864 @@
</a><a href="#h32-0-0" id="h32-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h32-0-1" id="h32-0-1" class="i">+//
</a><a href="#h32-0-2" id="h32-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h32-0-3" id="h32-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h32-0-4" id="h32-0-4" class="i">+//
</a><a href="#h32-0-5" id="h32-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h32-0-6" id="h32-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h32-0-7" id="h32-0-7" class="i">+// met:
</a><a href="#h32-0-8" id="h32-0-8" class="i">+//
</a><a href="#h32-0-9" id="h32-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h32-0-10" id="h32-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h32-0-11" id="h32-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h32-0-12" id="h32-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h32-0-13" id="h32-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h32-0-14" id="h32-0-14" class="i">+// distribution.
</a><a href="#h32-0-15" id="h32-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h32-0-16" id="h32-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h32-0-17" id="h32-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h32-0-18" id="h32-0-18" class="i">+//
</a><a href="#h32-0-19" id="h32-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h32-0-20" id="h32-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h32-0-21" id="h32-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h32-0-22" id="h32-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h32-0-23" id="h32-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h32-0-24" id="h32-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h32-0-25" id="h32-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h32-0-26" id="h32-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h32-0-27" id="h32-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h32-0-28" id="h32-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h32-0-29" id="h32-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h32-0-30" id="h32-0-30" class="i">+
</a><a href="#h32-0-31" id="h32-0-31" class="i">+package proto
</a><a href="#h32-0-32" id="h32-0-32" class="i">+
</a><a href="#h32-0-33" id="h32-0-33" class="i">+/*
</a><a href="#h32-0-34" id="h32-0-34" class="i">+ * Routines for encoding data into the wire format for protocol buffers.
</a><a href="#h32-0-35" id="h32-0-35" class="i">+ */
</a><a href="#h32-0-36" id="h32-0-36" class="i">+
</a><a href="#h32-0-37" id="h32-0-37" class="i">+import (
</a><a href="#h32-0-38" id="h32-0-38" class="i">+	&quot;fmt&quot;
</a><a href="#h32-0-39" id="h32-0-39" class="i">+	&quot;log&quot;
</a><a href="#h32-0-40" id="h32-0-40" class="i">+	&quot;os&quot;
</a><a href="#h32-0-41" id="h32-0-41" class="i">+	&quot;reflect&quot;
</a><a href="#h32-0-42" id="h32-0-42" class="i">+	&quot;sort&quot;
</a><a href="#h32-0-43" id="h32-0-43" class="i">+	&quot;strconv&quot;
</a><a href="#h32-0-44" id="h32-0-44" class="i">+	&quot;strings&quot;
</a><a href="#h32-0-45" id="h32-0-45" class="i">+	&quot;sync&quot;
</a><a href="#h32-0-46" id="h32-0-46" class="i">+)
</a><a href="#h32-0-47" id="h32-0-47" class="i">+
</a><a href="#h32-0-48" id="h32-0-48" class="i">+const debug bool = false
</a><a href="#h32-0-49" id="h32-0-49" class="i">+
</a><a href="#h32-0-50" id="h32-0-50" class="i">+// Constants that identify the encoding of a value on the wire.
</a><a href="#h32-0-51" id="h32-0-51" class="i">+const (
</a><a href="#h32-0-52" id="h32-0-52" class="i">+	WireVarint     = 0
</a><a href="#h32-0-53" id="h32-0-53" class="i">+	WireFixed64    = 1
</a><a href="#h32-0-54" id="h32-0-54" class="i">+	WireBytes      = 2
</a><a href="#h32-0-55" id="h32-0-55" class="i">+	WireStartGroup = 3
</a><a href="#h32-0-56" id="h32-0-56" class="i">+	WireEndGroup   = 4
</a><a href="#h32-0-57" id="h32-0-57" class="i">+	WireFixed32    = 5
</a><a href="#h32-0-58" id="h32-0-58" class="i">+)
</a><a href="#h32-0-59" id="h32-0-59" class="i">+
</a><a href="#h32-0-60" id="h32-0-60" class="i">+const startSize = 10 // initial slice/string sizes
</a><a href="#h32-0-61" id="h32-0-61" class="i">+
</a><a href="#h32-0-62" id="h32-0-62" class="i">+// Encoders are defined in encode.go
</a><a href="#h32-0-63" id="h32-0-63" class="i">+// An encoder outputs the full representation of a field, including its
</a><a href="#h32-0-64" id="h32-0-64" class="i">+// tag and encoder type.
</a><a href="#h32-0-65" id="h32-0-65" class="i">+type encoder func(p *Buffer, prop *Properties, base structPointer) error
</a><a href="#h32-0-66" id="h32-0-66" class="i">+
</a><a href="#h32-0-67" id="h32-0-67" class="i">+// A valueEncoder encodes a single integer in a particular encoding.
</a><a href="#h32-0-68" id="h32-0-68" class="i">+type valueEncoder func(o *Buffer, x uint64) error
</a><a href="#h32-0-69" id="h32-0-69" class="i">+
</a><a href="#h32-0-70" id="h32-0-70" class="i">+// Sizers are defined in encode.go
</a><a href="#h32-0-71" id="h32-0-71" class="i">+// A sizer returns the encoded size of a field, including its tag and encoder
</a><a href="#h32-0-72" id="h32-0-72" class="i">+// type.
</a><a href="#h32-0-73" id="h32-0-73" class="i">+type sizer func(prop *Properties, base structPointer) int
</a><a href="#h32-0-74" id="h32-0-74" class="i">+
</a><a href="#h32-0-75" id="h32-0-75" class="i">+// A valueSizer returns the encoded size of a single integer in a particular
</a><a href="#h32-0-76" id="h32-0-76" class="i">+// encoding.
</a><a href="#h32-0-77" id="h32-0-77" class="i">+type valueSizer func(x uint64) int
</a><a href="#h32-0-78" id="h32-0-78" class="i">+
</a><a href="#h32-0-79" id="h32-0-79" class="i">+// Decoders are defined in decode.go
</a><a href="#h32-0-80" id="h32-0-80" class="i">+// A decoder creates a value from its wire representation.
</a><a href="#h32-0-81" id="h32-0-81" class="i">+// Unrecognized subelements are saved in unrec.
</a><a href="#h32-0-82" id="h32-0-82" class="i">+type decoder func(p *Buffer, prop *Properties, base structPointer) error
</a><a href="#h32-0-83" id="h32-0-83" class="i">+
</a><a href="#h32-0-84" id="h32-0-84" class="i">+// A valueDecoder decodes a single integer in a particular encoding.
</a><a href="#h32-0-85" id="h32-0-85" class="i">+type valueDecoder func(o *Buffer) (x uint64, err error)
</a><a href="#h32-0-86" id="h32-0-86" class="i">+
</a><a href="#h32-0-87" id="h32-0-87" class="i">+// A oneofMarshaler does the marshaling for all oneof fields in a message.
</a><a href="#h32-0-88" id="h32-0-88" class="i">+type oneofMarshaler func(Message, *Buffer) error
</a><a href="#h32-0-89" id="h32-0-89" class="i">+
</a><a href="#h32-0-90" id="h32-0-90" class="i">+// A oneofUnmarshaler does the unmarshaling for a oneof field in a message.
</a><a href="#h32-0-91" id="h32-0-91" class="i">+type oneofUnmarshaler func(Message, int, int, *Buffer) (bool, error)
</a><a href="#h32-0-92" id="h32-0-92" class="i">+
</a><a href="#h32-0-93" id="h32-0-93" class="i">+// A oneofSizer does the sizing for all oneof fields in a message.
</a><a href="#h32-0-94" id="h32-0-94" class="i">+type oneofSizer func(Message) int
</a><a href="#h32-0-95" id="h32-0-95" class="i">+
</a><a href="#h32-0-96" id="h32-0-96" class="i">+// tagMap is an optimization over map[int]int for typical protocol buffer
</a><a href="#h32-0-97" id="h32-0-97" class="i">+// use-cases. Encoded protocol buffers are often in tag order with small tag
</a><a href="#h32-0-98" id="h32-0-98" class="i">+// numbers.
</a><a href="#h32-0-99" id="h32-0-99" class="i">+type tagMap struct {
</a><a href="#h32-0-100" id="h32-0-100" class="i">+	fastTags []int
</a><a href="#h32-0-101" id="h32-0-101" class="i">+	slowTags map[int]int
</a><a href="#h32-0-102" id="h32-0-102" class="i">+}
</a><a href="#h32-0-103" id="h32-0-103" class="i">+
</a><a href="#h32-0-104" id="h32-0-104" class="i">+// tagMapFastLimit is the upper bound on the tag number that will be stored in
</a><a href="#h32-0-105" id="h32-0-105" class="i">+// the tagMap slice rather than its map.
</a><a href="#h32-0-106" id="h32-0-106" class="i">+const tagMapFastLimit = 1024
</a><a href="#h32-0-107" id="h32-0-107" class="i">+
</a><a href="#h32-0-108" id="h32-0-108" class="i">+func (p *tagMap) get(t int) (int, bool) {
</a><a href="#h32-0-109" id="h32-0-109" class="i">+	if t &gt; 0 &amp;&amp; t &lt; tagMapFastLimit {
</a><a href="#h32-0-110" id="h32-0-110" class="i">+		if t &gt;= len(p.fastTags) {
</a><a href="#h32-0-111" id="h32-0-111" class="i">+			return 0, false
</a><a href="#h32-0-112" id="h32-0-112" class="i">+		}
</a><a href="#h32-0-113" id="h32-0-113" class="i">+		fi := p.fastTags[t]
</a><a href="#h32-0-114" id="h32-0-114" class="i">+		return fi, fi &gt;= 0
</a><a href="#h32-0-115" id="h32-0-115" class="i">+	}
</a><a href="#h32-0-116" id="h32-0-116" class="i">+	fi, ok := p.slowTags[t]
</a><a href="#h32-0-117" id="h32-0-117" class="i">+	return fi, ok
</a><a href="#h32-0-118" id="h32-0-118" class="i">+}
</a><a href="#h32-0-119" id="h32-0-119" class="i">+
</a><a href="#h32-0-120" id="h32-0-120" class="i">+func (p *tagMap) put(t int, fi int) {
</a><a href="#h32-0-121" id="h32-0-121" class="i">+	if t &gt; 0 &amp;&amp; t &lt; tagMapFastLimit {
</a><a href="#h32-0-122" id="h32-0-122" class="i">+		for len(p.fastTags) &lt; t+1 {
</a><a href="#h32-0-123" id="h32-0-123" class="i">+			p.fastTags = append(p.fastTags, -1)
</a><a href="#h32-0-124" id="h32-0-124" class="i">+		}
</a><a href="#h32-0-125" id="h32-0-125" class="i">+		p.fastTags[t] = fi
</a><a href="#h32-0-126" id="h32-0-126" class="i">+		return
</a><a href="#h32-0-127" id="h32-0-127" class="i">+	}
</a><a href="#h32-0-128" id="h32-0-128" class="i">+	if p.slowTags == nil {
</a><a href="#h32-0-129" id="h32-0-129" class="i">+		p.slowTags = make(map[int]int)
</a><a href="#h32-0-130" id="h32-0-130" class="i">+	}
</a><a href="#h32-0-131" id="h32-0-131" class="i">+	p.slowTags[t] = fi
</a><a href="#h32-0-132" id="h32-0-132" class="i">+}
</a><a href="#h32-0-133" id="h32-0-133" class="i">+
</a><a href="#h32-0-134" id="h32-0-134" class="i">+// StructProperties represents properties for all the fields of a struct.
</a><a href="#h32-0-135" id="h32-0-135" class="i">+// decoderTags and decoderOrigNames should only be used by the decoder.
</a><a href="#h32-0-136" id="h32-0-136" class="i">+type StructProperties struct {
</a><a href="#h32-0-137" id="h32-0-137" class="i">+	Prop             []*Properties  // properties for each field
</a><a href="#h32-0-138" id="h32-0-138" class="i">+	reqCount         int            // required count
</a><a href="#h32-0-139" id="h32-0-139" class="i">+	decoderTags      tagMap         // map from proto tag to struct field number
</a><a href="#h32-0-140" id="h32-0-140" class="i">+	decoderOrigNames map[string]int // map from original name to struct field number
</a><a href="#h32-0-141" id="h32-0-141" class="i">+	order            []int          // list of struct field numbers in tag order
</a><a href="#h32-0-142" id="h32-0-142" class="i">+	unrecField       field          // field id of the XXX_unrecognized []byte field
</a><a href="#h32-0-143" id="h32-0-143" class="i">+	extendable       bool           // is this an extendable proto
</a><a href="#h32-0-144" id="h32-0-144" class="i">+
</a><a href="#h32-0-145" id="h32-0-145" class="i">+	oneofMarshaler   oneofMarshaler
</a><a href="#h32-0-146" id="h32-0-146" class="i">+	oneofUnmarshaler oneofUnmarshaler
</a><a href="#h32-0-147" id="h32-0-147" class="i">+	oneofSizer       oneofSizer
</a><a href="#h32-0-148" id="h32-0-148" class="i">+	stype            reflect.Type
</a><a href="#h32-0-149" id="h32-0-149" class="i">+
</a><a href="#h32-0-150" id="h32-0-150" class="i">+	// OneofTypes contains information about the oneof fields in this message.
</a><a href="#h32-0-151" id="h32-0-151" class="i">+	// It is keyed by the original name of a field.
</a><a href="#h32-0-152" id="h32-0-152" class="i">+	OneofTypes map[string]*OneofProperties
</a><a href="#h32-0-153" id="h32-0-153" class="i">+}
</a><a href="#h32-0-154" id="h32-0-154" class="i">+
</a><a href="#h32-0-155" id="h32-0-155" class="i">+// OneofProperties represents information about a specific field in a oneof.
</a><a href="#h32-0-156" id="h32-0-156" class="i">+type OneofProperties struct {
</a><a href="#h32-0-157" id="h32-0-157" class="i">+	Type  reflect.Type // pointer to generated struct type for this oneof field
</a><a href="#h32-0-158" id="h32-0-158" class="i">+	Field int          // struct field number of the containing oneof in the message
</a><a href="#h32-0-159" id="h32-0-159" class="i">+	Prop  *Properties
</a><a href="#h32-0-160" id="h32-0-160" class="i">+}
</a><a href="#h32-0-161" id="h32-0-161" class="i">+
</a><a href="#h32-0-162" id="h32-0-162" class="i">+// Implement the sorting interface so we can sort the fields in tag order, as recommended by the spec.
</a><a href="#h32-0-163" id="h32-0-163" class="i">+// See encode.go, (*Buffer).enc_struct.
</a><a href="#h32-0-164" id="h32-0-164" class="i">+
</a><a href="#h32-0-165" id="h32-0-165" class="i">+func (sp *StructProperties) Len() int { return len(sp.order) }
</a><a href="#h32-0-166" id="h32-0-166" class="i">+func (sp *StructProperties) Less(i, j int) bool {
</a><a href="#h32-0-167" id="h32-0-167" class="i">+	return sp.Prop[sp.order[i]].Tag &lt; sp.Prop[sp.order[j]].Tag
</a><a href="#h32-0-168" id="h32-0-168" class="i">+}
</a><a href="#h32-0-169" id="h32-0-169" class="i">+func (sp *StructProperties) Swap(i, j int) { sp.order[i], sp.order[j] = sp.order[j], sp.order[i] }
</a><a href="#h32-0-170" id="h32-0-170" class="i">+
</a><a href="#h32-0-171" id="h32-0-171" class="i">+// Properties represents the protocol-specific behavior of a single struct field.
</a><a href="#h32-0-172" id="h32-0-172" class="i">+type Properties struct {
</a><a href="#h32-0-173" id="h32-0-173" class="i">+	Name     string // name of the field, for error messages
</a><a href="#h32-0-174" id="h32-0-174" class="i">+	OrigName string // original name before protocol compiler (always set)
</a><a href="#h32-0-175" id="h32-0-175" class="i">+	JSONName string // name to use for JSON; determined by protoc
</a><a href="#h32-0-176" id="h32-0-176" class="i">+	Wire     string
</a><a href="#h32-0-177" id="h32-0-177" class="i">+	WireType int
</a><a href="#h32-0-178" id="h32-0-178" class="i">+	Tag      int
</a><a href="#h32-0-179" id="h32-0-179" class="i">+	Required bool
</a><a href="#h32-0-180" id="h32-0-180" class="i">+	Optional bool
</a><a href="#h32-0-181" id="h32-0-181" class="i">+	Repeated bool
</a><a href="#h32-0-182" id="h32-0-182" class="i">+	Packed   bool   // relevant for repeated primitives only
</a><a href="#h32-0-183" id="h32-0-183" class="i">+	Enum     string // set for enum types only
</a><a href="#h32-0-184" id="h32-0-184" class="i">+	proto3   bool   // whether this is known to be a proto3 field; set for []byte only
</a><a href="#h32-0-185" id="h32-0-185" class="i">+	oneof    bool   // whether this is a oneof field
</a><a href="#h32-0-186" id="h32-0-186" class="i">+
</a><a href="#h32-0-187" id="h32-0-187" class="i">+	Default    string // default value
</a><a href="#h32-0-188" id="h32-0-188" class="i">+	HasDefault bool   // whether an explicit default was provided
</a><a href="#h32-0-189" id="h32-0-189" class="i">+	def_uint64 uint64
</a><a href="#h32-0-190" id="h32-0-190" class="i">+
</a><a href="#h32-0-191" id="h32-0-191" class="i">+	enc           encoder
</a><a href="#h32-0-192" id="h32-0-192" class="i">+	valEnc        valueEncoder // set for bool and numeric types only
</a><a href="#h32-0-193" id="h32-0-193" class="i">+	field         field
</a><a href="#h32-0-194" id="h32-0-194" class="i">+	tagcode       []byte // encoding of EncodeVarint((Tag&lt;&lt;3)|WireType)
</a><a href="#h32-0-195" id="h32-0-195" class="i">+	tagbuf        [8]byte
</a><a href="#h32-0-196" id="h32-0-196" class="i">+	stype         reflect.Type      // set for struct types only
</a><a href="#h32-0-197" id="h32-0-197" class="i">+	sprop         *StructProperties // set for struct types only
</a><a href="#h32-0-198" id="h32-0-198" class="i">+	isMarshaler   bool
</a><a href="#h32-0-199" id="h32-0-199" class="i">+	isUnmarshaler bool
</a><a href="#h32-0-200" id="h32-0-200" class="i">+
</a><a href="#h32-0-201" id="h32-0-201" class="i">+	mtype    reflect.Type // set for map types only
</a><a href="#h32-0-202" id="h32-0-202" class="i">+	mkeyprop *Properties  // set for map types only
</a><a href="#h32-0-203" id="h32-0-203" class="i">+	mvalprop *Properties  // set for map types only
</a><a href="#h32-0-204" id="h32-0-204" class="i">+
</a><a href="#h32-0-205" id="h32-0-205" class="i">+	size    sizer
</a><a href="#h32-0-206" id="h32-0-206" class="i">+	valSize valueSizer // set for bool and numeric types only
</a><a href="#h32-0-207" id="h32-0-207" class="i">+
</a><a href="#h32-0-208" id="h32-0-208" class="i">+	dec    decoder
</a><a href="#h32-0-209" id="h32-0-209" class="i">+	valDec valueDecoder // set for bool and numeric types only
</a><a href="#h32-0-210" id="h32-0-210" class="i">+
</a><a href="#h32-0-211" id="h32-0-211" class="i">+	// If this is a packable field, this will be the decoder for the packed version of the field.
</a><a href="#h32-0-212" id="h32-0-212" class="i">+	packedDec decoder
</a><a href="#h32-0-213" id="h32-0-213" class="i">+}
</a><a href="#h32-0-214" id="h32-0-214" class="i">+
</a><a href="#h32-0-215" id="h32-0-215" class="i">+// String formats the properties in the protobuf struct field tag style.
</a><a href="#h32-0-216" id="h32-0-216" class="i">+func (p *Properties) String() string {
</a><a href="#h32-0-217" id="h32-0-217" class="i">+	s := p.Wire
</a><a href="#h32-0-218" id="h32-0-218" class="i">+	s = &quot;,&quot;
</a><a href="#h32-0-219" id="h32-0-219" class="i">+	s += strconv.Itoa(p.Tag)
</a><a href="#h32-0-220" id="h32-0-220" class="i">+	if p.Required {
</a><a href="#h32-0-221" id="h32-0-221" class="i">+		s += &quot;,req&quot;
</a><a href="#h32-0-222" id="h32-0-222" class="i">+	}
</a><a href="#h32-0-223" id="h32-0-223" class="i">+	if p.Optional {
</a><a href="#h32-0-224" id="h32-0-224" class="i">+		s += &quot;,opt&quot;
</a><a href="#h32-0-225" id="h32-0-225" class="i">+	}
</a><a href="#h32-0-226" id="h32-0-226" class="i">+	if p.Repeated {
</a><a href="#h32-0-227" id="h32-0-227" class="i">+		s += &quot;,rep&quot;
</a><a href="#h32-0-228" id="h32-0-228" class="i">+	}
</a><a href="#h32-0-229" id="h32-0-229" class="i">+	if p.Packed {
</a><a href="#h32-0-230" id="h32-0-230" class="i">+		s += &quot;,packed&quot;
</a><a href="#h32-0-231" id="h32-0-231" class="i">+	}
</a><a href="#h32-0-232" id="h32-0-232" class="i">+	s += &quot;,name=&quot; + p.OrigName
</a><a href="#h32-0-233" id="h32-0-233" class="i">+	if p.JSONName != p.OrigName {
</a><a href="#h32-0-234" id="h32-0-234" class="i">+		s += &quot;,json=&quot; + p.JSONName
</a><a href="#h32-0-235" id="h32-0-235" class="i">+	}
</a><a href="#h32-0-236" id="h32-0-236" class="i">+	if p.proto3 {
</a><a href="#h32-0-237" id="h32-0-237" class="i">+		s += &quot;,proto3&quot;
</a><a href="#h32-0-238" id="h32-0-238" class="i">+	}
</a><a href="#h32-0-239" id="h32-0-239" class="i">+	if p.oneof {
</a><a href="#h32-0-240" id="h32-0-240" class="i">+		s += &quot;,oneof&quot;
</a><a href="#h32-0-241" id="h32-0-241" class="i">+	}
</a><a href="#h32-0-242" id="h32-0-242" class="i">+	if len(p.Enum) &gt; 0 {
</a><a href="#h32-0-243" id="h32-0-243" class="i">+		s += &quot;,enum=&quot; + p.Enum
</a><a href="#h32-0-244" id="h32-0-244" class="i">+	}
</a><a href="#h32-0-245" id="h32-0-245" class="i">+	if p.HasDefault {
</a><a href="#h32-0-246" id="h32-0-246" class="i">+		s += &quot;,def=&quot; + p.Default
</a><a href="#h32-0-247" id="h32-0-247" class="i">+	}
</a><a href="#h32-0-248" id="h32-0-248" class="i">+	return s
</a><a href="#h32-0-249" id="h32-0-249" class="i">+}
</a><a href="#h32-0-250" id="h32-0-250" class="i">+
</a><a href="#h32-0-251" id="h32-0-251" class="i">+// Parse populates p by parsing a string in the protobuf struct field tag style.
</a><a href="#h32-0-252" id="h32-0-252" class="i">+func (p *Properties) Parse(s string) {
</a><a href="#h32-0-253" id="h32-0-253" class="i">+	// &quot;bytes,49,opt,name=foo,def=hello!&quot;
</a><a href="#h32-0-254" id="h32-0-254" class="i">+	fields := strings.Split(s, &quot;,&quot;) // breaks def=, but handled below.
</a><a href="#h32-0-255" id="h32-0-255" class="i">+	if len(fields) &lt; 2 {
</a><a href="#h32-0-256" id="h32-0-256" class="i">+		fmt.Fprintf(os.Stderr, &quot;proto: tag has too few fields: %q\n&quot;, s)
</a><a href="#h32-0-257" id="h32-0-257" class="i">+		return
</a><a href="#h32-0-258" id="h32-0-258" class="i">+	}
</a><a href="#h32-0-259" id="h32-0-259" class="i">+
</a><a href="#h32-0-260" id="h32-0-260" class="i">+	p.Wire = fields[0]
</a><a href="#h32-0-261" id="h32-0-261" class="i">+	switch p.Wire {
</a><a href="#h32-0-262" id="h32-0-262" class="i">+	case &quot;varint&quot;:
</a><a href="#h32-0-263" id="h32-0-263" class="i">+		p.WireType = WireVarint
</a><a href="#h32-0-264" id="h32-0-264" class="i">+		p.valEnc = (*Buffer).EncodeVarint
</a><a href="#h32-0-265" id="h32-0-265" class="i">+		p.valDec = (*Buffer).DecodeVarint
</a><a href="#h32-0-266" id="h32-0-266" class="i">+		p.valSize = sizeVarint
</a><a href="#h32-0-267" id="h32-0-267" class="i">+	case &quot;fixed32&quot;:
</a><a href="#h32-0-268" id="h32-0-268" class="i">+		p.WireType = WireFixed32
</a><a href="#h32-0-269" id="h32-0-269" class="i">+		p.valEnc = (*Buffer).EncodeFixed32
</a><a href="#h32-0-270" id="h32-0-270" class="i">+		p.valDec = (*Buffer).DecodeFixed32
</a><a href="#h32-0-271" id="h32-0-271" class="i">+		p.valSize = sizeFixed32
</a><a href="#h32-0-272" id="h32-0-272" class="i">+	case &quot;fixed64&quot;:
</a><a href="#h32-0-273" id="h32-0-273" class="i">+		p.WireType = WireFixed64
</a><a href="#h32-0-274" id="h32-0-274" class="i">+		p.valEnc = (*Buffer).EncodeFixed64
</a><a href="#h32-0-275" id="h32-0-275" class="i">+		p.valDec = (*Buffer).DecodeFixed64
</a><a href="#h32-0-276" id="h32-0-276" class="i">+		p.valSize = sizeFixed64
</a><a href="#h32-0-277" id="h32-0-277" class="i">+	case &quot;zigzag32&quot;:
</a><a href="#h32-0-278" id="h32-0-278" class="i">+		p.WireType = WireVarint
</a><a href="#h32-0-279" id="h32-0-279" class="i">+		p.valEnc = (*Buffer).EncodeZigzag32
</a><a href="#h32-0-280" id="h32-0-280" class="i">+		p.valDec = (*Buffer).DecodeZigzag32
</a><a href="#h32-0-281" id="h32-0-281" class="i">+		p.valSize = sizeZigzag32
</a><a href="#h32-0-282" id="h32-0-282" class="i">+	case &quot;zigzag64&quot;:
</a><a href="#h32-0-283" id="h32-0-283" class="i">+		p.WireType = WireVarint
</a><a href="#h32-0-284" id="h32-0-284" class="i">+		p.valEnc = (*Buffer).EncodeZigzag64
</a><a href="#h32-0-285" id="h32-0-285" class="i">+		p.valDec = (*Buffer).DecodeZigzag64
</a><a href="#h32-0-286" id="h32-0-286" class="i">+		p.valSize = sizeZigzag64
</a><a href="#h32-0-287" id="h32-0-287" class="i">+	case &quot;bytes&quot;, &quot;group&quot;:
</a><a href="#h32-0-288" id="h32-0-288" class="i">+		p.WireType = WireBytes
</a><a href="#h32-0-289" id="h32-0-289" class="i">+		// no numeric converter for non-numeric types
</a><a href="#h32-0-290" id="h32-0-290" class="i">+	default:
</a><a href="#h32-0-291" id="h32-0-291" class="i">+		fmt.Fprintf(os.Stderr, &quot;proto: tag has unknown wire type: %q\n&quot;, s)
</a><a href="#h32-0-292" id="h32-0-292" class="i">+		return
</a><a href="#h32-0-293" id="h32-0-293" class="i">+	}
</a><a href="#h32-0-294" id="h32-0-294" class="i">+
</a><a href="#h32-0-295" id="h32-0-295" class="i">+	var err error
</a><a href="#h32-0-296" id="h32-0-296" class="i">+	p.Tag, err = strconv.Atoi(fields[1])
</a><a href="#h32-0-297" id="h32-0-297" class="i">+	if err != nil {
</a><a href="#h32-0-298" id="h32-0-298" class="i">+		return
</a><a href="#h32-0-299" id="h32-0-299" class="i">+	}
</a><a href="#h32-0-300" id="h32-0-300" class="i">+
</a><a href="#h32-0-301" id="h32-0-301" class="i">+	for i := 2; i &lt; len(fields); i++ {
</a><a href="#h32-0-302" id="h32-0-302" class="i">+		f := fields[i]
</a><a href="#h32-0-303" id="h32-0-303" class="i">+		switch {
</a><a href="#h32-0-304" id="h32-0-304" class="i">+		case f == &quot;req&quot;:
</a><a href="#h32-0-305" id="h32-0-305" class="i">+			p.Required = true
</a><a href="#h32-0-306" id="h32-0-306" class="i">+		case f == &quot;opt&quot;:
</a><a href="#h32-0-307" id="h32-0-307" class="i">+			p.Optional = true
</a><a href="#h32-0-308" id="h32-0-308" class="i">+		case f == &quot;rep&quot;:
</a><a href="#h32-0-309" id="h32-0-309" class="i">+			p.Repeated = true
</a><a href="#h32-0-310" id="h32-0-310" class="i">+		case f == &quot;packed&quot;:
</a><a href="#h32-0-311" id="h32-0-311" class="i">+			p.Packed = true
</a><a href="#h32-0-312" id="h32-0-312" class="i">+		case strings.HasPrefix(f, &quot;name=&quot;):
</a><a href="#h32-0-313" id="h32-0-313" class="i">+			p.OrigName = f[5:]
</a><a href="#h32-0-314" id="h32-0-314" class="i">+		case strings.HasPrefix(f, &quot;json=&quot;):
</a><a href="#h32-0-315" id="h32-0-315" class="i">+			p.JSONName = f[5:]
</a><a href="#h32-0-316" id="h32-0-316" class="i">+		case strings.HasPrefix(f, &quot;enum=&quot;):
</a><a href="#h32-0-317" id="h32-0-317" class="i">+			p.Enum = f[5:]
</a><a href="#h32-0-318" id="h32-0-318" class="i">+		case f == &quot;proto3&quot;:
</a><a href="#h32-0-319" id="h32-0-319" class="i">+			p.proto3 = true
</a><a href="#h32-0-320" id="h32-0-320" class="i">+		case f == &quot;oneof&quot;:
</a><a href="#h32-0-321" id="h32-0-321" class="i">+			p.oneof = true
</a><a href="#h32-0-322" id="h32-0-322" class="i">+		case strings.HasPrefix(f, &quot;def=&quot;):
</a><a href="#h32-0-323" id="h32-0-323" class="i">+			p.HasDefault = true
</a><a href="#h32-0-324" id="h32-0-324" class="i">+			p.Default = f[4:] // rest of string
</a><a href="#h32-0-325" id="h32-0-325" class="i">+			if i+1 &lt; len(fields) {
</a><a href="#h32-0-326" id="h32-0-326" class="i">+				// Commas aren&#39;t escaped, and def is always last.
</a><a href="#h32-0-327" id="h32-0-327" class="i">+				p.Default += &quot;,&quot; + strings.Join(fields[i+1:], &quot;,&quot;)
</a><a href="#h32-0-328" id="h32-0-328" class="i">+				break
</a><a href="#h32-0-329" id="h32-0-329" class="i">+			}
</a><a href="#h32-0-330" id="h32-0-330" class="i">+		}
</a><a href="#h32-0-331" id="h32-0-331" class="i">+	}
</a><a href="#h32-0-332" id="h32-0-332" class="i">+}
</a><a href="#h32-0-333" id="h32-0-333" class="i">+
</a><a href="#h32-0-334" id="h32-0-334" class="i">+func logNoSliceEnc(t1, t2 reflect.Type) {
</a><a href="#h32-0-335" id="h32-0-335" class="i">+	fmt.Fprintf(os.Stderr, &quot;proto: no slice oenc for %T = []%T\n&quot;, t1, t2)
</a><a href="#h32-0-336" id="h32-0-336" class="i">+}
</a><a href="#h32-0-337" id="h32-0-337" class="i">+
</a><a href="#h32-0-338" id="h32-0-338" class="i">+var protoMessageType = reflect.TypeOf((*Message)(nil)).Elem()
</a><a href="#h32-0-339" id="h32-0-339" class="i">+
</a><a href="#h32-0-340" id="h32-0-340" class="i">+// Initialize the fields for encoding and decoding.
</a><a href="#h32-0-341" id="h32-0-341" class="i">+func (p *Properties) setEncAndDec(typ reflect.Type, f *reflect.StructField, lockGetProp bool) {
</a><a href="#h32-0-342" id="h32-0-342" class="i">+	p.enc = nil
</a><a href="#h32-0-343" id="h32-0-343" class="i">+	p.dec = nil
</a><a href="#h32-0-344" id="h32-0-344" class="i">+	p.size = nil
</a><a href="#h32-0-345" id="h32-0-345" class="i">+
</a><a href="#h32-0-346" id="h32-0-346" class="i">+	switch t1 := typ; t1.Kind() {
</a><a href="#h32-0-347" id="h32-0-347" class="i">+	default:
</a><a href="#h32-0-348" id="h32-0-348" class="i">+		fmt.Fprintf(os.Stderr, &quot;proto: no coders for %v\n&quot;, t1)
</a><a href="#h32-0-349" id="h32-0-349" class="i">+
</a><a href="#h32-0-350" id="h32-0-350" class="i">+	// proto3 scalar types
</a><a href="#h32-0-351" id="h32-0-351" class="i">+
</a><a href="#h32-0-352" id="h32-0-352" class="i">+	case reflect.Bool:
</a><a href="#h32-0-353" id="h32-0-353" class="i">+		p.enc = (*Buffer).enc_proto3_bool
</a><a href="#h32-0-354" id="h32-0-354" class="i">+		p.dec = (*Buffer).dec_proto3_bool
</a><a href="#h32-0-355" id="h32-0-355" class="i">+		p.size = size_proto3_bool
</a><a href="#h32-0-356" id="h32-0-356" class="i">+	case reflect.Int32:
</a><a href="#h32-0-357" id="h32-0-357" class="i">+		p.enc = (*Buffer).enc_proto3_int32
</a><a href="#h32-0-358" id="h32-0-358" class="i">+		p.dec = (*Buffer).dec_proto3_int32
</a><a href="#h32-0-359" id="h32-0-359" class="i">+		p.size = size_proto3_int32
</a><a href="#h32-0-360" id="h32-0-360" class="i">+	case reflect.Uint32:
</a><a href="#h32-0-361" id="h32-0-361" class="i">+		p.enc = (*Buffer).enc_proto3_uint32
</a><a href="#h32-0-362" id="h32-0-362" class="i">+		p.dec = (*Buffer).dec_proto3_int32 // can reuse
</a><a href="#h32-0-363" id="h32-0-363" class="i">+		p.size = size_proto3_uint32
</a><a href="#h32-0-364" id="h32-0-364" class="i">+	case reflect.Int64, reflect.Uint64:
</a><a href="#h32-0-365" id="h32-0-365" class="i">+		p.enc = (*Buffer).enc_proto3_int64
</a><a href="#h32-0-366" id="h32-0-366" class="i">+		p.dec = (*Buffer).dec_proto3_int64
</a><a href="#h32-0-367" id="h32-0-367" class="i">+		p.size = size_proto3_int64
</a><a href="#h32-0-368" id="h32-0-368" class="i">+	case reflect.Float32:
</a><a href="#h32-0-369" id="h32-0-369" class="i">+		p.enc = (*Buffer).enc_proto3_uint32 // can just treat them as bits
</a><a href="#h32-0-370" id="h32-0-370" class="i">+		p.dec = (*Buffer).dec_proto3_int32
</a><a href="#h32-0-371" id="h32-0-371" class="i">+		p.size = size_proto3_uint32
</a><a href="#h32-0-372" id="h32-0-372" class="i">+	case reflect.Float64:
</a><a href="#h32-0-373" id="h32-0-373" class="i">+		p.enc = (*Buffer).enc_proto3_int64 // can just treat them as bits
</a><a href="#h32-0-374" id="h32-0-374" class="i">+		p.dec = (*Buffer).dec_proto3_int64
</a><a href="#h32-0-375" id="h32-0-375" class="i">+		p.size = size_proto3_int64
</a><a href="#h32-0-376" id="h32-0-376" class="i">+	case reflect.String:
</a><a href="#h32-0-377" id="h32-0-377" class="i">+		p.enc = (*Buffer).enc_proto3_string
</a><a href="#h32-0-378" id="h32-0-378" class="i">+		p.dec = (*Buffer).dec_proto3_string
</a><a href="#h32-0-379" id="h32-0-379" class="i">+		p.size = size_proto3_string
</a><a href="#h32-0-380" id="h32-0-380" class="i">+
</a><a href="#h32-0-381" id="h32-0-381" class="i">+	case reflect.Ptr:
</a><a href="#h32-0-382" id="h32-0-382" class="i">+		switch t2 := t1.Elem(); t2.Kind() {
</a><a href="#h32-0-383" id="h32-0-383" class="i">+		default:
</a><a href="#h32-0-384" id="h32-0-384" class="i">+			fmt.Fprintf(os.Stderr, &quot;proto: no encoder function for %v -&gt; %v\n&quot;, t1, t2)
</a><a href="#h32-0-385" id="h32-0-385" class="i">+			break
</a><a href="#h32-0-386" id="h32-0-386" class="i">+		case reflect.Bool:
</a><a href="#h32-0-387" id="h32-0-387" class="i">+			p.enc = (*Buffer).enc_bool
</a><a href="#h32-0-388" id="h32-0-388" class="i">+			p.dec = (*Buffer).dec_bool
</a><a href="#h32-0-389" id="h32-0-389" class="i">+			p.size = size_bool
</a><a href="#h32-0-390" id="h32-0-390" class="i">+		case reflect.Int32:
</a><a href="#h32-0-391" id="h32-0-391" class="i">+			p.enc = (*Buffer).enc_int32
</a><a href="#h32-0-392" id="h32-0-392" class="i">+			p.dec = (*Buffer).dec_int32
</a><a href="#h32-0-393" id="h32-0-393" class="i">+			p.size = size_int32
</a><a href="#h32-0-394" id="h32-0-394" class="i">+		case reflect.Uint32:
</a><a href="#h32-0-395" id="h32-0-395" class="i">+			p.enc = (*Buffer).enc_uint32
</a><a href="#h32-0-396" id="h32-0-396" class="i">+			p.dec = (*Buffer).dec_int32 // can reuse
</a><a href="#h32-0-397" id="h32-0-397" class="i">+			p.size = size_uint32
</a><a href="#h32-0-398" id="h32-0-398" class="i">+		case reflect.Int64, reflect.Uint64:
</a><a href="#h32-0-399" id="h32-0-399" class="i">+			p.enc = (*Buffer).enc_int64
</a><a href="#h32-0-400" id="h32-0-400" class="i">+			p.dec = (*Buffer).dec_int64
</a><a href="#h32-0-401" id="h32-0-401" class="i">+			p.size = size_int64
</a><a href="#h32-0-402" id="h32-0-402" class="i">+		case reflect.Float32:
</a><a href="#h32-0-403" id="h32-0-403" class="i">+			p.enc = (*Buffer).enc_uint32 // can just treat them as bits
</a><a href="#h32-0-404" id="h32-0-404" class="i">+			p.dec = (*Buffer).dec_int32
</a><a href="#h32-0-405" id="h32-0-405" class="i">+			p.size = size_uint32
</a><a href="#h32-0-406" id="h32-0-406" class="i">+		case reflect.Float64:
</a><a href="#h32-0-407" id="h32-0-407" class="i">+			p.enc = (*Buffer).enc_int64 // can just treat them as bits
</a><a href="#h32-0-408" id="h32-0-408" class="i">+			p.dec = (*Buffer).dec_int64
</a><a href="#h32-0-409" id="h32-0-409" class="i">+			p.size = size_int64
</a><a href="#h32-0-410" id="h32-0-410" class="i">+		case reflect.String:
</a><a href="#h32-0-411" id="h32-0-411" class="i">+			p.enc = (*Buffer).enc_string
</a><a href="#h32-0-412" id="h32-0-412" class="i">+			p.dec = (*Buffer).dec_string
</a><a href="#h32-0-413" id="h32-0-413" class="i">+			p.size = size_string
</a><a href="#h32-0-414" id="h32-0-414" class="i">+		case reflect.Struct:
</a><a href="#h32-0-415" id="h32-0-415" class="i">+			p.stype = t1.Elem()
</a><a href="#h32-0-416" id="h32-0-416" class="i">+			p.isMarshaler = isMarshaler(t1)
</a><a href="#h32-0-417" id="h32-0-417" class="i">+			p.isUnmarshaler = isUnmarshaler(t1)
</a><a href="#h32-0-418" id="h32-0-418" class="i">+			if p.Wire == &quot;bytes&quot; {
</a><a href="#h32-0-419" id="h32-0-419" class="i">+				p.enc = (*Buffer).enc_struct_message
</a><a href="#h32-0-420" id="h32-0-420" class="i">+				p.dec = (*Buffer).dec_struct_message
</a><a href="#h32-0-421" id="h32-0-421" class="i">+				p.size = size_struct_message
</a><a href="#h32-0-422" id="h32-0-422" class="i">+			} else {
</a><a href="#h32-0-423" id="h32-0-423" class="i">+				p.enc = (*Buffer).enc_struct_group
</a><a href="#h32-0-424" id="h32-0-424" class="i">+				p.dec = (*Buffer).dec_struct_group
</a><a href="#h32-0-425" id="h32-0-425" class="i">+				p.size = size_struct_group
</a><a href="#h32-0-426" id="h32-0-426" class="i">+			}
</a><a href="#h32-0-427" id="h32-0-427" class="i">+		}
</a><a href="#h32-0-428" id="h32-0-428" class="i">+
</a><a href="#h32-0-429" id="h32-0-429" class="i">+	case reflect.Slice:
</a><a href="#h32-0-430" id="h32-0-430" class="i">+		switch t2 := t1.Elem(); t2.Kind() {
</a><a href="#h32-0-431" id="h32-0-431" class="i">+		default:
</a><a href="#h32-0-432" id="h32-0-432" class="i">+			logNoSliceEnc(t1, t2)
</a><a href="#h32-0-433" id="h32-0-433" class="i">+			break
</a><a href="#h32-0-434" id="h32-0-434" class="i">+		case reflect.Bool:
</a><a href="#h32-0-435" id="h32-0-435" class="i">+			if p.Packed {
</a><a href="#h32-0-436" id="h32-0-436" class="i">+				p.enc = (*Buffer).enc_slice_packed_bool
</a><a href="#h32-0-437" id="h32-0-437" class="i">+				p.size = size_slice_packed_bool
</a><a href="#h32-0-438" id="h32-0-438" class="i">+			} else {
</a><a href="#h32-0-439" id="h32-0-439" class="i">+				p.enc = (*Buffer).enc_slice_bool
</a><a href="#h32-0-440" id="h32-0-440" class="i">+				p.size = size_slice_bool
</a><a href="#h32-0-441" id="h32-0-441" class="i">+			}
</a><a href="#h32-0-442" id="h32-0-442" class="i">+			p.dec = (*Buffer).dec_slice_bool
</a><a href="#h32-0-443" id="h32-0-443" class="i">+			p.packedDec = (*Buffer).dec_slice_packed_bool
</a><a href="#h32-0-444" id="h32-0-444" class="i">+		case reflect.Int32:
</a><a href="#h32-0-445" id="h32-0-445" class="i">+			if p.Packed {
</a><a href="#h32-0-446" id="h32-0-446" class="i">+				p.enc = (*Buffer).enc_slice_packed_int32
</a><a href="#h32-0-447" id="h32-0-447" class="i">+				p.size = size_slice_packed_int32
</a><a href="#h32-0-448" id="h32-0-448" class="i">+			} else {
</a><a href="#h32-0-449" id="h32-0-449" class="i">+				p.enc = (*Buffer).enc_slice_int32
</a><a href="#h32-0-450" id="h32-0-450" class="i">+				p.size = size_slice_int32
</a><a href="#h32-0-451" id="h32-0-451" class="i">+			}
</a><a href="#h32-0-452" id="h32-0-452" class="i">+			p.dec = (*Buffer).dec_slice_int32
</a><a href="#h32-0-453" id="h32-0-453" class="i">+			p.packedDec = (*Buffer).dec_slice_packed_int32
</a><a href="#h32-0-454" id="h32-0-454" class="i">+		case reflect.Uint32:
</a><a href="#h32-0-455" id="h32-0-455" class="i">+			if p.Packed {
</a><a href="#h32-0-456" id="h32-0-456" class="i">+				p.enc = (*Buffer).enc_slice_packed_uint32
</a><a href="#h32-0-457" id="h32-0-457" class="i">+				p.size = size_slice_packed_uint32
</a><a href="#h32-0-458" id="h32-0-458" class="i">+			} else {
</a><a href="#h32-0-459" id="h32-0-459" class="i">+				p.enc = (*Buffer).enc_slice_uint32
</a><a href="#h32-0-460" id="h32-0-460" class="i">+				p.size = size_slice_uint32
</a><a href="#h32-0-461" id="h32-0-461" class="i">+			}
</a><a href="#h32-0-462" id="h32-0-462" class="i">+			p.dec = (*Buffer).dec_slice_int32
</a><a href="#h32-0-463" id="h32-0-463" class="i">+			p.packedDec = (*Buffer).dec_slice_packed_int32
</a><a href="#h32-0-464" id="h32-0-464" class="i">+		case reflect.Int64, reflect.Uint64:
</a><a href="#h32-0-465" id="h32-0-465" class="i">+			if p.Packed {
</a><a href="#h32-0-466" id="h32-0-466" class="i">+				p.enc = (*Buffer).enc_slice_packed_int64
</a><a href="#h32-0-467" id="h32-0-467" class="i">+				p.size = size_slice_packed_int64
</a><a href="#h32-0-468" id="h32-0-468" class="i">+			} else {
</a><a href="#h32-0-469" id="h32-0-469" class="i">+				p.enc = (*Buffer).enc_slice_int64
</a><a href="#h32-0-470" id="h32-0-470" class="i">+				p.size = size_slice_int64
</a><a href="#h32-0-471" id="h32-0-471" class="i">+			}
</a><a href="#h32-0-472" id="h32-0-472" class="i">+			p.dec = (*Buffer).dec_slice_int64
</a><a href="#h32-0-473" id="h32-0-473" class="i">+			p.packedDec = (*Buffer).dec_slice_packed_int64
</a><a href="#h32-0-474" id="h32-0-474" class="i">+		case reflect.Uint8:
</a><a href="#h32-0-475" id="h32-0-475" class="i">+			p.dec = (*Buffer).dec_slice_byte
</a><a href="#h32-0-476" id="h32-0-476" class="i">+			if p.proto3 {
</a><a href="#h32-0-477" id="h32-0-477" class="i">+				p.enc = (*Buffer).enc_proto3_slice_byte
</a><a href="#h32-0-478" id="h32-0-478" class="i">+				p.size = size_proto3_slice_byte
</a><a href="#h32-0-479" id="h32-0-479" class="i">+			} else {
</a><a href="#h32-0-480" id="h32-0-480" class="i">+				p.enc = (*Buffer).enc_slice_byte
</a><a href="#h32-0-481" id="h32-0-481" class="i">+				p.size = size_slice_byte
</a><a href="#h32-0-482" id="h32-0-482" class="i">+			}
</a><a href="#h32-0-483" id="h32-0-483" class="i">+		case reflect.Float32, reflect.Float64:
</a><a href="#h32-0-484" id="h32-0-484" class="i">+			switch t2.Bits() {
</a><a href="#h32-0-485" id="h32-0-485" class="i">+			case 32:
</a><a href="#h32-0-486" id="h32-0-486" class="i">+				// can just treat them as bits
</a><a href="#h32-0-487" id="h32-0-487" class="i">+				if p.Packed {
</a><a href="#h32-0-488" id="h32-0-488" class="i">+					p.enc = (*Buffer).enc_slice_packed_uint32
</a><a href="#h32-0-489" id="h32-0-489" class="i">+					p.size = size_slice_packed_uint32
</a><a href="#h32-0-490" id="h32-0-490" class="i">+				} else {
</a><a href="#h32-0-491" id="h32-0-491" class="i">+					p.enc = (*Buffer).enc_slice_uint32
</a><a href="#h32-0-492" id="h32-0-492" class="i">+					p.size = size_slice_uint32
</a><a href="#h32-0-493" id="h32-0-493" class="i">+				}
</a><a href="#h32-0-494" id="h32-0-494" class="i">+				p.dec = (*Buffer).dec_slice_int32
</a><a href="#h32-0-495" id="h32-0-495" class="i">+				p.packedDec = (*Buffer).dec_slice_packed_int32
</a><a href="#h32-0-496" id="h32-0-496" class="i">+			case 64:
</a><a href="#h32-0-497" id="h32-0-497" class="i">+				// can just treat them as bits
</a><a href="#h32-0-498" id="h32-0-498" class="i">+				if p.Packed {
</a><a href="#h32-0-499" id="h32-0-499" class="i">+					p.enc = (*Buffer).enc_slice_packed_int64
</a><a href="#h32-0-500" id="h32-0-500" class="i">+					p.size = size_slice_packed_int64
</a><a href="#h32-0-501" id="h32-0-501" class="i">+				} else {
</a><a href="#h32-0-502" id="h32-0-502" class="i">+					p.enc = (*Buffer).enc_slice_int64
</a><a href="#h32-0-503" id="h32-0-503" class="i">+					p.size = size_slice_int64
</a><a href="#h32-0-504" id="h32-0-504" class="i">+				}
</a><a href="#h32-0-505" id="h32-0-505" class="i">+				p.dec = (*Buffer).dec_slice_int64
</a><a href="#h32-0-506" id="h32-0-506" class="i">+				p.packedDec = (*Buffer).dec_slice_packed_int64
</a><a href="#h32-0-507" id="h32-0-507" class="i">+			default:
</a><a href="#h32-0-508" id="h32-0-508" class="i">+				logNoSliceEnc(t1, t2)
</a><a href="#h32-0-509" id="h32-0-509" class="i">+				break
</a><a href="#h32-0-510" id="h32-0-510" class="i">+			}
</a><a href="#h32-0-511" id="h32-0-511" class="i">+		case reflect.String:
</a><a href="#h32-0-512" id="h32-0-512" class="i">+			p.enc = (*Buffer).enc_slice_string
</a><a href="#h32-0-513" id="h32-0-513" class="i">+			p.dec = (*Buffer).dec_slice_string
</a><a href="#h32-0-514" id="h32-0-514" class="i">+			p.size = size_slice_string
</a><a href="#h32-0-515" id="h32-0-515" class="i">+		case reflect.Ptr:
</a><a href="#h32-0-516" id="h32-0-516" class="i">+			switch t3 := t2.Elem(); t3.Kind() {
</a><a href="#h32-0-517" id="h32-0-517" class="i">+			default:
</a><a href="#h32-0-518" id="h32-0-518" class="i">+				fmt.Fprintf(os.Stderr, &quot;proto: no ptr oenc for %T -&gt; %T -&gt; %T\n&quot;, t1, t2, t3)
</a><a href="#h32-0-519" id="h32-0-519" class="i">+				break
</a><a href="#h32-0-520" id="h32-0-520" class="i">+			case reflect.Struct:
</a><a href="#h32-0-521" id="h32-0-521" class="i">+				p.stype = t2.Elem()
</a><a href="#h32-0-522" id="h32-0-522" class="i">+				p.isMarshaler = isMarshaler(t2)
</a><a href="#h32-0-523" id="h32-0-523" class="i">+				p.isUnmarshaler = isUnmarshaler(t2)
</a><a href="#h32-0-524" id="h32-0-524" class="i">+				if p.Wire == &quot;bytes&quot; {
</a><a href="#h32-0-525" id="h32-0-525" class="i">+					p.enc = (*Buffer).enc_slice_struct_message
</a><a href="#h32-0-526" id="h32-0-526" class="i">+					p.dec = (*Buffer).dec_slice_struct_message
</a><a href="#h32-0-527" id="h32-0-527" class="i">+					p.size = size_slice_struct_message
</a><a href="#h32-0-528" id="h32-0-528" class="i">+				} else {
</a><a href="#h32-0-529" id="h32-0-529" class="i">+					p.enc = (*Buffer).enc_slice_struct_group
</a><a href="#h32-0-530" id="h32-0-530" class="i">+					p.dec = (*Buffer).dec_slice_struct_group
</a><a href="#h32-0-531" id="h32-0-531" class="i">+					p.size = size_slice_struct_group
</a><a href="#h32-0-532" id="h32-0-532" class="i">+				}
</a><a href="#h32-0-533" id="h32-0-533" class="i">+			}
</a><a href="#h32-0-534" id="h32-0-534" class="i">+		case reflect.Slice:
</a><a href="#h32-0-535" id="h32-0-535" class="i">+			switch t2.Elem().Kind() {
</a><a href="#h32-0-536" id="h32-0-536" class="i">+			default:
</a><a href="#h32-0-537" id="h32-0-537" class="i">+				fmt.Fprintf(os.Stderr, &quot;proto: no slice elem oenc for %T -&gt; %T -&gt; %T\n&quot;, t1, t2, t2.Elem())
</a><a href="#h32-0-538" id="h32-0-538" class="i">+				break
</a><a href="#h32-0-539" id="h32-0-539" class="i">+			case reflect.Uint8:
</a><a href="#h32-0-540" id="h32-0-540" class="i">+				p.enc = (*Buffer).enc_slice_slice_byte
</a><a href="#h32-0-541" id="h32-0-541" class="i">+				p.dec = (*Buffer).dec_slice_slice_byte
</a><a href="#h32-0-542" id="h32-0-542" class="i">+				p.size = size_slice_slice_byte
</a><a href="#h32-0-543" id="h32-0-543" class="i">+			}
</a><a href="#h32-0-544" id="h32-0-544" class="i">+		}
</a><a href="#h32-0-545" id="h32-0-545" class="i">+
</a><a href="#h32-0-546" id="h32-0-546" class="i">+	case reflect.Map:
</a><a href="#h32-0-547" id="h32-0-547" class="i">+		p.enc = (*Buffer).enc_new_map
</a><a href="#h32-0-548" id="h32-0-548" class="i">+		p.dec = (*Buffer).dec_new_map
</a><a href="#h32-0-549" id="h32-0-549" class="i">+		p.size = size_new_map
</a><a href="#h32-0-550" id="h32-0-550" class="i">+
</a><a href="#h32-0-551" id="h32-0-551" class="i">+		p.mtype = t1
</a><a href="#h32-0-552" id="h32-0-552" class="i">+		p.mkeyprop = &amp;Properties{}
</a><a href="#h32-0-553" id="h32-0-553" class="i">+		p.mkeyprop.init(reflect.PtrTo(p.mtype.Key()), &quot;Key&quot;, f.Tag.Get(&quot;protobuf_key&quot;), nil, lockGetProp)
</a><a href="#h32-0-554" id="h32-0-554" class="i">+		p.mvalprop = &amp;Properties{}
</a><a href="#h32-0-555" id="h32-0-555" class="i">+		vtype := p.mtype.Elem()
</a><a href="#h32-0-556" id="h32-0-556" class="i">+		if vtype.Kind() != reflect.Ptr &amp;&amp; vtype.Kind() != reflect.Slice {
</a><a href="#h32-0-557" id="h32-0-557" class="i">+			// The value type is not a message (*T) or bytes ([]byte),
</a><a href="#h32-0-558" id="h32-0-558" class="i">+			// so we need encoders for the pointer to this type.
</a><a href="#h32-0-559" id="h32-0-559" class="i">+			vtype = reflect.PtrTo(vtype)
</a><a href="#h32-0-560" id="h32-0-560" class="i">+		}
</a><a href="#h32-0-561" id="h32-0-561" class="i">+		p.mvalprop.init(vtype, &quot;Value&quot;, f.Tag.Get(&quot;protobuf_val&quot;), nil, lockGetProp)
</a><a href="#h32-0-562" id="h32-0-562" class="i">+	}
</a><a href="#h32-0-563" id="h32-0-563" class="i">+
</a><a href="#h32-0-564" id="h32-0-564" class="i">+	// precalculate tag code
</a><a href="#h32-0-565" id="h32-0-565" class="i">+	wire := p.WireType
</a><a href="#h32-0-566" id="h32-0-566" class="i">+	if p.Packed {
</a><a href="#h32-0-567" id="h32-0-567" class="i">+		wire = WireBytes
</a><a href="#h32-0-568" id="h32-0-568" class="i">+	}
</a><a href="#h32-0-569" id="h32-0-569" class="i">+	x := uint32(p.Tag)&lt;&lt;3 | uint32(wire)
</a><a href="#h32-0-570" id="h32-0-570" class="i">+	i := 0
</a><a href="#h32-0-571" id="h32-0-571" class="i">+	for i = 0; x &gt; 127; i++ {
</a><a href="#h32-0-572" id="h32-0-572" class="i">+		p.tagbuf[i] = 0x80 | uint8(x&amp;0x7F)
</a><a href="#h32-0-573" id="h32-0-573" class="i">+		x &gt;&gt;= 7
</a><a href="#h32-0-574" id="h32-0-574" class="i">+	}
</a><a href="#h32-0-575" id="h32-0-575" class="i">+	p.tagbuf[i] = uint8(x)
</a><a href="#h32-0-576" id="h32-0-576" class="i">+	p.tagcode = p.tagbuf[0 : i+1]
</a><a href="#h32-0-577" id="h32-0-577" class="i">+
</a><a href="#h32-0-578" id="h32-0-578" class="i">+	if p.stype != nil {
</a><a href="#h32-0-579" id="h32-0-579" class="i">+		if lockGetProp {
</a><a href="#h32-0-580" id="h32-0-580" class="i">+			p.sprop = GetProperties(p.stype)
</a><a href="#h32-0-581" id="h32-0-581" class="i">+		} else {
</a><a href="#h32-0-582" id="h32-0-582" class="i">+			p.sprop = getPropertiesLocked(p.stype)
</a><a href="#h32-0-583" id="h32-0-583" class="i">+		}
</a><a href="#h32-0-584" id="h32-0-584" class="i">+	}
</a><a href="#h32-0-585" id="h32-0-585" class="i">+}
</a><a href="#h32-0-586" id="h32-0-586" class="i">+
</a><a href="#h32-0-587" id="h32-0-587" class="i">+var (
</a><a href="#h32-0-588" id="h32-0-588" class="i">+	marshalerType   = reflect.TypeOf((*Marshaler)(nil)).Elem()
</a><a href="#h32-0-589" id="h32-0-589" class="i">+	unmarshalerType = reflect.TypeOf((*Unmarshaler)(nil)).Elem()
</a><a href="#h32-0-590" id="h32-0-590" class="i">+)
</a><a href="#h32-0-591" id="h32-0-591" class="i">+
</a><a href="#h32-0-592" id="h32-0-592" class="i">+// isMarshaler reports whether type t implements Marshaler.
</a><a href="#h32-0-593" id="h32-0-593" class="i">+func isMarshaler(t reflect.Type) bool {
</a><a href="#h32-0-594" id="h32-0-594" class="i">+	// We&#39;re checking for (likely) pointer-receiver methods
</a><a href="#h32-0-595" id="h32-0-595" class="i">+	// so if t is not a pointer, something is very wrong.
</a><a href="#h32-0-596" id="h32-0-596" class="i">+	// The calls above only invoke isMarshaler on pointer types.
</a><a href="#h32-0-597" id="h32-0-597" class="i">+	if t.Kind() != reflect.Ptr {
</a><a href="#h32-0-598" id="h32-0-598" class="i">+		panic(&quot;proto: misuse of isMarshaler&quot;)
</a><a href="#h32-0-599" id="h32-0-599" class="i">+	}
</a><a href="#h32-0-600" id="h32-0-600" class="i">+	return t.Implements(marshalerType)
</a><a href="#h32-0-601" id="h32-0-601" class="i">+}
</a><a href="#h32-0-602" id="h32-0-602" class="i">+
</a><a href="#h32-0-603" id="h32-0-603" class="i">+// isUnmarshaler reports whether type t implements Unmarshaler.
</a><a href="#h32-0-604" id="h32-0-604" class="i">+func isUnmarshaler(t reflect.Type) bool {
</a><a href="#h32-0-605" id="h32-0-605" class="i">+	// We&#39;re checking for (likely) pointer-receiver methods
</a><a href="#h32-0-606" id="h32-0-606" class="i">+	// so if t is not a pointer, something is very wrong.
</a><a href="#h32-0-607" id="h32-0-607" class="i">+	// The calls above only invoke isUnmarshaler on pointer types.
</a><a href="#h32-0-608" id="h32-0-608" class="i">+	if t.Kind() != reflect.Ptr {
</a><a href="#h32-0-609" id="h32-0-609" class="i">+		panic(&quot;proto: misuse of isUnmarshaler&quot;)
</a><a href="#h32-0-610" id="h32-0-610" class="i">+	}
</a><a href="#h32-0-611" id="h32-0-611" class="i">+	return t.Implements(unmarshalerType)
</a><a href="#h32-0-612" id="h32-0-612" class="i">+}
</a><a href="#h32-0-613" id="h32-0-613" class="i">+
</a><a href="#h32-0-614" id="h32-0-614" class="i">+// Init populates the properties from a protocol buffer struct tag.
</a><a href="#h32-0-615" id="h32-0-615" class="i">+func (p *Properties) Init(typ reflect.Type, name, tag string, f *reflect.StructField) {
</a><a href="#h32-0-616" id="h32-0-616" class="i">+	p.init(typ, name, tag, f, true)
</a><a href="#h32-0-617" id="h32-0-617" class="i">+}
</a><a href="#h32-0-618" id="h32-0-618" class="i">+
</a><a href="#h32-0-619" id="h32-0-619" class="i">+func (p *Properties) init(typ reflect.Type, name, tag string, f *reflect.StructField, lockGetProp bool) {
</a><a href="#h32-0-620" id="h32-0-620" class="i">+	// &quot;bytes,49,opt,def=hello!&quot;
</a><a href="#h32-0-621" id="h32-0-621" class="i">+	p.Name = name
</a><a href="#h32-0-622" id="h32-0-622" class="i">+	p.OrigName = name
</a><a href="#h32-0-623" id="h32-0-623" class="i">+	if f != nil {
</a><a href="#h32-0-624" id="h32-0-624" class="i">+		p.field = toField(f)
</a><a href="#h32-0-625" id="h32-0-625" class="i">+	}
</a><a href="#h32-0-626" id="h32-0-626" class="i">+	if tag == &quot;&quot; {
</a><a href="#h32-0-627" id="h32-0-627" class="i">+		return
</a><a href="#h32-0-628" id="h32-0-628" class="i">+	}
</a><a href="#h32-0-629" id="h32-0-629" class="i">+	p.Parse(tag)
</a><a href="#h32-0-630" id="h32-0-630" class="i">+	p.setEncAndDec(typ, f, lockGetProp)
</a><a href="#h32-0-631" id="h32-0-631" class="i">+}
</a><a href="#h32-0-632" id="h32-0-632" class="i">+
</a><a href="#h32-0-633" id="h32-0-633" class="i">+var (
</a><a href="#h32-0-634" id="h32-0-634" class="i">+	propertiesMu  sync.RWMutex
</a><a href="#h32-0-635" id="h32-0-635" class="i">+	propertiesMap = make(map[reflect.Type]*StructProperties)
</a><a href="#h32-0-636" id="h32-0-636" class="i">+)
</a><a href="#h32-0-637" id="h32-0-637" class="i">+
</a><a href="#h32-0-638" id="h32-0-638" class="i">+// GetProperties returns the list of properties for the type represented by t.
</a><a href="#h32-0-639" id="h32-0-639" class="i">+// t must represent a generated struct type of a protocol message.
</a><a href="#h32-0-640" id="h32-0-640" class="i">+func GetProperties(t reflect.Type) *StructProperties {
</a><a href="#h32-0-641" id="h32-0-641" class="i">+	if t.Kind() != reflect.Struct {
</a><a href="#h32-0-642" id="h32-0-642" class="i">+		panic(&quot;proto: type must have kind struct&quot;)
</a><a href="#h32-0-643" id="h32-0-643" class="i">+	}
</a><a href="#h32-0-644" id="h32-0-644" class="i">+
</a><a href="#h32-0-645" id="h32-0-645" class="i">+	// Most calls to GetProperties in a long-running program will be
</a><a href="#h32-0-646" id="h32-0-646" class="i">+	// retrieving details for types we have seen before.
</a><a href="#h32-0-647" id="h32-0-647" class="i">+	propertiesMu.RLock()
</a><a href="#h32-0-648" id="h32-0-648" class="i">+	sprop, ok := propertiesMap[t]
</a><a href="#h32-0-649" id="h32-0-649" class="i">+	propertiesMu.RUnlock()
</a><a href="#h32-0-650" id="h32-0-650" class="i">+	if ok {
</a><a href="#h32-0-651" id="h32-0-651" class="i">+		if collectStats {
</a><a href="#h32-0-652" id="h32-0-652" class="i">+			stats.Chit++
</a><a href="#h32-0-653" id="h32-0-653" class="i">+		}
</a><a href="#h32-0-654" id="h32-0-654" class="i">+		return sprop
</a><a href="#h32-0-655" id="h32-0-655" class="i">+	}
</a><a href="#h32-0-656" id="h32-0-656" class="i">+
</a><a href="#h32-0-657" id="h32-0-657" class="i">+	propertiesMu.Lock()
</a><a href="#h32-0-658" id="h32-0-658" class="i">+	sprop = getPropertiesLocked(t)
</a><a href="#h32-0-659" id="h32-0-659" class="i">+	propertiesMu.Unlock()
</a><a href="#h32-0-660" id="h32-0-660" class="i">+	return sprop
</a><a href="#h32-0-661" id="h32-0-661" class="i">+}
</a><a href="#h32-0-662" id="h32-0-662" class="i">+
</a><a href="#h32-0-663" id="h32-0-663" class="i">+// getPropertiesLocked requires that propertiesMu is held.
</a><a href="#h32-0-664" id="h32-0-664" class="i">+func getPropertiesLocked(t reflect.Type) *StructProperties {
</a><a href="#h32-0-665" id="h32-0-665" class="i">+	if prop, ok := propertiesMap[t]; ok {
</a><a href="#h32-0-666" id="h32-0-666" class="i">+		if collectStats {
</a><a href="#h32-0-667" id="h32-0-667" class="i">+			stats.Chit++
</a><a href="#h32-0-668" id="h32-0-668" class="i">+		}
</a><a href="#h32-0-669" id="h32-0-669" class="i">+		return prop
</a><a href="#h32-0-670" id="h32-0-670" class="i">+	}
</a><a href="#h32-0-671" id="h32-0-671" class="i">+	if collectStats {
</a><a href="#h32-0-672" id="h32-0-672" class="i">+		stats.Cmiss++
</a><a href="#h32-0-673" id="h32-0-673" class="i">+	}
</a><a href="#h32-0-674" id="h32-0-674" class="i">+
</a><a href="#h32-0-675" id="h32-0-675" class="i">+	prop := new(StructProperties)
</a><a href="#h32-0-676" id="h32-0-676" class="i">+	// in case of recursive protos, fill this in now.
</a><a href="#h32-0-677" id="h32-0-677" class="i">+	propertiesMap[t] = prop
</a><a href="#h32-0-678" id="h32-0-678" class="i">+
</a><a href="#h32-0-679" id="h32-0-679" class="i">+	// build properties
</a><a href="#h32-0-680" id="h32-0-680" class="i">+	prop.extendable = reflect.PtrTo(t).Implements(extendableProtoType) ||
</a><a href="#h32-0-681" id="h32-0-681" class="i">+		reflect.PtrTo(t).Implements(extendableProtoV1Type)
</a><a href="#h32-0-682" id="h32-0-682" class="i">+	prop.unrecField = invalidField
</a><a href="#h32-0-683" id="h32-0-683" class="i">+	prop.Prop = make([]*Properties, t.NumField())
</a><a href="#h32-0-684" id="h32-0-684" class="i">+	prop.order = make([]int, t.NumField())
</a><a href="#h32-0-685" id="h32-0-685" class="i">+
</a><a href="#h32-0-686" id="h32-0-686" class="i">+	for i := 0; i &lt; t.NumField(); i++ {
</a><a href="#h32-0-687" id="h32-0-687" class="i">+		f := t.Field(i)
</a><a href="#h32-0-688" id="h32-0-688" class="i">+		p := new(Properties)
</a><a href="#h32-0-689" id="h32-0-689" class="i">+		name := f.Name
</a><a href="#h32-0-690" id="h32-0-690" class="i">+		p.init(f.Type, name, f.Tag.Get(&quot;protobuf&quot;), &amp;f, false)
</a><a href="#h32-0-691" id="h32-0-691" class="i">+
</a><a href="#h32-0-692" id="h32-0-692" class="i">+		if f.Name == &quot;XXX_InternalExtensions&quot; { // special case
</a><a href="#h32-0-693" id="h32-0-693" class="i">+			p.enc = (*Buffer).enc_exts
</a><a href="#h32-0-694" id="h32-0-694" class="i">+			p.dec = nil // not needed
</a><a href="#h32-0-695" id="h32-0-695" class="i">+			p.size = size_exts
</a><a href="#h32-0-696" id="h32-0-696" class="i">+		} else if f.Name == &quot;XXX_extensions&quot; { // special case
</a><a href="#h32-0-697" id="h32-0-697" class="i">+			p.enc = (*Buffer).enc_map
</a><a href="#h32-0-698" id="h32-0-698" class="i">+			p.dec = nil // not needed
</a><a href="#h32-0-699" id="h32-0-699" class="i">+			p.size = size_map
</a><a href="#h32-0-700" id="h32-0-700" class="i">+		} else if f.Name == &quot;XXX_unrecognized&quot; { // special case
</a><a href="#h32-0-701" id="h32-0-701" class="i">+			prop.unrecField = toField(&amp;f)
</a><a href="#h32-0-702" id="h32-0-702" class="i">+		}
</a><a href="#h32-0-703" id="h32-0-703" class="i">+		oneof := f.Tag.Get(&quot;protobuf_oneof&quot;) // special case
</a><a href="#h32-0-704" id="h32-0-704" class="i">+		if oneof != &quot;&quot; {
</a><a href="#h32-0-705" id="h32-0-705" class="i">+			// Oneof fields don&#39;t use the traditional protobuf tag.
</a><a href="#h32-0-706" id="h32-0-706" class="i">+			p.OrigName = oneof
</a><a href="#h32-0-707" id="h32-0-707" class="i">+		}
</a><a href="#h32-0-708" id="h32-0-708" class="i">+		prop.Prop[i] = p
</a><a href="#h32-0-709" id="h32-0-709" class="i">+		prop.order[i] = i
</a><a href="#h32-0-710" id="h32-0-710" class="i">+		if debug {
</a><a href="#h32-0-711" id="h32-0-711" class="i">+			print(i, &quot; &quot;, f.Name, &quot; &quot;, t.String(), &quot; &quot;)
</a><a href="#h32-0-712" id="h32-0-712" class="i">+			if p.Tag &gt; 0 {
</a><a href="#h32-0-713" id="h32-0-713" class="i">+				print(p.String())
</a><a href="#h32-0-714" id="h32-0-714" class="i">+			}
</a><a href="#h32-0-715" id="h32-0-715" class="i">+			print(&quot;\n&quot;)
</a><a href="#h32-0-716" id="h32-0-716" class="i">+		}
</a><a href="#h32-0-717" id="h32-0-717" class="i">+		if p.enc == nil &amp;&amp; !strings.HasPrefix(f.Name, &quot;XXX_&quot;) &amp;&amp; oneof == &quot;&quot; {
</a><a href="#h32-0-718" id="h32-0-718" class="i">+			fmt.Fprintln(os.Stderr, &quot;proto: no encoder for&quot;, f.Name, f.Type.String(), &quot;[GetProperties]&quot;)
</a><a href="#h32-0-719" id="h32-0-719" class="i">+		}
</a><a href="#h32-0-720" id="h32-0-720" class="i">+	}
</a><a href="#h32-0-721" id="h32-0-721" class="i">+
</a><a href="#h32-0-722" id="h32-0-722" class="i">+	// Re-order prop.order.
</a><a href="#h32-0-723" id="h32-0-723" class="i">+	sort.Sort(prop)
</a><a href="#h32-0-724" id="h32-0-724" class="i">+
</a><a href="#h32-0-725" id="h32-0-725" class="i">+	type oneofMessage interface {
</a><a href="#h32-0-726" id="h32-0-726" class="i">+		XXX_OneofFuncs() (func(Message, *Buffer) error, func(Message, int, int, *Buffer) (bool, error), func(Message) int, []interface{})
</a><a href="#h32-0-727" id="h32-0-727" class="i">+	}
</a><a href="#h32-0-728" id="h32-0-728" class="i">+	if om, ok := reflect.Zero(reflect.PtrTo(t)).Interface().(oneofMessage); ok {
</a><a href="#h32-0-729" id="h32-0-729" class="i">+		var oots []interface{}
</a><a href="#h32-0-730" id="h32-0-730" class="i">+		prop.oneofMarshaler, prop.oneofUnmarshaler, prop.oneofSizer, oots = om.XXX_OneofFuncs()
</a><a href="#h32-0-731" id="h32-0-731" class="i">+		prop.stype = t
</a><a href="#h32-0-732" id="h32-0-732" class="i">+
</a><a href="#h32-0-733" id="h32-0-733" class="i">+		// Interpret oneof metadata.
</a><a href="#h32-0-734" id="h32-0-734" class="i">+		prop.OneofTypes = make(map[string]*OneofProperties)
</a><a href="#h32-0-735" id="h32-0-735" class="i">+		for _, oot := range oots {
</a><a href="#h32-0-736" id="h32-0-736" class="i">+			oop := &amp;OneofProperties{
</a><a href="#h32-0-737" id="h32-0-737" class="i">+				Type: reflect.ValueOf(oot).Type(), // *T
</a><a href="#h32-0-738" id="h32-0-738" class="i">+				Prop: new(Properties),
</a><a href="#h32-0-739" id="h32-0-739" class="i">+			}
</a><a href="#h32-0-740" id="h32-0-740" class="i">+			sft := oop.Type.Elem().Field(0)
</a><a href="#h32-0-741" id="h32-0-741" class="i">+			oop.Prop.Name = sft.Name
</a><a href="#h32-0-742" id="h32-0-742" class="i">+			oop.Prop.Parse(sft.Tag.Get(&quot;protobuf&quot;))
</a><a href="#h32-0-743" id="h32-0-743" class="i">+			// There will be exactly one interface field that
</a><a href="#h32-0-744" id="h32-0-744" class="i">+			// this new value is assignable to.
</a><a href="#h32-0-745" id="h32-0-745" class="i">+			for i := 0; i &lt; t.NumField(); i++ {
</a><a href="#h32-0-746" id="h32-0-746" class="i">+				f := t.Field(i)
</a><a href="#h32-0-747" id="h32-0-747" class="i">+				if f.Type.Kind() != reflect.Interface {
</a><a href="#h32-0-748" id="h32-0-748" class="i">+					continue
</a><a href="#h32-0-749" id="h32-0-749" class="i">+				}
</a><a href="#h32-0-750" id="h32-0-750" class="i">+				if !oop.Type.AssignableTo(f.Type) {
</a><a href="#h32-0-751" id="h32-0-751" class="i">+					continue
</a><a href="#h32-0-752" id="h32-0-752" class="i">+				}
</a><a href="#h32-0-753" id="h32-0-753" class="i">+				oop.Field = i
</a><a href="#h32-0-754" id="h32-0-754" class="i">+				break
</a><a href="#h32-0-755" id="h32-0-755" class="i">+			}
</a><a href="#h32-0-756" id="h32-0-756" class="i">+			prop.OneofTypes[oop.Prop.OrigName] = oop
</a><a href="#h32-0-757" id="h32-0-757" class="i">+		}
</a><a href="#h32-0-758" id="h32-0-758" class="i">+	}
</a><a href="#h32-0-759" id="h32-0-759" class="i">+
</a><a href="#h32-0-760" id="h32-0-760" class="i">+	// build required counts
</a><a href="#h32-0-761" id="h32-0-761" class="i">+	// build tags
</a><a href="#h32-0-762" id="h32-0-762" class="i">+	reqCount := 0
</a><a href="#h32-0-763" id="h32-0-763" class="i">+	prop.decoderOrigNames = make(map[string]int)
</a><a href="#h32-0-764" id="h32-0-764" class="i">+	for i, p := range prop.Prop {
</a><a href="#h32-0-765" id="h32-0-765" class="i">+		if strings.HasPrefix(p.Name, &quot;XXX_&quot;) {
</a><a href="#h32-0-766" id="h32-0-766" class="i">+			// Internal fields should not appear in tags/origNames maps.
</a><a href="#h32-0-767" id="h32-0-767" class="i">+			// They are handled specially when encoding and decoding.
</a><a href="#h32-0-768" id="h32-0-768" class="i">+			continue
</a><a href="#h32-0-769" id="h32-0-769" class="i">+		}
</a><a href="#h32-0-770" id="h32-0-770" class="i">+		if p.Required {
</a><a href="#h32-0-771" id="h32-0-771" class="i">+			reqCount++
</a><a href="#h32-0-772" id="h32-0-772" class="i">+		}
</a><a href="#h32-0-773" id="h32-0-773" class="i">+		prop.decoderTags.put(p.Tag, i)
</a><a href="#h32-0-774" id="h32-0-774" class="i">+		prop.decoderOrigNames[p.OrigName] = i
</a><a href="#h32-0-775" id="h32-0-775" class="i">+	}
</a><a href="#h32-0-776" id="h32-0-776" class="i">+	prop.reqCount = reqCount
</a><a href="#h32-0-777" id="h32-0-777" class="i">+
</a><a href="#h32-0-778" id="h32-0-778" class="i">+	return prop
</a><a href="#h32-0-779" id="h32-0-779" class="i">+}
</a><a href="#h32-0-780" id="h32-0-780" class="i">+
</a><a href="#h32-0-781" id="h32-0-781" class="i">+// Return the Properties object for the x[0]&#39;th field of the structure.
</a><a href="#h32-0-782" id="h32-0-782" class="i">+func propByIndex(t reflect.Type, x []int) *Properties {
</a><a href="#h32-0-783" id="h32-0-783" class="i">+	if len(x) != 1 {
</a><a href="#h32-0-784" id="h32-0-784" class="i">+		fmt.Fprintf(os.Stderr, &quot;proto: field index dimension %d (not 1) for type %s\n&quot;, len(x), t)
</a><a href="#h32-0-785" id="h32-0-785" class="i">+		return nil
</a><a href="#h32-0-786" id="h32-0-786" class="i">+	}
</a><a href="#h32-0-787" id="h32-0-787" class="i">+	prop := GetProperties(t)
</a><a href="#h32-0-788" id="h32-0-788" class="i">+	return prop.Prop[x[0]]
</a><a href="#h32-0-789" id="h32-0-789" class="i">+}
</a><a href="#h32-0-790" id="h32-0-790" class="i">+
</a><a href="#h32-0-791" id="h32-0-791" class="i">+// Get the address and type of a pointer to a struct from an interface.
</a><a href="#h32-0-792" id="h32-0-792" class="i">+func getbase(pb Message) (t reflect.Type, b structPointer, err error) {
</a><a href="#h32-0-793" id="h32-0-793" class="i">+	if pb == nil {
</a><a href="#h32-0-794" id="h32-0-794" class="i">+		err = ErrNil
</a><a href="#h32-0-795" id="h32-0-795" class="i">+		return
</a><a href="#h32-0-796" id="h32-0-796" class="i">+	}
</a><a href="#h32-0-797" id="h32-0-797" class="i">+	// get the reflect type of the pointer to the struct.
</a><a href="#h32-0-798" id="h32-0-798" class="i">+	t = reflect.TypeOf(pb)
</a><a href="#h32-0-799" id="h32-0-799" class="i">+	// get the address of the struct.
</a><a href="#h32-0-800" id="h32-0-800" class="i">+	value := reflect.ValueOf(pb)
</a><a href="#h32-0-801" id="h32-0-801" class="i">+	b = toStructPointer(value)
</a><a href="#h32-0-802" id="h32-0-802" class="i">+	return
</a><a href="#h32-0-803" id="h32-0-803" class="i">+}
</a><a href="#h32-0-804" id="h32-0-804" class="i">+
</a><a href="#h32-0-805" id="h32-0-805" class="i">+// A global registry of enum types.
</a><a href="#h32-0-806" id="h32-0-806" class="i">+// The generated code will register the generated maps by calling RegisterEnum.
</a><a href="#h32-0-807" id="h32-0-807" class="i">+
</a><a href="#h32-0-808" id="h32-0-808" class="i">+var enumValueMaps = make(map[string]map[string]int32)
</a><a href="#h32-0-809" id="h32-0-809" class="i">+
</a><a href="#h32-0-810" id="h32-0-810" class="i">+// RegisterEnum is called from the generated code to install the enum descriptor
</a><a href="#h32-0-811" id="h32-0-811" class="i">+// maps into the global table to aid parsing text format protocol buffers.
</a><a href="#h32-0-812" id="h32-0-812" class="i">+func RegisterEnum(typeName string, unusedNameMap map[int32]string, valueMap map[string]int32) {
</a><a href="#h32-0-813" id="h32-0-813" class="i">+	if _, ok := enumValueMaps[typeName]; ok {
</a><a href="#h32-0-814" id="h32-0-814" class="i">+		panic(&quot;proto: duplicate enum registered: &quot; + typeName)
</a><a href="#h32-0-815" id="h32-0-815" class="i">+	}
</a><a href="#h32-0-816" id="h32-0-816" class="i">+	enumValueMaps[typeName] = valueMap
</a><a href="#h32-0-817" id="h32-0-817" class="i">+}
</a><a href="#h32-0-818" id="h32-0-818" class="i">+
</a><a href="#h32-0-819" id="h32-0-819" class="i">+// EnumValueMap returns the mapping from names to integers of the
</a><a href="#h32-0-820" id="h32-0-820" class="i">+// enum type enumType, or a nil if not found.
</a><a href="#h32-0-821" id="h32-0-821" class="i">+func EnumValueMap(enumType string) map[string]int32 {
</a><a href="#h32-0-822" id="h32-0-822" class="i">+	return enumValueMaps[enumType]
</a><a href="#h32-0-823" id="h32-0-823" class="i">+}
</a><a href="#h32-0-824" id="h32-0-824" class="i">+
</a><a href="#h32-0-825" id="h32-0-825" class="i">+// A registry of all linked message types.
</a><a href="#h32-0-826" id="h32-0-826" class="i">+// The string is a fully-qualified proto name (&quot;pkg.Message&quot;).
</a><a href="#h32-0-827" id="h32-0-827" class="i">+var (
</a><a href="#h32-0-828" id="h32-0-828" class="i">+	protoTypes    = make(map[string]reflect.Type)
</a><a href="#h32-0-829" id="h32-0-829" class="i">+	revProtoTypes = make(map[reflect.Type]string)
</a><a href="#h32-0-830" id="h32-0-830" class="i">+)
</a><a href="#h32-0-831" id="h32-0-831" class="i">+
</a><a href="#h32-0-832" id="h32-0-832" class="i">+// RegisterType is called from generated code and maps from the fully qualified
</a><a href="#h32-0-833" id="h32-0-833" class="i">+// proto name to the type (pointer to struct) of the protocol buffer.
</a><a href="#h32-0-834" id="h32-0-834" class="i">+func RegisterType(x Message, name string) {
</a><a href="#h32-0-835" id="h32-0-835" class="i">+	if _, ok := protoTypes[name]; ok {
</a><a href="#h32-0-836" id="h32-0-836" class="i">+		// TODO: Some day, make this a panic.
</a><a href="#h32-0-837" id="h32-0-837" class="i">+		log.Printf(&quot;proto: duplicate proto type registered: %s&quot;, name)
</a><a href="#h32-0-838" id="h32-0-838" class="i">+		return
</a><a href="#h32-0-839" id="h32-0-839" class="i">+	}
</a><a href="#h32-0-840" id="h32-0-840" class="i">+	t := reflect.TypeOf(x)
</a><a href="#h32-0-841" id="h32-0-841" class="i">+	protoTypes[name] = t
</a><a href="#h32-0-842" id="h32-0-842" class="i">+	revProtoTypes[t] = name
</a><a href="#h32-0-843" id="h32-0-843" class="i">+}
</a><a href="#h32-0-844" id="h32-0-844" class="i">+
</a><a href="#h32-0-845" id="h32-0-845" class="i">+// MessageName returns the fully-qualified proto name for the given message type.
</a><a href="#h32-0-846" id="h32-0-846" class="i">+func MessageName(x Message) string { return revProtoTypes[reflect.TypeOf(x)] }
</a><a href="#h32-0-847" id="h32-0-847" class="i">+
</a><a href="#h32-0-848" id="h32-0-848" class="i">+// MessageType returns the message type (pointer to struct) for a named message.
</a><a href="#h32-0-849" id="h32-0-849" class="i">+func MessageType(name string) reflect.Type { return protoTypes[name] }
</a><a href="#h32-0-850" id="h32-0-850" class="i">+
</a><a href="#h32-0-851" id="h32-0-851" class="i">+// A registry of all linked proto files.
</a><a href="#h32-0-852" id="h32-0-852" class="i">+var (
</a><a href="#h32-0-853" id="h32-0-853" class="i">+	protoFiles = make(map[string][]byte) // file name =&gt; fileDescriptor
</a><a href="#h32-0-854" id="h32-0-854" class="i">+)
</a><a href="#h32-0-855" id="h32-0-855" class="i">+
</a><a href="#h32-0-856" id="h32-0-856" class="i">+// RegisterFile is called from generated code and maps from the
</a><a href="#h32-0-857" id="h32-0-857" class="i">+// full file name of a .proto file to its compressed FileDescriptorProto.
</a><a href="#h32-0-858" id="h32-0-858" class="i">+func RegisterFile(filename string, fileDescriptor []byte) {
</a><a href="#h32-0-859" id="h32-0-859" class="i">+	protoFiles[filename] = fileDescriptor
</a><a href="#h32-0-860" id="h32-0-860" class="i">+}
</a><a href="#h32-0-861" id="h32-0-861" class="i">+
</a><a href="#h32-0-862" id="h32-0-862" class="i">+// FileDescriptor returns the compressed FileDescriptorProto for a .proto file.
</a><a href="#h32-0-863" id="h32-0-863" class="i">+func FileDescriptor(filename string) []byte { return protoFiles[filename] }
</a><b>diff --git a/<a id="h33" href="../file/vendor/github.com/golang/protobuf/proto/text.go">vendor/github.com/golang/protobuf/proto/text.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/text.go">vendor/github.com/golang/protobuf/proto/text.go</a></b>
<a href="#h33-0" id="h33-0" class="h">@@ -0,0 +1,854 @@
</a><a href="#h33-0-0" id="h33-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h33-0-1" id="h33-0-1" class="i">+//
</a><a href="#h33-0-2" id="h33-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h33-0-3" id="h33-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h33-0-4" id="h33-0-4" class="i">+//
</a><a href="#h33-0-5" id="h33-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h33-0-6" id="h33-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h33-0-7" id="h33-0-7" class="i">+// met:
</a><a href="#h33-0-8" id="h33-0-8" class="i">+//
</a><a href="#h33-0-9" id="h33-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h33-0-10" id="h33-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h33-0-11" id="h33-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h33-0-12" id="h33-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h33-0-13" id="h33-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h33-0-14" id="h33-0-14" class="i">+// distribution.
</a><a href="#h33-0-15" id="h33-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h33-0-16" id="h33-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h33-0-17" id="h33-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h33-0-18" id="h33-0-18" class="i">+//
</a><a href="#h33-0-19" id="h33-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h33-0-20" id="h33-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h33-0-21" id="h33-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h33-0-22" id="h33-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h33-0-23" id="h33-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h33-0-24" id="h33-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h33-0-25" id="h33-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h33-0-26" id="h33-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h33-0-27" id="h33-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h33-0-28" id="h33-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h33-0-29" id="h33-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h33-0-30" id="h33-0-30" class="i">+
</a><a href="#h33-0-31" id="h33-0-31" class="i">+package proto
</a><a href="#h33-0-32" id="h33-0-32" class="i">+
</a><a href="#h33-0-33" id="h33-0-33" class="i">+// Functions for writing the text protocol buffer format.
</a><a href="#h33-0-34" id="h33-0-34" class="i">+
</a><a href="#h33-0-35" id="h33-0-35" class="i">+import (
</a><a href="#h33-0-36" id="h33-0-36" class="i">+	&quot;bufio&quot;
</a><a href="#h33-0-37" id="h33-0-37" class="i">+	&quot;bytes&quot;
</a><a href="#h33-0-38" id="h33-0-38" class="i">+	&quot;encoding&quot;
</a><a href="#h33-0-39" id="h33-0-39" class="i">+	&quot;errors&quot;
</a><a href="#h33-0-40" id="h33-0-40" class="i">+	&quot;fmt&quot;
</a><a href="#h33-0-41" id="h33-0-41" class="i">+	&quot;io&quot;
</a><a href="#h33-0-42" id="h33-0-42" class="i">+	&quot;log&quot;
</a><a href="#h33-0-43" id="h33-0-43" class="i">+	&quot;math&quot;
</a><a href="#h33-0-44" id="h33-0-44" class="i">+	&quot;reflect&quot;
</a><a href="#h33-0-45" id="h33-0-45" class="i">+	&quot;sort&quot;
</a><a href="#h33-0-46" id="h33-0-46" class="i">+	&quot;strings&quot;
</a><a href="#h33-0-47" id="h33-0-47" class="i">+)
</a><a href="#h33-0-48" id="h33-0-48" class="i">+
</a><a href="#h33-0-49" id="h33-0-49" class="i">+var (
</a><a href="#h33-0-50" id="h33-0-50" class="i">+	newline         = []byte(&quot;\n&quot;)
</a><a href="#h33-0-51" id="h33-0-51" class="i">+	spaces          = []byte(&quot;                                        &quot;)
</a><a href="#h33-0-52" id="h33-0-52" class="i">+	gtNewline       = []byte(&quot;&gt;\n&quot;)
</a><a href="#h33-0-53" id="h33-0-53" class="i">+	endBraceNewline = []byte(&quot;}\n&quot;)
</a><a href="#h33-0-54" id="h33-0-54" class="i">+	backslashN      = []byte{&#39;\\&#39;, &#39;n&#39;}
</a><a href="#h33-0-55" id="h33-0-55" class="i">+	backslashR      = []byte{&#39;\\&#39;, &#39;r&#39;}
</a><a href="#h33-0-56" id="h33-0-56" class="i">+	backslashT      = []byte{&#39;\\&#39;, &#39;t&#39;}
</a><a href="#h33-0-57" id="h33-0-57" class="i">+	backslashDQ     = []byte{&#39;\\&#39;, &#39;&quot;&#39;}
</a><a href="#h33-0-58" id="h33-0-58" class="i">+	backslashBS     = []byte{&#39;\\&#39;, &#39;\\&#39;}
</a><a href="#h33-0-59" id="h33-0-59" class="i">+	posInf          = []byte(&quot;inf&quot;)
</a><a href="#h33-0-60" id="h33-0-60" class="i">+	negInf          = []byte(&quot;-inf&quot;)
</a><a href="#h33-0-61" id="h33-0-61" class="i">+	nan             = []byte(&quot;nan&quot;)
</a><a href="#h33-0-62" id="h33-0-62" class="i">+)
</a><a href="#h33-0-63" id="h33-0-63" class="i">+
</a><a href="#h33-0-64" id="h33-0-64" class="i">+type writer interface {
</a><a href="#h33-0-65" id="h33-0-65" class="i">+	io.Writer
</a><a href="#h33-0-66" id="h33-0-66" class="i">+	WriteByte(byte) error
</a><a href="#h33-0-67" id="h33-0-67" class="i">+}
</a><a href="#h33-0-68" id="h33-0-68" class="i">+
</a><a href="#h33-0-69" id="h33-0-69" class="i">+// textWriter is an io.Writer that tracks its indentation level.
</a><a href="#h33-0-70" id="h33-0-70" class="i">+type textWriter struct {
</a><a href="#h33-0-71" id="h33-0-71" class="i">+	ind      int
</a><a href="#h33-0-72" id="h33-0-72" class="i">+	complete bool // if the current position is a complete line
</a><a href="#h33-0-73" id="h33-0-73" class="i">+	compact  bool // whether to write out as a one-liner
</a><a href="#h33-0-74" id="h33-0-74" class="i">+	w        writer
</a><a href="#h33-0-75" id="h33-0-75" class="i">+}
</a><a href="#h33-0-76" id="h33-0-76" class="i">+
</a><a href="#h33-0-77" id="h33-0-77" class="i">+func (w *textWriter) WriteString(s string) (n int, err error) {
</a><a href="#h33-0-78" id="h33-0-78" class="i">+	if !strings.Contains(s, &quot;\n&quot;) {
</a><a href="#h33-0-79" id="h33-0-79" class="i">+		if !w.compact &amp;&amp; w.complete {
</a><a href="#h33-0-80" id="h33-0-80" class="i">+			w.writeIndent()
</a><a href="#h33-0-81" id="h33-0-81" class="i">+		}
</a><a href="#h33-0-82" id="h33-0-82" class="i">+		w.complete = false
</a><a href="#h33-0-83" id="h33-0-83" class="i">+		return io.WriteString(w.w, s)
</a><a href="#h33-0-84" id="h33-0-84" class="i">+	}
</a><a href="#h33-0-85" id="h33-0-85" class="i">+	// WriteString is typically called without newlines, so this
</a><a href="#h33-0-86" id="h33-0-86" class="i">+	// codepath and its copy are rare.  We copy to avoid
</a><a href="#h33-0-87" id="h33-0-87" class="i">+	// duplicating all of Write&#39;s logic here.
</a><a href="#h33-0-88" id="h33-0-88" class="i">+	return w.Write([]byte(s))
</a><a href="#h33-0-89" id="h33-0-89" class="i">+}
</a><a href="#h33-0-90" id="h33-0-90" class="i">+
</a><a href="#h33-0-91" id="h33-0-91" class="i">+func (w *textWriter) Write(p []byte) (n int, err error) {
</a><a href="#h33-0-92" id="h33-0-92" class="i">+	newlines := bytes.Count(p, newline)
</a><a href="#h33-0-93" id="h33-0-93" class="i">+	if newlines == 0 {
</a><a href="#h33-0-94" id="h33-0-94" class="i">+		if !w.compact &amp;&amp; w.complete {
</a><a href="#h33-0-95" id="h33-0-95" class="i">+			w.writeIndent()
</a><a href="#h33-0-96" id="h33-0-96" class="i">+		}
</a><a href="#h33-0-97" id="h33-0-97" class="i">+		n, err = w.w.Write(p)
</a><a href="#h33-0-98" id="h33-0-98" class="i">+		w.complete = false
</a><a href="#h33-0-99" id="h33-0-99" class="i">+		return n, err
</a><a href="#h33-0-100" id="h33-0-100" class="i">+	}
</a><a href="#h33-0-101" id="h33-0-101" class="i">+
</a><a href="#h33-0-102" id="h33-0-102" class="i">+	frags := bytes.SplitN(p, newline, newlines+1)
</a><a href="#h33-0-103" id="h33-0-103" class="i">+	if w.compact {
</a><a href="#h33-0-104" id="h33-0-104" class="i">+		for i, frag := range frags {
</a><a href="#h33-0-105" id="h33-0-105" class="i">+			if i &gt; 0 {
</a><a href="#h33-0-106" id="h33-0-106" class="i">+				if err := w.w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-107" id="h33-0-107" class="i">+					return n, err
</a><a href="#h33-0-108" id="h33-0-108" class="i">+				}
</a><a href="#h33-0-109" id="h33-0-109" class="i">+				n++
</a><a href="#h33-0-110" id="h33-0-110" class="i">+			}
</a><a href="#h33-0-111" id="h33-0-111" class="i">+			nn, err := w.w.Write(frag)
</a><a href="#h33-0-112" id="h33-0-112" class="i">+			n += nn
</a><a href="#h33-0-113" id="h33-0-113" class="i">+			if err != nil {
</a><a href="#h33-0-114" id="h33-0-114" class="i">+				return n, err
</a><a href="#h33-0-115" id="h33-0-115" class="i">+			}
</a><a href="#h33-0-116" id="h33-0-116" class="i">+		}
</a><a href="#h33-0-117" id="h33-0-117" class="i">+		return n, nil
</a><a href="#h33-0-118" id="h33-0-118" class="i">+	}
</a><a href="#h33-0-119" id="h33-0-119" class="i">+
</a><a href="#h33-0-120" id="h33-0-120" class="i">+	for i, frag := range frags {
</a><a href="#h33-0-121" id="h33-0-121" class="i">+		if w.complete {
</a><a href="#h33-0-122" id="h33-0-122" class="i">+			w.writeIndent()
</a><a href="#h33-0-123" id="h33-0-123" class="i">+		}
</a><a href="#h33-0-124" id="h33-0-124" class="i">+		nn, err := w.w.Write(frag)
</a><a href="#h33-0-125" id="h33-0-125" class="i">+		n += nn
</a><a href="#h33-0-126" id="h33-0-126" class="i">+		if err != nil {
</a><a href="#h33-0-127" id="h33-0-127" class="i">+			return n, err
</a><a href="#h33-0-128" id="h33-0-128" class="i">+		}
</a><a href="#h33-0-129" id="h33-0-129" class="i">+		if i+1 &lt; len(frags) {
</a><a href="#h33-0-130" id="h33-0-130" class="i">+			if err := w.w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-131" id="h33-0-131" class="i">+				return n, err
</a><a href="#h33-0-132" id="h33-0-132" class="i">+			}
</a><a href="#h33-0-133" id="h33-0-133" class="i">+			n++
</a><a href="#h33-0-134" id="h33-0-134" class="i">+		}
</a><a href="#h33-0-135" id="h33-0-135" class="i">+	}
</a><a href="#h33-0-136" id="h33-0-136" class="i">+	w.complete = len(frags[len(frags)-1]) == 0
</a><a href="#h33-0-137" id="h33-0-137" class="i">+	return n, nil
</a><a href="#h33-0-138" id="h33-0-138" class="i">+}
</a><a href="#h33-0-139" id="h33-0-139" class="i">+
</a><a href="#h33-0-140" id="h33-0-140" class="i">+func (w *textWriter) WriteByte(c byte) error {
</a><a href="#h33-0-141" id="h33-0-141" class="i">+	if w.compact &amp;&amp; c == &#39;\n&#39; {
</a><a href="#h33-0-142" id="h33-0-142" class="i">+		c = &#39; &#39;
</a><a href="#h33-0-143" id="h33-0-143" class="i">+	}
</a><a href="#h33-0-144" id="h33-0-144" class="i">+	if !w.compact &amp;&amp; w.complete {
</a><a href="#h33-0-145" id="h33-0-145" class="i">+		w.writeIndent()
</a><a href="#h33-0-146" id="h33-0-146" class="i">+	}
</a><a href="#h33-0-147" id="h33-0-147" class="i">+	err := w.w.WriteByte(c)
</a><a href="#h33-0-148" id="h33-0-148" class="i">+	w.complete = c == &#39;\n&#39;
</a><a href="#h33-0-149" id="h33-0-149" class="i">+	return err
</a><a href="#h33-0-150" id="h33-0-150" class="i">+}
</a><a href="#h33-0-151" id="h33-0-151" class="i">+
</a><a href="#h33-0-152" id="h33-0-152" class="i">+func (w *textWriter) indent() { w.ind++ }
</a><a href="#h33-0-153" id="h33-0-153" class="i">+
</a><a href="#h33-0-154" id="h33-0-154" class="i">+func (w *textWriter) unindent() {
</a><a href="#h33-0-155" id="h33-0-155" class="i">+	if w.ind == 0 {
</a><a href="#h33-0-156" id="h33-0-156" class="i">+		log.Print(&quot;proto: textWriter unindented too far&quot;)
</a><a href="#h33-0-157" id="h33-0-157" class="i">+		return
</a><a href="#h33-0-158" id="h33-0-158" class="i">+	}
</a><a href="#h33-0-159" id="h33-0-159" class="i">+	w.ind--
</a><a href="#h33-0-160" id="h33-0-160" class="i">+}
</a><a href="#h33-0-161" id="h33-0-161" class="i">+
</a><a href="#h33-0-162" id="h33-0-162" class="i">+func writeName(w *textWriter, props *Properties) error {
</a><a href="#h33-0-163" id="h33-0-163" class="i">+	if _, err := w.WriteString(props.OrigName); err != nil {
</a><a href="#h33-0-164" id="h33-0-164" class="i">+		return err
</a><a href="#h33-0-165" id="h33-0-165" class="i">+	}
</a><a href="#h33-0-166" id="h33-0-166" class="i">+	if props.Wire != &quot;group&quot; {
</a><a href="#h33-0-167" id="h33-0-167" class="i">+		return w.WriteByte(&#39;:&#39;)
</a><a href="#h33-0-168" id="h33-0-168" class="i">+	}
</a><a href="#h33-0-169" id="h33-0-169" class="i">+	return nil
</a><a href="#h33-0-170" id="h33-0-170" class="i">+}
</a><a href="#h33-0-171" id="h33-0-171" class="i">+
</a><a href="#h33-0-172" id="h33-0-172" class="i">+// raw is the interface satisfied by RawMessage.
</a><a href="#h33-0-173" id="h33-0-173" class="i">+type raw interface {
</a><a href="#h33-0-174" id="h33-0-174" class="i">+	Bytes() []byte
</a><a href="#h33-0-175" id="h33-0-175" class="i">+}
</a><a href="#h33-0-176" id="h33-0-176" class="i">+
</a><a href="#h33-0-177" id="h33-0-177" class="i">+func requiresQuotes(u string) bool {
</a><a href="#h33-0-178" id="h33-0-178" class="i">+	// When type URL contains any characters except [0-9A-Za-z./\-]*, it must be quoted.
</a><a href="#h33-0-179" id="h33-0-179" class="i">+	for _, ch := range u {
</a><a href="#h33-0-180" id="h33-0-180" class="i">+		switch {
</a><a href="#h33-0-181" id="h33-0-181" class="i">+		case ch == &#39;.&#39; || ch == &#39;/&#39; || ch == &#39;_&#39;:
</a><a href="#h33-0-182" id="h33-0-182" class="i">+			continue
</a><a href="#h33-0-183" id="h33-0-183" class="i">+		case &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;:
</a><a href="#h33-0-184" id="h33-0-184" class="i">+			continue
</a><a href="#h33-0-185" id="h33-0-185" class="i">+		case &#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;:
</a><a href="#h33-0-186" id="h33-0-186" class="i">+			continue
</a><a href="#h33-0-187" id="h33-0-187" class="i">+		case &#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;:
</a><a href="#h33-0-188" id="h33-0-188" class="i">+			continue
</a><a href="#h33-0-189" id="h33-0-189" class="i">+		default:
</a><a href="#h33-0-190" id="h33-0-190" class="i">+			return true
</a><a href="#h33-0-191" id="h33-0-191" class="i">+		}
</a><a href="#h33-0-192" id="h33-0-192" class="i">+	}
</a><a href="#h33-0-193" id="h33-0-193" class="i">+	return false
</a><a href="#h33-0-194" id="h33-0-194" class="i">+}
</a><a href="#h33-0-195" id="h33-0-195" class="i">+
</a><a href="#h33-0-196" id="h33-0-196" class="i">+// isAny reports whether sv is a google.protobuf.Any message
</a><a href="#h33-0-197" id="h33-0-197" class="i">+func isAny(sv reflect.Value) bool {
</a><a href="#h33-0-198" id="h33-0-198" class="i">+	type wkt interface {
</a><a href="#h33-0-199" id="h33-0-199" class="i">+		XXX_WellKnownType() string
</a><a href="#h33-0-200" id="h33-0-200" class="i">+	}
</a><a href="#h33-0-201" id="h33-0-201" class="i">+	t, ok := sv.Addr().Interface().(wkt)
</a><a href="#h33-0-202" id="h33-0-202" class="i">+	return ok &amp;&amp; t.XXX_WellKnownType() == &quot;Any&quot;
</a><a href="#h33-0-203" id="h33-0-203" class="i">+}
</a><a href="#h33-0-204" id="h33-0-204" class="i">+
</a><a href="#h33-0-205" id="h33-0-205" class="i">+// writeProto3Any writes an expanded google.protobuf.Any message.
</a><a href="#h33-0-206" id="h33-0-206" class="i">+//
</a><a href="#h33-0-207" id="h33-0-207" class="i">+// It returns (false, nil) if sv value can&#39;t be unmarshaled (e.g. because
</a><a href="#h33-0-208" id="h33-0-208" class="i">+// required messages are not linked in).
</a><a href="#h33-0-209" id="h33-0-209" class="i">+//
</a><a href="#h33-0-210" id="h33-0-210" class="i">+// It returns (true, error) when sv was written in expanded format or an error
</a><a href="#h33-0-211" id="h33-0-211" class="i">+// was encountered.
</a><a href="#h33-0-212" id="h33-0-212" class="i">+func (tm *TextMarshaler) writeProto3Any(w *textWriter, sv reflect.Value) (bool, error) {
</a><a href="#h33-0-213" id="h33-0-213" class="i">+	turl := sv.FieldByName(&quot;TypeUrl&quot;)
</a><a href="#h33-0-214" id="h33-0-214" class="i">+	val := sv.FieldByName(&quot;Value&quot;)
</a><a href="#h33-0-215" id="h33-0-215" class="i">+	if !turl.IsValid() || !val.IsValid() {
</a><a href="#h33-0-216" id="h33-0-216" class="i">+		return true, errors.New(&quot;proto: invalid google.protobuf.Any message&quot;)
</a><a href="#h33-0-217" id="h33-0-217" class="i">+	}
</a><a href="#h33-0-218" id="h33-0-218" class="i">+
</a><a href="#h33-0-219" id="h33-0-219" class="i">+	b, ok := val.Interface().([]byte)
</a><a href="#h33-0-220" id="h33-0-220" class="i">+	if !ok {
</a><a href="#h33-0-221" id="h33-0-221" class="i">+		return true, errors.New(&quot;proto: invalid google.protobuf.Any message&quot;)
</a><a href="#h33-0-222" id="h33-0-222" class="i">+	}
</a><a href="#h33-0-223" id="h33-0-223" class="i">+
</a><a href="#h33-0-224" id="h33-0-224" class="i">+	parts := strings.Split(turl.String(), &quot;/&quot;)
</a><a href="#h33-0-225" id="h33-0-225" class="i">+	mt := MessageType(parts[len(parts)-1])
</a><a href="#h33-0-226" id="h33-0-226" class="i">+	if mt == nil {
</a><a href="#h33-0-227" id="h33-0-227" class="i">+		return false, nil
</a><a href="#h33-0-228" id="h33-0-228" class="i">+	}
</a><a href="#h33-0-229" id="h33-0-229" class="i">+	m := reflect.New(mt.Elem())
</a><a href="#h33-0-230" id="h33-0-230" class="i">+	if err := Unmarshal(b, m.Interface().(Message)); err != nil {
</a><a href="#h33-0-231" id="h33-0-231" class="i">+		return false, nil
</a><a href="#h33-0-232" id="h33-0-232" class="i">+	}
</a><a href="#h33-0-233" id="h33-0-233" class="i">+	w.Write([]byte(&quot;[&quot;))
</a><a href="#h33-0-234" id="h33-0-234" class="i">+	u := turl.String()
</a><a href="#h33-0-235" id="h33-0-235" class="i">+	if requiresQuotes(u) {
</a><a href="#h33-0-236" id="h33-0-236" class="i">+		writeString(w, u)
</a><a href="#h33-0-237" id="h33-0-237" class="i">+	} else {
</a><a href="#h33-0-238" id="h33-0-238" class="i">+		w.Write([]byte(u))
</a><a href="#h33-0-239" id="h33-0-239" class="i">+	}
</a><a href="#h33-0-240" id="h33-0-240" class="i">+	if w.compact {
</a><a href="#h33-0-241" id="h33-0-241" class="i">+		w.Write([]byte(&quot;]:&lt;&quot;))
</a><a href="#h33-0-242" id="h33-0-242" class="i">+	} else {
</a><a href="#h33-0-243" id="h33-0-243" class="i">+		w.Write([]byte(&quot;]: &lt;\n&quot;))
</a><a href="#h33-0-244" id="h33-0-244" class="i">+		w.ind++
</a><a href="#h33-0-245" id="h33-0-245" class="i">+	}
</a><a href="#h33-0-246" id="h33-0-246" class="i">+	if err := tm.writeStruct(w, m.Elem()); err != nil {
</a><a href="#h33-0-247" id="h33-0-247" class="i">+		return true, err
</a><a href="#h33-0-248" id="h33-0-248" class="i">+	}
</a><a href="#h33-0-249" id="h33-0-249" class="i">+	if w.compact {
</a><a href="#h33-0-250" id="h33-0-250" class="i">+		w.Write([]byte(&quot;&gt; &quot;))
</a><a href="#h33-0-251" id="h33-0-251" class="i">+	} else {
</a><a href="#h33-0-252" id="h33-0-252" class="i">+		w.ind--
</a><a href="#h33-0-253" id="h33-0-253" class="i">+		w.Write([]byte(&quot;&gt;\n&quot;))
</a><a href="#h33-0-254" id="h33-0-254" class="i">+	}
</a><a href="#h33-0-255" id="h33-0-255" class="i">+	return true, nil
</a><a href="#h33-0-256" id="h33-0-256" class="i">+}
</a><a href="#h33-0-257" id="h33-0-257" class="i">+
</a><a href="#h33-0-258" id="h33-0-258" class="i">+func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {
</a><a href="#h33-0-259" id="h33-0-259" class="i">+	if tm.ExpandAny &amp;&amp; isAny(sv) {
</a><a href="#h33-0-260" id="h33-0-260" class="i">+		if canExpand, err := tm.writeProto3Any(w, sv); canExpand {
</a><a href="#h33-0-261" id="h33-0-261" class="i">+			return err
</a><a href="#h33-0-262" id="h33-0-262" class="i">+		}
</a><a href="#h33-0-263" id="h33-0-263" class="i">+	}
</a><a href="#h33-0-264" id="h33-0-264" class="i">+	st := sv.Type()
</a><a href="#h33-0-265" id="h33-0-265" class="i">+	sprops := GetProperties(st)
</a><a href="#h33-0-266" id="h33-0-266" class="i">+	for i := 0; i &lt; sv.NumField(); i++ {
</a><a href="#h33-0-267" id="h33-0-267" class="i">+		fv := sv.Field(i)
</a><a href="#h33-0-268" id="h33-0-268" class="i">+		props := sprops.Prop[i]
</a><a href="#h33-0-269" id="h33-0-269" class="i">+		name := st.Field(i).Name
</a><a href="#h33-0-270" id="h33-0-270" class="i">+
</a><a href="#h33-0-271" id="h33-0-271" class="i">+		if strings.HasPrefix(name, &quot;XXX_&quot;) {
</a><a href="#h33-0-272" id="h33-0-272" class="i">+			// There are two XXX_ fields:
</a><a href="#h33-0-273" id="h33-0-273" class="i">+			//   XXX_unrecognized []byte
</a><a href="#h33-0-274" id="h33-0-274" class="i">+			//   XXX_extensions   map[int32]proto.Extension
</a><a href="#h33-0-275" id="h33-0-275" class="i">+			// The first is handled here;
</a><a href="#h33-0-276" id="h33-0-276" class="i">+			// the second is handled at the bottom of this function.
</a><a href="#h33-0-277" id="h33-0-277" class="i">+			if name == &quot;XXX_unrecognized&quot; &amp;&amp; !fv.IsNil() {
</a><a href="#h33-0-278" id="h33-0-278" class="i">+				if err := writeUnknownStruct(w, fv.Interface().([]byte)); err != nil {
</a><a href="#h33-0-279" id="h33-0-279" class="i">+					return err
</a><a href="#h33-0-280" id="h33-0-280" class="i">+				}
</a><a href="#h33-0-281" id="h33-0-281" class="i">+			}
</a><a href="#h33-0-282" id="h33-0-282" class="i">+			continue
</a><a href="#h33-0-283" id="h33-0-283" class="i">+		}
</a><a href="#h33-0-284" id="h33-0-284" class="i">+		if fv.Kind() == reflect.Ptr &amp;&amp; fv.IsNil() {
</a><a href="#h33-0-285" id="h33-0-285" class="i">+			// Field not filled in. This could be an optional field or
</a><a href="#h33-0-286" id="h33-0-286" class="i">+			// a required field that wasn&#39;t filled in. Either way, there
</a><a href="#h33-0-287" id="h33-0-287" class="i">+			// isn&#39;t anything we can show for it.
</a><a href="#h33-0-288" id="h33-0-288" class="i">+			continue
</a><a href="#h33-0-289" id="h33-0-289" class="i">+		}
</a><a href="#h33-0-290" id="h33-0-290" class="i">+		if fv.Kind() == reflect.Slice &amp;&amp; fv.IsNil() {
</a><a href="#h33-0-291" id="h33-0-291" class="i">+			// Repeated field that is empty, or a bytes field that is unused.
</a><a href="#h33-0-292" id="h33-0-292" class="i">+			continue
</a><a href="#h33-0-293" id="h33-0-293" class="i">+		}
</a><a href="#h33-0-294" id="h33-0-294" class="i">+
</a><a href="#h33-0-295" id="h33-0-295" class="i">+		if props.Repeated &amp;&amp; fv.Kind() == reflect.Slice {
</a><a href="#h33-0-296" id="h33-0-296" class="i">+			// Repeated field.
</a><a href="#h33-0-297" id="h33-0-297" class="i">+			for j := 0; j &lt; fv.Len(); j++ {
</a><a href="#h33-0-298" id="h33-0-298" class="i">+				if err := writeName(w, props); err != nil {
</a><a href="#h33-0-299" id="h33-0-299" class="i">+					return err
</a><a href="#h33-0-300" id="h33-0-300" class="i">+				}
</a><a href="#h33-0-301" id="h33-0-301" class="i">+				if !w.compact {
</a><a href="#h33-0-302" id="h33-0-302" class="i">+					if err := w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-303" id="h33-0-303" class="i">+						return err
</a><a href="#h33-0-304" id="h33-0-304" class="i">+					}
</a><a href="#h33-0-305" id="h33-0-305" class="i">+				}
</a><a href="#h33-0-306" id="h33-0-306" class="i">+				v := fv.Index(j)
</a><a href="#h33-0-307" id="h33-0-307" class="i">+				if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() {
</a><a href="#h33-0-308" id="h33-0-308" class="i">+					// A nil message in a repeated field is not valid,
</a><a href="#h33-0-309" id="h33-0-309" class="i">+					// but we can handle that more gracefully than panicking.
</a><a href="#h33-0-310" id="h33-0-310" class="i">+					if _, err := w.Write([]byte(&quot;&lt;nil&gt;\n&quot;)); err != nil {
</a><a href="#h33-0-311" id="h33-0-311" class="i">+						return err
</a><a href="#h33-0-312" id="h33-0-312" class="i">+					}
</a><a href="#h33-0-313" id="h33-0-313" class="i">+					continue
</a><a href="#h33-0-314" id="h33-0-314" class="i">+				}
</a><a href="#h33-0-315" id="h33-0-315" class="i">+				if err := tm.writeAny(w, v, props); err != nil {
</a><a href="#h33-0-316" id="h33-0-316" class="i">+					return err
</a><a href="#h33-0-317" id="h33-0-317" class="i">+				}
</a><a href="#h33-0-318" id="h33-0-318" class="i">+				if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-319" id="h33-0-319" class="i">+					return err
</a><a href="#h33-0-320" id="h33-0-320" class="i">+				}
</a><a href="#h33-0-321" id="h33-0-321" class="i">+			}
</a><a href="#h33-0-322" id="h33-0-322" class="i">+			continue
</a><a href="#h33-0-323" id="h33-0-323" class="i">+		}
</a><a href="#h33-0-324" id="h33-0-324" class="i">+		if fv.Kind() == reflect.Map {
</a><a href="#h33-0-325" id="h33-0-325" class="i">+			// Map fields are rendered as a repeated struct with key/value fields.
</a><a href="#h33-0-326" id="h33-0-326" class="i">+			keys := fv.MapKeys()
</a><a href="#h33-0-327" id="h33-0-327" class="i">+			sort.Sort(mapKeys(keys))
</a><a href="#h33-0-328" id="h33-0-328" class="i">+			for _, key := range keys {
</a><a href="#h33-0-329" id="h33-0-329" class="i">+				val := fv.MapIndex(key)
</a><a href="#h33-0-330" id="h33-0-330" class="i">+				if err := writeName(w, props); err != nil {
</a><a href="#h33-0-331" id="h33-0-331" class="i">+					return err
</a><a href="#h33-0-332" id="h33-0-332" class="i">+				}
</a><a href="#h33-0-333" id="h33-0-333" class="i">+				if !w.compact {
</a><a href="#h33-0-334" id="h33-0-334" class="i">+					if err := w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-335" id="h33-0-335" class="i">+						return err
</a><a href="#h33-0-336" id="h33-0-336" class="i">+					}
</a><a href="#h33-0-337" id="h33-0-337" class="i">+				}
</a><a href="#h33-0-338" id="h33-0-338" class="i">+				// open struct
</a><a href="#h33-0-339" id="h33-0-339" class="i">+				if err := w.WriteByte(&#39;&lt;&#39;); err != nil {
</a><a href="#h33-0-340" id="h33-0-340" class="i">+					return err
</a><a href="#h33-0-341" id="h33-0-341" class="i">+				}
</a><a href="#h33-0-342" id="h33-0-342" class="i">+				if !w.compact {
</a><a href="#h33-0-343" id="h33-0-343" class="i">+					if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-344" id="h33-0-344" class="i">+						return err
</a><a href="#h33-0-345" id="h33-0-345" class="i">+					}
</a><a href="#h33-0-346" id="h33-0-346" class="i">+				}
</a><a href="#h33-0-347" id="h33-0-347" class="i">+				w.indent()
</a><a href="#h33-0-348" id="h33-0-348" class="i">+				// key
</a><a href="#h33-0-349" id="h33-0-349" class="i">+				if _, err := w.WriteString(&quot;key:&quot;); err != nil {
</a><a href="#h33-0-350" id="h33-0-350" class="i">+					return err
</a><a href="#h33-0-351" id="h33-0-351" class="i">+				}
</a><a href="#h33-0-352" id="h33-0-352" class="i">+				if !w.compact {
</a><a href="#h33-0-353" id="h33-0-353" class="i">+					if err := w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-354" id="h33-0-354" class="i">+						return err
</a><a href="#h33-0-355" id="h33-0-355" class="i">+					}
</a><a href="#h33-0-356" id="h33-0-356" class="i">+				}
</a><a href="#h33-0-357" id="h33-0-357" class="i">+				if err := tm.writeAny(w, key, props.mkeyprop); err != nil {
</a><a href="#h33-0-358" id="h33-0-358" class="i">+					return err
</a><a href="#h33-0-359" id="h33-0-359" class="i">+				}
</a><a href="#h33-0-360" id="h33-0-360" class="i">+				if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-361" id="h33-0-361" class="i">+					return err
</a><a href="#h33-0-362" id="h33-0-362" class="i">+				}
</a><a href="#h33-0-363" id="h33-0-363" class="i">+				// nil values aren&#39;t legal, but we can avoid panicking because of them.
</a><a href="#h33-0-364" id="h33-0-364" class="i">+				if val.Kind() != reflect.Ptr || !val.IsNil() {
</a><a href="#h33-0-365" id="h33-0-365" class="i">+					// value
</a><a href="#h33-0-366" id="h33-0-366" class="i">+					if _, err := w.WriteString(&quot;value:&quot;); err != nil {
</a><a href="#h33-0-367" id="h33-0-367" class="i">+						return err
</a><a href="#h33-0-368" id="h33-0-368" class="i">+					}
</a><a href="#h33-0-369" id="h33-0-369" class="i">+					if !w.compact {
</a><a href="#h33-0-370" id="h33-0-370" class="i">+						if err := w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-371" id="h33-0-371" class="i">+							return err
</a><a href="#h33-0-372" id="h33-0-372" class="i">+						}
</a><a href="#h33-0-373" id="h33-0-373" class="i">+					}
</a><a href="#h33-0-374" id="h33-0-374" class="i">+					if err := tm.writeAny(w, val, props.mvalprop); err != nil {
</a><a href="#h33-0-375" id="h33-0-375" class="i">+						return err
</a><a href="#h33-0-376" id="h33-0-376" class="i">+					}
</a><a href="#h33-0-377" id="h33-0-377" class="i">+					if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-378" id="h33-0-378" class="i">+						return err
</a><a href="#h33-0-379" id="h33-0-379" class="i">+					}
</a><a href="#h33-0-380" id="h33-0-380" class="i">+				}
</a><a href="#h33-0-381" id="h33-0-381" class="i">+				// close struct
</a><a href="#h33-0-382" id="h33-0-382" class="i">+				w.unindent()
</a><a href="#h33-0-383" id="h33-0-383" class="i">+				if err := w.WriteByte(&#39;&gt;&#39;); err != nil {
</a><a href="#h33-0-384" id="h33-0-384" class="i">+					return err
</a><a href="#h33-0-385" id="h33-0-385" class="i">+				}
</a><a href="#h33-0-386" id="h33-0-386" class="i">+				if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-387" id="h33-0-387" class="i">+					return err
</a><a href="#h33-0-388" id="h33-0-388" class="i">+				}
</a><a href="#h33-0-389" id="h33-0-389" class="i">+			}
</a><a href="#h33-0-390" id="h33-0-390" class="i">+			continue
</a><a href="#h33-0-391" id="h33-0-391" class="i">+		}
</a><a href="#h33-0-392" id="h33-0-392" class="i">+		if props.proto3 &amp;&amp; fv.Kind() == reflect.Slice &amp;&amp; fv.Len() == 0 {
</a><a href="#h33-0-393" id="h33-0-393" class="i">+			// empty bytes field
</a><a href="#h33-0-394" id="h33-0-394" class="i">+			continue
</a><a href="#h33-0-395" id="h33-0-395" class="i">+		}
</a><a href="#h33-0-396" id="h33-0-396" class="i">+		if fv.Kind() != reflect.Ptr &amp;&amp; fv.Kind() != reflect.Slice {
</a><a href="#h33-0-397" id="h33-0-397" class="i">+			// proto3 non-repeated scalar field; skip if zero value
</a><a href="#h33-0-398" id="h33-0-398" class="i">+			if isProto3Zero(fv) {
</a><a href="#h33-0-399" id="h33-0-399" class="i">+				continue
</a><a href="#h33-0-400" id="h33-0-400" class="i">+			}
</a><a href="#h33-0-401" id="h33-0-401" class="i">+		}
</a><a href="#h33-0-402" id="h33-0-402" class="i">+
</a><a href="#h33-0-403" id="h33-0-403" class="i">+		if fv.Kind() == reflect.Interface {
</a><a href="#h33-0-404" id="h33-0-404" class="i">+			// Check if it is a oneof.
</a><a href="#h33-0-405" id="h33-0-405" class="i">+			if st.Field(i).Tag.Get(&quot;protobuf_oneof&quot;) != &quot;&quot; {
</a><a href="#h33-0-406" id="h33-0-406" class="i">+				// fv is nil, or holds a pointer to generated struct.
</a><a href="#h33-0-407" id="h33-0-407" class="i">+				// That generated struct has exactly one field,
</a><a href="#h33-0-408" id="h33-0-408" class="i">+				// which has a protobuf struct tag.
</a><a href="#h33-0-409" id="h33-0-409" class="i">+				if fv.IsNil() {
</a><a href="#h33-0-410" id="h33-0-410" class="i">+					continue
</a><a href="#h33-0-411" id="h33-0-411" class="i">+				}
</a><a href="#h33-0-412" id="h33-0-412" class="i">+				inner := fv.Elem().Elem() // interface -&gt; *T -&gt; T
</a><a href="#h33-0-413" id="h33-0-413" class="i">+				tag := inner.Type().Field(0).Tag.Get(&quot;protobuf&quot;)
</a><a href="#h33-0-414" id="h33-0-414" class="i">+				props = new(Properties) // Overwrite the outer props var, but not its pointee.
</a><a href="#h33-0-415" id="h33-0-415" class="i">+				props.Parse(tag)
</a><a href="#h33-0-416" id="h33-0-416" class="i">+				// Write the value in the oneof, not the oneof itself.
</a><a href="#h33-0-417" id="h33-0-417" class="i">+				fv = inner.Field(0)
</a><a href="#h33-0-418" id="h33-0-418" class="i">+
</a><a href="#h33-0-419" id="h33-0-419" class="i">+				// Special case to cope with malformed messages gracefully:
</a><a href="#h33-0-420" id="h33-0-420" class="i">+				// If the value in the oneof is a nil pointer, don&#39;t panic
</a><a href="#h33-0-421" id="h33-0-421" class="i">+				// in writeAny.
</a><a href="#h33-0-422" id="h33-0-422" class="i">+				if fv.Kind() == reflect.Ptr &amp;&amp; fv.IsNil() {
</a><a href="#h33-0-423" id="h33-0-423" class="i">+					// Use errors.New so writeAny won&#39;t render quotes.
</a><a href="#h33-0-424" id="h33-0-424" class="i">+					msg := errors.New(&quot;/* nil */&quot;)
</a><a href="#h33-0-425" id="h33-0-425" class="i">+					fv = reflect.ValueOf(&amp;msg).Elem()
</a><a href="#h33-0-426" id="h33-0-426" class="i">+				}
</a><a href="#h33-0-427" id="h33-0-427" class="i">+			}
</a><a href="#h33-0-428" id="h33-0-428" class="i">+		}
</a><a href="#h33-0-429" id="h33-0-429" class="i">+
</a><a href="#h33-0-430" id="h33-0-430" class="i">+		if err := writeName(w, props); err != nil {
</a><a href="#h33-0-431" id="h33-0-431" class="i">+			return err
</a><a href="#h33-0-432" id="h33-0-432" class="i">+		}
</a><a href="#h33-0-433" id="h33-0-433" class="i">+		if !w.compact {
</a><a href="#h33-0-434" id="h33-0-434" class="i">+			if err := w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-435" id="h33-0-435" class="i">+				return err
</a><a href="#h33-0-436" id="h33-0-436" class="i">+			}
</a><a href="#h33-0-437" id="h33-0-437" class="i">+		}
</a><a href="#h33-0-438" id="h33-0-438" class="i">+		if b, ok := fv.Interface().(raw); ok {
</a><a href="#h33-0-439" id="h33-0-439" class="i">+			if err := writeRaw(w, b.Bytes()); err != nil {
</a><a href="#h33-0-440" id="h33-0-440" class="i">+				return err
</a><a href="#h33-0-441" id="h33-0-441" class="i">+			}
</a><a href="#h33-0-442" id="h33-0-442" class="i">+			continue
</a><a href="#h33-0-443" id="h33-0-443" class="i">+		}
</a><a href="#h33-0-444" id="h33-0-444" class="i">+
</a><a href="#h33-0-445" id="h33-0-445" class="i">+		// Enums have a String method, so writeAny will work fine.
</a><a href="#h33-0-446" id="h33-0-446" class="i">+		if err := tm.writeAny(w, fv, props); err != nil {
</a><a href="#h33-0-447" id="h33-0-447" class="i">+			return err
</a><a href="#h33-0-448" id="h33-0-448" class="i">+		}
</a><a href="#h33-0-449" id="h33-0-449" class="i">+
</a><a href="#h33-0-450" id="h33-0-450" class="i">+		if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-451" id="h33-0-451" class="i">+			return err
</a><a href="#h33-0-452" id="h33-0-452" class="i">+		}
</a><a href="#h33-0-453" id="h33-0-453" class="i">+	}
</a><a href="#h33-0-454" id="h33-0-454" class="i">+
</a><a href="#h33-0-455" id="h33-0-455" class="i">+	// Extensions (the XXX_extensions field).
</a><a href="#h33-0-456" id="h33-0-456" class="i">+	pv := sv.Addr()
</a><a href="#h33-0-457" id="h33-0-457" class="i">+	if _, ok := extendable(pv.Interface()); ok {
</a><a href="#h33-0-458" id="h33-0-458" class="i">+		if err := tm.writeExtensions(w, pv); err != nil {
</a><a href="#h33-0-459" id="h33-0-459" class="i">+			return err
</a><a href="#h33-0-460" id="h33-0-460" class="i">+		}
</a><a href="#h33-0-461" id="h33-0-461" class="i">+	}
</a><a href="#h33-0-462" id="h33-0-462" class="i">+
</a><a href="#h33-0-463" id="h33-0-463" class="i">+	return nil
</a><a href="#h33-0-464" id="h33-0-464" class="i">+}
</a><a href="#h33-0-465" id="h33-0-465" class="i">+
</a><a href="#h33-0-466" id="h33-0-466" class="i">+// writeRaw writes an uninterpreted raw message.
</a><a href="#h33-0-467" id="h33-0-467" class="i">+func writeRaw(w *textWriter, b []byte) error {
</a><a href="#h33-0-468" id="h33-0-468" class="i">+	if err := w.WriteByte(&#39;&lt;&#39;); err != nil {
</a><a href="#h33-0-469" id="h33-0-469" class="i">+		return err
</a><a href="#h33-0-470" id="h33-0-470" class="i">+	}
</a><a href="#h33-0-471" id="h33-0-471" class="i">+	if !w.compact {
</a><a href="#h33-0-472" id="h33-0-472" class="i">+		if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-473" id="h33-0-473" class="i">+			return err
</a><a href="#h33-0-474" id="h33-0-474" class="i">+		}
</a><a href="#h33-0-475" id="h33-0-475" class="i">+	}
</a><a href="#h33-0-476" id="h33-0-476" class="i">+	w.indent()
</a><a href="#h33-0-477" id="h33-0-477" class="i">+	if err := writeUnknownStruct(w, b); err != nil {
</a><a href="#h33-0-478" id="h33-0-478" class="i">+		return err
</a><a href="#h33-0-479" id="h33-0-479" class="i">+	}
</a><a href="#h33-0-480" id="h33-0-480" class="i">+	w.unindent()
</a><a href="#h33-0-481" id="h33-0-481" class="i">+	if err := w.WriteByte(&#39;&gt;&#39;); err != nil {
</a><a href="#h33-0-482" id="h33-0-482" class="i">+		return err
</a><a href="#h33-0-483" id="h33-0-483" class="i">+	}
</a><a href="#h33-0-484" id="h33-0-484" class="i">+	return nil
</a><a href="#h33-0-485" id="h33-0-485" class="i">+}
</a><a href="#h33-0-486" id="h33-0-486" class="i">+
</a><a href="#h33-0-487" id="h33-0-487" class="i">+// writeAny writes an arbitrary field.
</a><a href="#h33-0-488" id="h33-0-488" class="i">+func (tm *TextMarshaler) writeAny(w *textWriter, v reflect.Value, props *Properties) error {
</a><a href="#h33-0-489" id="h33-0-489" class="i">+	v = reflect.Indirect(v)
</a><a href="#h33-0-490" id="h33-0-490" class="i">+
</a><a href="#h33-0-491" id="h33-0-491" class="i">+	// Floats have special cases.
</a><a href="#h33-0-492" id="h33-0-492" class="i">+	if v.Kind() == reflect.Float32 || v.Kind() == reflect.Float64 {
</a><a href="#h33-0-493" id="h33-0-493" class="i">+		x := v.Float()
</a><a href="#h33-0-494" id="h33-0-494" class="i">+		var b []byte
</a><a href="#h33-0-495" id="h33-0-495" class="i">+		switch {
</a><a href="#h33-0-496" id="h33-0-496" class="i">+		case math.IsInf(x, 1):
</a><a href="#h33-0-497" id="h33-0-497" class="i">+			b = posInf
</a><a href="#h33-0-498" id="h33-0-498" class="i">+		case math.IsInf(x, -1):
</a><a href="#h33-0-499" id="h33-0-499" class="i">+			b = negInf
</a><a href="#h33-0-500" id="h33-0-500" class="i">+		case math.IsNaN(x):
</a><a href="#h33-0-501" id="h33-0-501" class="i">+			b = nan
</a><a href="#h33-0-502" id="h33-0-502" class="i">+		}
</a><a href="#h33-0-503" id="h33-0-503" class="i">+		if b != nil {
</a><a href="#h33-0-504" id="h33-0-504" class="i">+			_, err := w.Write(b)
</a><a href="#h33-0-505" id="h33-0-505" class="i">+			return err
</a><a href="#h33-0-506" id="h33-0-506" class="i">+		}
</a><a href="#h33-0-507" id="h33-0-507" class="i">+		// Other values are handled below.
</a><a href="#h33-0-508" id="h33-0-508" class="i">+	}
</a><a href="#h33-0-509" id="h33-0-509" class="i">+
</a><a href="#h33-0-510" id="h33-0-510" class="i">+	// We don&#39;t attempt to serialise every possible value type; only those
</a><a href="#h33-0-511" id="h33-0-511" class="i">+	// that can occur in protocol buffers.
</a><a href="#h33-0-512" id="h33-0-512" class="i">+	switch v.Kind() {
</a><a href="#h33-0-513" id="h33-0-513" class="i">+	case reflect.Slice:
</a><a href="#h33-0-514" id="h33-0-514" class="i">+		// Should only be a []byte; repeated fields are handled in writeStruct.
</a><a href="#h33-0-515" id="h33-0-515" class="i">+		if err := writeString(w, string(v.Bytes())); err != nil {
</a><a href="#h33-0-516" id="h33-0-516" class="i">+			return err
</a><a href="#h33-0-517" id="h33-0-517" class="i">+		}
</a><a href="#h33-0-518" id="h33-0-518" class="i">+	case reflect.String:
</a><a href="#h33-0-519" id="h33-0-519" class="i">+		if err := writeString(w, v.String()); err != nil {
</a><a href="#h33-0-520" id="h33-0-520" class="i">+			return err
</a><a href="#h33-0-521" id="h33-0-521" class="i">+		}
</a><a href="#h33-0-522" id="h33-0-522" class="i">+	case reflect.Struct:
</a><a href="#h33-0-523" id="h33-0-523" class="i">+		// Required/optional group/message.
</a><a href="#h33-0-524" id="h33-0-524" class="i">+		var bra, ket byte = &#39;&lt;&#39;, &#39;&gt;&#39;
</a><a href="#h33-0-525" id="h33-0-525" class="i">+		if props != nil &amp;&amp; props.Wire == &quot;group&quot; {
</a><a href="#h33-0-526" id="h33-0-526" class="i">+			bra, ket = &#39;{&#39;, &#39;}&#39;
</a><a href="#h33-0-527" id="h33-0-527" class="i">+		}
</a><a href="#h33-0-528" id="h33-0-528" class="i">+		if err := w.WriteByte(bra); err != nil {
</a><a href="#h33-0-529" id="h33-0-529" class="i">+			return err
</a><a href="#h33-0-530" id="h33-0-530" class="i">+		}
</a><a href="#h33-0-531" id="h33-0-531" class="i">+		if !w.compact {
</a><a href="#h33-0-532" id="h33-0-532" class="i">+			if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-533" id="h33-0-533" class="i">+				return err
</a><a href="#h33-0-534" id="h33-0-534" class="i">+			}
</a><a href="#h33-0-535" id="h33-0-535" class="i">+		}
</a><a href="#h33-0-536" id="h33-0-536" class="i">+		w.indent()
</a><a href="#h33-0-537" id="h33-0-537" class="i">+		if etm, ok := v.Interface().(encoding.TextMarshaler); ok {
</a><a href="#h33-0-538" id="h33-0-538" class="i">+			text, err := etm.MarshalText()
</a><a href="#h33-0-539" id="h33-0-539" class="i">+			if err != nil {
</a><a href="#h33-0-540" id="h33-0-540" class="i">+				return err
</a><a href="#h33-0-541" id="h33-0-541" class="i">+			}
</a><a href="#h33-0-542" id="h33-0-542" class="i">+			if _, err = w.Write(text); err != nil {
</a><a href="#h33-0-543" id="h33-0-543" class="i">+				return err
</a><a href="#h33-0-544" id="h33-0-544" class="i">+			}
</a><a href="#h33-0-545" id="h33-0-545" class="i">+		} else if err := tm.writeStruct(w, v); err != nil {
</a><a href="#h33-0-546" id="h33-0-546" class="i">+			return err
</a><a href="#h33-0-547" id="h33-0-547" class="i">+		}
</a><a href="#h33-0-548" id="h33-0-548" class="i">+		w.unindent()
</a><a href="#h33-0-549" id="h33-0-549" class="i">+		if err := w.WriteByte(ket); err != nil {
</a><a href="#h33-0-550" id="h33-0-550" class="i">+			return err
</a><a href="#h33-0-551" id="h33-0-551" class="i">+		}
</a><a href="#h33-0-552" id="h33-0-552" class="i">+	default:
</a><a href="#h33-0-553" id="h33-0-553" class="i">+		_, err := fmt.Fprint(w, v.Interface())
</a><a href="#h33-0-554" id="h33-0-554" class="i">+		return err
</a><a href="#h33-0-555" id="h33-0-555" class="i">+	}
</a><a href="#h33-0-556" id="h33-0-556" class="i">+	return nil
</a><a href="#h33-0-557" id="h33-0-557" class="i">+}
</a><a href="#h33-0-558" id="h33-0-558" class="i">+
</a><a href="#h33-0-559" id="h33-0-559" class="i">+// equivalent to C&#39;s isprint.
</a><a href="#h33-0-560" id="h33-0-560" class="i">+func isprint(c byte) bool {
</a><a href="#h33-0-561" id="h33-0-561" class="i">+	return c &gt;= 0x20 &amp;&amp; c &lt; 0x7f
</a><a href="#h33-0-562" id="h33-0-562" class="i">+}
</a><a href="#h33-0-563" id="h33-0-563" class="i">+
</a><a href="#h33-0-564" id="h33-0-564" class="i">+// writeString writes a string in the protocol buffer text format.
</a><a href="#h33-0-565" id="h33-0-565" class="i">+// It is similar to strconv.Quote except we don&#39;t use Go escape sequences,
</a><a href="#h33-0-566" id="h33-0-566" class="i">+// we treat the string as a byte sequence, and we use octal escapes.
</a><a href="#h33-0-567" id="h33-0-567" class="i">+// These differences are to maintain interoperability with the other
</a><a href="#h33-0-568" id="h33-0-568" class="i">+// languages&#39; implementations of the text format.
</a><a href="#h33-0-569" id="h33-0-569" class="i">+func writeString(w *textWriter, s string) error {
</a><a href="#h33-0-570" id="h33-0-570" class="i">+	// use WriteByte here to get any needed indent
</a><a href="#h33-0-571" id="h33-0-571" class="i">+	if err := w.WriteByte(&#39;&quot;&#39;); err != nil {
</a><a href="#h33-0-572" id="h33-0-572" class="i">+		return err
</a><a href="#h33-0-573" id="h33-0-573" class="i">+	}
</a><a href="#h33-0-574" id="h33-0-574" class="i">+	// Loop over the bytes, not the runes.
</a><a href="#h33-0-575" id="h33-0-575" class="i">+	for i := 0; i &lt; len(s); i++ {
</a><a href="#h33-0-576" id="h33-0-576" class="i">+		var err error
</a><a href="#h33-0-577" id="h33-0-577" class="i">+		// Divergence from C++: we don&#39;t escape apostrophes.
</a><a href="#h33-0-578" id="h33-0-578" class="i">+		// There&#39;s no need to escape them, and the C++ parser
</a><a href="#h33-0-579" id="h33-0-579" class="i">+		// copes with a naked apostrophe.
</a><a href="#h33-0-580" id="h33-0-580" class="i">+		switch c := s[i]; c {
</a><a href="#h33-0-581" id="h33-0-581" class="i">+		case &#39;\n&#39;:
</a><a href="#h33-0-582" id="h33-0-582" class="i">+			_, err = w.w.Write(backslashN)
</a><a href="#h33-0-583" id="h33-0-583" class="i">+		case &#39;\r&#39;:
</a><a href="#h33-0-584" id="h33-0-584" class="i">+			_, err = w.w.Write(backslashR)
</a><a href="#h33-0-585" id="h33-0-585" class="i">+		case &#39;\t&#39;:
</a><a href="#h33-0-586" id="h33-0-586" class="i">+			_, err = w.w.Write(backslashT)
</a><a href="#h33-0-587" id="h33-0-587" class="i">+		case &#39;&quot;&#39;:
</a><a href="#h33-0-588" id="h33-0-588" class="i">+			_, err = w.w.Write(backslashDQ)
</a><a href="#h33-0-589" id="h33-0-589" class="i">+		case &#39;\\&#39;:
</a><a href="#h33-0-590" id="h33-0-590" class="i">+			_, err = w.w.Write(backslashBS)
</a><a href="#h33-0-591" id="h33-0-591" class="i">+		default:
</a><a href="#h33-0-592" id="h33-0-592" class="i">+			if isprint(c) {
</a><a href="#h33-0-593" id="h33-0-593" class="i">+				err = w.w.WriteByte(c)
</a><a href="#h33-0-594" id="h33-0-594" class="i">+			} else {
</a><a href="#h33-0-595" id="h33-0-595" class="i">+				_, err = fmt.Fprintf(w.w, &quot;\\%03o&quot;, c)
</a><a href="#h33-0-596" id="h33-0-596" class="i">+			}
</a><a href="#h33-0-597" id="h33-0-597" class="i">+		}
</a><a href="#h33-0-598" id="h33-0-598" class="i">+		if err != nil {
</a><a href="#h33-0-599" id="h33-0-599" class="i">+			return err
</a><a href="#h33-0-600" id="h33-0-600" class="i">+		}
</a><a href="#h33-0-601" id="h33-0-601" class="i">+	}
</a><a href="#h33-0-602" id="h33-0-602" class="i">+	return w.WriteByte(&#39;&quot;&#39;)
</a><a href="#h33-0-603" id="h33-0-603" class="i">+}
</a><a href="#h33-0-604" id="h33-0-604" class="i">+
</a><a href="#h33-0-605" id="h33-0-605" class="i">+func writeUnknownStruct(w *textWriter, data []byte) (err error) {
</a><a href="#h33-0-606" id="h33-0-606" class="i">+	if !w.compact {
</a><a href="#h33-0-607" id="h33-0-607" class="i">+		if _, err := fmt.Fprintf(w, &quot;/* %d unknown bytes */\n&quot;, len(data)); err != nil {
</a><a href="#h33-0-608" id="h33-0-608" class="i">+			return err
</a><a href="#h33-0-609" id="h33-0-609" class="i">+		}
</a><a href="#h33-0-610" id="h33-0-610" class="i">+	}
</a><a href="#h33-0-611" id="h33-0-611" class="i">+	b := NewBuffer(data)
</a><a href="#h33-0-612" id="h33-0-612" class="i">+	for b.index &lt; len(b.buf) {
</a><a href="#h33-0-613" id="h33-0-613" class="i">+		x, err := b.DecodeVarint()
</a><a href="#h33-0-614" id="h33-0-614" class="i">+		if err != nil {
</a><a href="#h33-0-615" id="h33-0-615" class="i">+			_, err := fmt.Fprintf(w, &quot;/* %v */\n&quot;, err)
</a><a href="#h33-0-616" id="h33-0-616" class="i">+			return err
</a><a href="#h33-0-617" id="h33-0-617" class="i">+		}
</a><a href="#h33-0-618" id="h33-0-618" class="i">+		wire, tag := x&amp;7, x&gt;&gt;3
</a><a href="#h33-0-619" id="h33-0-619" class="i">+		if wire == WireEndGroup {
</a><a href="#h33-0-620" id="h33-0-620" class="i">+			w.unindent()
</a><a href="#h33-0-621" id="h33-0-621" class="i">+			if _, err := w.Write(endBraceNewline); err != nil {
</a><a href="#h33-0-622" id="h33-0-622" class="i">+				return err
</a><a href="#h33-0-623" id="h33-0-623" class="i">+			}
</a><a href="#h33-0-624" id="h33-0-624" class="i">+			continue
</a><a href="#h33-0-625" id="h33-0-625" class="i">+		}
</a><a href="#h33-0-626" id="h33-0-626" class="i">+		if _, err := fmt.Fprint(w, tag); err != nil {
</a><a href="#h33-0-627" id="h33-0-627" class="i">+			return err
</a><a href="#h33-0-628" id="h33-0-628" class="i">+		}
</a><a href="#h33-0-629" id="h33-0-629" class="i">+		if wire != WireStartGroup {
</a><a href="#h33-0-630" id="h33-0-630" class="i">+			if err := w.WriteByte(&#39;:&#39;); err != nil {
</a><a href="#h33-0-631" id="h33-0-631" class="i">+				return err
</a><a href="#h33-0-632" id="h33-0-632" class="i">+			}
</a><a href="#h33-0-633" id="h33-0-633" class="i">+		}
</a><a href="#h33-0-634" id="h33-0-634" class="i">+		if !w.compact || wire == WireStartGroup {
</a><a href="#h33-0-635" id="h33-0-635" class="i">+			if err := w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-636" id="h33-0-636" class="i">+				return err
</a><a href="#h33-0-637" id="h33-0-637" class="i">+			}
</a><a href="#h33-0-638" id="h33-0-638" class="i">+		}
</a><a href="#h33-0-639" id="h33-0-639" class="i">+		switch wire {
</a><a href="#h33-0-640" id="h33-0-640" class="i">+		case WireBytes:
</a><a href="#h33-0-641" id="h33-0-641" class="i">+			buf, e := b.DecodeRawBytes(false)
</a><a href="#h33-0-642" id="h33-0-642" class="i">+			if e == nil {
</a><a href="#h33-0-643" id="h33-0-643" class="i">+				_, err = fmt.Fprintf(w, &quot;%q&quot;, buf)
</a><a href="#h33-0-644" id="h33-0-644" class="i">+			} else {
</a><a href="#h33-0-645" id="h33-0-645" class="i">+				_, err = fmt.Fprintf(w, &quot;/* %v */&quot;, e)
</a><a href="#h33-0-646" id="h33-0-646" class="i">+			}
</a><a href="#h33-0-647" id="h33-0-647" class="i">+		case WireFixed32:
</a><a href="#h33-0-648" id="h33-0-648" class="i">+			x, err = b.DecodeFixed32()
</a><a href="#h33-0-649" id="h33-0-649" class="i">+			err = writeUnknownInt(w, x, err)
</a><a href="#h33-0-650" id="h33-0-650" class="i">+		case WireFixed64:
</a><a href="#h33-0-651" id="h33-0-651" class="i">+			x, err = b.DecodeFixed64()
</a><a href="#h33-0-652" id="h33-0-652" class="i">+			err = writeUnknownInt(w, x, err)
</a><a href="#h33-0-653" id="h33-0-653" class="i">+		case WireStartGroup:
</a><a href="#h33-0-654" id="h33-0-654" class="i">+			err = w.WriteByte(&#39;{&#39;)
</a><a href="#h33-0-655" id="h33-0-655" class="i">+			w.indent()
</a><a href="#h33-0-656" id="h33-0-656" class="i">+		case WireVarint:
</a><a href="#h33-0-657" id="h33-0-657" class="i">+			x, err = b.DecodeVarint()
</a><a href="#h33-0-658" id="h33-0-658" class="i">+			err = writeUnknownInt(w, x, err)
</a><a href="#h33-0-659" id="h33-0-659" class="i">+		default:
</a><a href="#h33-0-660" id="h33-0-660" class="i">+			_, err = fmt.Fprintf(w, &quot;/* unknown wire type %d */&quot;, wire)
</a><a href="#h33-0-661" id="h33-0-661" class="i">+		}
</a><a href="#h33-0-662" id="h33-0-662" class="i">+		if err != nil {
</a><a href="#h33-0-663" id="h33-0-663" class="i">+			return err
</a><a href="#h33-0-664" id="h33-0-664" class="i">+		}
</a><a href="#h33-0-665" id="h33-0-665" class="i">+		if err = w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-666" id="h33-0-666" class="i">+			return err
</a><a href="#h33-0-667" id="h33-0-667" class="i">+		}
</a><a href="#h33-0-668" id="h33-0-668" class="i">+	}
</a><a href="#h33-0-669" id="h33-0-669" class="i">+	return nil
</a><a href="#h33-0-670" id="h33-0-670" class="i">+}
</a><a href="#h33-0-671" id="h33-0-671" class="i">+
</a><a href="#h33-0-672" id="h33-0-672" class="i">+func writeUnknownInt(w *textWriter, x uint64, err error) error {
</a><a href="#h33-0-673" id="h33-0-673" class="i">+	if err == nil {
</a><a href="#h33-0-674" id="h33-0-674" class="i">+		_, err = fmt.Fprint(w, x)
</a><a href="#h33-0-675" id="h33-0-675" class="i">+	} else {
</a><a href="#h33-0-676" id="h33-0-676" class="i">+		_, err = fmt.Fprintf(w, &quot;/* %v */&quot;, err)
</a><a href="#h33-0-677" id="h33-0-677" class="i">+	}
</a><a href="#h33-0-678" id="h33-0-678" class="i">+	return err
</a><a href="#h33-0-679" id="h33-0-679" class="i">+}
</a><a href="#h33-0-680" id="h33-0-680" class="i">+
</a><a href="#h33-0-681" id="h33-0-681" class="i">+type int32Slice []int32
</a><a href="#h33-0-682" id="h33-0-682" class="i">+
</a><a href="#h33-0-683" id="h33-0-683" class="i">+func (s int32Slice) Len() int           { return len(s) }
</a><a href="#h33-0-684" id="h33-0-684" class="i">+func (s int32Slice) Less(i, j int) bool { return s[i] &lt; s[j] }
</a><a href="#h33-0-685" id="h33-0-685" class="i">+func (s int32Slice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
</a><a href="#h33-0-686" id="h33-0-686" class="i">+
</a><a href="#h33-0-687" id="h33-0-687" class="i">+// writeExtensions writes all the extensions in pv.
</a><a href="#h33-0-688" id="h33-0-688" class="i">+// pv is assumed to be a pointer to a protocol message struct that is extendable.
</a><a href="#h33-0-689" id="h33-0-689" class="i">+func (tm *TextMarshaler) writeExtensions(w *textWriter, pv reflect.Value) error {
</a><a href="#h33-0-690" id="h33-0-690" class="i">+	emap := extensionMaps[pv.Type().Elem()]
</a><a href="#h33-0-691" id="h33-0-691" class="i">+	ep, _ := extendable(pv.Interface())
</a><a href="#h33-0-692" id="h33-0-692" class="i">+
</a><a href="#h33-0-693" id="h33-0-693" class="i">+	// Order the extensions by ID.
</a><a href="#h33-0-694" id="h33-0-694" class="i">+	// This isn&#39;t strictly necessary, but it will give us
</a><a href="#h33-0-695" id="h33-0-695" class="i">+	// canonical output, which will also make testing easier.
</a><a href="#h33-0-696" id="h33-0-696" class="i">+	m, mu := ep.extensionsRead()
</a><a href="#h33-0-697" id="h33-0-697" class="i">+	if m == nil {
</a><a href="#h33-0-698" id="h33-0-698" class="i">+		return nil
</a><a href="#h33-0-699" id="h33-0-699" class="i">+	}
</a><a href="#h33-0-700" id="h33-0-700" class="i">+	mu.Lock()
</a><a href="#h33-0-701" id="h33-0-701" class="i">+	ids := make([]int32, 0, len(m))
</a><a href="#h33-0-702" id="h33-0-702" class="i">+	for id := range m {
</a><a href="#h33-0-703" id="h33-0-703" class="i">+		ids = append(ids, id)
</a><a href="#h33-0-704" id="h33-0-704" class="i">+	}
</a><a href="#h33-0-705" id="h33-0-705" class="i">+	sort.Sort(int32Slice(ids))
</a><a href="#h33-0-706" id="h33-0-706" class="i">+	mu.Unlock()
</a><a href="#h33-0-707" id="h33-0-707" class="i">+
</a><a href="#h33-0-708" id="h33-0-708" class="i">+	for _, extNum := range ids {
</a><a href="#h33-0-709" id="h33-0-709" class="i">+		ext := m[extNum]
</a><a href="#h33-0-710" id="h33-0-710" class="i">+		var desc *ExtensionDesc
</a><a href="#h33-0-711" id="h33-0-711" class="i">+		if emap != nil {
</a><a href="#h33-0-712" id="h33-0-712" class="i">+			desc = emap[extNum]
</a><a href="#h33-0-713" id="h33-0-713" class="i">+		}
</a><a href="#h33-0-714" id="h33-0-714" class="i">+		if desc == nil {
</a><a href="#h33-0-715" id="h33-0-715" class="i">+			// Unknown extension.
</a><a href="#h33-0-716" id="h33-0-716" class="i">+			if err := writeUnknownStruct(w, ext.enc); err != nil {
</a><a href="#h33-0-717" id="h33-0-717" class="i">+				return err
</a><a href="#h33-0-718" id="h33-0-718" class="i">+			}
</a><a href="#h33-0-719" id="h33-0-719" class="i">+			continue
</a><a href="#h33-0-720" id="h33-0-720" class="i">+		}
</a><a href="#h33-0-721" id="h33-0-721" class="i">+
</a><a href="#h33-0-722" id="h33-0-722" class="i">+		pb, err := GetExtension(ep, desc)
</a><a href="#h33-0-723" id="h33-0-723" class="i">+		if err != nil {
</a><a href="#h33-0-724" id="h33-0-724" class="i">+			return fmt.Errorf(&quot;failed getting extension: %v&quot;, err)
</a><a href="#h33-0-725" id="h33-0-725" class="i">+		}
</a><a href="#h33-0-726" id="h33-0-726" class="i">+
</a><a href="#h33-0-727" id="h33-0-727" class="i">+		// Repeated extensions will appear as a slice.
</a><a href="#h33-0-728" id="h33-0-728" class="i">+		if !desc.repeated() {
</a><a href="#h33-0-729" id="h33-0-729" class="i">+			if err := tm.writeExtension(w, desc.Name, pb); err != nil {
</a><a href="#h33-0-730" id="h33-0-730" class="i">+				return err
</a><a href="#h33-0-731" id="h33-0-731" class="i">+			}
</a><a href="#h33-0-732" id="h33-0-732" class="i">+		} else {
</a><a href="#h33-0-733" id="h33-0-733" class="i">+			v := reflect.ValueOf(pb)
</a><a href="#h33-0-734" id="h33-0-734" class="i">+			for i := 0; i &lt; v.Len(); i++ {
</a><a href="#h33-0-735" id="h33-0-735" class="i">+				if err := tm.writeExtension(w, desc.Name, v.Index(i).Interface()); err != nil {
</a><a href="#h33-0-736" id="h33-0-736" class="i">+					return err
</a><a href="#h33-0-737" id="h33-0-737" class="i">+				}
</a><a href="#h33-0-738" id="h33-0-738" class="i">+			}
</a><a href="#h33-0-739" id="h33-0-739" class="i">+		}
</a><a href="#h33-0-740" id="h33-0-740" class="i">+	}
</a><a href="#h33-0-741" id="h33-0-741" class="i">+	return nil
</a><a href="#h33-0-742" id="h33-0-742" class="i">+}
</a><a href="#h33-0-743" id="h33-0-743" class="i">+
</a><a href="#h33-0-744" id="h33-0-744" class="i">+func (tm *TextMarshaler) writeExtension(w *textWriter, name string, pb interface{}) error {
</a><a href="#h33-0-745" id="h33-0-745" class="i">+	if _, err := fmt.Fprintf(w, &quot;[%s]:&quot;, name); err != nil {
</a><a href="#h33-0-746" id="h33-0-746" class="i">+		return err
</a><a href="#h33-0-747" id="h33-0-747" class="i">+	}
</a><a href="#h33-0-748" id="h33-0-748" class="i">+	if !w.compact {
</a><a href="#h33-0-749" id="h33-0-749" class="i">+		if err := w.WriteByte(&#39; &#39;); err != nil {
</a><a href="#h33-0-750" id="h33-0-750" class="i">+			return err
</a><a href="#h33-0-751" id="h33-0-751" class="i">+		}
</a><a href="#h33-0-752" id="h33-0-752" class="i">+	}
</a><a href="#h33-0-753" id="h33-0-753" class="i">+	if err := tm.writeAny(w, reflect.ValueOf(pb), nil); err != nil {
</a><a href="#h33-0-754" id="h33-0-754" class="i">+		return err
</a><a href="#h33-0-755" id="h33-0-755" class="i">+	}
</a><a href="#h33-0-756" id="h33-0-756" class="i">+	if err := w.WriteByte(&#39;\n&#39;); err != nil {
</a><a href="#h33-0-757" id="h33-0-757" class="i">+		return err
</a><a href="#h33-0-758" id="h33-0-758" class="i">+	}
</a><a href="#h33-0-759" id="h33-0-759" class="i">+	return nil
</a><a href="#h33-0-760" id="h33-0-760" class="i">+}
</a><a href="#h33-0-761" id="h33-0-761" class="i">+
</a><a href="#h33-0-762" id="h33-0-762" class="i">+func (w *textWriter) writeIndent() {
</a><a href="#h33-0-763" id="h33-0-763" class="i">+	if !w.complete {
</a><a href="#h33-0-764" id="h33-0-764" class="i">+		return
</a><a href="#h33-0-765" id="h33-0-765" class="i">+	}
</a><a href="#h33-0-766" id="h33-0-766" class="i">+	remain := w.ind * 2
</a><a href="#h33-0-767" id="h33-0-767" class="i">+	for remain &gt; 0 {
</a><a href="#h33-0-768" id="h33-0-768" class="i">+		n := remain
</a><a href="#h33-0-769" id="h33-0-769" class="i">+		if n &gt; len(spaces) {
</a><a href="#h33-0-770" id="h33-0-770" class="i">+			n = len(spaces)
</a><a href="#h33-0-771" id="h33-0-771" class="i">+		}
</a><a href="#h33-0-772" id="h33-0-772" class="i">+		w.w.Write(spaces[:n])
</a><a href="#h33-0-773" id="h33-0-773" class="i">+		remain -= n
</a><a href="#h33-0-774" id="h33-0-774" class="i">+	}
</a><a href="#h33-0-775" id="h33-0-775" class="i">+	w.complete = false
</a><a href="#h33-0-776" id="h33-0-776" class="i">+}
</a><a href="#h33-0-777" id="h33-0-777" class="i">+
</a><a href="#h33-0-778" id="h33-0-778" class="i">+// TextMarshaler is a configurable text format marshaler.
</a><a href="#h33-0-779" id="h33-0-779" class="i">+type TextMarshaler struct {
</a><a href="#h33-0-780" id="h33-0-780" class="i">+	Compact   bool // use compact text format (one line).
</a><a href="#h33-0-781" id="h33-0-781" class="i">+	ExpandAny bool // expand google.protobuf.Any messages of known types
</a><a href="#h33-0-782" id="h33-0-782" class="i">+}
</a><a href="#h33-0-783" id="h33-0-783" class="i">+
</a><a href="#h33-0-784" id="h33-0-784" class="i">+// Marshal writes a given protocol buffer in text format.
</a><a href="#h33-0-785" id="h33-0-785" class="i">+// The only errors returned are from w.
</a><a href="#h33-0-786" id="h33-0-786" class="i">+func (tm *TextMarshaler) Marshal(w io.Writer, pb Message) error {
</a><a href="#h33-0-787" id="h33-0-787" class="i">+	val := reflect.ValueOf(pb)
</a><a href="#h33-0-788" id="h33-0-788" class="i">+	if pb == nil || val.IsNil() {
</a><a href="#h33-0-789" id="h33-0-789" class="i">+		w.Write([]byte(&quot;&lt;nil&gt;&quot;))
</a><a href="#h33-0-790" id="h33-0-790" class="i">+		return nil
</a><a href="#h33-0-791" id="h33-0-791" class="i">+	}
</a><a href="#h33-0-792" id="h33-0-792" class="i">+	var bw *bufio.Writer
</a><a href="#h33-0-793" id="h33-0-793" class="i">+	ww, ok := w.(writer)
</a><a href="#h33-0-794" id="h33-0-794" class="i">+	if !ok {
</a><a href="#h33-0-795" id="h33-0-795" class="i">+		bw = bufio.NewWriter(w)
</a><a href="#h33-0-796" id="h33-0-796" class="i">+		ww = bw
</a><a href="#h33-0-797" id="h33-0-797" class="i">+	}
</a><a href="#h33-0-798" id="h33-0-798" class="i">+	aw := &amp;textWriter{
</a><a href="#h33-0-799" id="h33-0-799" class="i">+		w:        ww,
</a><a href="#h33-0-800" id="h33-0-800" class="i">+		complete: true,
</a><a href="#h33-0-801" id="h33-0-801" class="i">+		compact:  tm.Compact,
</a><a href="#h33-0-802" id="h33-0-802" class="i">+	}
</a><a href="#h33-0-803" id="h33-0-803" class="i">+
</a><a href="#h33-0-804" id="h33-0-804" class="i">+	if etm, ok := pb.(encoding.TextMarshaler); ok {
</a><a href="#h33-0-805" id="h33-0-805" class="i">+		text, err := etm.MarshalText()
</a><a href="#h33-0-806" id="h33-0-806" class="i">+		if err != nil {
</a><a href="#h33-0-807" id="h33-0-807" class="i">+			return err
</a><a href="#h33-0-808" id="h33-0-808" class="i">+		}
</a><a href="#h33-0-809" id="h33-0-809" class="i">+		if _, err = aw.Write(text); err != nil {
</a><a href="#h33-0-810" id="h33-0-810" class="i">+			return err
</a><a href="#h33-0-811" id="h33-0-811" class="i">+		}
</a><a href="#h33-0-812" id="h33-0-812" class="i">+		if bw != nil {
</a><a href="#h33-0-813" id="h33-0-813" class="i">+			return bw.Flush()
</a><a href="#h33-0-814" id="h33-0-814" class="i">+		}
</a><a href="#h33-0-815" id="h33-0-815" class="i">+		return nil
</a><a href="#h33-0-816" id="h33-0-816" class="i">+	}
</a><a href="#h33-0-817" id="h33-0-817" class="i">+	// Dereference the received pointer so we don&#39;t have outer &lt; and &gt;.
</a><a href="#h33-0-818" id="h33-0-818" class="i">+	v := reflect.Indirect(val)
</a><a href="#h33-0-819" id="h33-0-819" class="i">+	if err := tm.writeStruct(aw, v); err != nil {
</a><a href="#h33-0-820" id="h33-0-820" class="i">+		return err
</a><a href="#h33-0-821" id="h33-0-821" class="i">+	}
</a><a href="#h33-0-822" id="h33-0-822" class="i">+	if bw != nil {
</a><a href="#h33-0-823" id="h33-0-823" class="i">+		return bw.Flush()
</a><a href="#h33-0-824" id="h33-0-824" class="i">+	}
</a><a href="#h33-0-825" id="h33-0-825" class="i">+	return nil
</a><a href="#h33-0-826" id="h33-0-826" class="i">+}
</a><a href="#h33-0-827" id="h33-0-827" class="i">+
</a><a href="#h33-0-828" id="h33-0-828" class="i">+// Text is the same as Marshal, but returns the string directly.
</a><a href="#h33-0-829" id="h33-0-829" class="i">+func (tm *TextMarshaler) Text(pb Message) string {
</a><a href="#h33-0-830" id="h33-0-830" class="i">+	var buf bytes.Buffer
</a><a href="#h33-0-831" id="h33-0-831" class="i">+	tm.Marshal(&amp;buf, pb)
</a><a href="#h33-0-832" id="h33-0-832" class="i">+	return buf.String()
</a><a href="#h33-0-833" id="h33-0-833" class="i">+}
</a><a href="#h33-0-834" id="h33-0-834" class="i">+
</a><a href="#h33-0-835" id="h33-0-835" class="i">+var (
</a><a href="#h33-0-836" id="h33-0-836" class="i">+	defaultTextMarshaler = TextMarshaler{}
</a><a href="#h33-0-837" id="h33-0-837" class="i">+	compactTextMarshaler = TextMarshaler{Compact: true}
</a><a href="#h33-0-838" id="h33-0-838" class="i">+)
</a><a href="#h33-0-839" id="h33-0-839" class="i">+
</a><a href="#h33-0-840" id="h33-0-840" class="i">+// TODO: consider removing some of the Marshal functions below.
</a><a href="#h33-0-841" id="h33-0-841" class="i">+
</a><a href="#h33-0-842" id="h33-0-842" class="i">+// MarshalText writes a given protocol buffer in text format.
</a><a href="#h33-0-843" id="h33-0-843" class="i">+// The only errors returned are from w.
</a><a href="#h33-0-844" id="h33-0-844" class="i">+func MarshalText(w io.Writer, pb Message) error { return defaultTextMarshaler.Marshal(w, pb) }
</a><a href="#h33-0-845" id="h33-0-845" class="i">+
</a><a href="#h33-0-846" id="h33-0-846" class="i">+// MarshalTextString is the same as MarshalText, but returns the string directly.
</a><a href="#h33-0-847" id="h33-0-847" class="i">+func MarshalTextString(pb Message) string { return defaultTextMarshaler.Text(pb) }
</a><a href="#h33-0-848" id="h33-0-848" class="i">+
</a><a href="#h33-0-849" id="h33-0-849" class="i">+// CompactText writes a given protocol buffer in compact text format (one line).
</a><a href="#h33-0-850" id="h33-0-850" class="i">+func CompactText(w io.Writer, pb Message) error { return compactTextMarshaler.Marshal(w, pb) }
</a><a href="#h33-0-851" id="h33-0-851" class="i">+
</a><a href="#h33-0-852" id="h33-0-852" class="i">+// CompactTextString is the same as CompactText, but returns the string directly.
</a><a href="#h33-0-853" id="h33-0-853" class="i">+func CompactTextString(pb Message) string { return compactTextMarshaler.Text(pb) }
</a><b>diff --git a/<a id="h34" href="../file/vendor/github.com/golang/protobuf/proto/text_parser.go">vendor/github.com/golang/protobuf/proto/text_parser.go</a> b/<a href="../file/vendor/github.com/golang/protobuf/proto/text_parser.go">vendor/github.com/golang/protobuf/proto/text_parser.go</a></b>
<a href="#h34-0" id="h34-0" class="h">@@ -0,0 +1,891 @@
</a><a href="#h34-0-0" id="h34-0-0" class="i">+// Go support for Protocol Buffers - Google&#39;s data interchange format
</a><a href="#h34-0-1" id="h34-0-1" class="i">+//
</a><a href="#h34-0-2" id="h34-0-2" class="i">+// Copyright 2010 The Go Authors.  All rights reserved.
</a><a href="#h34-0-3" id="h34-0-3" class="i">+// https://github.com/golang/protobuf
</a><a href="#h34-0-4" id="h34-0-4" class="i">+//
</a><a href="#h34-0-5" id="h34-0-5" class="i">+// Redistribution and use in source and binary forms, with or without
</a><a href="#h34-0-6" id="h34-0-6" class="i">+// modification, are permitted provided that the following conditions are
</a><a href="#h34-0-7" id="h34-0-7" class="i">+// met:
</a><a href="#h34-0-8" id="h34-0-8" class="i">+//
</a><a href="#h34-0-9" id="h34-0-9" class="i">+//     * Redistributions of source code must retain the above copyright
</a><a href="#h34-0-10" id="h34-0-10" class="i">+// notice, this list of conditions and the following disclaimer.
</a><a href="#h34-0-11" id="h34-0-11" class="i">+//     * Redistributions in binary form must reproduce the above
</a><a href="#h34-0-12" id="h34-0-12" class="i">+// copyright notice, this list of conditions and the following disclaimer
</a><a href="#h34-0-13" id="h34-0-13" class="i">+// in the documentation and/or other materials provided with the
</a><a href="#h34-0-14" id="h34-0-14" class="i">+// distribution.
</a><a href="#h34-0-15" id="h34-0-15" class="i">+//     * Neither the name of Google Inc. nor the names of its
</a><a href="#h34-0-16" id="h34-0-16" class="i">+// contributors may be used to endorse or promote products derived from
</a><a href="#h34-0-17" id="h34-0-17" class="i">+// this software without specific prior written permission.
</a><a href="#h34-0-18" id="h34-0-18" class="i">+//
</a><a href="#h34-0-19" id="h34-0-19" class="i">+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</a><a href="#h34-0-20" id="h34-0-20" class="i">+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</a><a href="#h34-0-21" id="h34-0-21" class="i">+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</a><a href="#h34-0-22" id="h34-0-22" class="i">+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</a><a href="#h34-0-23" id="h34-0-23" class="i">+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</a><a href="#h34-0-24" id="h34-0-24" class="i">+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</a><a href="#h34-0-25" id="h34-0-25" class="i">+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</a><a href="#h34-0-26" id="h34-0-26" class="i">+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</a><a href="#h34-0-27" id="h34-0-27" class="i">+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</a><a href="#h34-0-28" id="h34-0-28" class="i">+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</a><a href="#h34-0-29" id="h34-0-29" class="i">+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</a><a href="#h34-0-30" id="h34-0-30" class="i">+
</a><a href="#h34-0-31" id="h34-0-31" class="i">+package proto
</a><a href="#h34-0-32" id="h34-0-32" class="i">+
</a><a href="#h34-0-33" id="h34-0-33" class="i">+// Functions for parsing the Text protocol buffer format.
</a><a href="#h34-0-34" id="h34-0-34" class="i">+// TODO: message sets.
</a><a href="#h34-0-35" id="h34-0-35" class="i">+
</a><a href="#h34-0-36" id="h34-0-36" class="i">+import (
</a><a href="#h34-0-37" id="h34-0-37" class="i">+	&quot;encoding&quot;
</a><a href="#h34-0-38" id="h34-0-38" class="i">+	&quot;errors&quot;
</a><a href="#h34-0-39" id="h34-0-39" class="i">+	&quot;fmt&quot;
</a><a href="#h34-0-40" id="h34-0-40" class="i">+	&quot;reflect&quot;
</a><a href="#h34-0-41" id="h34-0-41" class="i">+	&quot;strconv&quot;
</a><a href="#h34-0-42" id="h34-0-42" class="i">+	&quot;strings&quot;
</a><a href="#h34-0-43" id="h34-0-43" class="i">+	&quot;unicode/utf8&quot;
</a><a href="#h34-0-44" id="h34-0-44" class="i">+)
</a><a href="#h34-0-45" id="h34-0-45" class="i">+
</a><a href="#h34-0-46" id="h34-0-46" class="i">+// Error string emitted when deserializing Any and fields are already set
</a><a href="#h34-0-47" id="h34-0-47" class="i">+const anyRepeatedlyUnpacked = &quot;Any message unpacked multiple times, or %q already set&quot;
</a><a href="#h34-0-48" id="h34-0-48" class="i">+
</a><a href="#h34-0-49" id="h34-0-49" class="i">+type ParseError struct {
</a><a href="#h34-0-50" id="h34-0-50" class="i">+	Message string
</a><a href="#h34-0-51" id="h34-0-51" class="i">+	Line    int // 1-based line number
</a><a href="#h34-0-52" id="h34-0-52" class="i">+	Offset  int // 0-based byte offset from start of input
</a><a href="#h34-0-53" id="h34-0-53" class="i">+}
</a><a href="#h34-0-54" id="h34-0-54" class="i">+
</a><a href="#h34-0-55" id="h34-0-55" class="i">+func (p *ParseError) Error() string {
</a><a href="#h34-0-56" id="h34-0-56" class="i">+	if p.Line == 1 {
</a><a href="#h34-0-57" id="h34-0-57" class="i">+		// show offset only for first line
</a><a href="#h34-0-58" id="h34-0-58" class="i">+		return fmt.Sprintf(&quot;line 1.%d: %v&quot;, p.Offset, p.Message)
</a><a href="#h34-0-59" id="h34-0-59" class="i">+	}
</a><a href="#h34-0-60" id="h34-0-60" class="i">+	return fmt.Sprintf(&quot;line %d: %v&quot;, p.Line, p.Message)
</a><a href="#h34-0-61" id="h34-0-61" class="i">+}
</a><a href="#h34-0-62" id="h34-0-62" class="i">+
</a><a href="#h34-0-63" id="h34-0-63" class="i">+type token struct {
</a><a href="#h34-0-64" id="h34-0-64" class="i">+	value    string
</a><a href="#h34-0-65" id="h34-0-65" class="i">+	err      *ParseError
</a><a href="#h34-0-66" id="h34-0-66" class="i">+	line     int    // line number
</a><a href="#h34-0-67" id="h34-0-67" class="i">+	offset   int    // byte number from start of input, not start of line
</a><a href="#h34-0-68" id="h34-0-68" class="i">+	unquoted string // the unquoted version of value, if it was a quoted string
</a><a href="#h34-0-69" id="h34-0-69" class="i">+}
</a><a href="#h34-0-70" id="h34-0-70" class="i">+
</a><a href="#h34-0-71" id="h34-0-71" class="i">+func (t *token) String() string {
</a><a href="#h34-0-72" id="h34-0-72" class="i">+	if t.err == nil {
</a><a href="#h34-0-73" id="h34-0-73" class="i">+		return fmt.Sprintf(&quot;%q (line=%d, offset=%d)&quot;, t.value, t.line, t.offset)
</a><a href="#h34-0-74" id="h34-0-74" class="i">+	}
</a><a href="#h34-0-75" id="h34-0-75" class="i">+	return fmt.Sprintf(&quot;parse error: %v&quot;, t.err)
</a><a href="#h34-0-76" id="h34-0-76" class="i">+}
</a><a href="#h34-0-77" id="h34-0-77" class="i">+
</a><a href="#h34-0-78" id="h34-0-78" class="i">+type textParser struct {
</a><a href="#h34-0-79" id="h34-0-79" class="i">+	s            string // remaining input
</a><a href="#h34-0-80" id="h34-0-80" class="i">+	done         bool   // whether the parsing is finished (success or error)
</a><a href="#h34-0-81" id="h34-0-81" class="i">+	backed       bool   // whether back() was called
</a><a href="#h34-0-82" id="h34-0-82" class="i">+	offset, line int
</a><a href="#h34-0-83" id="h34-0-83" class="i">+	cur          token
</a><a href="#h34-0-84" id="h34-0-84" class="i">+}
</a><a href="#h34-0-85" id="h34-0-85" class="i">+
</a><a href="#h34-0-86" id="h34-0-86" class="i">+func newTextParser(s string) *textParser {
</a><a href="#h34-0-87" id="h34-0-87" class="i">+	p := new(textParser)
</a><a href="#h34-0-88" id="h34-0-88" class="i">+	p.s = s
</a><a href="#h34-0-89" id="h34-0-89" class="i">+	p.line = 1
</a><a href="#h34-0-90" id="h34-0-90" class="i">+	p.cur.line = 1
</a><a href="#h34-0-91" id="h34-0-91" class="i">+	return p
</a><a href="#h34-0-92" id="h34-0-92" class="i">+}
</a><a href="#h34-0-93" id="h34-0-93" class="i">+
</a><a href="#h34-0-94" id="h34-0-94" class="i">+func (p *textParser) errorf(format string, a ...interface{}) *ParseError {
</a><a href="#h34-0-95" id="h34-0-95" class="i">+	pe := &amp;ParseError{fmt.Sprintf(format, a...), p.cur.line, p.cur.offset}
</a><a href="#h34-0-96" id="h34-0-96" class="i">+	p.cur.err = pe
</a><a href="#h34-0-97" id="h34-0-97" class="i">+	p.done = true
</a><a href="#h34-0-98" id="h34-0-98" class="i">+	return pe
</a><a href="#h34-0-99" id="h34-0-99" class="i">+}
</a><a href="#h34-0-100" id="h34-0-100" class="i">+
</a><a href="#h34-0-101" id="h34-0-101" class="i">+// Numbers and identifiers are matched by [-+._A-Za-z0-9]
</a><a href="#h34-0-102" id="h34-0-102" class="i">+func isIdentOrNumberChar(c byte) bool {
</a><a href="#h34-0-103" id="h34-0-103" class="i">+	switch {
</a><a href="#h34-0-104" id="h34-0-104" class="i">+	case &#39;A&#39; &lt;= c &amp;&amp; c &lt;= &#39;Z&#39;, &#39;a&#39; &lt;= c &amp;&amp; c &lt;= &#39;z&#39;:
</a><a href="#h34-0-105" id="h34-0-105" class="i">+		return true
</a><a href="#h34-0-106" id="h34-0-106" class="i">+	case &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;:
</a><a href="#h34-0-107" id="h34-0-107" class="i">+		return true
</a><a href="#h34-0-108" id="h34-0-108" class="i">+	}
</a><a href="#h34-0-109" id="h34-0-109" class="i">+	switch c {
</a><a href="#h34-0-110" id="h34-0-110" class="i">+	case &#39;-&#39;, &#39;+&#39;, &#39;.&#39;, &#39;_&#39;:
</a><a href="#h34-0-111" id="h34-0-111" class="i">+		return true
</a><a href="#h34-0-112" id="h34-0-112" class="i">+	}
</a><a href="#h34-0-113" id="h34-0-113" class="i">+	return false
</a><a href="#h34-0-114" id="h34-0-114" class="i">+}
</a><a href="#h34-0-115" id="h34-0-115" class="i">+
</a><a href="#h34-0-116" id="h34-0-116" class="i">+func isWhitespace(c byte) bool {
</a><a href="#h34-0-117" id="h34-0-117" class="i">+	switch c {
</a><a href="#h34-0-118" id="h34-0-118" class="i">+	case &#39; &#39;, &#39;\t&#39;, &#39;\n&#39;, &#39;\r&#39;:
</a><a href="#h34-0-119" id="h34-0-119" class="i">+		return true
</a><a href="#h34-0-120" id="h34-0-120" class="i">+	}
</a><a href="#h34-0-121" id="h34-0-121" class="i">+	return false
</a><a href="#h34-0-122" id="h34-0-122" class="i">+}
</a><a href="#h34-0-123" id="h34-0-123" class="i">+
</a><a href="#h34-0-124" id="h34-0-124" class="i">+func isQuote(c byte) bool {
</a><a href="#h34-0-125" id="h34-0-125" class="i">+	switch c {
</a><a href="#h34-0-126" id="h34-0-126" class="i">+	case &#39;&quot;&#39;, &#39;\&#39;&#39;:
</a><a href="#h34-0-127" id="h34-0-127" class="i">+		return true
</a><a href="#h34-0-128" id="h34-0-128" class="i">+	}
</a><a href="#h34-0-129" id="h34-0-129" class="i">+	return false
</a><a href="#h34-0-130" id="h34-0-130" class="i">+}
</a><a href="#h34-0-131" id="h34-0-131" class="i">+
</a><a href="#h34-0-132" id="h34-0-132" class="i">+func (p *textParser) skipWhitespace() {
</a><a href="#h34-0-133" id="h34-0-133" class="i">+	i := 0
</a><a href="#h34-0-134" id="h34-0-134" class="i">+	for i &lt; len(p.s) &amp;&amp; (isWhitespace(p.s[i]) || p.s[i] == &#39;#&#39;) {
</a><a href="#h34-0-135" id="h34-0-135" class="i">+		if p.s[i] == &#39;#&#39; {
</a><a href="#h34-0-136" id="h34-0-136" class="i">+			// comment; skip to end of line or input
</a><a href="#h34-0-137" id="h34-0-137" class="i">+			for i &lt; len(p.s) &amp;&amp; p.s[i] != &#39;\n&#39; {
</a><a href="#h34-0-138" id="h34-0-138" class="i">+				i++
</a><a href="#h34-0-139" id="h34-0-139" class="i">+			}
</a><a href="#h34-0-140" id="h34-0-140" class="i">+			if i == len(p.s) {
</a><a href="#h34-0-141" id="h34-0-141" class="i">+				break
</a><a href="#h34-0-142" id="h34-0-142" class="i">+			}
</a><a href="#h34-0-143" id="h34-0-143" class="i">+		}
</a><a href="#h34-0-144" id="h34-0-144" class="i">+		if p.s[i] == &#39;\n&#39; {
</a><a href="#h34-0-145" id="h34-0-145" class="i">+			p.line++
</a><a href="#h34-0-146" id="h34-0-146" class="i">+		}
</a><a href="#h34-0-147" id="h34-0-147" class="i">+		i++
</a><a href="#h34-0-148" id="h34-0-148" class="i">+	}
</a><a href="#h34-0-149" id="h34-0-149" class="i">+	p.offset += i
</a><a href="#h34-0-150" id="h34-0-150" class="i">+	p.s = p.s[i:len(p.s)]
</a><a href="#h34-0-151" id="h34-0-151" class="i">+	if len(p.s) == 0 {
</a><a href="#h34-0-152" id="h34-0-152" class="i">+		p.done = true
</a><a href="#h34-0-153" id="h34-0-153" class="i">+	}
</a><a href="#h34-0-154" id="h34-0-154" class="i">+}
</a><a href="#h34-0-155" id="h34-0-155" class="i">+
</a><a href="#h34-0-156" id="h34-0-156" class="i">+func (p *textParser) advance() {
</a><a href="#h34-0-157" id="h34-0-157" class="i">+	// Skip whitespace
</a><a href="#h34-0-158" id="h34-0-158" class="i">+	p.skipWhitespace()
</a><a href="#h34-0-159" id="h34-0-159" class="i">+	if p.done {
</a><a href="#h34-0-160" id="h34-0-160" class="i">+		return
</a><a href="#h34-0-161" id="h34-0-161" class="i">+	}
</a><a href="#h34-0-162" id="h34-0-162" class="i">+
</a><a href="#h34-0-163" id="h34-0-163" class="i">+	// Start of non-whitespace
</a><a href="#h34-0-164" id="h34-0-164" class="i">+	p.cur.err = nil
</a><a href="#h34-0-165" id="h34-0-165" class="i">+	p.cur.offset, p.cur.line = p.offset, p.line
</a><a href="#h34-0-166" id="h34-0-166" class="i">+	p.cur.unquoted = &quot;&quot;
</a><a href="#h34-0-167" id="h34-0-167" class="i">+	switch p.s[0] {
</a><a href="#h34-0-168" id="h34-0-168" class="i">+	case &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;{&#39;, &#39;}&#39;, &#39;:&#39;, &#39;[&#39;, &#39;]&#39;, &#39;;&#39;, &#39;,&#39;, &#39;/&#39;:
</a><a href="#h34-0-169" id="h34-0-169" class="i">+		// Single symbol
</a><a href="#h34-0-170" id="h34-0-170" class="i">+		p.cur.value, p.s = p.s[0:1], p.s[1:len(p.s)]
</a><a href="#h34-0-171" id="h34-0-171" class="i">+	case &#39;&quot;&#39;, &#39;\&#39;&#39;:
</a><a href="#h34-0-172" id="h34-0-172" class="i">+		// Quoted string
</a><a href="#h34-0-173" id="h34-0-173" class="i">+		i := 1
</a><a href="#h34-0-174" id="h34-0-174" class="i">+		for i &lt; len(p.s) &amp;&amp; p.s[i] != p.s[0] &amp;&amp; p.s[i] != &#39;\n&#39; {
</a><a href="#h34-0-175" id="h34-0-175" class="i">+			if p.s[i] == &#39;\\&#39; &amp;&amp; i+1 &lt; len(p.s) {
</a><a href="#h34-0-176" id="h34-0-176" class="i">+				// skip escaped char
</a><a href="#h34-0-177" id="h34-0-177" class="i">+				i++
</a><a href="#h34-0-178" id="h34-0-178" class="i">+			}
</a><a href="#h34-0-179" id="h34-0-179" class="i">+			i++
</a><a href="#h34-0-180" id="h34-0-180" class="i">+		}
</a><a href="#h34-0-181" id="h34-0-181" class="i">+		if i &gt;= len(p.s) || p.s[i] != p.s[0] {
</a><a href="#h34-0-182" id="h34-0-182" class="i">+			p.errorf(&quot;unmatched quote&quot;)
</a><a href="#h34-0-183" id="h34-0-183" class="i">+			return
</a><a href="#h34-0-184" id="h34-0-184" class="i">+		}
</a><a href="#h34-0-185" id="h34-0-185" class="i">+		unq, err := unquoteC(p.s[1:i], rune(p.s[0]))
</a><a href="#h34-0-186" id="h34-0-186" class="i">+		if err != nil {
</a><a href="#h34-0-187" id="h34-0-187" class="i">+			p.errorf(&quot;invalid quoted string %s: %v&quot;, p.s[0:i+1], err)
</a><a href="#h34-0-188" id="h34-0-188" class="i">+			return
</a><a href="#h34-0-189" id="h34-0-189" class="i">+		}
</a><a href="#h34-0-190" id="h34-0-190" class="i">+		p.cur.value, p.s = p.s[0:i+1], p.s[i+1:len(p.s)]
</a><a href="#h34-0-191" id="h34-0-191" class="i">+		p.cur.unquoted = unq
</a><a href="#h34-0-192" id="h34-0-192" class="i">+	default:
</a><a href="#h34-0-193" id="h34-0-193" class="i">+		i := 0
</a><a href="#h34-0-194" id="h34-0-194" class="i">+		for i &lt; len(p.s) &amp;&amp; isIdentOrNumberChar(p.s[i]) {
</a><a href="#h34-0-195" id="h34-0-195" class="i">+			i++
</a><a href="#h34-0-196" id="h34-0-196" class="i">+		}
</a><a href="#h34-0-197" id="h34-0-197" class="i">+		if i == 0 {
</a><a href="#h34-0-198" id="h34-0-198" class="i">+			p.errorf(&quot;unexpected byte %#x&quot;, p.s[0])
</a><a href="#h34-0-199" id="h34-0-199" class="i">+			return
</a><a href="#h34-0-200" id="h34-0-200" class="i">+		}
</a><a href="#h34-0-201" id="h34-0-201" class="i">+		p.cur.value, p.s = p.s[0:i], p.s[i:len(p.s)]
</a><a href="#h34-0-202" id="h34-0-202" class="i">+	}
</a><a href="#h34-0-203" id="h34-0-203" class="i">+	p.offset += len(p.cur.value)
</a><a href="#h34-0-204" id="h34-0-204" class="i">+}
</a><a href="#h34-0-205" id="h34-0-205" class="i">+
</a><a href="#h34-0-206" id="h34-0-206" class="i">+var (
</a><a href="#h34-0-207" id="h34-0-207" class="i">+	errBadUTF8 = errors.New(&quot;proto: bad UTF-8&quot;)
</a><a href="#h34-0-208" id="h34-0-208" class="i">+	errBadHex  = errors.New(&quot;proto: bad hexadecimal&quot;)
</a><a href="#h34-0-209" id="h34-0-209" class="i">+)
</a><a href="#h34-0-210" id="h34-0-210" class="i">+
</a><a href="#h34-0-211" id="h34-0-211" class="i">+func unquoteC(s string, quote rune) (string, error) {
</a><a href="#h34-0-212" id="h34-0-212" class="i">+	// This is based on C++&#39;s tokenizer.cc.
</a><a href="#h34-0-213" id="h34-0-213" class="i">+	// Despite its name, this is *not* parsing C syntax.
</a><a href="#h34-0-214" id="h34-0-214" class="i">+	// For instance, &quot;\0&quot; is an invalid quoted string.
</a><a href="#h34-0-215" id="h34-0-215" class="i">+
</a><a href="#h34-0-216" id="h34-0-216" class="i">+	// Avoid allocation in trivial cases.
</a><a href="#h34-0-217" id="h34-0-217" class="i">+	simple := true
</a><a href="#h34-0-218" id="h34-0-218" class="i">+	for _, r := range s {
</a><a href="#h34-0-219" id="h34-0-219" class="i">+		if r == &#39;\\&#39; || r == quote {
</a><a href="#h34-0-220" id="h34-0-220" class="i">+			simple = false
</a><a href="#h34-0-221" id="h34-0-221" class="i">+			break
</a><a href="#h34-0-222" id="h34-0-222" class="i">+		}
</a><a href="#h34-0-223" id="h34-0-223" class="i">+	}
</a><a href="#h34-0-224" id="h34-0-224" class="i">+	if simple {
</a><a href="#h34-0-225" id="h34-0-225" class="i">+		return s, nil
</a><a href="#h34-0-226" id="h34-0-226" class="i">+	}
</a><a href="#h34-0-227" id="h34-0-227" class="i">+
</a><a href="#h34-0-228" id="h34-0-228" class="i">+	buf := make([]byte, 0, 3*len(s)/2)
</a><a href="#h34-0-229" id="h34-0-229" class="i">+	for len(s) &gt; 0 {
</a><a href="#h34-0-230" id="h34-0-230" class="i">+		r, n := utf8.DecodeRuneInString(s)
</a><a href="#h34-0-231" id="h34-0-231" class="i">+		if r == utf8.RuneError &amp;&amp; n == 1 {
</a><a href="#h34-0-232" id="h34-0-232" class="i">+			return &quot;&quot;, errBadUTF8
</a><a href="#h34-0-233" id="h34-0-233" class="i">+		}
</a><a href="#h34-0-234" id="h34-0-234" class="i">+		s = s[n:]
</a><a href="#h34-0-235" id="h34-0-235" class="i">+		if r != &#39;\\&#39; {
</a><a href="#h34-0-236" id="h34-0-236" class="i">+			if r &lt; utf8.RuneSelf {
</a><a href="#h34-0-237" id="h34-0-237" class="i">+				buf = append(buf, byte(r))
</a><a href="#h34-0-238" id="h34-0-238" class="i">+			} else {
</a><a href="#h34-0-239" id="h34-0-239" class="i">+				buf = append(buf, string(r)...)
</a><a href="#h34-0-240" id="h34-0-240" class="i">+			}
</a><a href="#h34-0-241" id="h34-0-241" class="i">+			continue
</a><a href="#h34-0-242" id="h34-0-242" class="i">+		}
</a><a href="#h34-0-243" id="h34-0-243" class="i">+
</a><a href="#h34-0-244" id="h34-0-244" class="i">+		ch, tail, err := unescape(s)
</a><a href="#h34-0-245" id="h34-0-245" class="i">+		if err != nil {
</a><a href="#h34-0-246" id="h34-0-246" class="i">+			return &quot;&quot;, err
</a><a href="#h34-0-247" id="h34-0-247" class="i">+		}
</a><a href="#h34-0-248" id="h34-0-248" class="i">+		buf = append(buf, ch...)
</a><a href="#h34-0-249" id="h34-0-249" class="i">+		s = tail
</a><a href="#h34-0-250" id="h34-0-250" class="i">+	}
</a><a href="#h34-0-251" id="h34-0-251" class="i">+	return string(buf), nil
</a><a href="#h34-0-252" id="h34-0-252" class="i">+}
</a><a href="#h34-0-253" id="h34-0-253" class="i">+
</a><a href="#h34-0-254" id="h34-0-254" class="i">+func unescape(s string) (ch string, tail string, err error) {
</a><a href="#h34-0-255" id="h34-0-255" class="i">+	r, n := utf8.DecodeRuneInString(s)
</a><a href="#h34-0-256" id="h34-0-256" class="i">+	if r == utf8.RuneError &amp;&amp; n == 1 {
</a><a href="#h34-0-257" id="h34-0-257" class="i">+		return &quot;&quot;, &quot;&quot;, errBadUTF8
</a><a href="#h34-0-258" id="h34-0-258" class="i">+	}
</a><a href="#h34-0-259" id="h34-0-259" class="i">+	s = s[n:]
</a><a href="#h34-0-260" id="h34-0-260" class="i">+	switch r {
</a><a href="#h34-0-261" id="h34-0-261" class="i">+	case &#39;a&#39;:
</a><a href="#h34-0-262" id="h34-0-262" class="i">+		return &quot;\a&quot;, s, nil
</a><a href="#h34-0-263" id="h34-0-263" class="i">+	case &#39;b&#39;:
</a><a href="#h34-0-264" id="h34-0-264" class="i">+		return &quot;\b&quot;, s, nil
</a><a href="#h34-0-265" id="h34-0-265" class="i">+	case &#39;f&#39;:
</a><a href="#h34-0-266" id="h34-0-266" class="i">+		return &quot;\f&quot;, s, nil
</a><a href="#h34-0-267" id="h34-0-267" class="i">+	case &#39;n&#39;:
</a><a href="#h34-0-268" id="h34-0-268" class="i">+		return &quot;\n&quot;, s, nil
</a><a href="#h34-0-269" id="h34-0-269" class="i">+	case &#39;r&#39;:
</a><a href="#h34-0-270" id="h34-0-270" class="i">+		return &quot;\r&quot;, s, nil
</a><a href="#h34-0-271" id="h34-0-271" class="i">+	case &#39;t&#39;:
</a><a href="#h34-0-272" id="h34-0-272" class="i">+		return &quot;\t&quot;, s, nil
</a><a href="#h34-0-273" id="h34-0-273" class="i">+	case &#39;v&#39;:
</a><a href="#h34-0-274" id="h34-0-274" class="i">+		return &quot;\v&quot;, s, nil
</a><a href="#h34-0-275" id="h34-0-275" class="i">+	case &#39;?&#39;:
</a><a href="#h34-0-276" id="h34-0-276" class="i">+		return &quot;?&quot;, s, nil // trigraph workaround
</a><a href="#h34-0-277" id="h34-0-277" class="i">+	case &#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;\\&#39;:
</a><a href="#h34-0-278" id="h34-0-278" class="i">+		return string(r), s, nil
</a><a href="#h34-0-279" id="h34-0-279" class="i">+	case &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;x&#39;, &#39;X&#39;:
</a><a href="#h34-0-280" id="h34-0-280" class="i">+		if len(s) &lt; 2 {
</a><a href="#h34-0-281" id="h34-0-281" class="i">+			return &quot;&quot;, &quot;&quot;, fmt.Errorf(`\%c requires 2 following digits`, r)
</a><a href="#h34-0-282" id="h34-0-282" class="i">+		}
</a><a href="#h34-0-283" id="h34-0-283" class="i">+		base := 8
</a><a href="#h34-0-284" id="h34-0-284" class="i">+		ss := s[:2]
</a><a href="#h34-0-285" id="h34-0-285" class="i">+		s = s[2:]
</a><a href="#h34-0-286" id="h34-0-286" class="i">+		if r == &#39;x&#39; || r == &#39;X&#39; {
</a><a href="#h34-0-287" id="h34-0-287" class="i">+			base = 16
</a><a href="#h34-0-288" id="h34-0-288" class="i">+		} else {
</a><a href="#h34-0-289" id="h34-0-289" class="i">+			ss = string(r) + ss
</a><a href="#h34-0-290" id="h34-0-290" class="i">+		}
</a><a href="#h34-0-291" id="h34-0-291" class="i">+		i, err := strconv.ParseUint(ss, base, 8)
</a><a href="#h34-0-292" id="h34-0-292" class="i">+		if err != nil {
</a><a href="#h34-0-293" id="h34-0-293" class="i">+			return &quot;&quot;, &quot;&quot;, err
</a><a href="#h34-0-294" id="h34-0-294" class="i">+		}
</a><a href="#h34-0-295" id="h34-0-295" class="i">+		return string([]byte{byte(i)}), s, nil
</a><a href="#h34-0-296" id="h34-0-296" class="i">+	case &#39;u&#39;, &#39;U&#39;:
</a><a href="#h34-0-297" id="h34-0-297" class="i">+		n := 4
</a><a href="#h34-0-298" id="h34-0-298" class="i">+		if r == &#39;U&#39; {
</a><a href="#h34-0-299" id="h34-0-299" class="i">+			n = 8
</a><a href="#h34-0-300" id="h34-0-300" class="i">+		}
</a><a href="#h34-0-301" id="h34-0-301" class="i">+		if len(s) &lt; n {
</a><a href="#h34-0-302" id="h34-0-302" class="i">+			return &quot;&quot;, &quot;&quot;, fmt.Errorf(`\%c requires %d digits`, r, n)
</a><a href="#h34-0-303" id="h34-0-303" class="i">+		}
</a><a href="#h34-0-304" id="h34-0-304" class="i">+
</a><a href="#h34-0-305" id="h34-0-305" class="i">+		bs := make([]byte, n/2)
</a><a href="#h34-0-306" id="h34-0-306" class="i">+		for i := 0; i &lt; n; i += 2 {
</a><a href="#h34-0-307" id="h34-0-307" class="i">+			a, ok1 := unhex(s[i])
</a><a href="#h34-0-308" id="h34-0-308" class="i">+			b, ok2 := unhex(s[i+1])
</a><a href="#h34-0-309" id="h34-0-309" class="i">+			if !ok1 || !ok2 {
</a><a href="#h34-0-310" id="h34-0-310" class="i">+				return &quot;&quot;, &quot;&quot;, errBadHex
</a><a href="#h34-0-311" id="h34-0-311" class="i">+			}
</a><a href="#h34-0-312" id="h34-0-312" class="i">+			bs[i/2] = a&lt;&lt;4 | b
</a><a href="#h34-0-313" id="h34-0-313" class="i">+		}
</a><a href="#h34-0-314" id="h34-0-314" class="i">+		s = s[n:]
</a><a href="#h34-0-315" id="h34-0-315" class="i">+		return string(bs), s, nil
</a><a href="#h34-0-316" id="h34-0-316" class="i">+	}
</a><a href="#h34-0-317" id="h34-0-317" class="i">+	return &quot;&quot;, &quot;&quot;, fmt.Errorf(`unknown escape \%c`, r)
</a><a href="#h34-0-318" id="h34-0-318" class="i">+}
</a><a href="#h34-0-319" id="h34-0-319" class="i">+
</a><a href="#h34-0-320" id="h34-0-320" class="i">+// Adapted from src/pkg/strconv/quote.go.
</a><a href="#h34-0-321" id="h34-0-321" class="i">+func unhex(b byte) (v byte, ok bool) {
</a><a href="#h34-0-322" id="h34-0-322" class="i">+	switch {
</a><a href="#h34-0-323" id="h34-0-323" class="i">+	case &#39;0&#39; &lt;= b &amp;&amp; b &lt;= &#39;9&#39;:
</a><a href="#h34-0-324" id="h34-0-324" class="i">+		return b - &#39;0&#39;, true
</a><a href="#h34-0-325" id="h34-0-325" class="i">+	case &#39;a&#39; &lt;= b &amp;&amp; b &lt;= &#39;f&#39;:
</a><a href="#h34-0-326" id="h34-0-326" class="i">+		return b - &#39;a&#39; + 10, true
</a><a href="#h34-0-327" id="h34-0-327" class="i">+	case &#39;A&#39; &lt;= b &amp;&amp; b &lt;= &#39;F&#39;:
</a><a href="#h34-0-328" id="h34-0-328" class="i">+		return b - &#39;A&#39; + 10, true
</a><a href="#h34-0-329" id="h34-0-329" class="i">+	}
</a><a href="#h34-0-330" id="h34-0-330" class="i">+	return 0, false
</a><a href="#h34-0-331" id="h34-0-331" class="i">+}
</a><a href="#h34-0-332" id="h34-0-332" class="i">+
</a><a href="#h34-0-333" id="h34-0-333" class="i">+// Back off the parser by one token. Can only be done between calls to next().
</a><a href="#h34-0-334" id="h34-0-334" class="i">+// It makes the next advance() a no-op.
</a><a href="#h34-0-335" id="h34-0-335" class="i">+func (p *textParser) back() { p.backed = true }
</a><a href="#h34-0-336" id="h34-0-336" class="i">+
</a><a href="#h34-0-337" id="h34-0-337" class="i">+// Advances the parser and returns the new current token.
</a><a href="#h34-0-338" id="h34-0-338" class="i">+func (p *textParser) next() *token {
</a><a href="#h34-0-339" id="h34-0-339" class="i">+	if p.backed || p.done {
</a><a href="#h34-0-340" id="h34-0-340" class="i">+		p.backed = false
</a><a href="#h34-0-341" id="h34-0-341" class="i">+		return &amp;p.cur
</a><a href="#h34-0-342" id="h34-0-342" class="i">+	}
</a><a href="#h34-0-343" id="h34-0-343" class="i">+	p.advance()
</a><a href="#h34-0-344" id="h34-0-344" class="i">+	if p.done {
</a><a href="#h34-0-345" id="h34-0-345" class="i">+		p.cur.value = &quot;&quot;
</a><a href="#h34-0-346" id="h34-0-346" class="i">+	} else if len(p.cur.value) &gt; 0 &amp;&amp; isQuote(p.cur.value[0]) {
</a><a href="#h34-0-347" id="h34-0-347" class="i">+		// Look for multiple quoted strings separated by whitespace,
</a><a href="#h34-0-348" id="h34-0-348" class="i">+		// and concatenate them.
</a><a href="#h34-0-349" id="h34-0-349" class="i">+		cat := p.cur
</a><a href="#h34-0-350" id="h34-0-350" class="i">+		for {
</a><a href="#h34-0-351" id="h34-0-351" class="i">+			p.skipWhitespace()
</a><a href="#h34-0-352" id="h34-0-352" class="i">+			if p.done || !isQuote(p.s[0]) {
</a><a href="#h34-0-353" id="h34-0-353" class="i">+				break
</a><a href="#h34-0-354" id="h34-0-354" class="i">+			}
</a><a href="#h34-0-355" id="h34-0-355" class="i">+			p.advance()
</a><a href="#h34-0-356" id="h34-0-356" class="i">+			if p.cur.err != nil {
</a><a href="#h34-0-357" id="h34-0-357" class="i">+				return &amp;p.cur
</a><a href="#h34-0-358" id="h34-0-358" class="i">+			}
</a><a href="#h34-0-359" id="h34-0-359" class="i">+			cat.value += &quot; &quot; + p.cur.value
</a><a href="#h34-0-360" id="h34-0-360" class="i">+			cat.unquoted += p.cur.unquoted
</a><a href="#h34-0-361" id="h34-0-361" class="i">+		}
</a><a href="#h34-0-362" id="h34-0-362" class="i">+		p.done = false // parser may have seen EOF, but we want to return cat
</a><a href="#h34-0-363" id="h34-0-363" class="i">+		p.cur = cat
</a><a href="#h34-0-364" id="h34-0-364" class="i">+	}
</a><a href="#h34-0-365" id="h34-0-365" class="i">+	return &amp;p.cur
</a><a href="#h34-0-366" id="h34-0-366" class="i">+}
</a><a href="#h34-0-367" id="h34-0-367" class="i">+
</a><a href="#h34-0-368" id="h34-0-368" class="i">+func (p *textParser) consumeToken(s string) error {
</a><a href="#h34-0-369" id="h34-0-369" class="i">+	tok := p.next()
</a><a href="#h34-0-370" id="h34-0-370" class="i">+	if tok.err != nil {
</a><a href="#h34-0-371" id="h34-0-371" class="i">+		return tok.err
</a><a href="#h34-0-372" id="h34-0-372" class="i">+	}
</a><a href="#h34-0-373" id="h34-0-373" class="i">+	if tok.value != s {
</a><a href="#h34-0-374" id="h34-0-374" class="i">+		p.back()
</a><a href="#h34-0-375" id="h34-0-375" class="i">+		return p.errorf(&quot;expected %q, found %q&quot;, s, tok.value)
</a><a href="#h34-0-376" id="h34-0-376" class="i">+	}
</a><a href="#h34-0-377" id="h34-0-377" class="i">+	return nil
</a><a href="#h34-0-378" id="h34-0-378" class="i">+}
</a><a href="#h34-0-379" id="h34-0-379" class="i">+
</a><a href="#h34-0-380" id="h34-0-380" class="i">+// Return a RequiredNotSetError indicating which required field was not set.
</a><a href="#h34-0-381" id="h34-0-381" class="i">+func (p *textParser) missingRequiredFieldError(sv reflect.Value) *RequiredNotSetError {
</a><a href="#h34-0-382" id="h34-0-382" class="i">+	st := sv.Type()
</a><a href="#h34-0-383" id="h34-0-383" class="i">+	sprops := GetProperties(st)
</a><a href="#h34-0-384" id="h34-0-384" class="i">+	for i := 0; i &lt; st.NumField(); i++ {
</a><a href="#h34-0-385" id="h34-0-385" class="i">+		if !isNil(sv.Field(i)) {
</a><a href="#h34-0-386" id="h34-0-386" class="i">+			continue
</a><a href="#h34-0-387" id="h34-0-387" class="i">+		}
</a><a href="#h34-0-388" id="h34-0-388" class="i">+
</a><a href="#h34-0-389" id="h34-0-389" class="i">+		props := sprops.Prop[i]
</a><a href="#h34-0-390" id="h34-0-390" class="i">+		if props.Required {
</a><a href="#h34-0-391" id="h34-0-391" class="i">+			return &amp;RequiredNotSetError{fmt.Sprintf(&quot;%v.%v&quot;, st, props.OrigName)}
</a><a href="#h34-0-392" id="h34-0-392" class="i">+		}
</a><a href="#h34-0-393" id="h34-0-393" class="i">+	}
</a><a href="#h34-0-394" id="h34-0-394" class="i">+	return &amp;RequiredNotSetError{fmt.Sprintf(&quot;%v.&lt;unknown field name&gt;&quot;, st)} // should not happen
</a><a href="#h34-0-395" id="h34-0-395" class="i">+}
</a><a href="#h34-0-396" id="h34-0-396" class="i">+
</a><a href="#h34-0-397" id="h34-0-397" class="i">+// Returns the index in the struct for the named field, as well as the parsed tag properties.
</a><a href="#h34-0-398" id="h34-0-398" class="i">+func structFieldByName(sprops *StructProperties, name string) (int, *Properties, bool) {
</a><a href="#h34-0-399" id="h34-0-399" class="i">+	i, ok := sprops.decoderOrigNames[name]
</a><a href="#h34-0-400" id="h34-0-400" class="i">+	if ok {
</a><a href="#h34-0-401" id="h34-0-401" class="i">+		return i, sprops.Prop[i], true
</a><a href="#h34-0-402" id="h34-0-402" class="i">+	}
</a><a href="#h34-0-403" id="h34-0-403" class="i">+	return -1, nil, false
</a><a href="#h34-0-404" id="h34-0-404" class="i">+}
</a><a href="#h34-0-405" id="h34-0-405" class="i">+
</a><a href="#h34-0-406" id="h34-0-406" class="i">+// Consume a &#39;:&#39; from the input stream (if the next token is a colon),
</a><a href="#h34-0-407" id="h34-0-407" class="i">+// returning an error if a colon is needed but not present.
</a><a href="#h34-0-408" id="h34-0-408" class="i">+func (p *textParser) checkForColon(props *Properties, typ reflect.Type) *ParseError {
</a><a href="#h34-0-409" id="h34-0-409" class="i">+	tok := p.next()
</a><a href="#h34-0-410" id="h34-0-410" class="i">+	if tok.err != nil {
</a><a href="#h34-0-411" id="h34-0-411" class="i">+		return tok.err
</a><a href="#h34-0-412" id="h34-0-412" class="i">+	}
</a><a href="#h34-0-413" id="h34-0-413" class="i">+	if tok.value != &quot;:&quot; {
</a><a href="#h34-0-414" id="h34-0-414" class="i">+		// Colon is optional when the field is a group or message.
</a><a href="#h34-0-415" id="h34-0-415" class="i">+		needColon := true
</a><a href="#h34-0-416" id="h34-0-416" class="i">+		switch props.Wire {
</a><a href="#h34-0-417" id="h34-0-417" class="i">+		case &quot;group&quot;:
</a><a href="#h34-0-418" id="h34-0-418" class="i">+			needColon = false
</a><a href="#h34-0-419" id="h34-0-419" class="i">+		case &quot;bytes&quot;:
</a><a href="#h34-0-420" id="h34-0-420" class="i">+			// A &quot;bytes&quot; field is either a message, a string, or a repeated field;
</a><a href="#h34-0-421" id="h34-0-421" class="i">+			// those three become *T, *string and []T respectively, so we can check for
</a><a href="#h34-0-422" id="h34-0-422" class="i">+			// this field being a pointer to a non-string.
</a><a href="#h34-0-423" id="h34-0-423" class="i">+			if typ.Kind() == reflect.Ptr {
</a><a href="#h34-0-424" id="h34-0-424" class="i">+				// *T or *string
</a><a href="#h34-0-425" id="h34-0-425" class="i">+				if typ.Elem().Kind() == reflect.String {
</a><a href="#h34-0-426" id="h34-0-426" class="i">+					break
</a><a href="#h34-0-427" id="h34-0-427" class="i">+				}
</a><a href="#h34-0-428" id="h34-0-428" class="i">+			} else if typ.Kind() == reflect.Slice {
</a><a href="#h34-0-429" id="h34-0-429" class="i">+				// []T or []*T
</a><a href="#h34-0-430" id="h34-0-430" class="i">+				if typ.Elem().Kind() != reflect.Ptr {
</a><a href="#h34-0-431" id="h34-0-431" class="i">+					break
</a><a href="#h34-0-432" id="h34-0-432" class="i">+				}
</a><a href="#h34-0-433" id="h34-0-433" class="i">+			} else if typ.Kind() == reflect.String {
</a><a href="#h34-0-434" id="h34-0-434" class="i">+				// The proto3 exception is for a string field,
</a><a href="#h34-0-435" id="h34-0-435" class="i">+				// which requires a colon.
</a><a href="#h34-0-436" id="h34-0-436" class="i">+				break
</a><a href="#h34-0-437" id="h34-0-437" class="i">+			}
</a><a href="#h34-0-438" id="h34-0-438" class="i">+			needColon = false
</a><a href="#h34-0-439" id="h34-0-439" class="i">+		}
</a><a href="#h34-0-440" id="h34-0-440" class="i">+		if needColon {
</a><a href="#h34-0-441" id="h34-0-441" class="i">+			return p.errorf(&quot;expected &#39;:&#39;, found %q&quot;, tok.value)
</a><a href="#h34-0-442" id="h34-0-442" class="i">+		}
</a><a href="#h34-0-443" id="h34-0-443" class="i">+		p.back()
</a><a href="#h34-0-444" id="h34-0-444" class="i">+	}
</a><a href="#h34-0-445" id="h34-0-445" class="i">+	return nil
</a><a href="#h34-0-446" id="h34-0-446" class="i">+}
</a><a href="#h34-0-447" id="h34-0-447" class="i">+
</a><a href="#h34-0-448" id="h34-0-448" class="i">+func (p *textParser) readStruct(sv reflect.Value, terminator string) error {
</a><a href="#h34-0-449" id="h34-0-449" class="i">+	st := sv.Type()
</a><a href="#h34-0-450" id="h34-0-450" class="i">+	sprops := GetProperties(st)
</a><a href="#h34-0-451" id="h34-0-451" class="i">+	reqCount := sprops.reqCount
</a><a href="#h34-0-452" id="h34-0-452" class="i">+	var reqFieldErr error
</a><a href="#h34-0-453" id="h34-0-453" class="i">+	fieldSet := make(map[string]bool)
</a><a href="#h34-0-454" id="h34-0-454" class="i">+	// A struct is a sequence of &quot;name: value&quot;, terminated by one of
</a><a href="#h34-0-455" id="h34-0-455" class="i">+	// &#39;&gt;&#39; or &#39;}&#39;, or the end of the input.  A name may also be
</a><a href="#h34-0-456" id="h34-0-456" class="i">+	// &quot;[extension]&quot; or &quot;[type/url]&quot;.
</a><a href="#h34-0-457" id="h34-0-457" class="i">+	//
</a><a href="#h34-0-458" id="h34-0-458" class="i">+	// The whole struct can also be an expanded Any message, like:
</a><a href="#h34-0-459" id="h34-0-459" class="i">+	// [type/url] &lt; ... struct contents ... &gt;
</a><a href="#h34-0-460" id="h34-0-460" class="i">+	for {
</a><a href="#h34-0-461" id="h34-0-461" class="i">+		tok := p.next()
</a><a href="#h34-0-462" id="h34-0-462" class="i">+		if tok.err != nil {
</a><a href="#h34-0-463" id="h34-0-463" class="i">+			return tok.err
</a><a href="#h34-0-464" id="h34-0-464" class="i">+		}
</a><a href="#h34-0-465" id="h34-0-465" class="i">+		if tok.value == terminator {
</a><a href="#h34-0-466" id="h34-0-466" class="i">+			break
</a><a href="#h34-0-467" id="h34-0-467" class="i">+		}
</a><a href="#h34-0-468" id="h34-0-468" class="i">+		if tok.value == &quot;[&quot; {
</a><a href="#h34-0-469" id="h34-0-469" class="i">+			// Looks like an extension or an Any.
</a><a href="#h34-0-470" id="h34-0-470" class="i">+			//
</a><a href="#h34-0-471" id="h34-0-471" class="i">+			// TODO: Check whether we need to handle
</a><a href="#h34-0-472" id="h34-0-472" class="i">+			// namespace rooted names (e.g. &quot;.something.Foo&quot;).
</a><a href="#h34-0-473" id="h34-0-473" class="i">+			extName, err := p.consumeExtName()
</a><a href="#h34-0-474" id="h34-0-474" class="i">+			if err != nil {
</a><a href="#h34-0-475" id="h34-0-475" class="i">+				return err
</a><a href="#h34-0-476" id="h34-0-476" class="i">+			}
</a><a href="#h34-0-477" id="h34-0-477" class="i">+
</a><a href="#h34-0-478" id="h34-0-478" class="i">+			if s := strings.LastIndex(extName, &quot;/&quot;); s &gt;= 0 {
</a><a href="#h34-0-479" id="h34-0-479" class="i">+				// If it contains a slash, it&#39;s an Any type URL.
</a><a href="#h34-0-480" id="h34-0-480" class="i">+				messageName := extName[s+1:]
</a><a href="#h34-0-481" id="h34-0-481" class="i">+				mt := MessageType(messageName)
</a><a href="#h34-0-482" id="h34-0-482" class="i">+				if mt == nil {
</a><a href="#h34-0-483" id="h34-0-483" class="i">+					return p.errorf(&quot;unrecognized message %q in google.protobuf.Any&quot;, messageName)
</a><a href="#h34-0-484" id="h34-0-484" class="i">+				}
</a><a href="#h34-0-485" id="h34-0-485" class="i">+				tok = p.next()
</a><a href="#h34-0-486" id="h34-0-486" class="i">+				if tok.err != nil {
</a><a href="#h34-0-487" id="h34-0-487" class="i">+					return tok.err
</a><a href="#h34-0-488" id="h34-0-488" class="i">+				}
</a><a href="#h34-0-489" id="h34-0-489" class="i">+				// consume an optional colon
</a><a href="#h34-0-490" id="h34-0-490" class="i">+				if tok.value == &quot;:&quot; {
</a><a href="#h34-0-491" id="h34-0-491" class="i">+					tok = p.next()
</a><a href="#h34-0-492" id="h34-0-492" class="i">+					if tok.err != nil {
</a><a href="#h34-0-493" id="h34-0-493" class="i">+						return tok.err
</a><a href="#h34-0-494" id="h34-0-494" class="i">+					}
</a><a href="#h34-0-495" id="h34-0-495" class="i">+				}
</a><a href="#h34-0-496" id="h34-0-496" class="i">+				var terminator string
</a><a href="#h34-0-497" id="h34-0-497" class="i">+				switch tok.value {
</a><a href="#h34-0-498" id="h34-0-498" class="i">+				case &quot;&lt;&quot;:
</a><a href="#h34-0-499" id="h34-0-499" class="i">+					terminator = &quot;&gt;&quot;
</a><a href="#h34-0-500" id="h34-0-500" class="i">+				case &quot;{&quot;:
</a><a href="#h34-0-501" id="h34-0-501" class="i">+					terminator = &quot;}&quot;
</a><a href="#h34-0-502" id="h34-0-502" class="i">+				default:
</a><a href="#h34-0-503" id="h34-0-503" class="i">+					return p.errorf(&quot;expected &#39;{&#39; or &#39;&lt;&#39;, found %q&quot;, tok.value)
</a><a href="#h34-0-504" id="h34-0-504" class="i">+				}
</a><a href="#h34-0-505" id="h34-0-505" class="i">+				v := reflect.New(mt.Elem())
</a><a href="#h34-0-506" id="h34-0-506" class="i">+				if pe := p.readStruct(v.Elem(), terminator); pe != nil {
</a><a href="#h34-0-507" id="h34-0-507" class="i">+					return pe
</a><a href="#h34-0-508" id="h34-0-508" class="i">+				}
</a><a href="#h34-0-509" id="h34-0-509" class="i">+				b, err := Marshal(v.Interface().(Message))
</a><a href="#h34-0-510" id="h34-0-510" class="i">+				if err != nil {
</a><a href="#h34-0-511" id="h34-0-511" class="i">+					return p.errorf(&quot;failed to marshal message of type %q: %v&quot;, messageName, err)
</a><a href="#h34-0-512" id="h34-0-512" class="i">+				}
</a><a href="#h34-0-513" id="h34-0-513" class="i">+				if fieldSet[&quot;type_url&quot;] {
</a><a href="#h34-0-514" id="h34-0-514" class="i">+					return p.errorf(anyRepeatedlyUnpacked, &quot;type_url&quot;)
</a><a href="#h34-0-515" id="h34-0-515" class="i">+				}
</a><a href="#h34-0-516" id="h34-0-516" class="i">+				if fieldSet[&quot;value&quot;] {
</a><a href="#h34-0-517" id="h34-0-517" class="i">+					return p.errorf(anyRepeatedlyUnpacked, &quot;value&quot;)
</a><a href="#h34-0-518" id="h34-0-518" class="i">+				}
</a><a href="#h34-0-519" id="h34-0-519" class="i">+				sv.FieldByName(&quot;TypeUrl&quot;).SetString(extName)
</a><a href="#h34-0-520" id="h34-0-520" class="i">+				sv.FieldByName(&quot;Value&quot;).SetBytes(b)
</a><a href="#h34-0-521" id="h34-0-521" class="i">+				fieldSet[&quot;type_url&quot;] = true
</a><a href="#h34-0-522" id="h34-0-522" class="i">+				fieldSet[&quot;value&quot;] = true
</a><a href="#h34-0-523" id="h34-0-523" class="i">+				continue
</a><a href="#h34-0-524" id="h34-0-524" class="i">+			}
</a><a href="#h34-0-525" id="h34-0-525" class="i">+
</a><a href="#h34-0-526" id="h34-0-526" class="i">+			var desc *ExtensionDesc
</a><a href="#h34-0-527" id="h34-0-527" class="i">+			// This could be faster, but it&#39;s functional.
</a><a href="#h34-0-528" id="h34-0-528" class="i">+			// TODO: Do something smarter than a linear scan.
</a><a href="#h34-0-529" id="h34-0-529" class="i">+			for _, d := range RegisteredExtensions(reflect.New(st).Interface().(Message)) {
</a><a href="#h34-0-530" id="h34-0-530" class="i">+				if d.Name == extName {
</a><a href="#h34-0-531" id="h34-0-531" class="i">+					desc = d
</a><a href="#h34-0-532" id="h34-0-532" class="i">+					break
</a><a href="#h34-0-533" id="h34-0-533" class="i">+				}
</a><a href="#h34-0-534" id="h34-0-534" class="i">+			}
</a><a href="#h34-0-535" id="h34-0-535" class="i">+			if desc == nil {
</a><a href="#h34-0-536" id="h34-0-536" class="i">+				return p.errorf(&quot;unrecognized extension %q&quot;, extName)
</a><a href="#h34-0-537" id="h34-0-537" class="i">+			}
</a><a href="#h34-0-538" id="h34-0-538" class="i">+
</a><a href="#h34-0-539" id="h34-0-539" class="i">+			props := &amp;Properties{}
</a><a href="#h34-0-540" id="h34-0-540" class="i">+			props.Parse(desc.Tag)
</a><a href="#h34-0-541" id="h34-0-541" class="i">+
</a><a href="#h34-0-542" id="h34-0-542" class="i">+			typ := reflect.TypeOf(desc.ExtensionType)
</a><a href="#h34-0-543" id="h34-0-543" class="i">+			if err := p.checkForColon(props, typ); err != nil {
</a><a href="#h34-0-544" id="h34-0-544" class="i">+				return err
</a><a href="#h34-0-545" id="h34-0-545" class="i">+			}
</a><a href="#h34-0-546" id="h34-0-546" class="i">+
</a><a href="#h34-0-547" id="h34-0-547" class="i">+			rep := desc.repeated()
</a><a href="#h34-0-548" id="h34-0-548" class="i">+
</a><a href="#h34-0-549" id="h34-0-549" class="i">+			// Read the extension structure, and set it in
</a><a href="#h34-0-550" id="h34-0-550" class="i">+			// the value we&#39;re constructing.
</a><a href="#h34-0-551" id="h34-0-551" class="i">+			var ext reflect.Value
</a><a href="#h34-0-552" id="h34-0-552" class="i">+			if !rep {
</a><a href="#h34-0-553" id="h34-0-553" class="i">+				ext = reflect.New(typ).Elem()
</a><a href="#h34-0-554" id="h34-0-554" class="i">+			} else {
</a><a href="#h34-0-555" id="h34-0-555" class="i">+				ext = reflect.New(typ.Elem()).Elem()
</a><a href="#h34-0-556" id="h34-0-556" class="i">+			}
</a><a href="#h34-0-557" id="h34-0-557" class="i">+			if err := p.readAny(ext, props); err != nil {
</a><a href="#h34-0-558" id="h34-0-558" class="i">+				if _, ok := err.(*RequiredNotSetError); !ok {
</a><a href="#h34-0-559" id="h34-0-559" class="i">+					return err
</a><a href="#h34-0-560" id="h34-0-560" class="i">+				}
</a><a href="#h34-0-561" id="h34-0-561" class="i">+				reqFieldErr = err
</a><a href="#h34-0-562" id="h34-0-562" class="i">+			}
</a><a href="#h34-0-563" id="h34-0-563" class="i">+			ep := sv.Addr().Interface().(Message)
</a><a href="#h34-0-564" id="h34-0-564" class="i">+			if !rep {
</a><a href="#h34-0-565" id="h34-0-565" class="i">+				SetExtension(ep, desc, ext.Interface())
</a><a href="#h34-0-566" id="h34-0-566" class="i">+			} else {
</a><a href="#h34-0-567" id="h34-0-567" class="i">+				old, err := GetExtension(ep, desc)
</a><a href="#h34-0-568" id="h34-0-568" class="i">+				var sl reflect.Value
</a><a href="#h34-0-569" id="h34-0-569" class="i">+				if err == nil {
</a><a href="#h34-0-570" id="h34-0-570" class="i">+					sl = reflect.ValueOf(old) // existing slice
</a><a href="#h34-0-571" id="h34-0-571" class="i">+				} else {
</a><a href="#h34-0-572" id="h34-0-572" class="i">+					sl = reflect.MakeSlice(typ, 0, 1)
</a><a href="#h34-0-573" id="h34-0-573" class="i">+				}
</a><a href="#h34-0-574" id="h34-0-574" class="i">+				sl = reflect.Append(sl, ext)
</a><a href="#h34-0-575" id="h34-0-575" class="i">+				SetExtension(ep, desc, sl.Interface())
</a><a href="#h34-0-576" id="h34-0-576" class="i">+			}
</a><a href="#h34-0-577" id="h34-0-577" class="i">+			if err := p.consumeOptionalSeparator(); err != nil {
</a><a href="#h34-0-578" id="h34-0-578" class="i">+				return err
</a><a href="#h34-0-579" id="h34-0-579" class="i">+			}
</a><a href="#h34-0-580" id="h34-0-580" class="i">+			continue
</a><a href="#h34-0-581" id="h34-0-581" class="i">+		}
</a><a href="#h34-0-582" id="h34-0-582" class="i">+
</a><a href="#h34-0-583" id="h34-0-583" class="i">+		// This is a normal, non-extension field.
</a><a href="#h34-0-584" id="h34-0-584" class="i">+		name := tok.value
</a><a href="#h34-0-585" id="h34-0-585" class="i">+		var dst reflect.Value
</a><a href="#h34-0-586" id="h34-0-586" class="i">+		fi, props, ok := structFieldByName(sprops, name)
</a><a href="#h34-0-587" id="h34-0-587" class="i">+		if ok {
</a><a href="#h34-0-588" id="h34-0-588" class="i">+			dst = sv.Field(fi)
</a><a href="#h34-0-589" id="h34-0-589" class="i">+		} else if oop, ok := sprops.OneofTypes[name]; ok {
</a><a href="#h34-0-590" id="h34-0-590" class="i">+			// It is a oneof.
</a><a href="#h34-0-591" id="h34-0-591" class="i">+			props = oop.Prop
</a><a href="#h34-0-592" id="h34-0-592" class="i">+			nv := reflect.New(oop.Type.Elem())
</a><a href="#h34-0-593" id="h34-0-593" class="i">+			dst = nv.Elem().Field(0)
</a><a href="#h34-0-594" id="h34-0-594" class="i">+			sv.Field(oop.Field).Set(nv)
</a><a href="#h34-0-595" id="h34-0-595" class="i">+		}
</a><a href="#h34-0-596" id="h34-0-596" class="i">+		if !dst.IsValid() {
</a><a href="#h34-0-597" id="h34-0-597" class="i">+			return p.errorf(&quot;unknown field name %q in %v&quot;, name, st)
</a><a href="#h34-0-598" id="h34-0-598" class="i">+		}
</a><a href="#h34-0-599" id="h34-0-599" class="i">+
</a><a href="#h34-0-600" id="h34-0-600" class="i">+		if dst.Kind() == reflect.Map {
</a><a href="#h34-0-601" id="h34-0-601" class="i">+			// Consume any colon.
</a><a href="#h34-0-602" id="h34-0-602" class="i">+			if err := p.checkForColon(props, dst.Type()); err != nil {
</a><a href="#h34-0-603" id="h34-0-603" class="i">+				return err
</a><a href="#h34-0-604" id="h34-0-604" class="i">+			}
</a><a href="#h34-0-605" id="h34-0-605" class="i">+
</a><a href="#h34-0-606" id="h34-0-606" class="i">+			// Construct the map if it doesn&#39;t already exist.
</a><a href="#h34-0-607" id="h34-0-607" class="i">+			if dst.IsNil() {
</a><a href="#h34-0-608" id="h34-0-608" class="i">+				dst.Set(reflect.MakeMap(dst.Type()))
</a><a href="#h34-0-609" id="h34-0-609" class="i">+			}
</a><a href="#h34-0-610" id="h34-0-610" class="i">+			key := reflect.New(dst.Type().Key()).Elem()
</a><a href="#h34-0-611" id="h34-0-611" class="i">+			val := reflect.New(dst.Type().Elem()).Elem()
</a><a href="#h34-0-612" id="h34-0-612" class="i">+
</a><a href="#h34-0-613" id="h34-0-613" class="i">+			// The map entry should be this sequence of tokens:
</a><a href="#h34-0-614" id="h34-0-614" class="i">+			//	&lt; key : KEY value : VALUE &gt;
</a><a href="#h34-0-615" id="h34-0-615" class="i">+			// However, implementations may omit key or value, and technically
</a><a href="#h34-0-616" id="h34-0-616" class="i">+			// we should support them in any order.  See b/28924776 for a time
</a><a href="#h34-0-617" id="h34-0-617" class="i">+			// this went wrong.
</a><a href="#h34-0-618" id="h34-0-618" class="i">+
</a><a href="#h34-0-619" id="h34-0-619" class="i">+			tok := p.next()
</a><a href="#h34-0-620" id="h34-0-620" class="i">+			var terminator string
</a><a href="#h34-0-621" id="h34-0-621" class="i">+			switch tok.value {
</a><a href="#h34-0-622" id="h34-0-622" class="i">+			case &quot;&lt;&quot;:
</a><a href="#h34-0-623" id="h34-0-623" class="i">+				terminator = &quot;&gt;&quot;
</a><a href="#h34-0-624" id="h34-0-624" class="i">+			case &quot;{&quot;:
</a><a href="#h34-0-625" id="h34-0-625" class="i">+				terminator = &quot;}&quot;
</a><a href="#h34-0-626" id="h34-0-626" class="i">+			default:
</a><a href="#h34-0-627" id="h34-0-627" class="i">+				return p.errorf(&quot;expected &#39;{&#39; or &#39;&lt;&#39;, found %q&quot;, tok.value)
</a><a href="#h34-0-628" id="h34-0-628" class="i">+			}
</a><a href="#h34-0-629" id="h34-0-629" class="i">+			for {
</a><a href="#h34-0-630" id="h34-0-630" class="i">+				tok := p.next()
</a><a href="#h34-0-631" id="h34-0-631" class="i">+				if tok.err != nil {
</a><a href="#h34-0-632" id="h34-0-632" class="i">+					return tok.err
</a><a href="#h34-0-633" id="h34-0-633" class="i">+				}
</a><a href="#h34-0-634" id="h34-0-634" class="i">+				if tok.value == terminator {
</a><a href="#h34-0-635" id="h34-0-635" class="i">+					break
</a><a href="#h34-0-636" id="h34-0-636" class="i">+				}
</a><a href="#h34-0-637" id="h34-0-637" class="i">+				switch tok.value {
</a><a href="#h34-0-638" id="h34-0-638" class="i">+				case &quot;key&quot;:
</a><a href="#h34-0-639" id="h34-0-639" class="i">+					if err := p.consumeToken(&quot;:&quot;); err != nil {
</a><a href="#h34-0-640" id="h34-0-640" class="i">+						return err
</a><a href="#h34-0-641" id="h34-0-641" class="i">+					}
</a><a href="#h34-0-642" id="h34-0-642" class="i">+					if err := p.readAny(key, props.mkeyprop); err != nil {
</a><a href="#h34-0-643" id="h34-0-643" class="i">+						return err
</a><a href="#h34-0-644" id="h34-0-644" class="i">+					}
</a><a href="#h34-0-645" id="h34-0-645" class="i">+					if err := p.consumeOptionalSeparator(); err != nil {
</a><a href="#h34-0-646" id="h34-0-646" class="i">+						return err
</a><a href="#h34-0-647" id="h34-0-647" class="i">+					}
</a><a href="#h34-0-648" id="h34-0-648" class="i">+				case &quot;value&quot;:
</a><a href="#h34-0-649" id="h34-0-649" class="i">+					if err := p.checkForColon(props.mvalprop, dst.Type().Elem()); err != nil {
</a><a href="#h34-0-650" id="h34-0-650" class="i">+						return err
</a><a href="#h34-0-651" id="h34-0-651" class="i">+					}
</a><a href="#h34-0-652" id="h34-0-652" class="i">+					if err := p.readAny(val, props.mvalprop); err != nil {
</a><a href="#h34-0-653" id="h34-0-653" class="i">+						return err
</a><a href="#h34-0-654" id="h34-0-654" class="i">+					}
</a><a href="#h34-0-655" id="h34-0-655" class="i">+					if err := p.consumeOptionalSeparator(); err != nil {
</a><a href="#h34-0-656" id="h34-0-656" class="i">+						return err
</a><a href="#h34-0-657" id="h34-0-657" class="i">+					}
</a><a href="#h34-0-658" id="h34-0-658" class="i">+				default:
</a><a href="#h34-0-659" id="h34-0-659" class="i">+					p.back()
</a><a href="#h34-0-660" id="h34-0-660" class="i">+					return p.errorf(`expected &quot;key&quot;, &quot;value&quot;, or %q, found %q`, terminator, tok.value)
</a><a href="#h34-0-661" id="h34-0-661" class="i">+				}
</a><a href="#h34-0-662" id="h34-0-662" class="i">+			}
</a><a href="#h34-0-663" id="h34-0-663" class="i">+
</a><a href="#h34-0-664" id="h34-0-664" class="i">+			dst.SetMapIndex(key, val)
</a><a href="#h34-0-665" id="h34-0-665" class="i">+			continue
</a><a href="#h34-0-666" id="h34-0-666" class="i">+		}
</a><a href="#h34-0-667" id="h34-0-667" class="i">+
</a><a href="#h34-0-668" id="h34-0-668" class="i">+		// Check that it&#39;s not already set if it&#39;s not a repeated field.
</a><a href="#h34-0-669" id="h34-0-669" class="i">+		if !props.Repeated &amp;&amp; fieldSet[name] {
</a><a href="#h34-0-670" id="h34-0-670" class="i">+			return p.errorf(&quot;non-repeated field %q was repeated&quot;, name)
</a><a href="#h34-0-671" id="h34-0-671" class="i">+		}
</a><a href="#h34-0-672" id="h34-0-672" class="i">+
</a><a href="#h34-0-673" id="h34-0-673" class="i">+		if err := p.checkForColon(props, dst.Type()); err != nil {
</a><a href="#h34-0-674" id="h34-0-674" class="i">+			return err
</a><a href="#h34-0-675" id="h34-0-675" class="i">+		}
</a><a href="#h34-0-676" id="h34-0-676" class="i">+
</a><a href="#h34-0-677" id="h34-0-677" class="i">+		// Parse into the field.
</a><a href="#h34-0-678" id="h34-0-678" class="i">+		fieldSet[name] = true
</a><a href="#h34-0-679" id="h34-0-679" class="i">+		if err := p.readAny(dst, props); err != nil {
</a><a href="#h34-0-680" id="h34-0-680" class="i">+			if _, ok := err.(*RequiredNotSetError); !ok {
</a><a href="#h34-0-681" id="h34-0-681" class="i">+				return err
</a><a href="#h34-0-682" id="h34-0-682" class="i">+			}
</a><a href="#h34-0-683" id="h34-0-683" class="i">+			reqFieldErr = err
</a><a href="#h34-0-684" id="h34-0-684" class="i">+		}
</a><a href="#h34-0-685" id="h34-0-685" class="i">+		if props.Required {
</a><a href="#h34-0-686" id="h34-0-686" class="i">+			reqCount--
</a><a href="#h34-0-687" id="h34-0-687" class="i">+		}
</a><a href="#h34-0-688" id="h34-0-688" class="i">+
</a><a href="#h34-0-689" id="h34-0-689" class="i">+		if err := p.consumeOptionalSeparator(); err != nil {
</a><a href="#h34-0-690" id="h34-0-690" class="i">+			return err
</a><a href="#h34-0-691" id="h34-0-691" class="i">+		}
</a><a href="#h34-0-692" id="h34-0-692" class="i">+
</a><a href="#h34-0-693" id="h34-0-693" class="i">+	}
</a><a href="#h34-0-694" id="h34-0-694" class="i">+
</a><a href="#h34-0-695" id="h34-0-695" class="i">+	if reqCount &gt; 0 {
</a><a href="#h34-0-696" id="h34-0-696" class="i">+		return p.missingRequiredFieldError(sv)
</a><a href="#h34-0-697" id="h34-0-697" class="i">+	}
</a><a href="#h34-0-698" id="h34-0-698" class="i">+	return reqFieldErr
</a><a href="#h34-0-699" id="h34-0-699" class="i">+}
</a><a href="#h34-0-700" id="h34-0-700" class="i">+
</a><a href="#h34-0-701" id="h34-0-701" class="i">+// consumeExtName consumes extension name or expanded Any type URL and the
</a><a href="#h34-0-702" id="h34-0-702" class="i">+// following &#39;]&#39;. It returns the name or URL consumed.
</a><a href="#h34-0-703" id="h34-0-703" class="i">+func (p *textParser) consumeExtName() (string, error) {
</a><a href="#h34-0-704" id="h34-0-704" class="i">+	tok := p.next()
</a><a href="#h34-0-705" id="h34-0-705" class="i">+	if tok.err != nil {
</a><a href="#h34-0-706" id="h34-0-706" class="i">+		return &quot;&quot;, tok.err
</a><a href="#h34-0-707" id="h34-0-707" class="i">+	}
</a><a href="#h34-0-708" id="h34-0-708" class="i">+
</a><a href="#h34-0-709" id="h34-0-709" class="i">+	// If extension name or type url is quoted, it&#39;s a single token.
</a><a href="#h34-0-710" id="h34-0-710" class="i">+	if len(tok.value) &gt; 2 &amp;&amp; isQuote(tok.value[0]) &amp;&amp; tok.value[len(tok.value)-1] == tok.value[0] {
</a><a href="#h34-0-711" id="h34-0-711" class="i">+		name, err := unquoteC(tok.value[1:len(tok.value)-1], rune(tok.value[0]))
</a><a href="#h34-0-712" id="h34-0-712" class="i">+		if err != nil {
</a><a href="#h34-0-713" id="h34-0-713" class="i">+			return &quot;&quot;, err
</a><a href="#h34-0-714" id="h34-0-714" class="i">+		}
</a><a href="#h34-0-715" id="h34-0-715" class="i">+		return name, p.consumeToken(&quot;]&quot;)
</a><a href="#h34-0-716" id="h34-0-716" class="i">+	}
</a><a href="#h34-0-717" id="h34-0-717" class="i">+
</a><a href="#h34-0-718" id="h34-0-718" class="i">+	// Consume everything up to &quot;]&quot;
</a><a href="#h34-0-719" id="h34-0-719" class="i">+	var parts []string
</a><a href="#h34-0-720" id="h34-0-720" class="i">+	for tok.value != &quot;]&quot; {
</a><a href="#h34-0-721" id="h34-0-721" class="i">+		parts = append(parts, tok.value)
</a><a href="#h34-0-722" id="h34-0-722" class="i">+		tok = p.next()
</a><a href="#h34-0-723" id="h34-0-723" class="i">+		if tok.err != nil {
</a><a href="#h34-0-724" id="h34-0-724" class="i">+			return &quot;&quot;, p.errorf(&quot;unrecognized type_url or extension name: %s&quot;, tok.err)
</a><a href="#h34-0-725" id="h34-0-725" class="i">+		}
</a><a href="#h34-0-726" id="h34-0-726" class="i">+	}
</a><a href="#h34-0-727" id="h34-0-727" class="i">+	return strings.Join(parts, &quot;&quot;), nil
</a><a href="#h34-0-728" id="h34-0-728" class="i">+}
</a><a href="#h34-0-729" id="h34-0-729" class="i">+
</a><a href="#h34-0-730" id="h34-0-730" class="i">+// consumeOptionalSeparator consumes an optional semicolon or comma.
</a><a href="#h34-0-731" id="h34-0-731" class="i">+// It is used in readStruct to provide backward compatibility.
</a><a href="#h34-0-732" id="h34-0-732" class="i">+func (p *textParser) consumeOptionalSeparator() error {
</a><a href="#h34-0-733" id="h34-0-733" class="i">+	tok := p.next()
</a><a href="#h34-0-734" id="h34-0-734" class="i">+	if tok.err != nil {
</a><a href="#h34-0-735" id="h34-0-735" class="i">+		return tok.err
</a><a href="#h34-0-736" id="h34-0-736" class="i">+	}
</a><a href="#h34-0-737" id="h34-0-737" class="i">+	if tok.value != &quot;;&quot; &amp;&amp; tok.value != &quot;,&quot; {
</a><a href="#h34-0-738" id="h34-0-738" class="i">+		p.back()
</a><a href="#h34-0-739" id="h34-0-739" class="i">+	}
</a><a href="#h34-0-740" id="h34-0-740" class="i">+	return nil
</a><a href="#h34-0-741" id="h34-0-741" class="i">+}
</a><a href="#h34-0-742" id="h34-0-742" class="i">+
</a><a href="#h34-0-743" id="h34-0-743" class="i">+func (p *textParser) readAny(v reflect.Value, props *Properties) error {
</a><a href="#h34-0-744" id="h34-0-744" class="i">+	tok := p.next()
</a><a href="#h34-0-745" id="h34-0-745" class="i">+	if tok.err != nil {
</a><a href="#h34-0-746" id="h34-0-746" class="i">+		return tok.err
</a><a href="#h34-0-747" id="h34-0-747" class="i">+	}
</a><a href="#h34-0-748" id="h34-0-748" class="i">+	if tok.value == &quot;&quot; {
</a><a href="#h34-0-749" id="h34-0-749" class="i">+		return p.errorf(&quot;unexpected EOF&quot;)
</a><a href="#h34-0-750" id="h34-0-750" class="i">+	}
</a><a href="#h34-0-751" id="h34-0-751" class="i">+
</a><a href="#h34-0-752" id="h34-0-752" class="i">+	switch fv := v; fv.Kind() {
</a><a href="#h34-0-753" id="h34-0-753" class="i">+	case reflect.Slice:
</a><a href="#h34-0-754" id="h34-0-754" class="i">+		at := v.Type()
</a><a href="#h34-0-755" id="h34-0-755" class="i">+		if at.Elem().Kind() == reflect.Uint8 {
</a><a href="#h34-0-756" id="h34-0-756" class="i">+			// Special case for []byte
</a><a href="#h34-0-757" id="h34-0-757" class="i">+			if tok.value[0] != &#39;&quot;&#39; &amp;&amp; tok.value[0] != &#39;\&#39;&#39; {
</a><a href="#h34-0-758" id="h34-0-758" class="i">+				// Deliberately written out here, as the error after
</a><a href="#h34-0-759" id="h34-0-759" class="i">+				// this switch statement would write &quot;invalid []byte: ...&quot;,
</a><a href="#h34-0-760" id="h34-0-760" class="i">+				// which is not as user-friendly.
</a><a href="#h34-0-761" id="h34-0-761" class="i">+				return p.errorf(&quot;invalid string: %v&quot;, tok.value)
</a><a href="#h34-0-762" id="h34-0-762" class="i">+			}
</a><a href="#h34-0-763" id="h34-0-763" class="i">+			bytes := []byte(tok.unquoted)
</a><a href="#h34-0-764" id="h34-0-764" class="i">+			fv.Set(reflect.ValueOf(bytes))
</a><a href="#h34-0-765" id="h34-0-765" class="i">+			return nil
</a><a href="#h34-0-766" id="h34-0-766" class="i">+		}
</a><a href="#h34-0-767" id="h34-0-767" class="i">+		// Repeated field.
</a><a href="#h34-0-768" id="h34-0-768" class="i">+		if tok.value == &quot;[&quot; {
</a><a href="#h34-0-769" id="h34-0-769" class="i">+			// Repeated field with list notation, like [1,2,3].
</a><a href="#h34-0-770" id="h34-0-770" class="i">+			for {
</a><a href="#h34-0-771" id="h34-0-771" class="i">+				fv.Set(reflect.Append(fv, reflect.New(at.Elem()).Elem()))
</a><a href="#h34-0-772" id="h34-0-772" class="i">+				err := p.readAny(fv.Index(fv.Len()-1), props)
</a><a href="#h34-0-773" id="h34-0-773" class="i">+				if err != nil {
</a><a href="#h34-0-774" id="h34-0-774" class="i">+					return err
</a><a href="#h34-0-775" id="h34-0-775" class="i">+				}
</a><a href="#h34-0-776" id="h34-0-776" class="i">+				tok := p.next()
</a><a href="#h34-0-777" id="h34-0-777" class="i">+				if tok.err != nil {
</a><a href="#h34-0-778" id="h34-0-778" class="i">+					return tok.err
</a><a href="#h34-0-779" id="h34-0-779" class="i">+				}
</a><a href="#h34-0-780" id="h34-0-780" class="i">+				if tok.value == &quot;]&quot; {
</a><a href="#h34-0-781" id="h34-0-781" class="i">+					break
</a><a href="#h34-0-782" id="h34-0-782" class="i">+				}
</a><a href="#h34-0-783" id="h34-0-783" class="i">+				if tok.value != &quot;,&quot; {
</a><a href="#h34-0-784" id="h34-0-784" class="i">+					return p.errorf(&quot;Expected &#39;]&#39; or &#39;,&#39; found %q&quot;, tok.value)
</a><a href="#h34-0-785" id="h34-0-785" class="i">+				}
</a><a href="#h34-0-786" id="h34-0-786" class="i">+			}
</a><a href="#h34-0-787" id="h34-0-787" class="i">+			return nil
</a><a href="#h34-0-788" id="h34-0-788" class="i">+		}
</a><a href="#h34-0-789" id="h34-0-789" class="i">+		// One value of the repeated field.
</a><a href="#h34-0-790" id="h34-0-790" class="i">+		p.back()
</a><a href="#h34-0-791" id="h34-0-791" class="i">+		fv.Set(reflect.Append(fv, reflect.New(at.Elem()).Elem()))
</a><a href="#h34-0-792" id="h34-0-792" class="i">+		return p.readAny(fv.Index(fv.Len()-1), props)
</a><a href="#h34-0-793" id="h34-0-793" class="i">+	case reflect.Bool:
</a><a href="#h34-0-794" id="h34-0-794" class="i">+		// Either &quot;true&quot;, &quot;false&quot;, 1 or 0.
</a><a href="#h34-0-795" id="h34-0-795" class="i">+		switch tok.value {
</a><a href="#h34-0-796" id="h34-0-796" class="i">+		case &quot;true&quot;, &quot;1&quot;:
</a><a href="#h34-0-797" id="h34-0-797" class="i">+			fv.SetBool(true)
</a><a href="#h34-0-798" id="h34-0-798" class="i">+			return nil
</a><a href="#h34-0-799" id="h34-0-799" class="i">+		case &quot;false&quot;, &quot;0&quot;:
</a><a href="#h34-0-800" id="h34-0-800" class="i">+			fv.SetBool(false)
</a><a href="#h34-0-801" id="h34-0-801" class="i">+			return nil
</a><a href="#h34-0-802" id="h34-0-802" class="i">+		}
</a><a href="#h34-0-803" id="h34-0-803" class="i">+	case reflect.Float32, reflect.Float64:
</a><a href="#h34-0-804" id="h34-0-804" class="i">+		v := tok.value
</a><a href="#h34-0-805" id="h34-0-805" class="i">+		// Ignore &#39;f&#39; for compatibility with output generated by C++, but don&#39;t
</a><a href="#h34-0-806" id="h34-0-806" class="i">+		// remove &#39;f&#39; when the value is &quot;-inf&quot; or &quot;inf&quot;.
</a><a href="#h34-0-807" id="h34-0-807" class="i">+		if strings.HasSuffix(v, &quot;f&quot;) &amp;&amp; tok.value != &quot;-inf&quot; &amp;&amp; tok.value != &quot;inf&quot; {
</a><a href="#h34-0-808" id="h34-0-808" class="i">+			v = v[:len(v)-1]
</a><a href="#h34-0-809" id="h34-0-809" class="i">+		}
</a><a href="#h34-0-810" id="h34-0-810" class="i">+		if f, err := strconv.ParseFloat(v, fv.Type().Bits()); err == nil {
</a><a href="#h34-0-811" id="h34-0-811" class="i">+			fv.SetFloat(f)
</a><a href="#h34-0-812" id="h34-0-812" class="i">+			return nil
</a><a href="#h34-0-813" id="h34-0-813" class="i">+		}
</a><a href="#h34-0-814" id="h34-0-814" class="i">+	case reflect.Int32:
</a><a href="#h34-0-815" id="h34-0-815" class="i">+		if x, err := strconv.ParseInt(tok.value, 0, 32); err == nil {
</a><a href="#h34-0-816" id="h34-0-816" class="i">+			fv.SetInt(x)
</a><a href="#h34-0-817" id="h34-0-817" class="i">+			return nil
</a><a href="#h34-0-818" id="h34-0-818" class="i">+		}
</a><a href="#h34-0-819" id="h34-0-819" class="i">+
</a><a href="#h34-0-820" id="h34-0-820" class="i">+		if len(props.Enum) == 0 {
</a><a href="#h34-0-821" id="h34-0-821" class="i">+			break
</a><a href="#h34-0-822" id="h34-0-822" class="i">+		}
</a><a href="#h34-0-823" id="h34-0-823" class="i">+		m, ok := enumValueMaps[props.Enum]
</a><a href="#h34-0-824" id="h34-0-824" class="i">+		if !ok {
</a><a href="#h34-0-825" id="h34-0-825" class="i">+			break
</a><a href="#h34-0-826" id="h34-0-826" class="i">+		}
</a><a href="#h34-0-827" id="h34-0-827" class="i">+		x, ok := m[tok.value]
</a><a href="#h34-0-828" id="h34-0-828" class="i">+		if !ok {
</a><a href="#h34-0-829" id="h34-0-829" class="i">+			break
</a><a href="#h34-0-830" id="h34-0-830" class="i">+		}
</a><a href="#h34-0-831" id="h34-0-831" class="i">+		fv.SetInt(int64(x))
</a><a href="#h34-0-832" id="h34-0-832" class="i">+		return nil
</a><a href="#h34-0-833" id="h34-0-833" class="i">+	case reflect.Int64:
</a><a href="#h34-0-834" id="h34-0-834" class="i">+		if x, err := strconv.ParseInt(tok.value, 0, 64); err == nil {
</a><a href="#h34-0-835" id="h34-0-835" class="i">+			fv.SetInt(x)
</a><a href="#h34-0-836" id="h34-0-836" class="i">+			return nil
</a><a href="#h34-0-837" id="h34-0-837" class="i">+		}
</a><a href="#h34-0-838" id="h34-0-838" class="i">+
</a><a href="#h34-0-839" id="h34-0-839" class="i">+	case reflect.Ptr:
</a><a href="#h34-0-840" id="h34-0-840" class="i">+		// A basic field (indirected through pointer), or a repeated message/group
</a><a href="#h34-0-841" id="h34-0-841" class="i">+		p.back()
</a><a href="#h34-0-842" id="h34-0-842" class="i">+		fv.Set(reflect.New(fv.Type().Elem()))
</a><a href="#h34-0-843" id="h34-0-843" class="i">+		return p.readAny(fv.Elem(), props)
</a><a href="#h34-0-844" id="h34-0-844" class="i">+	case reflect.String:
</a><a href="#h34-0-845" id="h34-0-845" class="i">+		if tok.value[0] == &#39;&quot;&#39; || tok.value[0] == &#39;\&#39;&#39; {
</a><a href="#h34-0-846" id="h34-0-846" class="i">+			fv.SetString(tok.unquoted)
</a><a href="#h34-0-847" id="h34-0-847" class="i">+			return nil
</a><a href="#h34-0-848" id="h34-0-848" class="i">+		}
</a><a href="#h34-0-849" id="h34-0-849" class="i">+	case reflect.Struct:
</a><a href="#h34-0-850" id="h34-0-850" class="i">+		var terminator string
</a><a href="#h34-0-851" id="h34-0-851" class="i">+		switch tok.value {
</a><a href="#h34-0-852" id="h34-0-852" class="i">+		case &quot;{&quot;:
</a><a href="#h34-0-853" id="h34-0-853" class="i">+			terminator = &quot;}&quot;
</a><a href="#h34-0-854" id="h34-0-854" class="i">+		case &quot;&lt;&quot;:
</a><a href="#h34-0-855" id="h34-0-855" class="i">+			terminator = &quot;&gt;&quot;
</a><a href="#h34-0-856" id="h34-0-856" class="i">+		default:
</a><a href="#h34-0-857" id="h34-0-857" class="i">+			return p.errorf(&quot;expected &#39;{&#39; or &#39;&lt;&#39;, found %q&quot;, tok.value)
</a><a href="#h34-0-858" id="h34-0-858" class="i">+		}
</a><a href="#h34-0-859" id="h34-0-859" class="i">+		// TODO: Handle nested messages which implement encoding.TextUnmarshaler.
</a><a href="#h34-0-860" id="h34-0-860" class="i">+		return p.readStruct(fv, terminator)
</a><a href="#h34-0-861" id="h34-0-861" class="i">+	case reflect.Uint32:
</a><a href="#h34-0-862" id="h34-0-862" class="i">+		if x, err := strconv.ParseUint(tok.value, 0, 32); err == nil {
</a><a href="#h34-0-863" id="h34-0-863" class="i">+			fv.SetUint(uint64(x))
</a><a href="#h34-0-864" id="h34-0-864" class="i">+			return nil
</a><a href="#h34-0-865" id="h34-0-865" class="i">+		}
</a><a href="#h34-0-866" id="h34-0-866" class="i">+	case reflect.Uint64:
</a><a href="#h34-0-867" id="h34-0-867" class="i">+		if x, err := strconv.ParseUint(tok.value, 0, 64); err == nil {
</a><a href="#h34-0-868" id="h34-0-868" class="i">+			fv.SetUint(x)
</a><a href="#h34-0-869" id="h34-0-869" class="i">+			return nil
</a><a href="#h34-0-870" id="h34-0-870" class="i">+		}
</a><a href="#h34-0-871" id="h34-0-871" class="i">+	}
</a><a href="#h34-0-872" id="h34-0-872" class="i">+	return p.errorf(&quot;invalid %v: %v&quot;, v.Type(), tok.value)
</a><a href="#h34-0-873" id="h34-0-873" class="i">+}
</a><a href="#h34-0-874" id="h34-0-874" class="i">+
</a><a href="#h34-0-875" id="h34-0-875" class="i">+// UnmarshalText reads a protocol buffer in Text format. UnmarshalText resets pb
</a><a href="#h34-0-876" id="h34-0-876" class="i">+// before starting to unmarshal, so any existing data in pb is always removed.
</a><a href="#h34-0-877" id="h34-0-877" class="i">+// If a required field is not set and no other error occurs,
</a><a href="#h34-0-878" id="h34-0-878" class="i">+// UnmarshalText returns *RequiredNotSetError.
</a><a href="#h34-0-879" id="h34-0-879" class="i">+func UnmarshalText(s string, pb Message) error {
</a><a href="#h34-0-880" id="h34-0-880" class="i">+	if um, ok := pb.(encoding.TextUnmarshaler); ok {
</a><a href="#h34-0-881" id="h34-0-881" class="i">+		err := um.UnmarshalText([]byte(s))
</a><a href="#h34-0-882" id="h34-0-882" class="i">+		return err
</a><a href="#h34-0-883" id="h34-0-883" class="i">+	}
</a><a href="#h34-0-884" id="h34-0-884" class="i">+	pb.Reset()
</a><a href="#h34-0-885" id="h34-0-885" class="i">+	v := reflect.ValueOf(pb)
</a><a href="#h34-0-886" id="h34-0-886" class="i">+	if pe := newTextParser(s).readStruct(v.Elem(), &quot;&quot;); pe != nil {
</a><a href="#h34-0-887" id="h34-0-887" class="i">+		return pe
</a><a href="#h34-0-888" id="h34-0-888" class="i">+	}
</a><a href="#h34-0-889" id="h34-0-889" class="i">+	return nil
</a><a href="#h34-0-890" id="h34-0-890" class="i">+}
</a><b>diff --git a/<a id="h35" href="../file/vendor/github.com/honeycombio/libhoney-go/BUILD">vendor/github.com/honeycombio/libhoney-go/BUILD</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/BUILD">vendor/github.com/honeycombio/libhoney-go/BUILD</a></b>
<a href="#h35-0" id="h35-0" class="h">@@ -0,0 +1,24 @@
</a><a href="#h35-0-0" id="h35-0-0" class="i">+
</a><a href="#h35-0-1" id="h35-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h35-0-2" id="h35-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h35-0-3" id="h35-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h35-0-4" id="h35-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h35-0-5" id="h35-0-5" class="i">+)
</a><a href="#h35-0-6" id="h35-0-6" class="i">+
</a><a href="#h35-0-7" id="h35-0-7" class="i">+go_library(
</a><a href="#h35-0-8" id="h35-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h35-0-9" id="h35-0-9" class="i">+  srcs = [
</a><a href="#h35-0-10" id="h35-0-10" class="i">+    &quot;doc.go&quot;,
</a><a href="#h35-0-11" id="h35-0-11" class="i">+    &quot;libhoney.go&quot;,
</a><a href="#h35-0-12" id="h35-0-12" class="i">+    &quot;response.go&quot;,
</a><a href="#h35-0-13" id="h35-0-13" class="i">+    &quot;test_helpers.go&quot;,
</a><a href="#h35-0-14" id="h35-0-14" class="i">+    &quot;transmission.go&quot;,
</a><a href="#h35-0-15" id="h35-0-15" class="i">+  ],
</a><a href="#h35-0-16" id="h35-0-16" class="i">+  deps = [
</a><a href="#h35-0-17" id="h35-0-17" class="i">+    &quot;//vendor/github.com/facebookgo/muster:go_default_library&quot;,
</a><a href="#h35-0-18" id="h35-0-18" class="i">+    &quot;//vendor/gopkg.in/alexcesaro/statsd.v2:go_default_library&quot;,
</a><a href="#h35-0-19" id="h35-0-19" class="i">+  ],
</a><a href="#h35-0-20" id="h35-0-20" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h35-0-21" id="h35-0-21" class="i">+)
</a><a href="#h35-0-22" id="h35-0-22" class="i">+
</a><a href="#h35-0-23" id="h35-0-23" class="i">+
</a><b>diff --git a/<a id="h36" href="../file/vendor/github.com/honeycombio/libhoney-go/CONTRIBUTORS">vendor/github.com/honeycombio/libhoney-go/CONTRIBUTORS</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/CONTRIBUTORS">vendor/github.com/honeycombio/libhoney-go/CONTRIBUTORS</a></b>
<a href="#h36-0" id="h36-0" class="h">@@ -0,0 +1,8 @@
</a><a href="#h36-0-0" id="h36-0-0" class="i">+Libhoney contributors:
</a><a href="#h36-0-1" id="h36-0-1" class="i">+
</a><a href="#h36-0-2" id="h36-0-2" class="i">+Ben Hartshorne
</a><a href="#h36-0-3" id="h36-0-3" class="i">+Charity Majors
</a><a href="#h36-0-4" id="h36-0-4" class="i">+Chris Toshok
</a><a href="#h36-0-5" id="h36-0-5" class="i">+Christine Yen
</a><a href="#h36-0-6" id="h36-0-6" class="i">+Conrad Irwin
</a><a href="#h36-0-7" id="h36-0-7" class="i">+Ian Wilkes
</a><b>diff --git a/<a id="h37" href="../file/vendor/github.com/honeycombio/libhoney-go/LICENSE">vendor/github.com/honeycombio/libhoney-go/LICENSE</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/LICENSE">vendor/github.com/honeycombio/libhoney-go/LICENSE</a></b>
<a href="#h37-0" id="h37-0" class="h">@@ -0,0 +1,201 @@
</a><a href="#h37-0-0" id="h37-0-0" class="i">+                                 Apache License
</a><a href="#h37-0-1" id="h37-0-1" class="i">+                           Version 2.0, January 2004
</a><a href="#h37-0-2" id="h37-0-2" class="i">+                        http://www.apache.org/licenses/
</a><a href="#h37-0-3" id="h37-0-3" class="i">+
</a><a href="#h37-0-4" id="h37-0-4" class="i">+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
</a><a href="#h37-0-5" id="h37-0-5" class="i">+
</a><a href="#h37-0-6" id="h37-0-6" class="i">+   1. Definitions.
</a><a href="#h37-0-7" id="h37-0-7" class="i">+
</a><a href="#h37-0-8" id="h37-0-8" class="i">+      &quot;License&quot; shall mean the terms and conditions for use, reproduction,
</a><a href="#h37-0-9" id="h37-0-9" class="i">+      and distribution as defined by Sections 1 through 9 of this document.
</a><a href="#h37-0-10" id="h37-0-10" class="i">+
</a><a href="#h37-0-11" id="h37-0-11" class="i">+      &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
</a><a href="#h37-0-12" id="h37-0-12" class="i">+      the copyright owner that is granting the License.
</a><a href="#h37-0-13" id="h37-0-13" class="i">+
</a><a href="#h37-0-14" id="h37-0-14" class="i">+      &quot;Legal Entity&quot; shall mean the union of the acting entity and all
</a><a href="#h37-0-15" id="h37-0-15" class="i">+      other entities that control, are controlled by, or are under common
</a><a href="#h37-0-16" id="h37-0-16" class="i">+      control with that entity. For the purposes of this definition,
</a><a href="#h37-0-17" id="h37-0-17" class="i">+      &quot;control&quot; means (i) the power, direct or indirect, to cause the
</a><a href="#h37-0-18" id="h37-0-18" class="i">+      direction or management of such entity, whether by contract or
</a><a href="#h37-0-19" id="h37-0-19" class="i">+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
</a><a href="#h37-0-20" id="h37-0-20" class="i">+      outstanding shares, or (iii) beneficial ownership of such entity.
</a><a href="#h37-0-21" id="h37-0-21" class="i">+
</a><a href="#h37-0-22" id="h37-0-22" class="i">+      &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
</a><a href="#h37-0-23" id="h37-0-23" class="i">+      exercising permissions granted by this License.
</a><a href="#h37-0-24" id="h37-0-24" class="i">+
</a><a href="#h37-0-25" id="h37-0-25" class="i">+      &quot;Source&quot; form shall mean the preferred form for making modifications,
</a><a href="#h37-0-26" id="h37-0-26" class="i">+      including but not limited to software source code, documentation
</a><a href="#h37-0-27" id="h37-0-27" class="i">+      source, and configuration files.
</a><a href="#h37-0-28" id="h37-0-28" class="i">+
</a><a href="#h37-0-29" id="h37-0-29" class="i">+      &quot;Object&quot; form shall mean any form resulting from mechanical
</a><a href="#h37-0-30" id="h37-0-30" class="i">+      transformation or translation of a Source form, including but
</a><a href="#h37-0-31" id="h37-0-31" class="i">+      not limited to compiled object code, generated documentation,
</a><a href="#h37-0-32" id="h37-0-32" class="i">+      and conversions to other media types.
</a><a href="#h37-0-33" id="h37-0-33" class="i">+
</a><a href="#h37-0-34" id="h37-0-34" class="i">+      &quot;Work&quot; shall mean the work of authorship, whether in Source or
</a><a href="#h37-0-35" id="h37-0-35" class="i">+      Object form, made available under the License, as indicated by a
</a><a href="#h37-0-36" id="h37-0-36" class="i">+      copyright notice that is included in or attached to the work
</a><a href="#h37-0-37" id="h37-0-37" class="i">+      (an example is provided in the Appendix below).
</a><a href="#h37-0-38" id="h37-0-38" class="i">+
</a><a href="#h37-0-39" id="h37-0-39" class="i">+      &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
</a><a href="#h37-0-40" id="h37-0-40" class="i">+      form, that is based on (or derived from) the Work and for which the
</a><a href="#h37-0-41" id="h37-0-41" class="i">+      editorial revisions, annotations, elaborations, or other modifications
</a><a href="#h37-0-42" id="h37-0-42" class="i">+      represent, as a whole, an original work of authorship. For the purposes
</a><a href="#h37-0-43" id="h37-0-43" class="i">+      of this License, Derivative Works shall not include works that remain
</a><a href="#h37-0-44" id="h37-0-44" class="i">+      separable from, or merely link (or bind by name) to the interfaces of,
</a><a href="#h37-0-45" id="h37-0-45" class="i">+      the Work and Derivative Works thereof.
</a><a href="#h37-0-46" id="h37-0-46" class="i">+
</a><a href="#h37-0-47" id="h37-0-47" class="i">+      &quot;Contribution&quot; shall mean any work of authorship, including
</a><a href="#h37-0-48" id="h37-0-48" class="i">+      the original version of the Work and any modifications or additions
</a><a href="#h37-0-49" id="h37-0-49" class="i">+      to that Work or Derivative Works thereof, that is intentionally
</a><a href="#h37-0-50" id="h37-0-50" class="i">+      submitted to Licensor for inclusion in the Work by the copyright owner
</a><a href="#h37-0-51" id="h37-0-51" class="i">+      or by an individual or Legal Entity authorized to submit on behalf of
</a><a href="#h37-0-52" id="h37-0-52" class="i">+      the copyright owner. For the purposes of this definition, &quot;submitted&quot;
</a><a href="#h37-0-53" id="h37-0-53" class="i">+      means any form of electronic, verbal, or written communication sent
</a><a href="#h37-0-54" id="h37-0-54" class="i">+      to the Licensor or its representatives, including but not limited to
</a><a href="#h37-0-55" id="h37-0-55" class="i">+      communication on electronic mailing lists, source code control systems,
</a><a href="#h37-0-56" id="h37-0-56" class="i">+      and issue tracking systems that are managed by, or on behalf of, the
</a><a href="#h37-0-57" id="h37-0-57" class="i">+      Licensor for the purpose of discussing and improving the Work, but
</a><a href="#h37-0-58" id="h37-0-58" class="i">+      excluding communication that is conspicuously marked or otherwise
</a><a href="#h37-0-59" id="h37-0-59" class="i">+      designated in writing by the copyright owner as &quot;Not a Contribution.&quot;
</a><a href="#h37-0-60" id="h37-0-60" class="i">+
</a><a href="#h37-0-61" id="h37-0-61" class="i">+      &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
</a><a href="#h37-0-62" id="h37-0-62" class="i">+      on behalf of whom a Contribution has been received by Licensor and
</a><a href="#h37-0-63" id="h37-0-63" class="i">+      subsequently incorporated within the Work.
</a><a href="#h37-0-64" id="h37-0-64" class="i">+
</a><a href="#h37-0-65" id="h37-0-65" class="i">+   2. Grant of Copyright License. Subject to the terms and conditions of
</a><a href="#h37-0-66" id="h37-0-66" class="i">+      this License, each Contributor hereby grants to You a perpetual,
</a><a href="#h37-0-67" id="h37-0-67" class="i">+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
</a><a href="#h37-0-68" id="h37-0-68" class="i">+      copyright license to reproduce, prepare Derivative Works of,
</a><a href="#h37-0-69" id="h37-0-69" class="i">+      publicly display, publicly perform, sublicense, and distribute the
</a><a href="#h37-0-70" id="h37-0-70" class="i">+      Work and such Derivative Works in Source or Object form.
</a><a href="#h37-0-71" id="h37-0-71" class="i">+
</a><a href="#h37-0-72" id="h37-0-72" class="i">+   3. Grant of Patent License. Subject to the terms and conditions of
</a><a href="#h37-0-73" id="h37-0-73" class="i">+      this License, each Contributor hereby grants to You a perpetual,
</a><a href="#h37-0-74" id="h37-0-74" class="i">+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
</a><a href="#h37-0-75" id="h37-0-75" class="i">+      (except as stated in this section) patent license to make, have made,
</a><a href="#h37-0-76" id="h37-0-76" class="i">+      use, offer to sell, sell, import, and otherwise transfer the Work,
</a><a href="#h37-0-77" id="h37-0-77" class="i">+      where such license applies only to those patent claims licensable
</a><a href="#h37-0-78" id="h37-0-78" class="i">+      by such Contributor that are necessarily infringed by their
</a><a href="#h37-0-79" id="h37-0-79" class="i">+      Contribution(s) alone or by combination of their Contribution(s)
</a><a href="#h37-0-80" id="h37-0-80" class="i">+      with the Work to which such Contribution(s) was submitted. If You
</a><a href="#h37-0-81" id="h37-0-81" class="i">+      institute patent litigation against any entity (including a
</a><a href="#h37-0-82" id="h37-0-82" class="i">+      cross-claim or counterclaim in a lawsuit) alleging that the Work
</a><a href="#h37-0-83" id="h37-0-83" class="i">+      or a Contribution incorporated within the Work constitutes direct
</a><a href="#h37-0-84" id="h37-0-84" class="i">+      or contributory patent infringement, then any patent licenses
</a><a href="#h37-0-85" id="h37-0-85" class="i">+      granted to You under this License for that Work shall terminate
</a><a href="#h37-0-86" id="h37-0-86" class="i">+      as of the date such litigation is filed.
</a><a href="#h37-0-87" id="h37-0-87" class="i">+
</a><a href="#h37-0-88" id="h37-0-88" class="i">+   4. Redistribution. You may reproduce and distribute copies of the
</a><a href="#h37-0-89" id="h37-0-89" class="i">+      Work or Derivative Works thereof in any medium, with or without
</a><a href="#h37-0-90" id="h37-0-90" class="i">+      modifications, and in Source or Object form, provided that You
</a><a href="#h37-0-91" id="h37-0-91" class="i">+      meet the following conditions:
</a><a href="#h37-0-92" id="h37-0-92" class="i">+
</a><a href="#h37-0-93" id="h37-0-93" class="i">+      (a) You must give any other recipients of the Work or
</a><a href="#h37-0-94" id="h37-0-94" class="i">+          Derivative Works a copy of this License; and
</a><a href="#h37-0-95" id="h37-0-95" class="i">+
</a><a href="#h37-0-96" id="h37-0-96" class="i">+      (b) You must cause any modified files to carry prominent notices
</a><a href="#h37-0-97" id="h37-0-97" class="i">+          stating that You changed the files; and
</a><a href="#h37-0-98" id="h37-0-98" class="i">+
</a><a href="#h37-0-99" id="h37-0-99" class="i">+      (c) You must retain, in the Source form of any Derivative Works
</a><a href="#h37-0-100" id="h37-0-100" class="i">+          that You distribute, all copyright, patent, trademark, and
</a><a href="#h37-0-101" id="h37-0-101" class="i">+          attribution notices from the Source form of the Work,
</a><a href="#h37-0-102" id="h37-0-102" class="i">+          excluding those notices that do not pertain to any part of
</a><a href="#h37-0-103" id="h37-0-103" class="i">+          the Derivative Works; and
</a><a href="#h37-0-104" id="h37-0-104" class="i">+
</a><a href="#h37-0-105" id="h37-0-105" class="i">+      (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
</a><a href="#h37-0-106" id="h37-0-106" class="i">+          distribution, then any Derivative Works that You distribute must
</a><a href="#h37-0-107" id="h37-0-107" class="i">+          include a readable copy of the attribution notices contained
</a><a href="#h37-0-108" id="h37-0-108" class="i">+          within such NOTICE file, excluding those notices that do not
</a><a href="#h37-0-109" id="h37-0-109" class="i">+          pertain to any part of the Derivative Works, in at least one
</a><a href="#h37-0-110" id="h37-0-110" class="i">+          of the following places: within a NOTICE text file distributed
</a><a href="#h37-0-111" id="h37-0-111" class="i">+          as part of the Derivative Works; within the Source form or
</a><a href="#h37-0-112" id="h37-0-112" class="i">+          documentation, if provided along with the Derivative Works; or,
</a><a href="#h37-0-113" id="h37-0-113" class="i">+          within a display generated by the Derivative Works, if and
</a><a href="#h37-0-114" id="h37-0-114" class="i">+          wherever such third-party notices normally appear. The contents
</a><a href="#h37-0-115" id="h37-0-115" class="i">+          of the NOTICE file are for informational purposes only and
</a><a href="#h37-0-116" id="h37-0-116" class="i">+          do not modify the License. You may add Your own attribution
</a><a href="#h37-0-117" id="h37-0-117" class="i">+          notices within Derivative Works that You distribute, alongside
</a><a href="#h37-0-118" id="h37-0-118" class="i">+          or as an addendum to the NOTICE text from the Work, provided
</a><a href="#h37-0-119" id="h37-0-119" class="i">+          that such additional attribution notices cannot be construed
</a><a href="#h37-0-120" id="h37-0-120" class="i">+          as modifying the License.
</a><a href="#h37-0-121" id="h37-0-121" class="i">+
</a><a href="#h37-0-122" id="h37-0-122" class="i">+      You may add Your own copyright statement to Your modifications and
</a><a href="#h37-0-123" id="h37-0-123" class="i">+      may provide additional or different license terms and conditions
</a><a href="#h37-0-124" id="h37-0-124" class="i">+      for use, reproduction, or distribution of Your modifications, or
</a><a href="#h37-0-125" id="h37-0-125" class="i">+      for any such Derivative Works as a whole, provided Your use,
</a><a href="#h37-0-126" id="h37-0-126" class="i">+      reproduction, and distribution of the Work otherwise complies with
</a><a href="#h37-0-127" id="h37-0-127" class="i">+      the conditions stated in this License.
</a><a href="#h37-0-128" id="h37-0-128" class="i">+
</a><a href="#h37-0-129" id="h37-0-129" class="i">+   5. Submission of Contributions. Unless You explicitly state otherwise,
</a><a href="#h37-0-130" id="h37-0-130" class="i">+      any Contribution intentionally submitted for inclusion in the Work
</a><a href="#h37-0-131" id="h37-0-131" class="i">+      by You to the Licensor shall be under the terms and conditions of
</a><a href="#h37-0-132" id="h37-0-132" class="i">+      this License, without any additional terms or conditions.
</a><a href="#h37-0-133" id="h37-0-133" class="i">+      Notwithstanding the above, nothing herein shall supersede or modify
</a><a href="#h37-0-134" id="h37-0-134" class="i">+      the terms of any separate license agreement you may have executed
</a><a href="#h37-0-135" id="h37-0-135" class="i">+      with Licensor regarding such Contributions.
</a><a href="#h37-0-136" id="h37-0-136" class="i">+
</a><a href="#h37-0-137" id="h37-0-137" class="i">+   6. Trademarks. This License does not grant permission to use the trade
</a><a href="#h37-0-138" id="h37-0-138" class="i">+      names, trademarks, service marks, or product names of the Licensor,
</a><a href="#h37-0-139" id="h37-0-139" class="i">+      except as required for reasonable and customary use in describing the
</a><a href="#h37-0-140" id="h37-0-140" class="i">+      origin of the Work and reproducing the content of the NOTICE file.
</a><a href="#h37-0-141" id="h37-0-141" class="i">+
</a><a href="#h37-0-142" id="h37-0-142" class="i">+   7. Disclaimer of Warranty. Unless required by applicable law or
</a><a href="#h37-0-143" id="h37-0-143" class="i">+      agreed to in writing, Licensor provides the Work (and each
</a><a href="#h37-0-144" id="h37-0-144" class="i">+      Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
</a><a href="#h37-0-145" id="h37-0-145" class="i">+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
</a><a href="#h37-0-146" id="h37-0-146" class="i">+      implied, including, without limitation, any warranties or conditions
</a><a href="#h37-0-147" id="h37-0-147" class="i">+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
</a><a href="#h37-0-148" id="h37-0-148" class="i">+      PARTICULAR PURPOSE. You are solely responsible for determining the
</a><a href="#h37-0-149" id="h37-0-149" class="i">+      appropriateness of using or redistributing the Work and assume any
</a><a href="#h37-0-150" id="h37-0-150" class="i">+      risks associated with Your exercise of permissions under this License.
</a><a href="#h37-0-151" id="h37-0-151" class="i">+
</a><a href="#h37-0-152" id="h37-0-152" class="i">+   8. Limitation of Liability. In no event and under no legal theory,
</a><a href="#h37-0-153" id="h37-0-153" class="i">+      whether in tort (including negligence), contract, or otherwise,
</a><a href="#h37-0-154" id="h37-0-154" class="i">+      unless required by applicable law (such as deliberate and grossly
</a><a href="#h37-0-155" id="h37-0-155" class="i">+      negligent acts) or agreed to in writing, shall any Contributor be
</a><a href="#h37-0-156" id="h37-0-156" class="i">+      liable to You for damages, including any direct, indirect, special,
</a><a href="#h37-0-157" id="h37-0-157" class="i">+      incidental, or consequential damages of any character arising as a
</a><a href="#h37-0-158" id="h37-0-158" class="i">+      result of this License or out of the use or inability to use the
</a><a href="#h37-0-159" id="h37-0-159" class="i">+      Work (including but not limited to damages for loss of goodwill,
</a><a href="#h37-0-160" id="h37-0-160" class="i">+      work stoppage, computer failure or malfunction, or any and all
</a><a href="#h37-0-161" id="h37-0-161" class="i">+      other commercial damages or losses), even if such Contributor
</a><a href="#h37-0-162" id="h37-0-162" class="i">+      has been advised of the possibility of such damages.
</a><a href="#h37-0-163" id="h37-0-163" class="i">+
</a><a href="#h37-0-164" id="h37-0-164" class="i">+   9. Accepting Warranty or Additional Liability. While redistributing
</a><a href="#h37-0-165" id="h37-0-165" class="i">+      the Work or Derivative Works thereof, You may choose to offer,
</a><a href="#h37-0-166" id="h37-0-166" class="i">+      and charge a fee for, acceptance of support, warranty, indemnity,
</a><a href="#h37-0-167" id="h37-0-167" class="i">+      or other liability obligations and/or rights consistent with this
</a><a href="#h37-0-168" id="h37-0-168" class="i">+      License. However, in accepting such obligations, You may act only
</a><a href="#h37-0-169" id="h37-0-169" class="i">+      on Your own behalf and on Your sole responsibility, not on behalf
</a><a href="#h37-0-170" id="h37-0-170" class="i">+      of any other Contributor, and only if You agree to indemnify,
</a><a href="#h37-0-171" id="h37-0-171" class="i">+      defend, and hold each Contributor harmless for any liability
</a><a href="#h37-0-172" id="h37-0-172" class="i">+      incurred by, or claims asserted against, such Contributor by reason
</a><a href="#h37-0-173" id="h37-0-173" class="i">+      of your accepting any such warranty or additional liability.
</a><a href="#h37-0-174" id="h37-0-174" class="i">+
</a><a href="#h37-0-175" id="h37-0-175" class="i">+   END OF TERMS AND CONDITIONS
</a><a href="#h37-0-176" id="h37-0-176" class="i">+
</a><a href="#h37-0-177" id="h37-0-177" class="i">+   APPENDIX: How to apply the Apache License to your work.
</a><a href="#h37-0-178" id="h37-0-178" class="i">+
</a><a href="#h37-0-179" id="h37-0-179" class="i">+      To apply the Apache License to your work, attach the following
</a><a href="#h37-0-180" id="h37-0-180" class="i">+      boilerplate notice, with the fields enclosed by brackets &quot;{}&quot;
</a><a href="#h37-0-181" id="h37-0-181" class="i">+      replaced with your own identifying information. (Don&#39;t include
</a><a href="#h37-0-182" id="h37-0-182" class="i">+      the brackets!)  The text should be enclosed in the appropriate
</a><a href="#h37-0-183" id="h37-0-183" class="i">+      comment syntax for the file format. We also recommend that a
</a><a href="#h37-0-184" id="h37-0-184" class="i">+      file or class name and description of purpose be included on the
</a><a href="#h37-0-185" id="h37-0-185" class="i">+      same &quot;printed page&quot; as the copyright notice for easier
</a><a href="#h37-0-186" id="h37-0-186" class="i">+      identification within third-party archives.
</a><a href="#h37-0-187" id="h37-0-187" class="i">+
</a><a href="#h37-0-188" id="h37-0-188" class="i">+   Copyright {yyyy} {name of copyright owner}
</a><a href="#h37-0-189" id="h37-0-189" class="i">+
</a><a href="#h37-0-190" id="h37-0-190" class="i">+   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</a><a href="#h37-0-191" id="h37-0-191" class="i">+   you may not use this file except in compliance with the License.
</a><a href="#h37-0-192" id="h37-0-192" class="i">+   You may obtain a copy of the License at
</a><a href="#h37-0-193" id="h37-0-193" class="i">+
</a><a href="#h37-0-194" id="h37-0-194" class="i">+       http://www.apache.org/licenses/LICENSE-2.0
</a><a href="#h37-0-195" id="h37-0-195" class="i">+
</a><a href="#h37-0-196" id="h37-0-196" class="i">+   Unless required by applicable law or agreed to in writing, software
</a><a href="#h37-0-197" id="h37-0-197" class="i">+   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</a><a href="#h37-0-198" id="h37-0-198" class="i">+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</a><a href="#h37-0-199" id="h37-0-199" class="i">+   See the License for the specific language governing permissions and
</a><a href="#h37-0-200" id="h37-0-200" class="i">+   limitations under the License.
</a><b>diff --git a/<a id="h38" href="../file/vendor/github.com/honeycombio/libhoney-go/README.md">vendor/github.com/honeycombio/libhoney-go/README.md</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/README.md">vendor/github.com/honeycombio/libhoney-go/README.md</a></b>
<a href="#h38-0" id="h38-0" class="h">@@ -0,0 +1,29 @@
</a><a href="#h38-0-0" id="h38-0-0" class="i">+A Go library for sending data to Honeycomb (http://honeycomb.io)
</a><a href="#h38-0-1" id="h38-0-1" class="i">+========================================================
</a><a href="#h38-0-2" id="h38-0-2" class="i">+
</a><a href="#h38-0-3" id="h38-0-3" class="i">+[![Build Status](https://travis-ci.org/honeycombio/libhoney-go.svg?branch=master)](https://travis-ci.org/honeycombio/libhoney-go)
</a><a href="#h38-0-4" id="h38-0-4" class="i">+
</a><a href="#h38-0-5" id="h38-0-5" class="i">+## Summary
</a><a href="#h38-0-6" id="h38-0-6" class="i">+
</a><a href="#h38-0-7" id="h38-0-7" class="i">+libhoney is written to ease the process of sending data to Honeycomb from within
</a><a href="#h38-0-8" id="h38-0-8" class="i">+your go code.
</a><a href="#h38-0-9" id="h38-0-9" class="i">+
</a><a href="#h38-0-10" id="h38-0-10" class="i">+For an overview of how to use a honeycomb library, see our documentation at
</a><a href="#h38-0-11" id="h38-0-11" class="i">+https://honeycomb.io/docs/send-data/sdks/
</a><a href="#h38-0-12" id="h38-0-12" class="i">+
</a><a href="#h38-0-13" id="h38-0-13" class="i">+For specifics on the go libhoney, check out the
</a><a href="#h38-0-14" id="h38-0-14" class="i">+[godoc](https://godoc.org/github.com/honeycombio/libhoney-go)
</a><a href="#h38-0-15" id="h38-0-15" class="i">+
</a><a href="#h38-0-16" id="h38-0-16" class="i">+## Example
</a><a href="#h38-0-17" id="h38-0-17" class="i">+
</a><a href="#h38-0-18" id="h38-0-18" class="i">+See the examples directory for sample code demonstrating how to use events,
</a><a href="#h38-0-19" id="h38-0-19" class="i">+builders, fields, and dynamic fields.
</a><a href="#h38-0-20" id="h38-0-20" class="i">+
</a><a href="#h38-0-21" id="h38-0-21" class="i">+## Contributions
</a><a href="#h38-0-22" id="h38-0-22" class="i">+
</a><a href="#h38-0-23" id="h38-0-23" class="i">+Features, bug fixes and other changes to libhoney are gladly accepted. Please
</a><a href="#h38-0-24" id="h38-0-24" class="i">+open issues or a pull request with your change. Remember to add your name to the
</a><a href="#h38-0-25" id="h38-0-25" class="i">+CONTRIBUTORS file!
</a><a href="#h38-0-26" id="h38-0-26" class="i">+
</a><a href="#h38-0-27" id="h38-0-27" class="i">+All contributions will be released under the Apache License 2.0.
</a><a href="#h38-0-28" id="h38-0-28" class="i">+
</a><b>diff --git a/<a id="h39" href="../file/vendor/github.com/honeycombio/libhoney-go/doc.go">vendor/github.com/honeycombio/libhoney-go/doc.go</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/doc.go">vendor/github.com/honeycombio/libhoney-go/doc.go</a></b>
<a href="#h39-0" id="h39-0" class="h">@@ -0,0 +1,13 @@
</a><a href="#h39-0-0" id="h39-0-0" class="i">+/*
</a><a href="#h39-0-1" id="h39-0-1" class="i">+Package libhoney is a client library for sending data to https://honeycomb.io
</a><a href="#h39-0-2" id="h39-0-2" class="i">+
</a><a href="#h39-0-3" id="h39-0-3" class="i">+Summary
</a><a href="#h39-0-4" id="h39-0-4" class="i">+
</a><a href="#h39-0-5" id="h39-0-5" class="i">+libhoney aims to make it as easy as possible to create events and send them on
</a><a href="#h39-0-6" id="h39-0-6" class="i">+into honeycomb.
</a><a href="#h39-0-7" id="h39-0-7" class="i">+
</a><a href="#h39-0-8" id="h39-0-8" class="i">+See https://docs.honeycomb.io for background on how to use this library
</a><a href="#h39-0-9" id="h39-0-9" class="i">+
</a><a href="#h39-0-10" id="h39-0-10" class="i">+Look in the examples/ directory for a complete example using libhoney.
</a><a href="#h39-0-11" id="h39-0-11" class="i">+*/
</a><a href="#h39-0-12" id="h39-0-12" class="i">+package libhoney
</a><b>diff --git a/<a id="h40" href="../file/vendor/github.com/honeycombio/libhoney-go/libhoney.go">vendor/github.com/honeycombio/libhoney-go/libhoney.go</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/libhoney.go">vendor/github.com/honeycombio/libhoney-go/libhoney.go</a></b>
<a href="#h40-0" id="h40-0" class="h">@@ -0,0 +1,528 @@
</a><a href="#h40-0-0" id="h40-0-0" class="i">+// Copyright 2016 Honeycomb, Hound Technology, Inc. All rights reserved.
</a><a href="#h40-0-1" id="h40-0-1" class="i">+// Use of this source code is governed by the Apache License 2.0
</a><a href="#h40-0-2" id="h40-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h40-0-3" id="h40-0-3" class="i">+
</a><a href="#h40-0-4" id="h40-0-4" class="i">+package libhoney
</a><a href="#h40-0-5" id="h40-0-5" class="i">+
</a><a href="#h40-0-6" id="h40-0-6" class="i">+import (
</a><a href="#h40-0-7" id="h40-0-7" class="i">+	&quot;encoding/json&quot;
</a><a href="#h40-0-8" id="h40-0-8" class="i">+	&quot;errors&quot;
</a><a href="#h40-0-9" id="h40-0-9" class="i">+	&quot;fmt&quot;
</a><a href="#h40-0-10" id="h40-0-10" class="i">+	&quot;math/rand&quot;
</a><a href="#h40-0-11" id="h40-0-11" class="i">+	&quot;reflect&quot;
</a><a href="#h40-0-12" id="h40-0-12" class="i">+	&quot;strings&quot;
</a><a href="#h40-0-13" id="h40-0-13" class="i">+	&quot;sync&quot;
</a><a href="#h40-0-14" id="h40-0-14" class="i">+	&quot;time&quot;
</a><a href="#h40-0-15" id="h40-0-15" class="i">+
</a><a href="#h40-0-16" id="h40-0-16" class="i">+	&quot;gopkg.in/alexcesaro/statsd.v2&quot;
</a><a href="#h40-0-17" id="h40-0-17" class="i">+)
</a><a href="#h40-0-18" id="h40-0-18" class="i">+
</a><a href="#h40-0-19" id="h40-0-19" class="i">+const (
</a><a href="#h40-0-20" id="h40-0-20" class="i">+	defaultSampleRate = 1
</a><a href="#h40-0-21" id="h40-0-21" class="i">+	defaultAPIHost    = &quot;https://api.honeycomb.io/&quot;
</a><a href="#h40-0-22" id="h40-0-22" class="i">+	version           = &quot;1.1.0&quot;
</a><a href="#h40-0-23" id="h40-0-23" class="i">+)
</a><a href="#h40-0-24" id="h40-0-24" class="i">+
</a><a href="#h40-0-25" id="h40-0-25" class="i">+var (
</a><a href="#h40-0-26" id="h40-0-26" class="i">+	ptrKinds = []reflect.Kind{reflect.Ptr, reflect.Slice, reflect.Map}
</a><a href="#h40-0-27" id="h40-0-27" class="i">+)
</a><a href="#h40-0-28" id="h40-0-28" class="i">+
</a><a href="#h40-0-29" id="h40-0-29" class="i">+// UserAgentAddition is a variable set at compile time via -ldflags to allow you
</a><a href="#h40-0-30" id="h40-0-30" class="i">+// to augment the &quot;User-Agent&quot; header that libhoney sends along with each event.
</a><a href="#h40-0-31" id="h40-0-31" class="i">+// The default User-Agent is &quot;libhoney-go/1.1.0&quot;. If you set this variable, its
</a><a href="#h40-0-32" id="h40-0-32" class="i">+// contents will be appended to the User-Agent string, separated by a space. The
</a><a href="#h40-0-33" id="h40-0-33" class="i">+// expected format is product-name/version, eg &quot;myapp/1.0&quot;
</a><a href="#h40-0-34" id="h40-0-34" class="i">+var UserAgentAddition string
</a><a href="#h40-0-35" id="h40-0-35" class="i">+
</a><a href="#h40-0-36" id="h40-0-36" class="i">+type Config struct {
</a><a href="#h40-0-37" id="h40-0-37" class="i">+
</a><a href="#h40-0-38" id="h40-0-38" class="i">+	// WriteKey is the Honeycomb authentication token. If it is specified during
</a><a href="#h40-0-39" id="h40-0-39" class="i">+	// libhoney initialization, it will be used as the default write key for all
</a><a href="#h40-0-40" id="h40-0-40" class="i">+	// events. If absent, write key must be explicitly set on a builder or
</a><a href="#h40-0-41" id="h40-0-41" class="i">+	// event. Find your team write key at https://ui.honeycomb.io/account
</a><a href="#h40-0-42" id="h40-0-42" class="i">+	WriteKey string
</a><a href="#h40-0-43" id="h40-0-43" class="i">+
</a><a href="#h40-0-44" id="h40-0-44" class="i">+	// Dataset is the name of the Honeycomb dataset to which to send these events.
</a><a href="#h40-0-45" id="h40-0-45" class="i">+	// If it is specified during libhoney initialization, it will be used as the
</a><a href="#h40-0-46" id="h40-0-46" class="i">+	// default dataset for all events. If absent, dataset must be explicitly set
</a><a href="#h40-0-47" id="h40-0-47" class="i">+	// on a builder or event.
</a><a href="#h40-0-48" id="h40-0-48" class="i">+	Dataset string
</a><a href="#h40-0-49" id="h40-0-49" class="i">+
</a><a href="#h40-0-50" id="h40-0-50" class="i">+	// SampleRate is the rate at which to sample this event. Default is 1,
</a><a href="#h40-0-51" id="h40-0-51" class="i">+	// meaning no sampling. If you want to send one event out of every 250 times
</a><a href="#h40-0-52" id="h40-0-52" class="i">+	// Send() is called, you would specify 250 here.
</a><a href="#h40-0-53" id="h40-0-53" class="i">+	SampleRate uint
</a><a href="#h40-0-54" id="h40-0-54" class="i">+
</a><a href="#h40-0-55" id="h40-0-55" class="i">+	// APIHost is the hostname for the Honeycomb API server to which to send this
</a><a href="#h40-0-56" id="h40-0-56" class="i">+	// event. default: https://api.honeycomb.io/
</a><a href="#h40-0-57" id="h40-0-57" class="i">+	APIHost string
</a><a href="#h40-0-58" id="h40-0-58" class="i">+
</a><a href="#h40-0-59" id="h40-0-59" class="i">+	// TODO add logger in an agnostic way
</a><a href="#h40-0-60" id="h40-0-60" class="i">+
</a><a href="#h40-0-61" id="h40-0-61" class="i">+	// BlockOnSend determines if libhoney should block or drop packets that exceed
</a><a href="#h40-0-62" id="h40-0-62" class="i">+	// the size of the send channel (set by PendingWorkCapacity). Defaults to
</a><a href="#h40-0-63" id="h40-0-63" class="i">+	// False - events overflowing the send channel will be dropped.
</a><a href="#h40-0-64" id="h40-0-64" class="i">+	BlockOnSend bool
</a><a href="#h40-0-65" id="h40-0-65" class="i">+
</a><a href="#h40-0-66" id="h40-0-66" class="i">+	// BlockOnResponse determines if libhoney should block trying to hand
</a><a href="#h40-0-67" id="h40-0-67" class="i">+	// responses back to the caller. If this is true and there is nothing reading
</a><a href="#h40-0-68" id="h40-0-68" class="i">+	// from the Responses channel, it will fill up and prevent events from being
</a><a href="#h40-0-69" id="h40-0-69" class="i">+	// sent to Honeycomb. Defaults to False - if you don&#39;t read from the Responses
</a><a href="#h40-0-70" id="h40-0-70" class="i">+	// channel it will be ok.
</a><a href="#h40-0-71" id="h40-0-71" class="i">+	BlockOnResponse bool
</a><a href="#h40-0-72" id="h40-0-72" class="i">+
</a><a href="#h40-0-73" id="h40-0-73" class="i">+	// Configuration for the underlying sender. It is safe (and recommended) to
</a><a href="#h40-0-74" id="h40-0-74" class="i">+	// leave these values at their defaults. You cannot change these values
</a><a href="#h40-0-75" id="h40-0-75" class="i">+	// after calling Init()
</a><a href="#h40-0-76" id="h40-0-76" class="i">+	MaxBatchSize         uint          // how many events to collect into a batch before sending
</a><a href="#h40-0-77" id="h40-0-77" class="i">+	SendFrequency        time.Duration // how often to send off batches
</a><a href="#h40-0-78" id="h40-0-78" class="i">+	MaxConcurrentBatches uint          // how many batches can be inflight simultaneously
</a><a href="#h40-0-79" id="h40-0-79" class="i">+	PendingWorkCapacity  uint          // how many events to allow to pile up
</a><a href="#h40-0-80" id="h40-0-80" class="i">+
</a><a href="#h40-0-81" id="h40-0-81" class="i">+}
</a><a href="#h40-0-82" id="h40-0-82" class="i">+
</a><a href="#h40-0-83" id="h40-0-83" class="i">+type Event struct {
</a><a href="#h40-0-84" id="h40-0-84" class="i">+	// WriteKey, if set, overrides whatever is found in Config
</a><a href="#h40-0-85" id="h40-0-85" class="i">+	WriteKey string
</a><a href="#h40-0-86" id="h40-0-86" class="i">+	// Dataset, if set, overrides whatever is found in Config
</a><a href="#h40-0-87" id="h40-0-87" class="i">+	Dataset string
</a><a href="#h40-0-88" id="h40-0-88" class="i">+	// SampleRate, if set, overrides whatever is found in Config
</a><a href="#h40-0-89" id="h40-0-89" class="i">+	SampleRate uint
</a><a href="#h40-0-90" id="h40-0-90" class="i">+	// APIHost, if set, overrides whatever is found in Config
</a><a href="#h40-0-91" id="h40-0-91" class="i">+	APIHost string
</a><a href="#h40-0-92" id="h40-0-92" class="i">+	// Timestamp, if set, specifies the time for this event. If unset, defaults
</a><a href="#h40-0-93" id="h40-0-93" class="i">+	// to Now()
</a><a href="#h40-0-94" id="h40-0-94" class="i">+	Timestamp time.Time
</a><a href="#h40-0-95" id="h40-0-95" class="i">+	// Metadata is a field for you to add in data that will be handed back to you
</a><a href="#h40-0-96" id="h40-0-96" class="i">+	// on the Response object read off the Responses channel. It is not sent to
</a><a href="#h40-0-97" id="h40-0-97" class="i">+	// Honeycomb with the event.
</a><a href="#h40-0-98" id="h40-0-98" class="i">+	Metadata interface{}
</a><a href="#h40-0-99" id="h40-0-99" class="i">+
</a><a href="#h40-0-100" id="h40-0-100" class="i">+	// fieldHolder contains fields (and methods) common to both events and builders
</a><a href="#h40-0-101" id="h40-0-101" class="i">+	fieldHolder
</a><a href="#h40-0-102" id="h40-0-102" class="i">+}
</a><a href="#h40-0-103" id="h40-0-103" class="i">+
</a><a href="#h40-0-104" id="h40-0-104" class="i">+type Builder struct {
</a><a href="#h40-0-105" id="h40-0-105" class="i">+	// WriteKey, if set, overrides whatever is found in Config
</a><a href="#h40-0-106" id="h40-0-106" class="i">+	WriteKey string
</a><a href="#h40-0-107" id="h40-0-107" class="i">+	// Dataset, if set, overrides whatever is found in Config
</a><a href="#h40-0-108" id="h40-0-108" class="i">+	Dataset string
</a><a href="#h40-0-109" id="h40-0-109" class="i">+	// SampleRate, if set, overrides whatever is found in Config
</a><a href="#h40-0-110" id="h40-0-110" class="i">+	SampleRate uint
</a><a href="#h40-0-111" id="h40-0-111" class="i">+	// APIHost, if set, overrides whatever is found in Config
</a><a href="#h40-0-112" id="h40-0-112" class="i">+	APIHost string
</a><a href="#h40-0-113" id="h40-0-113" class="i">+
</a><a href="#h40-0-114" id="h40-0-114" class="i">+	// fieldHolder contains fields (and methods) common to both events and builders
</a><a href="#h40-0-115" id="h40-0-115" class="i">+	fieldHolder
</a><a href="#h40-0-116" id="h40-0-116" class="i">+
</a><a href="#h40-0-117" id="h40-0-117" class="i">+	// any dynamic fields to apply to each generated event
</a><a href="#h40-0-118" id="h40-0-118" class="i">+	dynFields     []dynamicField
</a><a href="#h40-0-119" id="h40-0-119" class="i">+	dynFieldsLock sync.Mutex
</a><a href="#h40-0-120" id="h40-0-120" class="i">+}
</a><a href="#h40-0-121" id="h40-0-121" class="i">+
</a><a href="#h40-0-122" id="h40-0-122" class="i">+type fieldHolder struct {
</a><a href="#h40-0-123" id="h40-0-123" class="i">+	data map[string]interface{}
</a><a href="#h40-0-124" id="h40-0-124" class="i">+	lock sync.Mutex
</a><a href="#h40-0-125" id="h40-0-125" class="i">+}
</a><a href="#h40-0-126" id="h40-0-126" class="i">+
</a><a href="#h40-0-127" id="h40-0-127" class="i">+// globals for singleton-like behavior
</a><a href="#h40-0-128" id="h40-0-128" class="i">+var (
</a><a href="#h40-0-129" id="h40-0-129" class="i">+	tx               txClient
</a><a href="#h40-0-130" id="h40-0-130" class="i">+	responses        chan Response
</a><a href="#h40-0-131" id="h40-0-131" class="i">+	blockOnResponses bool
</a><a href="#h40-0-132" id="h40-0-132" class="i">+	sd               *statsd.Client
</a><a href="#h40-0-133" id="h40-0-133" class="i">+	globalState      *Builder
</a><a href="#h40-0-134" id="h40-0-134" class="i">+)
</a><a href="#h40-0-135" id="h40-0-135" class="i">+
</a><a href="#h40-0-136" id="h40-0-136" class="i">+type dynamicField struct {
</a><a href="#h40-0-137" id="h40-0-137" class="i">+	name string
</a><a href="#h40-0-138" id="h40-0-138" class="i">+	fn   func() interface{}
</a><a href="#h40-0-139" id="h40-0-139" class="i">+}
</a><a href="#h40-0-140" id="h40-0-140" class="i">+
</a><a href="#h40-0-141" id="h40-0-141" class="i">+// initialize a default config to protect ourselves against using unitialized
</a><a href="#h40-0-142" id="h40-0-142" class="i">+// values if someone forgets to run Init(). It&#39;s fine if things don&#39;t work
</a><a href="#h40-0-143" id="h40-0-143" class="i">+// without running Init; it&#39;s not fine if they panic.
</a><a href="#h40-0-144" id="h40-0-144" class="i">+func init() {
</a><a href="#h40-0-145" id="h40-0-145" class="i">+	// initialize global statsd client as mute to provide a working default
</a><a href="#h40-0-146" id="h40-0-146" class="i">+	sd, _ = statsd.New(statsd.Mute(true))
</a><a href="#h40-0-147" id="h40-0-147" class="i">+	globalState = &amp;Builder{
</a><a href="#h40-0-148" id="h40-0-148" class="i">+		SampleRate: 1,
</a><a href="#h40-0-149" id="h40-0-149" class="i">+		dynFields:  make([]dynamicField, 0, 0),
</a><a href="#h40-0-150" id="h40-0-150" class="i">+	}
</a><a href="#h40-0-151" id="h40-0-151" class="i">+	globalState.data = make(map[string]interface{})
</a><a href="#h40-0-152" id="h40-0-152" class="i">+}
</a><a href="#h40-0-153" id="h40-0-153" class="i">+
</a><a href="#h40-0-154" id="h40-0-154" class="i">+// Init must be called once on app initialization. All fields in the Config
</a><a href="#h40-0-155" id="h40-0-155" class="i">+// struct are optional. If WriteKey and DataSet are absent, they must be
</a><a href="#h40-0-156" id="h40-0-156" class="i">+// specified later, either on a builder or an event. WriteKey, Dataset,
</a><a href="#h40-0-157" id="h40-0-157" class="i">+// SampleRate, and APIHost can all be overridden on a per-builder or per-event
</a><a href="#h40-0-158" id="h40-0-158" class="i">+// basis.
</a><a href="#h40-0-159" id="h40-0-159" class="i">+//
</a><a href="#h40-0-160" id="h40-0-160" class="i">+// Make sure to call Close() to flush transmisison buffers.
</a><a href="#h40-0-161" id="h40-0-161" class="i">+func Init(config Config) error {
</a><a href="#h40-0-162" id="h40-0-162" class="i">+	// Default sample rate should be 1. 0 is invalid.
</a><a href="#h40-0-163" id="h40-0-163" class="i">+	if config.SampleRate == 0 {
</a><a href="#h40-0-164" id="h40-0-164" class="i">+		config.SampleRate = defaultSampleRate
</a><a href="#h40-0-165" id="h40-0-165" class="i">+	}
</a><a href="#h40-0-166" id="h40-0-166" class="i">+	if config.APIHost == &quot;&quot; {
</a><a href="#h40-0-167" id="h40-0-167" class="i">+		config.APIHost = defaultAPIHost
</a><a href="#h40-0-168" id="h40-0-168" class="i">+	}
</a><a href="#h40-0-169" id="h40-0-169" class="i">+
</a><a href="#h40-0-170" id="h40-0-170" class="i">+	sd, _ = statsd.New(statsd.Prefix(&quot;libhoney&quot;))
</a><a href="#h40-0-171" id="h40-0-171" class="i">+
</a><a href="#h40-0-172" id="h40-0-172" class="i">+	responses = make(chan Response, config.PendingWorkCapacity*2)
</a><a href="#h40-0-173" id="h40-0-173" class="i">+
</a><a href="#h40-0-174" id="h40-0-174" class="i">+	// spin up the global transmission
</a><a href="#h40-0-175" id="h40-0-175" class="i">+	tx = &amp;txDefaultClient{
</a><a href="#h40-0-176" id="h40-0-176" class="i">+		maxBatchSize:         config.MaxBatchSize,
</a><a href="#h40-0-177" id="h40-0-177" class="i">+		batchTimeout:         config.SendFrequency,
</a><a href="#h40-0-178" id="h40-0-178" class="i">+		maxConcurrentBatches: config.MaxConcurrentBatches,
</a><a href="#h40-0-179" id="h40-0-179" class="i">+		pendingWorkCapacity:  config.PendingWorkCapacity,
</a><a href="#h40-0-180" id="h40-0-180" class="i">+		blockOnSend:          config.BlockOnSend,
</a><a href="#h40-0-181" id="h40-0-181" class="i">+	}
</a><a href="#h40-0-182" id="h40-0-182" class="i">+
</a><a href="#h40-0-183" id="h40-0-183" class="i">+	if err := tx.Start(); err != nil {
</a><a href="#h40-0-184" id="h40-0-184" class="i">+		return err
</a><a href="#h40-0-185" id="h40-0-185" class="i">+	}
</a><a href="#h40-0-186" id="h40-0-186" class="i">+
</a><a href="#h40-0-187" id="h40-0-187" class="i">+	globalState = &amp;Builder{
</a><a href="#h40-0-188" id="h40-0-188" class="i">+		WriteKey:   config.WriteKey,
</a><a href="#h40-0-189" id="h40-0-189" class="i">+		Dataset:    config.Dataset,
</a><a href="#h40-0-190" id="h40-0-190" class="i">+		SampleRate: config.SampleRate,
</a><a href="#h40-0-191" id="h40-0-191" class="i">+		APIHost:    config.APIHost,
</a><a href="#h40-0-192" id="h40-0-192" class="i">+		dynFields:  make([]dynamicField, 0, 0),
</a><a href="#h40-0-193" id="h40-0-193" class="i">+	}
</a><a href="#h40-0-194" id="h40-0-194" class="i">+	globalState.data = make(map[string]interface{})
</a><a href="#h40-0-195" id="h40-0-195" class="i">+
</a><a href="#h40-0-196" id="h40-0-196" class="i">+	return nil
</a><a href="#h40-0-197" id="h40-0-197" class="i">+}
</a><a href="#h40-0-198" id="h40-0-198" class="i">+
</a><a href="#h40-0-199" id="h40-0-199" class="i">+// Close waits for all in-flight messages to be sent. You should
</a><a href="#h40-0-200" id="h40-0-200" class="i">+// call Close() before app termination.
</a><a href="#h40-0-201" id="h40-0-201" class="i">+func Close() {
</a><a href="#h40-0-202" id="h40-0-202" class="i">+	tx.Stop()
</a><a href="#h40-0-203" id="h40-0-203" class="i">+	close(responses)
</a><a href="#h40-0-204" id="h40-0-204" class="i">+}
</a><a href="#h40-0-205" id="h40-0-205" class="i">+
</a><a href="#h40-0-206" id="h40-0-206" class="i">+// SendNow is a shortcut to create an event, add data, and send the event.
</a><a href="#h40-0-207" id="h40-0-207" class="i">+func SendNow(data interface{}) error {
</a><a href="#h40-0-208" id="h40-0-208" class="i">+	ev := NewEvent()
</a><a href="#h40-0-209" id="h40-0-209" class="i">+	if err := ev.Add(data); err != nil {
</a><a href="#h40-0-210" id="h40-0-210" class="i">+		return err
</a><a href="#h40-0-211" id="h40-0-211" class="i">+	}
</a><a href="#h40-0-212" id="h40-0-212" class="i">+	if err := ev.Send(); err != nil {
</a><a href="#h40-0-213" id="h40-0-213" class="i">+		return err
</a><a href="#h40-0-214" id="h40-0-214" class="i">+	}
</a><a href="#h40-0-215" id="h40-0-215" class="i">+	return nil
</a><a href="#h40-0-216" id="h40-0-216" class="i">+}
</a><a href="#h40-0-217" id="h40-0-217" class="i">+
</a><a href="#h40-0-218" id="h40-0-218" class="i">+// Responses returns the channel from which the caller can read the responses
</a><a href="#h40-0-219" id="h40-0-219" class="i">+// to sent events
</a><a href="#h40-0-220" id="h40-0-220" class="i">+func Responses() chan Response {
</a><a href="#h40-0-221" id="h40-0-221" class="i">+	return responses
</a><a href="#h40-0-222" id="h40-0-222" class="i">+}
</a><a href="#h40-0-223" id="h40-0-223" class="i">+
</a><a href="#h40-0-224" id="h40-0-224" class="i">+// AddDynamicField takes a field name and a function that will generate values
</a><a href="#h40-0-225" id="h40-0-225" class="i">+// for that metric. The function is called once every time a NewEvent() is
</a><a href="#h40-0-226" id="h40-0-226" class="i">+// created and added as a field (with name as the key) to the newly created
</a><a href="#h40-0-227" id="h40-0-227" class="i">+// event.
</a><a href="#h40-0-228" id="h40-0-228" class="i">+func AddDynamicField(name string, fn func() interface{}) error {
</a><a href="#h40-0-229" id="h40-0-229" class="i">+	return globalState.AddDynamicField(name, fn)
</a><a href="#h40-0-230" id="h40-0-230" class="i">+}
</a><a href="#h40-0-231" id="h40-0-231" class="i">+
</a><a href="#h40-0-232" id="h40-0-232" class="i">+// AddField adds a Field to the global scope. This metric will be inherited by
</a><a href="#h40-0-233" id="h40-0-233" class="i">+// all builders and events.
</a><a href="#h40-0-234" id="h40-0-234" class="i">+func AddField(name string, val interface{}) {
</a><a href="#h40-0-235" id="h40-0-235" class="i">+	globalState.AddField(name, val)
</a><a href="#h40-0-236" id="h40-0-236" class="i">+}
</a><a href="#h40-0-237" id="h40-0-237" class="i">+
</a><a href="#h40-0-238" id="h40-0-238" class="i">+// Add adds its data to the global scope. It adds all fields in a struct or all
</a><a href="#h40-0-239" id="h40-0-239" class="i">+// keys in a map as individual Fields. These metrics will be inherited by all
</a><a href="#h40-0-240" id="h40-0-240" class="i">+// builders and events.
</a><a href="#h40-0-241" id="h40-0-241" class="i">+func Add(data interface{}) error {
</a><a href="#h40-0-242" id="h40-0-242" class="i">+	return globalState.Add(data)
</a><a href="#h40-0-243" id="h40-0-243" class="i">+}
</a><a href="#h40-0-244" id="h40-0-244" class="i">+
</a><a href="#h40-0-245" id="h40-0-245" class="i">+// Creates a new event prepopulated with any Fields present in the global
</a><a href="#h40-0-246" id="h40-0-246" class="i">+// scope.
</a><a href="#h40-0-247" id="h40-0-247" class="i">+func NewEvent() *Event {
</a><a href="#h40-0-248" id="h40-0-248" class="i">+	return globalState.NewEvent()
</a><a href="#h40-0-249" id="h40-0-249" class="i">+}
</a><a href="#h40-0-250" id="h40-0-250" class="i">+
</a><a href="#h40-0-251" id="h40-0-251" class="i">+// AddField adds an individual metric to the event or builder on which it is
</a><a href="#h40-0-252" id="h40-0-252" class="i">+// called.
</a><a href="#h40-0-253" id="h40-0-253" class="i">+func (f *fieldHolder) AddField(key string, val interface{}) {
</a><a href="#h40-0-254" id="h40-0-254" class="i">+	f.lock.Lock()
</a><a href="#h40-0-255" id="h40-0-255" class="i">+	defer f.lock.Unlock()
</a><a href="#h40-0-256" id="h40-0-256" class="i">+	// run a sanity check on data, transparently drop if it fails.
</a><a href="#h40-0-257" id="h40-0-257" class="i">+	if validateData(val) {
</a><a href="#h40-0-258" id="h40-0-258" class="i">+		f.data[key] = val
</a><a href="#h40-0-259" id="h40-0-259" class="i">+	}
</a><a href="#h40-0-260" id="h40-0-260" class="i">+}
</a><a href="#h40-0-261" id="h40-0-261" class="i">+
</a><a href="#h40-0-262" id="h40-0-262" class="i">+// validateData runs some checks on the data and returns false if it&#39;s bad data
</a><a href="#h40-0-263" id="h40-0-263" class="i">+// and should be skipped
</a><a href="#h40-0-264" id="h40-0-264" class="i">+func validateData(val interface{}) bool {
</a><a href="#h40-0-265" id="h40-0-265" class="i">+	if val == nil {
</a><a href="#h40-0-266" id="h40-0-266" class="i">+		return false
</a><a href="#h40-0-267" id="h40-0-267" class="i">+	}
</a><a href="#h40-0-268" id="h40-0-268" class="i">+	// if we can&#39;t json encode the value, we should skip it.
</a><a href="#h40-0-269" id="h40-0-269" class="i">+	// TODO this is probably slow. Decide whether it&#39;s unacceptably slow.
</a><a href="#h40-0-270" id="h40-0-270" class="i">+	_, err := json.Marshal(val)
</a><a href="#h40-0-271" id="h40-0-271" class="i">+	if err != nil {
</a><a href="#h40-0-272" id="h40-0-272" class="i">+		return false
</a><a href="#h40-0-273" id="h40-0-273" class="i">+	}
</a><a href="#h40-0-274" id="h40-0-274" class="i">+	return true
</a><a href="#h40-0-275" id="h40-0-275" class="i">+}
</a><a href="#h40-0-276" id="h40-0-276" class="i">+
</a><a href="#h40-0-277" id="h40-0-277" class="i">+func validateValue(val reflect.Value) bool {
</a><a href="#h40-0-278" id="h40-0-278" class="i">+	if val.Type().Kind() == reflect.Chan {
</a><a href="#h40-0-279" id="h40-0-279" class="i">+		return false
</a><a href="#h40-0-280" id="h40-0-280" class="i">+	}
</a><a href="#h40-0-281" id="h40-0-281" class="i">+	kind := val.Type().Kind()
</a><a href="#h40-0-282" id="h40-0-282" class="i">+	for _, ptrKind := range ptrKinds {
</a><a href="#h40-0-283" id="h40-0-283" class="i">+		if kind == ptrKind &amp;&amp; val.IsNil() {
</a><a href="#h40-0-284" id="h40-0-284" class="i">+			return false
</a><a href="#h40-0-285" id="h40-0-285" class="i">+		}
</a><a href="#h40-0-286" id="h40-0-286" class="i">+	}
</a><a href="#h40-0-287" id="h40-0-287" class="i">+	if validateData(val.Interface()) == false {
</a><a href="#h40-0-288" id="h40-0-288" class="i">+		return false
</a><a href="#h40-0-289" id="h40-0-289" class="i">+	}
</a><a href="#h40-0-290" id="h40-0-290" class="i">+	return true
</a><a href="#h40-0-291" id="h40-0-291" class="i">+}
</a><a href="#h40-0-292" id="h40-0-292" class="i">+
</a><a href="#h40-0-293" id="h40-0-293" class="i">+// Add adds a complex data type to the event or builder on which it&#39;s called.
</a><a href="#h40-0-294" id="h40-0-294" class="i">+// For structs, it adds each exported field. For maps, it adds each key/value.
</a><a href="#h40-0-295" id="h40-0-295" class="i">+// Add will error on all other types.
</a><a href="#h40-0-296" id="h40-0-296" class="i">+func (f *fieldHolder) Add(data interface{}) error {
</a><a href="#h40-0-297" id="h40-0-297" class="i">+	switch reflect.TypeOf(data).Kind() {
</a><a href="#h40-0-298" id="h40-0-298" class="i">+	case reflect.Struct:
</a><a href="#h40-0-299" id="h40-0-299" class="i">+		return f.addStruct(data)
</a><a href="#h40-0-300" id="h40-0-300" class="i">+	case reflect.Map:
</a><a href="#h40-0-301" id="h40-0-301" class="i">+		return f.addMap(data)
</a><a href="#h40-0-302" id="h40-0-302" class="i">+	case reflect.Ptr:
</a><a href="#h40-0-303" id="h40-0-303" class="i">+		return f.Add(reflect.ValueOf(data).Elem().Interface())
</a><a href="#h40-0-304" id="h40-0-304" class="i">+	}
</a><a href="#h40-0-305" id="h40-0-305" class="i">+	return fmt.Errorf(
</a><a href="#h40-0-306" id="h40-0-306" class="i">+		&quot;Couldn&#39;t add type %s content %+v&quot;,
</a><a href="#h40-0-307" id="h40-0-307" class="i">+		reflect.TypeOf(data).Kind(), data,
</a><a href="#h40-0-308" id="h40-0-308" class="i">+	)
</a><a href="#h40-0-309" id="h40-0-309" class="i">+}
</a><a href="#h40-0-310" id="h40-0-310" class="i">+
</a><a href="#h40-0-311" id="h40-0-311" class="i">+func (f *fieldHolder) addStruct(s interface{}) error {
</a><a href="#h40-0-312" id="h40-0-312" class="i">+	f.lock.Lock()
</a><a href="#h40-0-313" id="h40-0-313" class="i">+	defer f.lock.Unlock()
</a><a href="#h40-0-314" id="h40-0-314" class="i">+
</a><a href="#h40-0-315" id="h40-0-315" class="i">+	// TODO should we handle embedded structs differently from other deep structs?
</a><a href="#h40-0-316" id="h40-0-316" class="i">+	sType := reflect.TypeOf(s)
</a><a href="#h40-0-317" id="h40-0-317" class="i">+	sVal := reflect.ValueOf(s)
</a><a href="#h40-0-318" id="h40-0-318" class="i">+	// Iterate through the fields, adding each.
</a><a href="#h40-0-319" id="h40-0-319" class="i">+	for i := 0; i &lt; sType.NumField(); i++ {
</a><a href="#h40-0-320" id="h40-0-320" class="i">+		fieldInfo := sType.Field(i)
</a><a href="#h40-0-321" id="h40-0-321" class="i">+		if fieldInfo.PkgPath != &quot;&quot; {
</a><a href="#h40-0-322" id="h40-0-322" class="i">+			// skipping unexported field in the struct
</a><a href="#h40-0-323" id="h40-0-323" class="i">+			continue
</a><a href="#h40-0-324" id="h40-0-324" class="i">+		}
</a><a href="#h40-0-325" id="h40-0-325" class="i">+
</a><a href="#h40-0-326" id="h40-0-326" class="i">+		var fName string
</a><a href="#h40-0-327" id="h40-0-327" class="i">+		fTag := fieldInfo.Tag.Get(&quot;json&quot;)
</a><a href="#h40-0-328" id="h40-0-328" class="i">+		if fTag != &quot;&quot; {
</a><a href="#h40-0-329" id="h40-0-329" class="i">+			if fTag == &quot;-&quot; {
</a><a href="#h40-0-330" id="h40-0-330" class="i">+				// skip this field
</a><a href="#h40-0-331" id="h40-0-331" class="i">+				continue
</a><a href="#h40-0-332" id="h40-0-332" class="i">+			}
</a><a href="#h40-0-333" id="h40-0-333" class="i">+			// slice off options
</a><a href="#h40-0-334" id="h40-0-334" class="i">+			if idx := strings.Index(fTag, &quot;,&quot;); idx != -1 {
</a><a href="#h40-0-335" id="h40-0-335" class="i">+				fTag = fTag[:idx]
</a><a href="#h40-0-336" id="h40-0-336" class="i">+			}
</a><a href="#h40-0-337" id="h40-0-337" class="i">+			fName = fTag
</a><a href="#h40-0-338" id="h40-0-338" class="i">+		} else {
</a><a href="#h40-0-339" id="h40-0-339" class="i">+			fName = fieldInfo.Name
</a><a href="#h40-0-340" id="h40-0-340" class="i">+		}
</a><a href="#h40-0-341" id="h40-0-341" class="i">+
</a><a href="#h40-0-342" id="h40-0-342" class="i">+		if validateValue(sVal.Field(i)) {
</a><a href="#h40-0-343" id="h40-0-343" class="i">+			f.data[fName] = sVal.Field(i).Interface()
</a><a href="#h40-0-344" id="h40-0-344" class="i">+		}
</a><a href="#h40-0-345" id="h40-0-345" class="i">+	}
</a><a href="#h40-0-346" id="h40-0-346" class="i">+	return nil
</a><a href="#h40-0-347" id="h40-0-347" class="i">+}
</a><a href="#h40-0-348" id="h40-0-348" class="i">+
</a><a href="#h40-0-349" id="h40-0-349" class="i">+func (f *fieldHolder) addMap(m interface{}) error {
</a><a href="#h40-0-350" id="h40-0-350" class="i">+	f.lock.Lock()
</a><a href="#h40-0-351" id="h40-0-351" class="i">+	defer f.lock.Unlock()
</a><a href="#h40-0-352" id="h40-0-352" class="i">+
</a><a href="#h40-0-353" id="h40-0-353" class="i">+	mVal := reflect.ValueOf(m)
</a><a href="#h40-0-354" id="h40-0-354" class="i">+	mKeys := mVal.MapKeys()
</a><a href="#h40-0-355" id="h40-0-355" class="i">+	for _, key := range mKeys {
</a><a href="#h40-0-356" id="h40-0-356" class="i">+		// get a string representation of key
</a><a href="#h40-0-357" id="h40-0-357" class="i">+		var keyStr string
</a><a href="#h40-0-358" id="h40-0-358" class="i">+		switch key.Type().Kind() {
</a><a href="#h40-0-359" id="h40-0-359" class="i">+		case reflect.String:
</a><a href="#h40-0-360" id="h40-0-360" class="i">+			keyStr = key.String()
</a><a href="#h40-0-361" id="h40-0-361" class="i">+		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32,
</a><a href="#h40-0-362" id="h40-0-362" class="i">+			reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32,
</a><a href="#h40-0-363" id="h40-0-363" class="i">+			reflect.Uint64, reflect.Float32, reflect.Float64, reflect.Complex64,
</a><a href="#h40-0-364" id="h40-0-364" class="i">+			reflect.Complex128:
</a><a href="#h40-0-365" id="h40-0-365" class="i">+			keyStr = fmt.Sprintf(&quot;%v&quot;, key.Interface())
</a><a href="#h40-0-366" id="h40-0-366" class="i">+		default:
</a><a href="#h40-0-367" id="h40-0-367" class="i">+			return fmt.Errorf(&quot;failed to add map: key type %s unaccepted&quot;, key.Type().Kind())
</a><a href="#h40-0-368" id="h40-0-368" class="i">+		}
</a><a href="#h40-0-369" id="h40-0-369" class="i">+		if validateValue(mVal.MapIndex(key)) {
</a><a href="#h40-0-370" id="h40-0-370" class="i">+			f.data[keyStr] = mVal.MapIndex(key).Interface()
</a><a href="#h40-0-371" id="h40-0-371" class="i">+		}
</a><a href="#h40-0-372" id="h40-0-372" class="i">+	}
</a><a href="#h40-0-373" id="h40-0-373" class="i">+	return nil
</a><a href="#h40-0-374" id="h40-0-374" class="i">+}
</a><a href="#h40-0-375" id="h40-0-375" class="i">+
</a><a href="#h40-0-376" id="h40-0-376" class="i">+// AddFunc takes a function and runs it repeatedly, adding the return values
</a><a href="#h40-0-377" id="h40-0-377" class="i">+// as fields.
</a><a href="#h40-0-378" id="h40-0-378" class="i">+// The function should return error when it has exhausted its values
</a><a href="#h40-0-379" id="h40-0-379" class="i">+func (f *fieldHolder) AddFunc(fn func() (string, interface{}, error)) error {
</a><a href="#h40-0-380" id="h40-0-380" class="i">+	for {
</a><a href="#h40-0-381" id="h40-0-381" class="i">+		key, rawVal, err := fn()
</a><a href="#h40-0-382" id="h40-0-382" class="i">+		if err != nil {
</a><a href="#h40-0-383" id="h40-0-383" class="i">+			// fn is done giving us data
</a><a href="#h40-0-384" id="h40-0-384" class="i">+			break
</a><a href="#h40-0-385" id="h40-0-385" class="i">+		}
</a><a href="#h40-0-386" id="h40-0-386" class="i">+		f.AddField(key, rawVal)
</a><a href="#h40-0-387" id="h40-0-387" class="i">+	}
</a><a href="#h40-0-388" id="h40-0-388" class="i">+	return nil
</a><a href="#h40-0-389" id="h40-0-389" class="i">+}
</a><a href="#h40-0-390" id="h40-0-390" class="i">+
</a><a href="#h40-0-391" id="h40-0-391" class="i">+// Send dispatches the event to be sent to Honeycomb.
</a><a href="#h40-0-392" id="h40-0-392" class="i">+//
</a><a href="#h40-0-393" id="h40-0-393" class="i">+// If you have sampling enabled
</a><a href="#h40-0-394" id="h40-0-394" class="i">+// (i.e. SampleRate &gt;1), Send will only actually transmit data with a
</a><a href="#h40-0-395" id="h40-0-395" class="i">+// probability of 1/SampleRate. No error is returned whether or not traffic
</a><a href="#h40-0-396" id="h40-0-396" class="i">+// is sampled, however, the Response sent down the response channel will
</a><a href="#h40-0-397" id="h40-0-397" class="i">+// indicate the event was sampled in the errors Err field.
</a><a href="#h40-0-398" id="h40-0-398" class="i">+//
</a><a href="#h40-0-399" id="h40-0-399" class="i">+// Send inherits the values of required fields from Config. If any required
</a><a href="#h40-0-400" id="h40-0-400" class="i">+// fields are specified in neither Config nor the Event, Send will return an
</a><a href="#h40-0-401" id="h40-0-401" class="i">+// error.  Required fields are APIHost, WriteKey, and Dataset. Values specified
</a><a href="#h40-0-402" id="h40-0-402" class="i">+// in an Event override Config.
</a><a href="#h40-0-403" id="h40-0-403" class="i">+func (e *Event) Send() error {
</a><a href="#h40-0-404" id="h40-0-404" class="i">+	if shouldDrop(e.SampleRate) {
</a><a href="#h40-0-405" id="h40-0-405" class="i">+		sd.Increment(&quot;sampled&quot;)
</a><a href="#h40-0-406" id="h40-0-406" class="i">+		sendDroppedResponse(e, &quot;event dropped due to sampling&quot;)
</a><a href="#h40-0-407" id="h40-0-407" class="i">+		return nil
</a><a href="#h40-0-408" id="h40-0-408" class="i">+	}
</a><a href="#h40-0-409" id="h40-0-409" class="i">+	if len(e.data) == 0 {
</a><a href="#h40-0-410" id="h40-0-410" class="i">+		return errors.New(&quot;No metrics added to event. Won&#39;t send empty event.&quot;)
</a><a href="#h40-0-411" id="h40-0-411" class="i">+	}
</a><a href="#h40-0-412" id="h40-0-412" class="i">+	if e.APIHost == &quot;&quot; {
</a><a href="#h40-0-413" id="h40-0-413" class="i">+		return errors.New(&quot;No APIHost for Honeycomb. Can&#39;t send to the Great Unknown.&quot;)
</a><a href="#h40-0-414" id="h40-0-414" class="i">+	}
</a><a href="#h40-0-415" id="h40-0-415" class="i">+	if e.WriteKey == &quot;&quot; {
</a><a href="#h40-0-416" id="h40-0-416" class="i">+		return errors.New(&quot;No WriteKey specified. Can&#39;t send event.&quot;)
</a><a href="#h40-0-417" id="h40-0-417" class="i">+	}
</a><a href="#h40-0-418" id="h40-0-418" class="i">+	if e.Dataset == &quot;&quot; {
</a><a href="#h40-0-419" id="h40-0-419" class="i">+		return errors.New(&quot;No Dataset for Honeycomb. Can&#39;t send datasetless.&quot;)
</a><a href="#h40-0-420" id="h40-0-420" class="i">+	}
</a><a href="#h40-0-421" id="h40-0-421" class="i">+
</a><a href="#h40-0-422" id="h40-0-422" class="i">+	tx.Add(e)
</a><a href="#h40-0-423" id="h40-0-423" class="i">+	return nil
</a><a href="#h40-0-424" id="h40-0-424" class="i">+}
</a><a href="#h40-0-425" id="h40-0-425" class="i">+
</a><a href="#h40-0-426" id="h40-0-426" class="i">+// sendResponse sends a dropped event response down the response channel
</a><a href="#h40-0-427" id="h40-0-427" class="i">+func sendDroppedResponse(e *Event, message string) {
</a><a href="#h40-0-428" id="h40-0-428" class="i">+	r := Response{
</a><a href="#h40-0-429" id="h40-0-429" class="i">+		Err:      errors.New(message),
</a><a href="#h40-0-430" id="h40-0-430" class="i">+		Metadata: e.Metadata,
</a><a href="#h40-0-431" id="h40-0-431" class="i">+	}
</a><a href="#h40-0-432" id="h40-0-432" class="i">+	if blockOnResponses {
</a><a href="#h40-0-433" id="h40-0-433" class="i">+		responses &lt;- r
</a><a href="#h40-0-434" id="h40-0-434" class="i">+	} else {
</a><a href="#h40-0-435" id="h40-0-435" class="i">+		select {
</a><a href="#h40-0-436" id="h40-0-436" class="i">+		case responses &lt;- r:
</a><a href="#h40-0-437" id="h40-0-437" class="i">+		default:
</a><a href="#h40-0-438" id="h40-0-438" class="i">+		}
</a><a href="#h40-0-439" id="h40-0-439" class="i">+	}
</a><a href="#h40-0-440" id="h40-0-440" class="i">+}
</a><a href="#h40-0-441" id="h40-0-441" class="i">+
</a><a href="#h40-0-442" id="h40-0-442" class="i">+// returns true if the sample should be dropped
</a><a href="#h40-0-443" id="h40-0-443" class="i">+func shouldDrop(rate uint) bool {
</a><a href="#h40-0-444" id="h40-0-444" class="i">+	return rand.Intn(int(rate)) != 0
</a><a href="#h40-0-445" id="h40-0-445" class="i">+}
</a><a href="#h40-0-446" id="h40-0-446" class="i">+
</a><a href="#h40-0-447" id="h40-0-447" class="i">+// returns true if the first character of the string is lowercase
</a><a href="#h40-0-448" id="h40-0-448" class="i">+func isFirstLower(s string) bool {
</a><a href="#h40-0-449" id="h40-0-449" class="i">+	return false
</a><a href="#h40-0-450" id="h40-0-450" class="i">+}
</a><a href="#h40-0-451" id="h40-0-451" class="i">+
</a><a href="#h40-0-452" id="h40-0-452" class="i">+// NewBuilder creates a new event builder. The builder inherits any
</a><a href="#h40-0-453" id="h40-0-453" class="i">+// Dynamic or Static Fields present in the global scope.
</a><a href="#h40-0-454" id="h40-0-454" class="i">+func NewBuilder() *Builder {
</a><a href="#h40-0-455" id="h40-0-455" class="i">+	return globalState.Clone()
</a><a href="#h40-0-456" id="h40-0-456" class="i">+}
</a><a href="#h40-0-457" id="h40-0-457" class="i">+
</a><a href="#h40-0-458" id="h40-0-458" class="i">+// AddDynamicField adds a dynamic field to the builder. Any events
</a><a href="#h40-0-459" id="h40-0-459" class="i">+// created from this builder will get this metric added.
</a><a href="#h40-0-460" id="h40-0-460" class="i">+func (b *Builder) AddDynamicField(name string, fn func() interface{}) error {
</a><a href="#h40-0-461" id="h40-0-461" class="i">+	b.dynFieldsLock.Lock()
</a><a href="#h40-0-462" id="h40-0-462" class="i">+	defer b.dynFieldsLock.Unlock()
</a><a href="#h40-0-463" id="h40-0-463" class="i">+	dynFn := dynamicField{
</a><a href="#h40-0-464" id="h40-0-464" class="i">+		name: name,
</a><a href="#h40-0-465" id="h40-0-465" class="i">+		fn:   fn,
</a><a href="#h40-0-466" id="h40-0-466" class="i">+	}
</a><a href="#h40-0-467" id="h40-0-467" class="i">+	b.dynFields = append(b.dynFields, dynFn)
</a><a href="#h40-0-468" id="h40-0-468" class="i">+	return nil
</a><a href="#h40-0-469" id="h40-0-469" class="i">+}
</a><a href="#h40-0-470" id="h40-0-470" class="i">+
</a><a href="#h40-0-471" id="h40-0-471" class="i">+// SendNow is a shortcut to create an event from this builder, add data, and
</a><a href="#h40-0-472" id="h40-0-472" class="i">+// send the event.
</a><a href="#h40-0-473" id="h40-0-473" class="i">+func (b *Builder) SendNow(data interface{}) error {
</a><a href="#h40-0-474" id="h40-0-474" class="i">+	ev := b.NewEvent()
</a><a href="#h40-0-475" id="h40-0-475" class="i">+	if err := ev.Add(data); err != nil {
</a><a href="#h40-0-476" id="h40-0-476" class="i">+		return err
</a><a href="#h40-0-477" id="h40-0-477" class="i">+	}
</a><a href="#h40-0-478" id="h40-0-478" class="i">+	if err := ev.Send(); err != nil {
</a><a href="#h40-0-479" id="h40-0-479" class="i">+		return err
</a><a href="#h40-0-480" id="h40-0-480" class="i">+	}
</a><a href="#h40-0-481" id="h40-0-481" class="i">+	return nil
</a><a href="#h40-0-482" id="h40-0-482" class="i">+}
</a><a href="#h40-0-483" id="h40-0-483" class="i">+
</a><a href="#h40-0-484" id="h40-0-484" class="i">+// NewEvent creates a new Event prepopulated with fields, dynamic
</a><a href="#h40-0-485" id="h40-0-485" class="i">+// field values, and configuration inherited from the builder.
</a><a href="#h40-0-486" id="h40-0-486" class="i">+func (b *Builder) NewEvent() *Event {
</a><a href="#h40-0-487" id="h40-0-487" class="i">+	e := &amp;Event{
</a><a href="#h40-0-488" id="h40-0-488" class="i">+		WriteKey:   b.WriteKey,
</a><a href="#h40-0-489" id="h40-0-489" class="i">+		Dataset:    b.Dataset,
</a><a href="#h40-0-490" id="h40-0-490" class="i">+		SampleRate: b.SampleRate,
</a><a href="#h40-0-491" id="h40-0-491" class="i">+		APIHost:    b.APIHost,
</a><a href="#h40-0-492" id="h40-0-492" class="i">+		Timestamp:  time.Now(),
</a><a href="#h40-0-493" id="h40-0-493" class="i">+	}
</a><a href="#h40-0-494" id="h40-0-494" class="i">+	e.data = make(map[string]interface{})
</a><a href="#h40-0-495" id="h40-0-495" class="i">+
</a><a href="#h40-0-496" id="h40-0-496" class="i">+	// copy static metrics (everything&#39;s been serialized so flat copy is OK)
</a><a href="#h40-0-497" id="h40-0-497" class="i">+	for k, v := range b.data {
</a><a href="#h40-0-498" id="h40-0-498" class="i">+		e.data[k] = v
</a><a href="#h40-0-499" id="h40-0-499" class="i">+	}
</a><a href="#h40-0-500" id="h40-0-500" class="i">+	// create dynamic metrics
</a><a href="#h40-0-501" id="h40-0-501" class="i">+	for _, dynField := range b.dynFields {
</a><a href="#h40-0-502" id="h40-0-502" class="i">+		e.AddField(dynField.name, dynField.fn())
</a><a href="#h40-0-503" id="h40-0-503" class="i">+	}
</a><a href="#h40-0-504" id="h40-0-504" class="i">+	return e
</a><a href="#h40-0-505" id="h40-0-505" class="i">+}
</a><a href="#h40-0-506" id="h40-0-506" class="i">+
</a><a href="#h40-0-507" id="h40-0-507" class="i">+// Clone creates a new builder that inherits all traits of this builder and
</a><a href="#h40-0-508" id="h40-0-508" class="i">+// creates its own scope in which to add additional static and dynamic fields.
</a><a href="#h40-0-509" id="h40-0-509" class="i">+func (b *Builder) Clone() *Builder {
</a><a href="#h40-0-510" id="h40-0-510" class="i">+	newB := &amp;Builder{
</a><a href="#h40-0-511" id="h40-0-511" class="i">+		WriteKey:   b.WriteKey,
</a><a href="#h40-0-512" id="h40-0-512" class="i">+		Dataset:    b.Dataset,
</a><a href="#h40-0-513" id="h40-0-513" class="i">+		SampleRate: b.SampleRate,
</a><a href="#h40-0-514" id="h40-0-514" class="i">+		APIHost:    b.APIHost,
</a><a href="#h40-0-515" id="h40-0-515" class="i">+		dynFields:  make([]dynamicField, 0, len(b.dynFields)),
</a><a href="#h40-0-516" id="h40-0-516" class="i">+	}
</a><a href="#h40-0-517" id="h40-0-517" class="i">+	newB.data = make(map[string]interface{})
</a><a href="#h40-0-518" id="h40-0-518" class="i">+	// copy static metrics (everything&#39;s been serialized so flat copy is OK)
</a><a href="#h40-0-519" id="h40-0-519" class="i">+	for k, v := range b.data {
</a><a href="#h40-0-520" id="h40-0-520" class="i">+		newB.data[k] = v
</a><a href="#h40-0-521" id="h40-0-521" class="i">+	}
</a><a href="#h40-0-522" id="h40-0-522" class="i">+	// copy dynamic metric generators
</a><a href="#h40-0-523" id="h40-0-523" class="i">+	for _, dynFd := range b.dynFields {
</a><a href="#h40-0-524" id="h40-0-524" class="i">+		newB.dynFields = append(newB.dynFields, dynFd)
</a><a href="#h40-0-525" id="h40-0-525" class="i">+	}
</a><a href="#h40-0-526" id="h40-0-526" class="i">+	return newB
</a><a href="#h40-0-527" id="h40-0-527" class="i">+}
</a><b>diff --git a/<a id="h41" href="../file/vendor/github.com/honeycombio/libhoney-go/response.go">vendor/github.com/honeycombio/libhoney-go/response.go</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/response.go">vendor/github.com/honeycombio/libhoney-go/response.go</a></b>
<a href="#h41-0" id="h41-0" class="h">@@ -0,0 +1,32 @@
</a><a href="#h41-0-0" id="h41-0-0" class="i">+package libhoney
</a><a href="#h41-0-1" id="h41-0-1" class="i">+
</a><a href="#h41-0-2" id="h41-0-2" class="i">+import &quot;time&quot;
</a><a href="#h41-0-3" id="h41-0-3" class="i">+
</a><a href="#h41-0-4" id="h41-0-4" class="i">+// Response is a record of an event sent. It includes information about sending
</a><a href="#h41-0-5" id="h41-0-5" class="i">+// the event - how long it took, whether it succeeded, and so on. It also has
</a><a href="#h41-0-6" id="h41-0-6" class="i">+// a metadata field that is just a pass through - you add it to an Event and
</a><a href="#h41-0-7" id="h41-0-7" class="i">+// it will be on the Response that correlates with that Event. This allows you
</a><a href="#h41-0-8" id="h41-0-8" class="i">+// to track specific events.
</a><a href="#h41-0-9" id="h41-0-9" class="i">+type Response struct {
</a><a href="#h41-0-10" id="h41-0-10" class="i">+
</a><a href="#h41-0-11" id="h41-0-11" class="i">+	// Err contains any error returned by the httpClient on sending or an error
</a><a href="#h41-0-12" id="h41-0-12" class="i">+	// indicating queue overflow
</a><a href="#h41-0-13" id="h41-0-13" class="i">+	Err error
</a><a href="#h41-0-14" id="h41-0-14" class="i">+
</a><a href="#h41-0-15" id="h41-0-15" class="i">+	// StatusCode contains the HTTP Status Code returned by the Honeycomb API
</a><a href="#h41-0-16" id="h41-0-16" class="i">+	// server
</a><a href="#h41-0-17" id="h41-0-17" class="i">+	StatusCode int
</a><a href="#h41-0-18" id="h41-0-18" class="i">+
</a><a href="#h41-0-19" id="h41-0-19" class="i">+	// Body is the body of the HTTP response from the Honeycomb API server.
</a><a href="#h41-0-20" id="h41-0-20" class="i">+	Body []byte
</a><a href="#h41-0-21" id="h41-0-21" class="i">+
</a><a href="#h41-0-22" id="h41-0-22" class="i">+	// Duration is a measurement of how long the HTTP request to send an event
</a><a href="#h41-0-23" id="h41-0-23" class="i">+	// took to process. The actual time it takes libhoney to send an event may
</a><a href="#h41-0-24" id="h41-0-24" class="i">+	// be longer due to any time the event spends waiting in the queue before
</a><a href="#h41-0-25" id="h41-0-25" class="i">+	// being sent.
</a><a href="#h41-0-26" id="h41-0-26" class="i">+	Duration time.Duration
</a><a href="#h41-0-27" id="h41-0-27" class="i">+
</a><a href="#h41-0-28" id="h41-0-28" class="i">+	// Metadata is whatever content you put in the Metadata field of the event for
</a><a href="#h41-0-29" id="h41-0-29" class="i">+	// which this is the response. It is passed through unmodified.
</a><a href="#h41-0-30" id="h41-0-30" class="i">+	Metadata interface{}
</a><a href="#h41-0-31" id="h41-0-31" class="i">+}
</a><b>diff --git a/<a id="h42" href="../file/vendor/github.com/honeycombio/libhoney-go/test_helpers.go">vendor/github.com/honeycombio/libhoney-go/test_helpers.go</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/test_helpers.go">vendor/github.com/honeycombio/libhoney-go/test_helpers.go</a></b>
<a href="#h42-0" id="h42-0" class="h">@@ -0,0 +1,114 @@
</a><a href="#h42-0-0" id="h42-0-0" class="i">+package libhoney
</a><a href="#h42-0-1" id="h42-0-1" class="i">+
</a><a href="#h42-0-2" id="h42-0-2" class="i">+import (
</a><a href="#h42-0-3" id="h42-0-3" class="i">+	&quot;fmt&quot;
</a><a href="#h42-0-4" id="h42-0-4" class="i">+	&quot;path/filepath&quot;
</a><a href="#h42-0-5" id="h42-0-5" class="i">+	&quot;reflect&quot;
</a><a href="#h42-0-6" id="h42-0-6" class="i">+	&quot;runtime&quot;
</a><a href="#h42-0-7" id="h42-0-7" class="i">+	&quot;strings&quot;
</a><a href="#h42-0-8" id="h42-0-8" class="i">+	&quot;testing&quot;
</a><a href="#h42-0-9" id="h42-0-9" class="i">+	&quot;time&quot;
</a><a href="#h42-0-10" id="h42-0-10" class="i">+)
</a><a href="#h42-0-11" id="h42-0-11" class="i">+
</a><a href="#h42-0-12" id="h42-0-12" class="i">+func testOK(t testing.TB, err error) {
</a><a href="#h42-0-13" id="h42-0-13" class="i">+	if err != nil {
</a><a href="#h42-0-14" id="h42-0-14" class="i">+		_, file, line, _ := runtime.Caller(1)
</a><a href="#h42-0-15" id="h42-0-15" class="i">+		t.Fatalf(&quot;%s:%d: unexpected error: %s&quot;, filepath.Base(file), line, err.Error())
</a><a href="#h42-0-16" id="h42-0-16" class="i">+	}
</a><a href="#h42-0-17" id="h42-0-17" class="i">+}
</a><a href="#h42-0-18" id="h42-0-18" class="i">+func testErr(t testing.TB, err error) {
</a><a href="#h42-0-19" id="h42-0-19" class="i">+	if err == nil {
</a><a href="#h42-0-20" id="h42-0-20" class="i">+		_, file, line, _ := runtime.Caller(1)
</a><a href="#h42-0-21" id="h42-0-21" class="i">+		t.Fatalf(&quot;%s:%d: error expected!&quot;, filepath.Base(file), line)
</a><a href="#h42-0-22" id="h42-0-22" class="i">+	}
</a><a href="#h42-0-23" id="h42-0-23" class="i">+}
</a><a href="#h42-0-24" id="h42-0-24" class="i">+
</a><a href="#h42-0-25" id="h42-0-25" class="i">+func testEquals(t testing.TB, actual, expected interface{}, msg ...string) {
</a><a href="#h42-0-26" id="h42-0-26" class="i">+	if !reflect.DeepEqual(actual, expected) {
</a><a href="#h42-0-27" id="h42-0-27" class="i">+		testCommonErr(t, actual, expected, msg)
</a><a href="#h42-0-28" id="h42-0-28" class="i">+	}
</a><a href="#h42-0-29" id="h42-0-29" class="i">+}
</a><a href="#h42-0-30" id="h42-0-30" class="i">+
</a><a href="#h42-0-31" id="h42-0-31" class="i">+func testNotEquals(t testing.TB, actual, expected interface{}, msg ...string) {
</a><a href="#h42-0-32" id="h42-0-32" class="i">+	if reflect.DeepEqual(actual, expected) {
</a><a href="#h42-0-33" id="h42-0-33" class="i">+		testCommonErr(t, actual, expected, msg)
</a><a href="#h42-0-34" id="h42-0-34" class="i">+	}
</a><a href="#h42-0-35" id="h42-0-35" class="i">+}
</a><a href="#h42-0-36" id="h42-0-36" class="i">+
</a><a href="#h42-0-37" id="h42-0-37" class="i">+func testResponsesChannelEmpty(t testing.TB, chnl chan Response, msg ...string) {
</a><a href="#h42-0-38" id="h42-0-38" class="i">+	expected := &quot;no response&quot;
</a><a href="#h42-0-39" id="h42-0-39" class="i">+	var rsp string
</a><a href="#h42-0-40" id="h42-0-40" class="i">+	select {
</a><a href="#h42-0-41" id="h42-0-41" class="i">+	case _ = &lt;-chnl:
</a><a href="#h42-0-42" id="h42-0-42" class="i">+		rsp = &quot;got response&quot;
</a><a href="#h42-0-43" id="h42-0-43" class="i">+	default:
</a><a href="#h42-0-44" id="h42-0-44" class="i">+		rsp = &quot;no response&quot;
</a><a href="#h42-0-45" id="h42-0-45" class="i">+	}
</a><a href="#h42-0-46" id="h42-0-46" class="i">+	testEquals(t, rsp, expected)
</a><a href="#h42-0-47" id="h42-0-47" class="i">+}
</a><a href="#h42-0-48" id="h42-0-48" class="i">+
</a><a href="#h42-0-49" id="h42-0-49" class="i">+func testChannelHasResponse(t testing.TB, chnl chan Response, msg ...string) {
</a><a href="#h42-0-50" id="h42-0-50" class="i">+	expected := &quot;got response&quot;
</a><a href="#h42-0-51" id="h42-0-51" class="i">+	var r Response
</a><a href="#h42-0-52" id="h42-0-52" class="i">+	var rsp string
</a><a href="#h42-0-53" id="h42-0-53" class="i">+	select {
</a><a href="#h42-0-54" id="h42-0-54" class="i">+	case r = &lt;-chnl:
</a><a href="#h42-0-55" id="h42-0-55" class="i">+		rsp = &quot;got response&quot;
</a><a href="#h42-0-56" id="h42-0-56" class="i">+	default:
</a><a href="#h42-0-57" id="h42-0-57" class="i">+		rsp = &quot;no response&quot;
</a><a href="#h42-0-58" id="h42-0-58" class="i">+	}
</a><a href="#h42-0-59" id="h42-0-59" class="i">+	t.Log(r)
</a><a href="#h42-0-60" id="h42-0-60" class="i">+	testEquals(t, rsp, expected)
</a><a href="#h42-0-61" id="h42-0-61" class="i">+}
</a><a href="#h42-0-62" id="h42-0-62" class="i">+
</a><a href="#h42-0-63" id="h42-0-63" class="i">+func testCommonErr(t testing.TB, actual, expected interface{}, msg []string) {
</a><a href="#h42-0-64" id="h42-0-64" class="i">+	message := strings.Join(msg, &quot;, &quot;)
</a><a href="#h42-0-65" id="h42-0-65" class="i">+	_, file, line, _ := runtime.Caller(2)
</a><a href="#h42-0-66" id="h42-0-66" class="i">+
</a><a href="#h42-0-67" id="h42-0-67" class="i">+	t.Errorf(
</a><a href="#h42-0-68" id="h42-0-68" class="i">+		&quot;%s:%d: %s -- actual(%T): %v, expected(%T): %v&quot;,
</a><a href="#h42-0-69" id="h42-0-69" class="i">+		filepath.Base(file),
</a><a href="#h42-0-70" id="h42-0-70" class="i">+		line,
</a><a href="#h42-0-71" id="h42-0-71" class="i">+		message,
</a><a href="#h42-0-72" id="h42-0-72" class="i">+		testDeref(actual),
</a><a href="#h42-0-73" id="h42-0-73" class="i">+		testDeref(actual),
</a><a href="#h42-0-74" id="h42-0-74" class="i">+		testDeref(expected),
</a><a href="#h42-0-75" id="h42-0-75" class="i">+		testDeref(expected),
</a><a href="#h42-0-76" id="h42-0-76" class="i">+	)
</a><a href="#h42-0-77" id="h42-0-77" class="i">+}
</a><a href="#h42-0-78" id="h42-0-78" class="i">+
</a><a href="#h42-0-79" id="h42-0-79" class="i">+func testDeref(v interface{}) interface{} {
</a><a href="#h42-0-80" id="h42-0-80" class="i">+	switch t := v.(type) {
</a><a href="#h42-0-81" id="h42-0-81" class="i">+	case *string:
</a><a href="#h42-0-82" id="h42-0-82" class="i">+		return fmt.Sprintf(&quot;*(%v)&quot;, *t)
</a><a href="#h42-0-83" id="h42-0-83" class="i">+	case *int64:
</a><a href="#h42-0-84" id="h42-0-84" class="i">+		return fmt.Sprintf(&quot;*(%v)&quot;, *t)
</a><a href="#h42-0-85" id="h42-0-85" class="i">+	case *float64:
</a><a href="#h42-0-86" id="h42-0-86" class="i">+		return fmt.Sprintf(&quot;*(%v)&quot;, *t)
</a><a href="#h42-0-87" id="h42-0-87" class="i">+	case *bool:
</a><a href="#h42-0-88" id="h42-0-88" class="i">+		return fmt.Sprintf(&quot;*(%v)&quot;, *t)
</a><a href="#h42-0-89" id="h42-0-89" class="i">+	default:
</a><a href="#h42-0-90" id="h42-0-90" class="i">+		return v
</a><a href="#h42-0-91" id="h42-0-91" class="i">+	}
</a><a href="#h42-0-92" id="h42-0-92" class="i">+}
</a><a href="#h42-0-93" id="h42-0-93" class="i">+
</a><a href="#h42-0-94" id="h42-0-94" class="i">+// for easy time manipulation during tests
</a><a href="#h42-0-95" id="h42-0-95" class="i">+type fakeNower struct {
</a><a href="#h42-0-96" id="h42-0-96" class="i">+	now  time.Time
</a><a href="#h42-0-97" id="h42-0-97" class="i">+	iter int
</a><a href="#h42-0-98" id="h42-0-98" class="i">+}
</a><a href="#h42-0-99" id="h42-0-99" class="i">+
</a><a href="#h42-0-100" id="h42-0-100" class="i">+// Now() returns the nth element of nows
</a><a href="#h42-0-101" id="h42-0-101" class="i">+func (f *fakeNower) Now() time.Time {
</a><a href="#h42-0-102" id="h42-0-102" class="i">+	now := f.now.Add(time.Second * 10 * time.Duration(f.iter))
</a><a href="#h42-0-103" id="h42-0-103" class="i">+	f.iter += 1
</a><a href="#h42-0-104" id="h42-0-104" class="i">+	return now
</a><a href="#h42-0-105" id="h42-0-105" class="i">+}
</a><a href="#h42-0-106" id="h42-0-106" class="i">+func (f *fakeNower) set(t time.Time) {
</a><a href="#h42-0-107" id="h42-0-107" class="i">+	f.now = t
</a><a href="#h42-0-108" id="h42-0-108" class="i">+}
</a><a href="#h42-0-109" id="h42-0-109" class="i">+func (f *fakeNower) init() {
</a><a href="#h42-0-110" id="h42-0-110" class="i">+	f.iter = 0
</a><a href="#h42-0-111" id="h42-0-111" class="i">+	t0, _ := time.Parse(time.RFC3339, &quot;2010-06-21T15:04:05Z&quot;)
</a><a href="#h42-0-112" id="h42-0-112" class="i">+	f.now = t0
</a><a href="#h42-0-113" id="h42-0-113" class="i">+}
</a><b>diff --git a/<a id="h43" href="../file/vendor/github.com/honeycombio/libhoney-go/transmission.go">vendor/github.com/honeycombio/libhoney-go/transmission.go</a> b/<a href="../file/vendor/github.com/honeycombio/libhoney-go/transmission.go">vendor/github.com/honeycombio/libhoney-go/transmission.go</a></b>
<a href="#h43-0" id="h43-0" class="h">@@ -0,0 +1,222 @@
</a><a href="#h43-0-0" id="h43-0-0" class="i">+package libhoney
</a><a href="#h43-0-1" id="h43-0-1" class="i">+
</a><a href="#h43-0-2" id="h43-0-2" class="i">+// Package transmission handles sending events to houd.
</a><a href="#h43-0-3" id="h43-0-3" class="i">+//
</a><a href="#h43-0-4" id="h43-0-4" class="i">+// Overview
</a><a href="#h43-0-5" id="h43-0-5" class="i">+//
</a><a href="#h43-0-6" id="h43-0-6" class="i">+// Create a new instance of Client.
</a><a href="#h43-0-7" id="h43-0-7" class="i">+// Set any of the public fields for which you want to override the defaults.
</a><a href="#h43-0-8" id="h43-0-8" class="i">+// Call Start() to spin up the background goroutines necessary for transmission
</a><a href="#h43-0-9" id="h43-0-9" class="i">+// Call Add(Event) to queue an event for transmission
</a><a href="#h43-0-10" id="h43-0-10" class="i">+
</a><a href="#h43-0-11" id="h43-0-11" class="i">+import (
</a><a href="#h43-0-12" id="h43-0-12" class="i">+	&quot;bytes&quot;
</a><a href="#h43-0-13" id="h43-0-13" class="i">+	&quot;encoding/json&quot;
</a><a href="#h43-0-14" id="h43-0-14" class="i">+	&quot;errors&quot;
</a><a href="#h43-0-15" id="h43-0-15" class="i">+	&quot;fmt&quot;
</a><a href="#h43-0-16" id="h43-0-16" class="i">+	&quot;io/ioutil&quot;
</a><a href="#h43-0-17" id="h43-0-17" class="i">+	&quot;net/http&quot;
</a><a href="#h43-0-18" id="h43-0-18" class="i">+	&quot;strconv&quot;
</a><a href="#h43-0-19" id="h43-0-19" class="i">+	&quot;strings&quot;
</a><a href="#h43-0-20" id="h43-0-20" class="i">+	&quot;time&quot;
</a><a href="#h43-0-21" id="h43-0-21" class="i">+
</a><a href="#h43-0-22" id="h43-0-22" class="i">+	&quot;github.com/facebookgo/muster&quot;
</a><a href="#h43-0-23" id="h43-0-23" class="i">+)
</a><a href="#h43-0-24" id="h43-0-24" class="i">+
</a><a href="#h43-0-25" id="h43-0-25" class="i">+const (
</a><a href="#h43-0-26" id="h43-0-26" class="i">+	// defaultmaxBatchSize how many events to collect in a batch
</a><a href="#h43-0-27" id="h43-0-27" class="i">+	defaultmaxBatchSize = 50
</a><a href="#h43-0-28" id="h43-0-28" class="i">+	// defaultbatchTimeout how frequently to send unfilled batches
</a><a href="#h43-0-29" id="h43-0-29" class="i">+	defaultbatchTimeout = 100 * time.Millisecond
</a><a href="#h43-0-30" id="h43-0-30" class="i">+	// defaultmaxConcurrentBatches how many batches to maintain in parallel
</a><a href="#h43-0-31" id="h43-0-31" class="i">+	defaultmaxConcurrentBatches = 10
</a><a href="#h43-0-32" id="h43-0-32" class="i">+	// defaultpendingWorkCapacity how many events to queue up for busy batches
</a><a href="#h43-0-33" id="h43-0-33" class="i">+	defaultpendingWorkCapacity = 10000
</a><a href="#h43-0-34" id="h43-0-34" class="i">+)
</a><a href="#h43-0-35" id="h43-0-35" class="i">+
</a><a href="#h43-0-36" id="h43-0-36" class="i">+type txClient interface {
</a><a href="#h43-0-37" id="h43-0-37" class="i">+	Start() error
</a><a href="#h43-0-38" id="h43-0-38" class="i">+	Stop() error
</a><a href="#h43-0-39" id="h43-0-39" class="i">+	Add(*Event)
</a><a href="#h43-0-40" id="h43-0-40" class="i">+}
</a><a href="#h43-0-41" id="h43-0-41" class="i">+
</a><a href="#h43-0-42" id="h43-0-42" class="i">+type txDefaultClient struct {
</a><a href="#h43-0-43" id="h43-0-43" class="i">+	maxBatchSize         uint          // how many events to collect into a batch before sending
</a><a href="#h43-0-44" id="h43-0-44" class="i">+	batchTimeout         time.Duration // how often to send off batches
</a><a href="#h43-0-45" id="h43-0-45" class="i">+	maxConcurrentBatches uint          // how many batches can be inflight simultaneously
</a><a href="#h43-0-46" id="h43-0-46" class="i">+	pendingWorkCapacity  uint          // how many events to allow to pile up
</a><a href="#h43-0-47" id="h43-0-47" class="i">+	blockOnSend          bool          // whether to block or drop events when the queue fills
</a><a href="#h43-0-48" id="h43-0-48" class="i">+	blockOnResponses     bool          // whether to block or drop responses when the queue fills
</a><a href="#h43-0-49" id="h43-0-49" class="i">+
</a><a href="#h43-0-50" id="h43-0-50" class="i">+	muster muster.Client
</a><a href="#h43-0-51" id="h43-0-51" class="i">+}
</a><a href="#h43-0-52" id="h43-0-52" class="i">+
</a><a href="#h43-0-53" id="h43-0-53" class="i">+func (t *txDefaultClient) Start() error {
</a><a href="#h43-0-54" id="h43-0-54" class="i">+	if t.maxBatchSize == 0 {
</a><a href="#h43-0-55" id="h43-0-55" class="i">+		t.maxBatchSize = defaultmaxBatchSize
</a><a href="#h43-0-56" id="h43-0-56" class="i">+	}
</a><a href="#h43-0-57" id="h43-0-57" class="i">+	t.muster.MaxBatchSize = t.maxBatchSize
</a><a href="#h43-0-58" id="h43-0-58" class="i">+	if t.batchTimeout == 0 {
</a><a href="#h43-0-59" id="h43-0-59" class="i">+		t.batchTimeout = defaultbatchTimeout
</a><a href="#h43-0-60" id="h43-0-60" class="i">+	}
</a><a href="#h43-0-61" id="h43-0-61" class="i">+	t.muster.BatchTimeout = t.batchTimeout
</a><a href="#h43-0-62" id="h43-0-62" class="i">+	if t.maxConcurrentBatches == 0 {
</a><a href="#h43-0-63" id="h43-0-63" class="i">+		t.maxConcurrentBatches = defaultmaxConcurrentBatches
</a><a href="#h43-0-64" id="h43-0-64" class="i">+	}
</a><a href="#h43-0-65" id="h43-0-65" class="i">+	t.muster.MaxConcurrentBatches = t.maxConcurrentBatches
</a><a href="#h43-0-66" id="h43-0-66" class="i">+	if t.pendingWorkCapacity == 0 {
</a><a href="#h43-0-67" id="h43-0-67" class="i">+		t.pendingWorkCapacity = defaultpendingWorkCapacity
</a><a href="#h43-0-68" id="h43-0-68" class="i">+	}
</a><a href="#h43-0-69" id="h43-0-69" class="i">+	t.muster.PendingWorkCapacity = t.pendingWorkCapacity
</a><a href="#h43-0-70" id="h43-0-70" class="i">+	t.muster.BatchMaker = func() muster.Batch {
</a><a href="#h43-0-71" id="h43-0-71" class="i">+		return &amp;batch{
</a><a href="#h43-0-72" id="h43-0-72" class="i">+			events:           make([]*Event, 0, t.maxBatchSize),
</a><a href="#h43-0-73" id="h43-0-73" class="i">+			n:                &amp;realNower{},
</a><a href="#h43-0-74" id="h43-0-74" class="i">+			httpClient:       &amp;http.Client{},
</a><a href="#h43-0-75" id="h43-0-75" class="i">+			blockOnResponses: t.blockOnResponses,
</a><a href="#h43-0-76" id="h43-0-76" class="i">+		}
</a><a href="#h43-0-77" id="h43-0-77" class="i">+	}
</a><a href="#h43-0-78" id="h43-0-78" class="i">+	return t.muster.Start()
</a><a href="#h43-0-79" id="h43-0-79" class="i">+}
</a><a href="#h43-0-80" id="h43-0-80" class="i">+
</a><a href="#h43-0-81" id="h43-0-81" class="i">+func (t *txDefaultClient) Stop() error {
</a><a href="#h43-0-82" id="h43-0-82" class="i">+	return t.muster.Stop()
</a><a href="#h43-0-83" id="h43-0-83" class="i">+}
</a><a href="#h43-0-84" id="h43-0-84" class="i">+
</a><a href="#h43-0-85" id="h43-0-85" class="i">+func (t *txDefaultClient) Add(ev *Event) {
</a><a href="#h43-0-86" id="h43-0-86" class="i">+	// don&#39;t block if we can&#39;t send events fast enough
</a><a href="#h43-0-87" id="h43-0-87" class="i">+	sd.Gauge(&quot;queue_length&quot;, len(t.muster.Work))
</a><a href="#h43-0-88" id="h43-0-88" class="i">+	if t.blockOnSend {
</a><a href="#h43-0-89" id="h43-0-89" class="i">+		t.muster.Work &lt;- ev
</a><a href="#h43-0-90" id="h43-0-90" class="i">+		sd.Increment(&quot;messages_queued&quot;)
</a><a href="#h43-0-91" id="h43-0-91" class="i">+	} else {
</a><a href="#h43-0-92" id="h43-0-92" class="i">+		select {
</a><a href="#h43-0-93" id="h43-0-93" class="i">+		case t.muster.Work &lt;- ev:
</a><a href="#h43-0-94" id="h43-0-94" class="i">+			sd.Increment(&quot;messages_queued&quot;)
</a><a href="#h43-0-95" id="h43-0-95" class="i">+		default:
</a><a href="#h43-0-96" id="h43-0-96" class="i">+			sd.Increment(&quot;queue_overflow&quot;)
</a><a href="#h43-0-97" id="h43-0-97" class="i">+			r := Response{
</a><a href="#h43-0-98" id="h43-0-98" class="i">+				Err:      errors.New(&quot;queue overflow&quot;),
</a><a href="#h43-0-99" id="h43-0-99" class="i">+				Metadata: ev.Metadata,
</a><a href="#h43-0-100" id="h43-0-100" class="i">+			}
</a><a href="#h43-0-101" id="h43-0-101" class="i">+			if t.blockOnResponses {
</a><a href="#h43-0-102" id="h43-0-102" class="i">+				responses &lt;- r
</a><a href="#h43-0-103" id="h43-0-103" class="i">+			} else {
</a><a href="#h43-0-104" id="h43-0-104" class="i">+				select {
</a><a href="#h43-0-105" id="h43-0-105" class="i">+				case responses &lt;- r:
</a><a href="#h43-0-106" id="h43-0-106" class="i">+				default:
</a><a href="#h43-0-107" id="h43-0-107" class="i">+				}
</a><a href="#h43-0-108" id="h43-0-108" class="i">+			}
</a><a href="#h43-0-109" id="h43-0-109" class="i">+		}
</a><a href="#h43-0-110" id="h43-0-110" class="i">+	}
</a><a href="#h43-0-111" id="h43-0-111" class="i">+}
</a><a href="#h43-0-112" id="h43-0-112" class="i">+
</a><a href="#h43-0-113" id="h43-0-113" class="i">+type txTestClient struct {
</a><a href="#h43-0-114" id="h43-0-114" class="i">+	Timestamps []time.Time
</a><a href="#h43-0-115" id="h43-0-115" class="i">+	datas      [][]byte
</a><a href="#h43-0-116" id="h43-0-116" class="i">+}
</a><a href="#h43-0-117" id="h43-0-117" class="i">+
</a><a href="#h43-0-118" id="h43-0-118" class="i">+func (t *txTestClient) Start() error {
</a><a href="#h43-0-119" id="h43-0-119" class="i">+	t.Timestamps = make([]time.Time, 0)
</a><a href="#h43-0-120" id="h43-0-120" class="i">+	t.datas = make([][]byte, 0)
</a><a href="#h43-0-121" id="h43-0-121" class="i">+	return nil
</a><a href="#h43-0-122" id="h43-0-122" class="i">+}
</a><a href="#h43-0-123" id="h43-0-123" class="i">+
</a><a href="#h43-0-124" id="h43-0-124" class="i">+func (t *txTestClient) Stop() error {
</a><a href="#h43-0-125" id="h43-0-125" class="i">+	return nil
</a><a href="#h43-0-126" id="h43-0-126" class="i">+}
</a><a href="#h43-0-127" id="h43-0-127" class="i">+
</a><a href="#h43-0-128" id="h43-0-128" class="i">+func (t *txTestClient) Add(ev *Event) {
</a><a href="#h43-0-129" id="h43-0-129" class="i">+	t.Timestamps = append(t.Timestamps, ev.Timestamp)
</a><a href="#h43-0-130" id="h43-0-130" class="i">+	blob, err := json.Marshal(ev.data)
</a><a href="#h43-0-131" id="h43-0-131" class="i">+	if err != nil {
</a><a href="#h43-0-132" id="h43-0-132" class="i">+		panic(err)
</a><a href="#h43-0-133" id="h43-0-133" class="i">+	}
</a><a href="#h43-0-134" id="h43-0-134" class="i">+	t.datas = append(t.datas, blob)
</a><a href="#h43-0-135" id="h43-0-135" class="i">+}
</a><a href="#h43-0-136" id="h43-0-136" class="i">+
</a><a href="#h43-0-137" id="h43-0-137" class="i">+type batch struct {
</a><a href="#h43-0-138" id="h43-0-138" class="i">+	events           []*Event
</a><a href="#h43-0-139" id="h43-0-139" class="i">+	n                nower
</a><a href="#h43-0-140" id="h43-0-140" class="i">+	httpClient       *http.Client
</a><a href="#h43-0-141" id="h43-0-141" class="i">+	blockOnResponses bool
</a><a href="#h43-0-142" id="h43-0-142" class="i">+}
</a><a href="#h43-0-143" id="h43-0-143" class="i">+
</a><a href="#h43-0-144" id="h43-0-144" class="i">+func (b *batch) Add(ev interface{}) {
</a><a href="#h43-0-145" id="h43-0-145" class="i">+	b.events = append(b.events, ev.(*Event))
</a><a href="#h43-0-146" id="h43-0-146" class="i">+}
</a><a href="#h43-0-147" id="h43-0-147" class="i">+
</a><a href="#h43-0-148" id="h43-0-148" class="i">+func (b *batch) Fire(notifier muster.Notifier) {
</a><a href="#h43-0-149" id="h43-0-149" class="i">+	defer notifier.Done()
</a><a href="#h43-0-150" id="h43-0-150" class="i">+	for _, e := range b.events {
</a><a href="#h43-0-151" id="h43-0-151" class="i">+		b.sendRequest(e)
</a><a href="#h43-0-152" id="h43-0-152" class="i">+	}
</a><a href="#h43-0-153" id="h43-0-153" class="i">+}
</a><a href="#h43-0-154" id="h43-0-154" class="i">+
</a><a href="#h43-0-155" id="h43-0-155" class="i">+// sendRequest sends an individual request to Honeycomb and returns
</a><a href="#h43-0-156" id="h43-0-156" class="i">+func (b *batch) sendRequest(e *Event) {
</a><a href="#h43-0-157" id="h43-0-157" class="i">+	start := b.n.Now()
</a><a href="#h43-0-158" id="h43-0-158" class="i">+	timestamp := e.Timestamp
</a><a href="#h43-0-159" id="h43-0-159" class="i">+	blob, err := json.Marshal(e.data)
</a><a href="#h43-0-160" id="h43-0-160" class="i">+	if err != nil {
</a><a href="#h43-0-161" id="h43-0-161" class="i">+		// TODO add logging or something to raise this error
</a><a href="#h43-0-162" id="h43-0-162" class="i">+		sd.Increment(&quot;json_marshal_errors&quot;)
</a><a href="#h43-0-163" id="h43-0-163" class="i">+		return
</a><a href="#h43-0-164" id="h43-0-164" class="i">+	}
</a><a href="#h43-0-165" id="h43-0-165" class="i">+
</a><a href="#h43-0-166" id="h43-0-166" class="i">+	userAgent := fmt.Sprintf(&quot;libhoney-go/%s&quot;, version)
</a><a href="#h43-0-167" id="h43-0-167" class="i">+	if UserAgentAddition != &quot;&quot; {
</a><a href="#h43-0-168" id="h43-0-168" class="i">+		userAgent = fmt.Sprintf(&quot;%s %s&quot;, userAgent, strings.TrimSpace(UserAgentAddition))
</a><a href="#h43-0-169" id="h43-0-169" class="i">+	}
</a><a href="#h43-0-170" id="h43-0-170" class="i">+
</a><a href="#h43-0-171" id="h43-0-171" class="i">+	url := fmt.Sprintf(&quot;%s/1/events/%s&quot;, e.APIHost, e.Dataset)
</a><a href="#h43-0-172" id="h43-0-172" class="i">+	req, err := http.NewRequest(&quot;POST&quot;, url, bytes.NewBuffer(blob))
</a><a href="#h43-0-173" id="h43-0-173" class="i">+	req.Header.Set(&quot;User-Agent&quot;, userAgent)
</a><a href="#h43-0-174" id="h43-0-174" class="i">+	req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
</a><a href="#h43-0-175" id="h43-0-175" class="i">+	req.Header.Add(&quot;X-Honeycomb-Team&quot;, e.WriteKey)
</a><a href="#h43-0-176" id="h43-0-176" class="i">+	req.Header.Add(&quot;X-Event-Time&quot;, timestamp.Format(time.RFC3339))
</a><a href="#h43-0-177" id="h43-0-177" class="i">+	req.Header.Add(&quot;X-Honeycomb-SampleRate&quot;, strconv.Itoa(int(e.SampleRate)))
</a><a href="#h43-0-178" id="h43-0-178" class="i">+
</a><a href="#h43-0-179" id="h43-0-179" class="i">+	resp, err := b.httpClient.Do(req)
</a><a href="#h43-0-180" id="h43-0-180" class="i">+
</a><a href="#h43-0-181" id="h43-0-181" class="i">+	dur := b.n.Now().Sub(start)
</a><a href="#h43-0-182" id="h43-0-182" class="i">+	evResp := Response{}
</a><a href="#h43-0-183" id="h43-0-183" class="i">+	if !b.blockOnResponses {
</a><a href="#h43-0-184" id="h43-0-184" class="i">+		defer func() {
</a><a href="#h43-0-185" id="h43-0-185" class="i">+			select {
</a><a href="#h43-0-186" id="h43-0-186" class="i">+			case responses &lt;- evResp:
</a><a href="#h43-0-187" id="h43-0-187" class="i">+			default:
</a><a href="#h43-0-188" id="h43-0-188" class="i">+			}
</a><a href="#h43-0-189" id="h43-0-189" class="i">+		}()
</a><a href="#h43-0-190" id="h43-0-190" class="i">+	}
</a><a href="#h43-0-191" id="h43-0-191" class="i">+	evResp.Duration = dur
</a><a href="#h43-0-192" id="h43-0-192" class="i">+	evResp.Metadata = e.Metadata
</a><a href="#h43-0-193" id="h43-0-193" class="i">+	if err != nil {
</a><a href="#h43-0-194" id="h43-0-194" class="i">+		// TODO add logging or something to raise this error
</a><a href="#h43-0-195" id="h43-0-195" class="i">+		sd.Increment(&quot;send_errors&quot;)
</a><a href="#h43-0-196" id="h43-0-196" class="i">+		evResp.Err = err
</a><a href="#h43-0-197" id="h43-0-197" class="i">+		if b.blockOnResponses {
</a><a href="#h43-0-198" id="h43-0-198" class="i">+			responses &lt;- evResp
</a><a href="#h43-0-199" id="h43-0-199" class="i">+		}
</a><a href="#h43-0-200" id="h43-0-200" class="i">+		return
</a><a href="#h43-0-201" id="h43-0-201" class="i">+	}
</a><a href="#h43-0-202" id="h43-0-202" class="i">+	sd.Increment(&quot;messages_sent&quot;)
</a><a href="#h43-0-203" id="h43-0-203" class="i">+	defer resp.Body.Close()
</a><a href="#h43-0-204" id="h43-0-204" class="i">+	evResp.StatusCode = resp.StatusCode
</a><a href="#h43-0-205" id="h43-0-205" class="i">+	body, _ := ioutil.ReadAll(resp.Body)
</a><a href="#h43-0-206" id="h43-0-206" class="i">+	evResp.Body = body
</a><a href="#h43-0-207" id="h43-0-207" class="i">+	if b.blockOnResponses {
</a><a href="#h43-0-208" id="h43-0-208" class="i">+		responses &lt;- evResp
</a><a href="#h43-0-209" id="h43-0-209" class="i">+	}
</a><a href="#h43-0-210" id="h43-0-210" class="i">+}
</a><a href="#h43-0-211" id="h43-0-211" class="i">+
</a><a href="#h43-0-212" id="h43-0-212" class="i">+// nower to make testing easier
</a><a href="#h43-0-213" id="h43-0-213" class="i">+type nower interface {
</a><a href="#h43-0-214" id="h43-0-214" class="i">+	Now() time.Time
</a><a href="#h43-0-215" id="h43-0-215" class="i">+}
</a><a href="#h43-0-216" id="h43-0-216" class="i">+
</a><a href="#h43-0-217" id="h43-0-217" class="i">+type realNower struct{}
</a><a href="#h43-0-218" id="h43-0-218" class="i">+
</a><a href="#h43-0-219" id="h43-0-219" class="i">+func (r *realNower) Now() time.Time {
</a><a href="#h43-0-220" id="h43-0-220" class="i">+	return time.Now().UTC()
</a><a href="#h43-0-221" id="h43-0-221" class="i">+}
</a><b>diff --git a/<a id="h44" href="../file/vendor/golang.org/x/net/context/BUILD">vendor/golang.org/x/net/context/BUILD</a> b/<a href="../file/vendor/golang.org/x/net/context/BUILD">vendor/golang.org/x/net/context/BUILD</a></b>
<a href="#h44-0" id="h44-0" class="h">@@ -9,7 +9,7 @@ go_library(
</a> name = &quot;go_default_library&quot;,
   srcs = [
     &quot;context.go&quot;,
<a href="#h44-0-3" id="h44-0-3" class="d">-    &quot;pre_go17.go&quot;,
</a><a href="#h44-0-4" id="h44-0-4" class="i">+    &quot;go17.go&quot;,
</a>   ],
   deps = [
   ],
<b>diff --git a/<a id="h45" href="../file/vendor/google.golang.org/appengine/LICENSE">vendor/google.golang.org/appengine/LICENSE</a> b/<a href="../file/vendor/google.golang.org/appengine/LICENSE">vendor/google.golang.org/appengine/LICENSE</a></b>
<a href="#h45-0" id="h45-0" class="h">@@ -0,0 +1,202 @@
</a><a href="#h45-0-0" id="h45-0-0" class="i">+
</a><a href="#h45-0-1" id="h45-0-1" class="i">+                                 Apache License
</a><a href="#h45-0-2" id="h45-0-2" class="i">+                           Version 2.0, January 2004
</a><a href="#h45-0-3" id="h45-0-3" class="i">+                        http://www.apache.org/licenses/
</a><a href="#h45-0-4" id="h45-0-4" class="i">+
</a><a href="#h45-0-5" id="h45-0-5" class="i">+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
</a><a href="#h45-0-6" id="h45-0-6" class="i">+
</a><a href="#h45-0-7" id="h45-0-7" class="i">+   1. Definitions.
</a><a href="#h45-0-8" id="h45-0-8" class="i">+
</a><a href="#h45-0-9" id="h45-0-9" class="i">+      &quot;License&quot; shall mean the terms and conditions for use, reproduction,
</a><a href="#h45-0-10" id="h45-0-10" class="i">+      and distribution as defined by Sections 1 through 9 of this document.
</a><a href="#h45-0-11" id="h45-0-11" class="i">+
</a><a href="#h45-0-12" id="h45-0-12" class="i">+      &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
</a><a href="#h45-0-13" id="h45-0-13" class="i">+      the copyright owner that is granting the License.
</a><a href="#h45-0-14" id="h45-0-14" class="i">+
</a><a href="#h45-0-15" id="h45-0-15" class="i">+      &quot;Legal Entity&quot; shall mean the union of the acting entity and all
</a><a href="#h45-0-16" id="h45-0-16" class="i">+      other entities that control, are controlled by, or are under common
</a><a href="#h45-0-17" id="h45-0-17" class="i">+      control with that entity. For the purposes of this definition,
</a><a href="#h45-0-18" id="h45-0-18" class="i">+      &quot;control&quot; means (i) the power, direct or indirect, to cause the
</a><a href="#h45-0-19" id="h45-0-19" class="i">+      direction or management of such entity, whether by contract or
</a><a href="#h45-0-20" id="h45-0-20" class="i">+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
</a><a href="#h45-0-21" id="h45-0-21" class="i">+      outstanding shares, or (iii) beneficial ownership of such entity.
</a><a href="#h45-0-22" id="h45-0-22" class="i">+
</a><a href="#h45-0-23" id="h45-0-23" class="i">+      &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
</a><a href="#h45-0-24" id="h45-0-24" class="i">+      exercising permissions granted by this License.
</a><a href="#h45-0-25" id="h45-0-25" class="i">+
</a><a href="#h45-0-26" id="h45-0-26" class="i">+      &quot;Source&quot; form shall mean the preferred form for making modifications,
</a><a href="#h45-0-27" id="h45-0-27" class="i">+      including but not limited to software source code, documentation
</a><a href="#h45-0-28" id="h45-0-28" class="i">+      source, and configuration files.
</a><a href="#h45-0-29" id="h45-0-29" class="i">+
</a><a href="#h45-0-30" id="h45-0-30" class="i">+      &quot;Object&quot; form shall mean any form resulting from mechanical
</a><a href="#h45-0-31" id="h45-0-31" class="i">+      transformation or translation of a Source form, including but
</a><a href="#h45-0-32" id="h45-0-32" class="i">+      not limited to compiled object code, generated documentation,
</a><a href="#h45-0-33" id="h45-0-33" class="i">+      and conversions to other media types.
</a><a href="#h45-0-34" id="h45-0-34" class="i">+
</a><a href="#h45-0-35" id="h45-0-35" class="i">+      &quot;Work&quot; shall mean the work of authorship, whether in Source or
</a><a href="#h45-0-36" id="h45-0-36" class="i">+      Object form, made available under the License, as indicated by a
</a><a href="#h45-0-37" id="h45-0-37" class="i">+      copyright notice that is included in or attached to the work
</a><a href="#h45-0-38" id="h45-0-38" class="i">+      (an example is provided in the Appendix below).
</a><a href="#h45-0-39" id="h45-0-39" class="i">+
</a><a href="#h45-0-40" id="h45-0-40" class="i">+      &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
</a><a href="#h45-0-41" id="h45-0-41" class="i">+      form, that is based on (or derived from) the Work and for which the
</a><a href="#h45-0-42" id="h45-0-42" class="i">+      editorial revisions, annotations, elaborations, or other modifications
</a><a href="#h45-0-43" id="h45-0-43" class="i">+      represent, as a whole, an original work of authorship. For the purposes
</a><a href="#h45-0-44" id="h45-0-44" class="i">+      of this License, Derivative Works shall not include works that remain
</a><a href="#h45-0-45" id="h45-0-45" class="i">+      separable from, or merely link (or bind by name) to the interfaces of,
</a><a href="#h45-0-46" id="h45-0-46" class="i">+      the Work and Derivative Works thereof.
</a><a href="#h45-0-47" id="h45-0-47" class="i">+
</a><a href="#h45-0-48" id="h45-0-48" class="i">+      &quot;Contribution&quot; shall mean any work of authorship, including
</a><a href="#h45-0-49" id="h45-0-49" class="i">+      the original version of the Work and any modifications or additions
</a><a href="#h45-0-50" id="h45-0-50" class="i">+      to that Work or Derivative Works thereof, that is intentionally
</a><a href="#h45-0-51" id="h45-0-51" class="i">+      submitted to Licensor for inclusion in the Work by the copyright owner
</a><a href="#h45-0-52" id="h45-0-52" class="i">+      or by an individual or Legal Entity authorized to submit on behalf of
</a><a href="#h45-0-53" id="h45-0-53" class="i">+      the copyright owner. For the purposes of this definition, &quot;submitted&quot;
</a><a href="#h45-0-54" id="h45-0-54" class="i">+      means any form of electronic, verbal, or written communication sent
</a><a href="#h45-0-55" id="h45-0-55" class="i">+      to the Licensor or its representatives, including but not limited to
</a><a href="#h45-0-56" id="h45-0-56" class="i">+      communication on electronic mailing lists, source code control systems,
</a><a href="#h45-0-57" id="h45-0-57" class="i">+      and issue tracking systems that are managed by, or on behalf of, the
</a><a href="#h45-0-58" id="h45-0-58" class="i">+      Licensor for the purpose of discussing and improving the Work, but
</a><a href="#h45-0-59" id="h45-0-59" class="i">+      excluding communication that is conspicuously marked or otherwise
</a><a href="#h45-0-60" id="h45-0-60" class="i">+      designated in writing by the copyright owner as &quot;Not a Contribution.&quot;
</a><a href="#h45-0-61" id="h45-0-61" class="i">+
</a><a href="#h45-0-62" id="h45-0-62" class="i">+      &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
</a><a href="#h45-0-63" id="h45-0-63" class="i">+      on behalf of whom a Contribution has been received by Licensor and
</a><a href="#h45-0-64" id="h45-0-64" class="i">+      subsequently incorporated within the Work.
</a><a href="#h45-0-65" id="h45-0-65" class="i">+
</a><a href="#h45-0-66" id="h45-0-66" class="i">+   2. Grant of Copyright License. Subject to the terms and conditions of
</a><a href="#h45-0-67" id="h45-0-67" class="i">+      this License, each Contributor hereby grants to You a perpetual,
</a><a href="#h45-0-68" id="h45-0-68" class="i">+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
</a><a href="#h45-0-69" id="h45-0-69" class="i">+      copyright license to reproduce, prepare Derivative Works of,
</a><a href="#h45-0-70" id="h45-0-70" class="i">+      publicly display, publicly perform, sublicense, and distribute the
</a><a href="#h45-0-71" id="h45-0-71" class="i">+      Work and such Derivative Works in Source or Object form.
</a><a href="#h45-0-72" id="h45-0-72" class="i">+
</a><a href="#h45-0-73" id="h45-0-73" class="i">+   3. Grant of Patent License. Subject to the terms and conditions of
</a><a href="#h45-0-74" id="h45-0-74" class="i">+      this License, each Contributor hereby grants to You a perpetual,
</a><a href="#h45-0-75" id="h45-0-75" class="i">+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
</a><a href="#h45-0-76" id="h45-0-76" class="i">+      (except as stated in this section) patent license to make, have made,
</a><a href="#h45-0-77" id="h45-0-77" class="i">+      use, offer to sell, sell, import, and otherwise transfer the Work,
</a><a href="#h45-0-78" id="h45-0-78" class="i">+      where such license applies only to those patent claims licensable
</a><a href="#h45-0-79" id="h45-0-79" class="i">+      by such Contributor that are necessarily infringed by their
</a><a href="#h45-0-80" id="h45-0-80" class="i">+      Contribution(s) alone or by combination of their Contribution(s)
</a><a href="#h45-0-81" id="h45-0-81" class="i">+      with the Work to which such Contribution(s) was submitted. If You
</a><a href="#h45-0-82" id="h45-0-82" class="i">+      institute patent litigation against any entity (including a
</a><a href="#h45-0-83" id="h45-0-83" class="i">+      cross-claim or counterclaim in a lawsuit) alleging that the Work
</a><a href="#h45-0-84" id="h45-0-84" class="i">+      or a Contribution incorporated within the Work constitutes direct
</a><a href="#h45-0-85" id="h45-0-85" class="i">+      or contributory patent infringement, then any patent licenses
</a><a href="#h45-0-86" id="h45-0-86" class="i">+      granted to You under this License for that Work shall terminate
</a><a href="#h45-0-87" id="h45-0-87" class="i">+      as of the date such litigation is filed.
</a><a href="#h45-0-88" id="h45-0-88" class="i">+
</a><a href="#h45-0-89" id="h45-0-89" class="i">+   4. Redistribution. You may reproduce and distribute copies of the
</a><a href="#h45-0-90" id="h45-0-90" class="i">+      Work or Derivative Works thereof in any medium, with or without
</a><a href="#h45-0-91" id="h45-0-91" class="i">+      modifications, and in Source or Object form, provided that You
</a><a href="#h45-0-92" id="h45-0-92" class="i">+      meet the following conditions:
</a><a href="#h45-0-93" id="h45-0-93" class="i">+
</a><a href="#h45-0-94" id="h45-0-94" class="i">+      (a) You must give any other recipients of the Work or
</a><a href="#h45-0-95" id="h45-0-95" class="i">+          Derivative Works a copy of this License; and
</a><a href="#h45-0-96" id="h45-0-96" class="i">+
</a><a href="#h45-0-97" id="h45-0-97" class="i">+      (b) You must cause any modified files to carry prominent notices
</a><a href="#h45-0-98" id="h45-0-98" class="i">+          stating that You changed the files; and
</a><a href="#h45-0-99" id="h45-0-99" class="i">+
</a><a href="#h45-0-100" id="h45-0-100" class="i">+      (c) You must retain, in the Source form of any Derivative Works
</a><a href="#h45-0-101" id="h45-0-101" class="i">+          that You distribute, all copyright, patent, trademark, and
</a><a href="#h45-0-102" id="h45-0-102" class="i">+          attribution notices from the Source form of the Work,
</a><a href="#h45-0-103" id="h45-0-103" class="i">+          excluding those notices that do not pertain to any part of
</a><a href="#h45-0-104" id="h45-0-104" class="i">+          the Derivative Works; and
</a><a href="#h45-0-105" id="h45-0-105" class="i">+
</a><a href="#h45-0-106" id="h45-0-106" class="i">+      (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
</a><a href="#h45-0-107" id="h45-0-107" class="i">+          distribution, then any Derivative Works that You distribute must
</a><a href="#h45-0-108" id="h45-0-108" class="i">+          include a readable copy of the attribution notices contained
</a><a href="#h45-0-109" id="h45-0-109" class="i">+          within such NOTICE file, excluding those notices that do not
</a><a href="#h45-0-110" id="h45-0-110" class="i">+          pertain to any part of the Derivative Works, in at least one
</a><a href="#h45-0-111" id="h45-0-111" class="i">+          of the following places: within a NOTICE text file distributed
</a><a href="#h45-0-112" id="h45-0-112" class="i">+          as part of the Derivative Works; within the Source form or
</a><a href="#h45-0-113" id="h45-0-113" class="i">+          documentation, if provided along with the Derivative Works; or,
</a><a href="#h45-0-114" id="h45-0-114" class="i">+          within a display generated by the Derivative Works, if and
</a><a href="#h45-0-115" id="h45-0-115" class="i">+          wherever such third-party notices normally appear. The contents
</a><a href="#h45-0-116" id="h45-0-116" class="i">+          of the NOTICE file are for informational purposes only and
</a><a href="#h45-0-117" id="h45-0-117" class="i">+          do not modify the License. You may add Your own attribution
</a><a href="#h45-0-118" id="h45-0-118" class="i">+          notices within Derivative Works that You distribute, alongside
</a><a href="#h45-0-119" id="h45-0-119" class="i">+          or as an addendum to the NOTICE text from the Work, provided
</a><a href="#h45-0-120" id="h45-0-120" class="i">+          that such additional attribution notices cannot be construed
</a><a href="#h45-0-121" id="h45-0-121" class="i">+          as modifying the License.
</a><a href="#h45-0-122" id="h45-0-122" class="i">+
</a><a href="#h45-0-123" id="h45-0-123" class="i">+      You may add Your own copyright statement to Your modifications and
</a><a href="#h45-0-124" id="h45-0-124" class="i">+      may provide additional or different license terms and conditions
</a><a href="#h45-0-125" id="h45-0-125" class="i">+      for use, reproduction, or distribution of Your modifications, or
</a><a href="#h45-0-126" id="h45-0-126" class="i">+      for any such Derivative Works as a whole, provided Your use,
</a><a href="#h45-0-127" id="h45-0-127" class="i">+      reproduction, and distribution of the Work otherwise complies with
</a><a href="#h45-0-128" id="h45-0-128" class="i">+      the conditions stated in this License.
</a><a href="#h45-0-129" id="h45-0-129" class="i">+
</a><a href="#h45-0-130" id="h45-0-130" class="i">+   5. Submission of Contributions. Unless You explicitly state otherwise,
</a><a href="#h45-0-131" id="h45-0-131" class="i">+      any Contribution intentionally submitted for inclusion in the Work
</a><a href="#h45-0-132" id="h45-0-132" class="i">+      by You to the Licensor shall be under the terms and conditions of
</a><a href="#h45-0-133" id="h45-0-133" class="i">+      this License, without any additional terms or conditions.
</a><a href="#h45-0-134" id="h45-0-134" class="i">+      Notwithstanding the above, nothing herein shall supersede or modify
</a><a href="#h45-0-135" id="h45-0-135" class="i">+      the terms of any separate license agreement you may have executed
</a><a href="#h45-0-136" id="h45-0-136" class="i">+      with Licensor regarding such Contributions.
</a><a href="#h45-0-137" id="h45-0-137" class="i">+
</a><a href="#h45-0-138" id="h45-0-138" class="i">+   6. Trademarks. This License does not grant permission to use the trade
</a><a href="#h45-0-139" id="h45-0-139" class="i">+      names, trademarks, service marks, or product names of the Licensor,
</a><a href="#h45-0-140" id="h45-0-140" class="i">+      except as required for reasonable and customary use in describing the
</a><a href="#h45-0-141" id="h45-0-141" class="i">+      origin of the Work and reproducing the content of the NOTICE file.
</a><a href="#h45-0-142" id="h45-0-142" class="i">+
</a><a href="#h45-0-143" id="h45-0-143" class="i">+   7. Disclaimer of Warranty. Unless required by applicable law or
</a><a href="#h45-0-144" id="h45-0-144" class="i">+      agreed to in writing, Licensor provides the Work (and each
</a><a href="#h45-0-145" id="h45-0-145" class="i">+      Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
</a><a href="#h45-0-146" id="h45-0-146" class="i">+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
</a><a href="#h45-0-147" id="h45-0-147" class="i">+      implied, including, without limitation, any warranties or conditions
</a><a href="#h45-0-148" id="h45-0-148" class="i">+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
</a><a href="#h45-0-149" id="h45-0-149" class="i">+      PARTICULAR PURPOSE. You are solely responsible for determining the
</a><a href="#h45-0-150" id="h45-0-150" class="i">+      appropriateness of using or redistributing the Work and assume any
</a><a href="#h45-0-151" id="h45-0-151" class="i">+      risks associated with Your exercise of permissions under this License.
</a><a href="#h45-0-152" id="h45-0-152" class="i">+
</a><a href="#h45-0-153" id="h45-0-153" class="i">+   8. Limitation of Liability. In no event and under no legal theory,
</a><a href="#h45-0-154" id="h45-0-154" class="i">+      whether in tort (including negligence), contract, or otherwise,
</a><a href="#h45-0-155" id="h45-0-155" class="i">+      unless required by applicable law (such as deliberate and grossly
</a><a href="#h45-0-156" id="h45-0-156" class="i">+      negligent acts) or agreed to in writing, shall any Contributor be
</a><a href="#h45-0-157" id="h45-0-157" class="i">+      liable to You for damages, including any direct, indirect, special,
</a><a href="#h45-0-158" id="h45-0-158" class="i">+      incidental, or consequential damages of any character arising as a
</a><a href="#h45-0-159" id="h45-0-159" class="i">+      result of this License or out of the use or inability to use the
</a><a href="#h45-0-160" id="h45-0-160" class="i">+      Work (including but not limited to damages for loss of goodwill,
</a><a href="#h45-0-161" id="h45-0-161" class="i">+      work stoppage, computer failure or malfunction, or any and all
</a><a href="#h45-0-162" id="h45-0-162" class="i">+      other commercial damages or losses), even if such Contributor
</a><a href="#h45-0-163" id="h45-0-163" class="i">+      has been advised of the possibility of such damages.
</a><a href="#h45-0-164" id="h45-0-164" class="i">+
</a><a href="#h45-0-165" id="h45-0-165" class="i">+   9. Accepting Warranty or Additional Liability. While redistributing
</a><a href="#h45-0-166" id="h45-0-166" class="i">+      the Work or Derivative Works thereof, You may choose to offer,
</a><a href="#h45-0-167" id="h45-0-167" class="i">+      and charge a fee for, acceptance of support, warranty, indemnity,
</a><a href="#h45-0-168" id="h45-0-168" class="i">+      or other liability obligations and/or rights consistent with this
</a><a href="#h45-0-169" id="h45-0-169" class="i">+      License. However, in accepting such obligations, You may act only
</a><a href="#h45-0-170" id="h45-0-170" class="i">+      on Your own behalf and on Your sole responsibility, not on behalf
</a><a href="#h45-0-171" id="h45-0-171" class="i">+      of any other Contributor, and only if You agree to indemnify,
</a><a href="#h45-0-172" id="h45-0-172" class="i">+      defend, and hold each Contributor harmless for any liability
</a><a href="#h45-0-173" id="h45-0-173" class="i">+      incurred by, or claims asserted against, such Contributor by reason
</a><a href="#h45-0-174" id="h45-0-174" class="i">+      of your accepting any such warranty or additional liability.
</a><a href="#h45-0-175" id="h45-0-175" class="i">+
</a><a href="#h45-0-176" id="h45-0-176" class="i">+   END OF TERMS AND CONDITIONS
</a><a href="#h45-0-177" id="h45-0-177" class="i">+
</a><a href="#h45-0-178" id="h45-0-178" class="i">+   APPENDIX: How to apply the Apache License to your work.
</a><a href="#h45-0-179" id="h45-0-179" class="i">+
</a><a href="#h45-0-180" id="h45-0-180" class="i">+      To apply the Apache License to your work, attach the following
</a><a href="#h45-0-181" id="h45-0-181" class="i">+      boilerplate notice, with the fields enclosed by brackets &quot;[]&quot;
</a><a href="#h45-0-182" id="h45-0-182" class="i">+      replaced with your own identifying information. (Don&#39;t include
</a><a href="#h45-0-183" id="h45-0-183" class="i">+      the brackets!)  The text should be enclosed in the appropriate
</a><a href="#h45-0-184" id="h45-0-184" class="i">+      comment syntax for the file format. We also recommend that a
</a><a href="#h45-0-185" id="h45-0-185" class="i">+      file or class name and description of purpose be included on the
</a><a href="#h45-0-186" id="h45-0-186" class="i">+      same &quot;printed page&quot; as the copyright notice for easier
</a><a href="#h45-0-187" id="h45-0-187" class="i">+      identification within third-party archives.
</a><a href="#h45-0-188" id="h45-0-188" class="i">+
</a><a href="#h45-0-189" id="h45-0-189" class="i">+   Copyright [yyyy] [name of copyright owner]
</a><a href="#h45-0-190" id="h45-0-190" class="i">+
</a><a href="#h45-0-191" id="h45-0-191" class="i">+   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</a><a href="#h45-0-192" id="h45-0-192" class="i">+   you may not use this file except in compliance with the License.
</a><a href="#h45-0-193" id="h45-0-193" class="i">+   You may obtain a copy of the License at
</a><a href="#h45-0-194" id="h45-0-194" class="i">+
</a><a href="#h45-0-195" id="h45-0-195" class="i">+       http://www.apache.org/licenses/LICENSE-2.0
</a><a href="#h45-0-196" id="h45-0-196" class="i">+
</a><a href="#h45-0-197" id="h45-0-197" class="i">+   Unless required by applicable law or agreed to in writing, software
</a><a href="#h45-0-198" id="h45-0-198" class="i">+   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</a><a href="#h45-0-199" id="h45-0-199" class="i">+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</a><a href="#h45-0-200" id="h45-0-200" class="i">+   See the License for the specific language governing permissions and
</a><a href="#h45-0-201" id="h45-0-201" class="i">+   limitations under the License.
</a><b>diff --git a/<a id="h46" href="../file/vendor/google.golang.org/appengine/internal/BUILD">vendor/google.golang.org/appengine/internal/BUILD</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/BUILD">vendor/google.golang.org/appengine/internal/BUILD</a></b>
<a href="#h46-0" id="h46-0" class="h">@@ -0,0 +1,33 @@
</a><a href="#h46-0-0" id="h46-0-0" class="i">+
</a><a href="#h46-0-1" id="h46-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h46-0-2" id="h46-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h46-0-3" id="h46-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h46-0-4" id="h46-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h46-0-5" id="h46-0-5" class="i">+)
</a><a href="#h46-0-6" id="h46-0-6" class="i">+
</a><a href="#h46-0-7" id="h46-0-7" class="i">+go_library(
</a><a href="#h46-0-8" id="h46-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h46-0-9" id="h46-0-9" class="i">+  srcs = [
</a><a href="#h46-0-10" id="h46-0-10" class="i">+    &quot;api.go&quot;,
</a><a href="#h46-0-11" id="h46-0-11" class="i">+    &quot;api_common.go&quot;,
</a><a href="#h46-0-12" id="h46-0-12" class="i">+    &quot;app_id.go&quot;,
</a><a href="#h46-0-13" id="h46-0-13" class="i">+    &quot;identity.go&quot;,
</a><a href="#h46-0-14" id="h46-0-14" class="i">+    &quot;identity_vm.go&quot;,
</a><a href="#h46-0-15" id="h46-0-15" class="i">+    &quot;internal.go&quot;,
</a><a href="#h46-0-16" id="h46-0-16" class="i">+    &quot;main_vm.go&quot;,
</a><a href="#h46-0-17" id="h46-0-17" class="i">+    &quot;metadata.go&quot;,
</a><a href="#h46-0-18" id="h46-0-18" class="i">+    &quot;net.go&quot;,
</a><a href="#h46-0-19" id="h46-0-19" class="i">+    &quot;transaction.go&quot;,
</a><a href="#h46-0-20" id="h46-0-20" class="i">+  ],
</a><a href="#h46-0-21" id="h46-0-21" class="i">+  deps = [
</a><a href="#h46-0-22" id="h46-0-22" class="i">+    &quot;//vendor/github.com/golang/protobuf/proto:go_default_library&quot;,
</a><a href="#h46-0-23" id="h46-0-23" class="i">+    &quot;//vendor/golang.org/x/net/context:go_default_library&quot;,
</a><a href="#h46-0-24" id="h46-0-24" class="i">+    &quot;//vendor/google.golang.org/appengine/internal/base:go_default_library&quot;,
</a><a href="#h46-0-25" id="h46-0-25" class="i">+    &quot;//vendor/google.golang.org/appengine/internal/datastore:go_default_library&quot;,
</a><a href="#h46-0-26" id="h46-0-26" class="i">+    &quot;//vendor/google.golang.org/appengine/internal/log:go_default_library&quot;,
</a><a href="#h46-0-27" id="h46-0-27" class="i">+    &quot;//vendor/google.golang.org/appengine/internal/remote_api:go_default_library&quot;,
</a><a href="#h46-0-28" id="h46-0-28" class="i">+  ],
</a><a href="#h46-0-29" id="h46-0-29" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h46-0-30" id="h46-0-30" class="i">+)
</a><a href="#h46-0-31" id="h46-0-31" class="i">+
</a><a href="#h46-0-32" id="h46-0-32" class="i">+
</a><b>diff --git a/<a id="h47" href="../file/vendor/google.golang.org/appengine/internal/api.go">vendor/google.golang.org/appengine/internal/api.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/api.go">vendor/google.golang.org/appengine/internal/api.go</a></b>
<a href="#h47-0" id="h47-0" class="h">@@ -0,0 +1,646 @@
</a><a href="#h47-0-0" id="h47-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h47-0-1" id="h47-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h47-0-2" id="h47-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h47-0-3" id="h47-0-3" class="i">+
</a><a href="#h47-0-4" id="h47-0-4" class="i">+// +build !appengine
</a><a href="#h47-0-5" id="h47-0-5" class="i">+
</a><a href="#h47-0-6" id="h47-0-6" class="i">+package internal
</a><a href="#h47-0-7" id="h47-0-7" class="i">+
</a><a href="#h47-0-8" id="h47-0-8" class="i">+import (
</a><a href="#h47-0-9" id="h47-0-9" class="i">+	&quot;bytes&quot;
</a><a href="#h47-0-10" id="h47-0-10" class="i">+	&quot;errors&quot;
</a><a href="#h47-0-11" id="h47-0-11" class="i">+	&quot;fmt&quot;
</a><a href="#h47-0-12" id="h47-0-12" class="i">+	&quot;io/ioutil&quot;
</a><a href="#h47-0-13" id="h47-0-13" class="i">+	&quot;log&quot;
</a><a href="#h47-0-14" id="h47-0-14" class="i">+	&quot;net&quot;
</a><a href="#h47-0-15" id="h47-0-15" class="i">+	&quot;net/http&quot;
</a><a href="#h47-0-16" id="h47-0-16" class="i">+	&quot;net/url&quot;
</a><a href="#h47-0-17" id="h47-0-17" class="i">+	&quot;os&quot;
</a><a href="#h47-0-18" id="h47-0-18" class="i">+	&quot;runtime&quot;
</a><a href="#h47-0-19" id="h47-0-19" class="i">+	&quot;strconv&quot;
</a><a href="#h47-0-20" id="h47-0-20" class="i">+	&quot;strings&quot;
</a><a href="#h47-0-21" id="h47-0-21" class="i">+	&quot;sync&quot;
</a><a href="#h47-0-22" id="h47-0-22" class="i">+	&quot;sync/atomic&quot;
</a><a href="#h47-0-23" id="h47-0-23" class="i">+	&quot;time&quot;
</a><a href="#h47-0-24" id="h47-0-24" class="i">+
</a><a href="#h47-0-25" id="h47-0-25" class="i">+	&quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h47-0-26" id="h47-0-26" class="i">+	netcontext &quot;golang.org/x/net/context&quot;
</a><a href="#h47-0-27" id="h47-0-27" class="i">+
</a><a href="#h47-0-28" id="h47-0-28" class="i">+	basepb &quot;google.golang.org/appengine/internal/base&quot;
</a><a href="#h47-0-29" id="h47-0-29" class="i">+	logpb &quot;google.golang.org/appengine/internal/log&quot;
</a><a href="#h47-0-30" id="h47-0-30" class="i">+	remotepb &quot;google.golang.org/appengine/internal/remote_api&quot;
</a><a href="#h47-0-31" id="h47-0-31" class="i">+)
</a><a href="#h47-0-32" id="h47-0-32" class="i">+
</a><a href="#h47-0-33" id="h47-0-33" class="i">+const (
</a><a href="#h47-0-34" id="h47-0-34" class="i">+	apiPath = &quot;/rpc_http&quot;
</a><a href="#h47-0-35" id="h47-0-35" class="i">+)
</a><a href="#h47-0-36" id="h47-0-36" class="i">+
</a><a href="#h47-0-37" id="h47-0-37" class="i">+var (
</a><a href="#h47-0-38" id="h47-0-38" class="i">+	// Incoming headers.
</a><a href="#h47-0-39" id="h47-0-39" class="i">+	ticketHeader       = http.CanonicalHeaderKey(&quot;X-AppEngine-API-Ticket&quot;)
</a><a href="#h47-0-40" id="h47-0-40" class="i">+	dapperHeader       = http.CanonicalHeaderKey(&quot;X-Google-DapperTraceInfo&quot;)
</a><a href="#h47-0-41" id="h47-0-41" class="i">+	traceHeader        = http.CanonicalHeaderKey(&quot;X-Cloud-Trace-Context&quot;)
</a><a href="#h47-0-42" id="h47-0-42" class="i">+	curNamespaceHeader = http.CanonicalHeaderKey(&quot;X-AppEngine-Current-Namespace&quot;)
</a><a href="#h47-0-43" id="h47-0-43" class="i">+	userIPHeader       = http.CanonicalHeaderKey(&quot;X-AppEngine-User-IP&quot;)
</a><a href="#h47-0-44" id="h47-0-44" class="i">+	remoteAddrHeader   = http.CanonicalHeaderKey(&quot;X-AppEngine-Remote-Addr&quot;)
</a><a href="#h47-0-45" id="h47-0-45" class="i">+
</a><a href="#h47-0-46" id="h47-0-46" class="i">+	// Outgoing headers.
</a><a href="#h47-0-47" id="h47-0-47" class="i">+	apiEndpointHeader      = http.CanonicalHeaderKey(&quot;X-Google-RPC-Service-Endpoint&quot;)
</a><a href="#h47-0-48" id="h47-0-48" class="i">+	apiEndpointHeaderValue = []string{&quot;app-engine-apis&quot;}
</a><a href="#h47-0-49" id="h47-0-49" class="i">+	apiMethodHeader        = http.CanonicalHeaderKey(&quot;X-Google-RPC-Service-Method&quot;)
</a><a href="#h47-0-50" id="h47-0-50" class="i">+	apiMethodHeaderValue   = []string{&quot;/VMRemoteAPI.CallRemoteAPI&quot;}
</a><a href="#h47-0-51" id="h47-0-51" class="i">+	apiDeadlineHeader      = http.CanonicalHeaderKey(&quot;X-Google-RPC-Service-Deadline&quot;)
</a><a href="#h47-0-52" id="h47-0-52" class="i">+	apiContentType         = http.CanonicalHeaderKey(&quot;Content-Type&quot;)
</a><a href="#h47-0-53" id="h47-0-53" class="i">+	apiContentTypeValue    = []string{&quot;application/octet-stream&quot;}
</a><a href="#h47-0-54" id="h47-0-54" class="i">+	logFlushHeader         = http.CanonicalHeaderKey(&quot;X-AppEngine-Log-Flush-Count&quot;)
</a><a href="#h47-0-55" id="h47-0-55" class="i">+
</a><a href="#h47-0-56" id="h47-0-56" class="i">+	apiHTTPClient = &amp;http.Client{
</a><a href="#h47-0-57" id="h47-0-57" class="i">+		Transport: &amp;http.Transport{
</a><a href="#h47-0-58" id="h47-0-58" class="i">+			Proxy: http.ProxyFromEnvironment,
</a><a href="#h47-0-59" id="h47-0-59" class="i">+			Dial:  limitDial,
</a><a href="#h47-0-60" id="h47-0-60" class="i">+		},
</a><a href="#h47-0-61" id="h47-0-61" class="i">+	}
</a><a href="#h47-0-62" id="h47-0-62" class="i">+)
</a><a href="#h47-0-63" id="h47-0-63" class="i">+
</a><a href="#h47-0-64" id="h47-0-64" class="i">+func apiURL() *url.URL {
</a><a href="#h47-0-65" id="h47-0-65" class="i">+	host, port := &quot;appengine.googleapis.internal&quot;, &quot;10001&quot;
</a><a href="#h47-0-66" id="h47-0-66" class="i">+	if h := os.Getenv(&quot;API_HOST&quot;); h != &quot;&quot; {
</a><a href="#h47-0-67" id="h47-0-67" class="i">+		host = h
</a><a href="#h47-0-68" id="h47-0-68" class="i">+	}
</a><a href="#h47-0-69" id="h47-0-69" class="i">+	if p := os.Getenv(&quot;API_PORT&quot;); p != &quot;&quot; {
</a><a href="#h47-0-70" id="h47-0-70" class="i">+		port = p
</a><a href="#h47-0-71" id="h47-0-71" class="i">+	}
</a><a href="#h47-0-72" id="h47-0-72" class="i">+	return &amp;url.URL{
</a><a href="#h47-0-73" id="h47-0-73" class="i">+		Scheme: &quot;http&quot;,
</a><a href="#h47-0-74" id="h47-0-74" class="i">+		Host:   host + &quot;:&quot; + port,
</a><a href="#h47-0-75" id="h47-0-75" class="i">+		Path:   apiPath,
</a><a href="#h47-0-76" id="h47-0-76" class="i">+	}
</a><a href="#h47-0-77" id="h47-0-77" class="i">+}
</a><a href="#h47-0-78" id="h47-0-78" class="i">+
</a><a href="#h47-0-79" id="h47-0-79" class="i">+func handleHTTP(w http.ResponseWriter, r *http.Request) {
</a><a href="#h47-0-80" id="h47-0-80" class="i">+	c := &amp;context{
</a><a href="#h47-0-81" id="h47-0-81" class="i">+		req:       r,
</a><a href="#h47-0-82" id="h47-0-82" class="i">+		outHeader: w.Header(),
</a><a href="#h47-0-83" id="h47-0-83" class="i">+		apiURL:    apiURL(),
</a><a href="#h47-0-84" id="h47-0-84" class="i">+	}
</a><a href="#h47-0-85" id="h47-0-85" class="i">+	stopFlushing := make(chan int)
</a><a href="#h47-0-86" id="h47-0-86" class="i">+
</a><a href="#h47-0-87" id="h47-0-87" class="i">+	ctxs.Lock()
</a><a href="#h47-0-88" id="h47-0-88" class="i">+	ctxs.m[r] = c
</a><a href="#h47-0-89" id="h47-0-89" class="i">+	ctxs.Unlock()
</a><a href="#h47-0-90" id="h47-0-90" class="i">+	defer func() {
</a><a href="#h47-0-91" id="h47-0-91" class="i">+		ctxs.Lock()
</a><a href="#h47-0-92" id="h47-0-92" class="i">+		delete(ctxs.m, r)
</a><a href="#h47-0-93" id="h47-0-93" class="i">+		ctxs.Unlock()
</a><a href="#h47-0-94" id="h47-0-94" class="i">+	}()
</a><a href="#h47-0-95" id="h47-0-95" class="i">+
</a><a href="#h47-0-96" id="h47-0-96" class="i">+	// Patch up RemoteAddr so it looks reasonable.
</a><a href="#h47-0-97" id="h47-0-97" class="i">+	if addr := r.Header.Get(userIPHeader); addr != &quot;&quot; {
</a><a href="#h47-0-98" id="h47-0-98" class="i">+		r.RemoteAddr = addr
</a><a href="#h47-0-99" id="h47-0-99" class="i">+	} else if addr = r.Header.Get(remoteAddrHeader); addr != &quot;&quot; {
</a><a href="#h47-0-100" id="h47-0-100" class="i">+		r.RemoteAddr = addr
</a><a href="#h47-0-101" id="h47-0-101" class="i">+	} else {
</a><a href="#h47-0-102" id="h47-0-102" class="i">+		// Should not normally reach here, but pick a sensible default anyway.
</a><a href="#h47-0-103" id="h47-0-103" class="i">+		r.RemoteAddr = &quot;127.0.0.1&quot;
</a><a href="#h47-0-104" id="h47-0-104" class="i">+	}
</a><a href="#h47-0-105" id="h47-0-105" class="i">+	// The address in the headers will most likely be of these forms:
</a><a href="#h47-0-106" id="h47-0-106" class="i">+	//	123.123.123.123
</a><a href="#h47-0-107" id="h47-0-107" class="i">+	//	2001:db8::1
</a><a href="#h47-0-108" id="h47-0-108" class="i">+	// net/http.Request.RemoteAddr is specified to be in &quot;IP:port&quot; form.
</a><a href="#h47-0-109" id="h47-0-109" class="i">+	if _, _, err := net.SplitHostPort(r.RemoteAddr); err != nil {
</a><a href="#h47-0-110" id="h47-0-110" class="i">+		// Assume the remote address is only a host; add a default port.
</a><a href="#h47-0-111" id="h47-0-111" class="i">+		r.RemoteAddr = net.JoinHostPort(r.RemoteAddr, &quot;80&quot;)
</a><a href="#h47-0-112" id="h47-0-112" class="i">+	}
</a><a href="#h47-0-113" id="h47-0-113" class="i">+
</a><a href="#h47-0-114" id="h47-0-114" class="i">+	// Start goroutine responsible for flushing app logs.
</a><a href="#h47-0-115" id="h47-0-115" class="i">+	// This is done after adding c to ctx.m (and stopped before removing it)
</a><a href="#h47-0-116" id="h47-0-116" class="i">+	// because flushing logs requires making an API call.
</a><a href="#h47-0-117" id="h47-0-117" class="i">+	go c.logFlusher(stopFlushing)
</a><a href="#h47-0-118" id="h47-0-118" class="i">+
</a><a href="#h47-0-119" id="h47-0-119" class="i">+	executeRequestSafely(c, r)
</a><a href="#h47-0-120" id="h47-0-120" class="i">+	c.outHeader = nil // make sure header changes aren&#39;t respected any more
</a><a href="#h47-0-121" id="h47-0-121" class="i">+
</a><a href="#h47-0-122" id="h47-0-122" class="i">+	stopFlushing &lt;- 1 // any logging beyond this point will be dropped
</a><a href="#h47-0-123" id="h47-0-123" class="i">+
</a><a href="#h47-0-124" id="h47-0-124" class="i">+	// Flush any pending logs asynchronously.
</a><a href="#h47-0-125" id="h47-0-125" class="i">+	c.pendingLogs.Lock()
</a><a href="#h47-0-126" id="h47-0-126" class="i">+	flushes := c.pendingLogs.flushes
</a><a href="#h47-0-127" id="h47-0-127" class="i">+	if len(c.pendingLogs.lines) &gt; 0 {
</a><a href="#h47-0-128" id="h47-0-128" class="i">+		flushes++
</a><a href="#h47-0-129" id="h47-0-129" class="i">+	}
</a><a href="#h47-0-130" id="h47-0-130" class="i">+	c.pendingLogs.Unlock()
</a><a href="#h47-0-131" id="h47-0-131" class="i">+	go c.flushLog(false)
</a><a href="#h47-0-132" id="h47-0-132" class="i">+	w.Header().Set(logFlushHeader, strconv.Itoa(flushes))
</a><a href="#h47-0-133" id="h47-0-133" class="i">+
</a><a href="#h47-0-134" id="h47-0-134" class="i">+	// Avoid nil Write call if c.Write is never called.
</a><a href="#h47-0-135" id="h47-0-135" class="i">+	if c.outCode != 0 {
</a><a href="#h47-0-136" id="h47-0-136" class="i">+		w.WriteHeader(c.outCode)
</a><a href="#h47-0-137" id="h47-0-137" class="i">+	}
</a><a href="#h47-0-138" id="h47-0-138" class="i">+	if c.outBody != nil {
</a><a href="#h47-0-139" id="h47-0-139" class="i">+		w.Write(c.outBody)
</a><a href="#h47-0-140" id="h47-0-140" class="i">+	}
</a><a href="#h47-0-141" id="h47-0-141" class="i">+}
</a><a href="#h47-0-142" id="h47-0-142" class="i">+
</a><a href="#h47-0-143" id="h47-0-143" class="i">+func executeRequestSafely(c *context, r *http.Request) {
</a><a href="#h47-0-144" id="h47-0-144" class="i">+	defer func() {
</a><a href="#h47-0-145" id="h47-0-145" class="i">+		if x := recover(); x != nil {
</a><a href="#h47-0-146" id="h47-0-146" class="i">+			logf(c, 4, &quot;%s&quot;, renderPanic(x)) // 4 == critical
</a><a href="#h47-0-147" id="h47-0-147" class="i">+			c.outCode = 500
</a><a href="#h47-0-148" id="h47-0-148" class="i">+		}
</a><a href="#h47-0-149" id="h47-0-149" class="i">+	}()
</a><a href="#h47-0-150" id="h47-0-150" class="i">+
</a><a href="#h47-0-151" id="h47-0-151" class="i">+	http.DefaultServeMux.ServeHTTP(c, r)
</a><a href="#h47-0-152" id="h47-0-152" class="i">+}
</a><a href="#h47-0-153" id="h47-0-153" class="i">+
</a><a href="#h47-0-154" id="h47-0-154" class="i">+func renderPanic(x interface{}) string {
</a><a href="#h47-0-155" id="h47-0-155" class="i">+	buf := make([]byte, 16&lt;&lt;10) // 16 KB should be plenty
</a><a href="#h47-0-156" id="h47-0-156" class="i">+	buf = buf[:runtime.Stack(buf, false)]
</a><a href="#h47-0-157" id="h47-0-157" class="i">+
</a><a href="#h47-0-158" id="h47-0-158" class="i">+	// Remove the first few stack frames:
</a><a href="#h47-0-159" id="h47-0-159" class="i">+	//   this func
</a><a href="#h47-0-160" id="h47-0-160" class="i">+	//   the recover closure in the caller
</a><a href="#h47-0-161" id="h47-0-161" class="i">+	// That will root the stack trace at the site of the panic.
</a><a href="#h47-0-162" id="h47-0-162" class="i">+	const (
</a><a href="#h47-0-163" id="h47-0-163" class="i">+		skipStart  = &quot;internal.renderPanic&quot;
</a><a href="#h47-0-164" id="h47-0-164" class="i">+		skipFrames = 2
</a><a href="#h47-0-165" id="h47-0-165" class="i">+	)
</a><a href="#h47-0-166" id="h47-0-166" class="i">+	start := bytes.Index(buf, []byte(skipStart))
</a><a href="#h47-0-167" id="h47-0-167" class="i">+	p := start
</a><a href="#h47-0-168" id="h47-0-168" class="i">+	for i := 0; i &lt; skipFrames*2 &amp;&amp; p+1 &lt; len(buf); i++ {
</a><a href="#h47-0-169" id="h47-0-169" class="i">+		p = bytes.IndexByte(buf[p+1:], &#39;\n&#39;) + p + 1
</a><a href="#h47-0-170" id="h47-0-170" class="i">+		if p &lt; 0 {
</a><a href="#h47-0-171" id="h47-0-171" class="i">+			break
</a><a href="#h47-0-172" id="h47-0-172" class="i">+		}
</a><a href="#h47-0-173" id="h47-0-173" class="i">+	}
</a><a href="#h47-0-174" id="h47-0-174" class="i">+	if p &gt;= 0 {
</a><a href="#h47-0-175" id="h47-0-175" class="i">+		// buf[start:p+1] is the block to remove.
</a><a href="#h47-0-176" id="h47-0-176" class="i">+		// Copy buf[p+1:] over buf[start:] and shrink buf.
</a><a href="#h47-0-177" id="h47-0-177" class="i">+		copy(buf[start:], buf[p+1:])
</a><a href="#h47-0-178" id="h47-0-178" class="i">+		buf = buf[:len(buf)-(p+1-start)]
</a><a href="#h47-0-179" id="h47-0-179" class="i">+	}
</a><a href="#h47-0-180" id="h47-0-180" class="i">+
</a><a href="#h47-0-181" id="h47-0-181" class="i">+	// Add panic heading.
</a><a href="#h47-0-182" id="h47-0-182" class="i">+	head := fmt.Sprintf(&quot;panic: %v\n\n&quot;, x)
</a><a href="#h47-0-183" id="h47-0-183" class="i">+	if len(head) &gt; len(buf) {
</a><a href="#h47-0-184" id="h47-0-184" class="i">+		// Extremely unlikely to happen.
</a><a href="#h47-0-185" id="h47-0-185" class="i">+		return head
</a><a href="#h47-0-186" id="h47-0-186" class="i">+	}
</a><a href="#h47-0-187" id="h47-0-187" class="i">+	copy(buf[len(head):], buf)
</a><a href="#h47-0-188" id="h47-0-188" class="i">+	copy(buf, head)
</a><a href="#h47-0-189" id="h47-0-189" class="i">+
</a><a href="#h47-0-190" id="h47-0-190" class="i">+	return string(buf)
</a><a href="#h47-0-191" id="h47-0-191" class="i">+}
</a><a href="#h47-0-192" id="h47-0-192" class="i">+
</a><a href="#h47-0-193" id="h47-0-193" class="i">+var ctxs = struct {
</a><a href="#h47-0-194" id="h47-0-194" class="i">+	sync.Mutex
</a><a href="#h47-0-195" id="h47-0-195" class="i">+	m  map[*http.Request]*context
</a><a href="#h47-0-196" id="h47-0-196" class="i">+	bg *context // background context, lazily initialized
</a><a href="#h47-0-197" id="h47-0-197" class="i">+	// dec is used by tests to decorate the netcontext.Context returned
</a><a href="#h47-0-198" id="h47-0-198" class="i">+	// for a given request. This allows tests to add overrides (such as
</a><a href="#h47-0-199" id="h47-0-199" class="i">+	// WithAppIDOverride) to the context. The map is nil outside tests.
</a><a href="#h47-0-200" id="h47-0-200" class="i">+	dec map[*http.Request]func(netcontext.Context) netcontext.Context
</a><a href="#h47-0-201" id="h47-0-201" class="i">+}{
</a><a href="#h47-0-202" id="h47-0-202" class="i">+	m: make(map[*http.Request]*context),
</a><a href="#h47-0-203" id="h47-0-203" class="i">+}
</a><a href="#h47-0-204" id="h47-0-204" class="i">+
</a><a href="#h47-0-205" id="h47-0-205" class="i">+// context represents the context of an in-flight HTTP request.
</a><a href="#h47-0-206" id="h47-0-206" class="i">+// It implements the appengine.Context and http.ResponseWriter interfaces.
</a><a href="#h47-0-207" id="h47-0-207" class="i">+type context struct {
</a><a href="#h47-0-208" id="h47-0-208" class="i">+	req *http.Request
</a><a href="#h47-0-209" id="h47-0-209" class="i">+
</a><a href="#h47-0-210" id="h47-0-210" class="i">+	outCode   int
</a><a href="#h47-0-211" id="h47-0-211" class="i">+	outHeader http.Header
</a><a href="#h47-0-212" id="h47-0-212" class="i">+	outBody   []byte
</a><a href="#h47-0-213" id="h47-0-213" class="i">+
</a><a href="#h47-0-214" id="h47-0-214" class="i">+	pendingLogs struct {
</a><a href="#h47-0-215" id="h47-0-215" class="i">+		sync.Mutex
</a><a href="#h47-0-216" id="h47-0-216" class="i">+		lines   []*logpb.UserAppLogLine
</a><a href="#h47-0-217" id="h47-0-217" class="i">+		flushes int
</a><a href="#h47-0-218" id="h47-0-218" class="i">+	}
</a><a href="#h47-0-219" id="h47-0-219" class="i">+
</a><a href="#h47-0-220" id="h47-0-220" class="i">+	apiURL *url.URL
</a><a href="#h47-0-221" id="h47-0-221" class="i">+}
</a><a href="#h47-0-222" id="h47-0-222" class="i">+
</a><a href="#h47-0-223" id="h47-0-223" class="i">+var contextKey = &quot;holds a *context&quot;
</a><a href="#h47-0-224" id="h47-0-224" class="i">+
</a><a href="#h47-0-225" id="h47-0-225" class="i">+func fromContext(ctx netcontext.Context) *context {
</a><a href="#h47-0-226" id="h47-0-226" class="i">+	c, _ := ctx.Value(&amp;contextKey).(*context)
</a><a href="#h47-0-227" id="h47-0-227" class="i">+	return c
</a><a href="#h47-0-228" id="h47-0-228" class="i">+}
</a><a href="#h47-0-229" id="h47-0-229" class="i">+
</a><a href="#h47-0-230" id="h47-0-230" class="i">+func withContext(parent netcontext.Context, c *context) netcontext.Context {
</a><a href="#h47-0-231" id="h47-0-231" class="i">+	ctx := netcontext.WithValue(parent, &amp;contextKey, c)
</a><a href="#h47-0-232" id="h47-0-232" class="i">+	if ns := c.req.Header.Get(curNamespaceHeader); ns != &quot;&quot; {
</a><a href="#h47-0-233" id="h47-0-233" class="i">+		ctx = withNamespace(ctx, ns)
</a><a href="#h47-0-234" id="h47-0-234" class="i">+	}
</a><a href="#h47-0-235" id="h47-0-235" class="i">+	return ctx
</a><a href="#h47-0-236" id="h47-0-236" class="i">+}
</a><a href="#h47-0-237" id="h47-0-237" class="i">+
</a><a href="#h47-0-238" id="h47-0-238" class="i">+func toContext(c *context) netcontext.Context {
</a><a href="#h47-0-239" id="h47-0-239" class="i">+	return withContext(netcontext.Background(), c)
</a><a href="#h47-0-240" id="h47-0-240" class="i">+}
</a><a href="#h47-0-241" id="h47-0-241" class="i">+
</a><a href="#h47-0-242" id="h47-0-242" class="i">+func IncomingHeaders(ctx netcontext.Context) http.Header {
</a><a href="#h47-0-243" id="h47-0-243" class="i">+	if c := fromContext(ctx); c != nil {
</a><a href="#h47-0-244" id="h47-0-244" class="i">+		return c.req.Header
</a><a href="#h47-0-245" id="h47-0-245" class="i">+	}
</a><a href="#h47-0-246" id="h47-0-246" class="i">+	return nil
</a><a href="#h47-0-247" id="h47-0-247" class="i">+}
</a><a href="#h47-0-248" id="h47-0-248" class="i">+
</a><a href="#h47-0-249" id="h47-0-249" class="i">+func WithContext(parent netcontext.Context, req *http.Request) netcontext.Context {
</a><a href="#h47-0-250" id="h47-0-250" class="i">+	ctxs.Lock()
</a><a href="#h47-0-251" id="h47-0-251" class="i">+	c := ctxs.m[req]
</a><a href="#h47-0-252" id="h47-0-252" class="i">+	d := ctxs.dec[req]
</a><a href="#h47-0-253" id="h47-0-253" class="i">+	ctxs.Unlock()
</a><a href="#h47-0-254" id="h47-0-254" class="i">+
</a><a href="#h47-0-255" id="h47-0-255" class="i">+	if d != nil {
</a><a href="#h47-0-256" id="h47-0-256" class="i">+		parent = d(parent)
</a><a href="#h47-0-257" id="h47-0-257" class="i">+	}
</a><a href="#h47-0-258" id="h47-0-258" class="i">+
</a><a href="#h47-0-259" id="h47-0-259" class="i">+	if c == nil {
</a><a href="#h47-0-260" id="h47-0-260" class="i">+		// Someone passed in an http.Request that is not in-flight.
</a><a href="#h47-0-261" id="h47-0-261" class="i">+		// We panic here rather than panicking at a later point
</a><a href="#h47-0-262" id="h47-0-262" class="i">+		// so that stack traces will be more sensible.
</a><a href="#h47-0-263" id="h47-0-263" class="i">+		log.Panic(&quot;appengine: NewContext passed an unknown http.Request&quot;)
</a><a href="#h47-0-264" id="h47-0-264" class="i">+	}
</a><a href="#h47-0-265" id="h47-0-265" class="i">+	return withContext(parent, c)
</a><a href="#h47-0-266" id="h47-0-266" class="i">+}
</a><a href="#h47-0-267" id="h47-0-267" class="i">+
</a><a href="#h47-0-268" id="h47-0-268" class="i">+func BackgroundContext() netcontext.Context {
</a><a href="#h47-0-269" id="h47-0-269" class="i">+	ctxs.Lock()
</a><a href="#h47-0-270" id="h47-0-270" class="i">+	defer ctxs.Unlock()
</a><a href="#h47-0-271" id="h47-0-271" class="i">+
</a><a href="#h47-0-272" id="h47-0-272" class="i">+	if ctxs.bg != nil {
</a><a href="#h47-0-273" id="h47-0-273" class="i">+		return toContext(ctxs.bg)
</a><a href="#h47-0-274" id="h47-0-274" class="i">+	}
</a><a href="#h47-0-275" id="h47-0-275" class="i">+
</a><a href="#h47-0-276" id="h47-0-276" class="i">+	// Compute background security ticket.
</a><a href="#h47-0-277" id="h47-0-277" class="i">+	appID := partitionlessAppID()
</a><a href="#h47-0-278" id="h47-0-278" class="i">+	escAppID := strings.Replace(strings.Replace(appID, &quot;:&quot;, &quot;_&quot;, -1), &quot;.&quot;, &quot;_&quot;, -1)
</a><a href="#h47-0-279" id="h47-0-279" class="i">+	majVersion := VersionID(nil)
</a><a href="#h47-0-280" id="h47-0-280" class="i">+	if i := strings.Index(majVersion, &quot;.&quot;); i &gt; 0 {
</a><a href="#h47-0-281" id="h47-0-281" class="i">+		majVersion = majVersion[:i]
</a><a href="#h47-0-282" id="h47-0-282" class="i">+	}
</a><a href="#h47-0-283" id="h47-0-283" class="i">+	ticket := fmt.Sprintf(&quot;%s/%s.%s.%s&quot;, escAppID, ModuleName(nil), majVersion, InstanceID())
</a><a href="#h47-0-284" id="h47-0-284" class="i">+
</a><a href="#h47-0-285" id="h47-0-285" class="i">+	ctxs.bg = &amp;context{
</a><a href="#h47-0-286" id="h47-0-286" class="i">+		req: &amp;http.Request{
</a><a href="#h47-0-287" id="h47-0-287" class="i">+			Header: http.Header{
</a><a href="#h47-0-288" id="h47-0-288" class="i">+				ticketHeader: []string{ticket},
</a><a href="#h47-0-289" id="h47-0-289" class="i">+			},
</a><a href="#h47-0-290" id="h47-0-290" class="i">+		},
</a><a href="#h47-0-291" id="h47-0-291" class="i">+		apiURL: apiURL(),
</a><a href="#h47-0-292" id="h47-0-292" class="i">+	}
</a><a href="#h47-0-293" id="h47-0-293" class="i">+
</a><a href="#h47-0-294" id="h47-0-294" class="i">+	// TODO(dsymonds): Wire up the shutdown handler to do a final flush.
</a><a href="#h47-0-295" id="h47-0-295" class="i">+	go ctxs.bg.logFlusher(make(chan int))
</a><a href="#h47-0-296" id="h47-0-296" class="i">+
</a><a href="#h47-0-297" id="h47-0-297" class="i">+	return toContext(ctxs.bg)
</a><a href="#h47-0-298" id="h47-0-298" class="i">+}
</a><a href="#h47-0-299" id="h47-0-299" class="i">+
</a><a href="#h47-0-300" id="h47-0-300" class="i">+// RegisterTestRequest registers the HTTP request req for testing, such that
</a><a href="#h47-0-301" id="h47-0-301" class="i">+// any API calls are sent to the provided URL. It returns a closure to delete
</a><a href="#h47-0-302" id="h47-0-302" class="i">+// the registration.
</a><a href="#h47-0-303" id="h47-0-303" class="i">+// It should only be used by aetest package.
</a><a href="#h47-0-304" id="h47-0-304" class="i">+func RegisterTestRequest(req *http.Request, apiURL *url.URL, decorate func(netcontext.Context) netcontext.Context) func() {
</a><a href="#h47-0-305" id="h47-0-305" class="i">+	c := &amp;context{
</a><a href="#h47-0-306" id="h47-0-306" class="i">+		req:    req,
</a><a href="#h47-0-307" id="h47-0-307" class="i">+		apiURL: apiURL,
</a><a href="#h47-0-308" id="h47-0-308" class="i">+	}
</a><a href="#h47-0-309" id="h47-0-309" class="i">+	ctxs.Lock()
</a><a href="#h47-0-310" id="h47-0-310" class="i">+	defer ctxs.Unlock()
</a><a href="#h47-0-311" id="h47-0-311" class="i">+	if _, ok := ctxs.m[req]; ok {
</a><a href="#h47-0-312" id="h47-0-312" class="i">+		log.Panic(&quot;req already associated with context&quot;)
</a><a href="#h47-0-313" id="h47-0-313" class="i">+	}
</a><a href="#h47-0-314" id="h47-0-314" class="i">+	if _, ok := ctxs.dec[req]; ok {
</a><a href="#h47-0-315" id="h47-0-315" class="i">+		log.Panic(&quot;req already associated with context&quot;)
</a><a href="#h47-0-316" id="h47-0-316" class="i">+	}
</a><a href="#h47-0-317" id="h47-0-317" class="i">+	if ctxs.dec == nil {
</a><a href="#h47-0-318" id="h47-0-318" class="i">+		ctxs.dec = make(map[*http.Request]func(netcontext.Context) netcontext.Context)
</a><a href="#h47-0-319" id="h47-0-319" class="i">+	}
</a><a href="#h47-0-320" id="h47-0-320" class="i">+	ctxs.m[req] = c
</a><a href="#h47-0-321" id="h47-0-321" class="i">+	ctxs.dec[req] = decorate
</a><a href="#h47-0-322" id="h47-0-322" class="i">+
</a><a href="#h47-0-323" id="h47-0-323" class="i">+	return func() {
</a><a href="#h47-0-324" id="h47-0-324" class="i">+		ctxs.Lock()
</a><a href="#h47-0-325" id="h47-0-325" class="i">+		delete(ctxs.m, req)
</a><a href="#h47-0-326" id="h47-0-326" class="i">+		delete(ctxs.dec, req)
</a><a href="#h47-0-327" id="h47-0-327" class="i">+		ctxs.Unlock()
</a><a href="#h47-0-328" id="h47-0-328" class="i">+	}
</a><a href="#h47-0-329" id="h47-0-329" class="i">+}
</a><a href="#h47-0-330" id="h47-0-330" class="i">+
</a><a href="#h47-0-331" id="h47-0-331" class="i">+var errTimeout = &amp;CallError{
</a><a href="#h47-0-332" id="h47-0-332" class="i">+	Detail:  &quot;Deadline exceeded&quot;,
</a><a href="#h47-0-333" id="h47-0-333" class="i">+	Code:    int32(remotepb.RpcError_CANCELLED),
</a><a href="#h47-0-334" id="h47-0-334" class="i">+	Timeout: true,
</a><a href="#h47-0-335" id="h47-0-335" class="i">+}
</a><a href="#h47-0-336" id="h47-0-336" class="i">+
</a><a href="#h47-0-337" id="h47-0-337" class="i">+func (c *context) Header() http.Header { return c.outHeader }
</a><a href="#h47-0-338" id="h47-0-338" class="i">+
</a><a href="#h47-0-339" id="h47-0-339" class="i">+// Copied from $GOROOT/src/pkg/net/http/transfer.go. Some response status
</a><a href="#h47-0-340" id="h47-0-340" class="i">+// codes do not permit a response body (nor response entity headers such as
</a><a href="#h47-0-341" id="h47-0-341" class="i">+// Content-Length, Content-Type, etc).
</a><a href="#h47-0-342" id="h47-0-342" class="i">+func bodyAllowedForStatus(status int) bool {
</a><a href="#h47-0-343" id="h47-0-343" class="i">+	switch {
</a><a href="#h47-0-344" id="h47-0-344" class="i">+	case status &gt;= 100 &amp;&amp; status &lt;= 199:
</a><a href="#h47-0-345" id="h47-0-345" class="i">+		return false
</a><a href="#h47-0-346" id="h47-0-346" class="i">+	case status == 204:
</a><a href="#h47-0-347" id="h47-0-347" class="i">+		return false
</a><a href="#h47-0-348" id="h47-0-348" class="i">+	case status == 304:
</a><a href="#h47-0-349" id="h47-0-349" class="i">+		return false
</a><a href="#h47-0-350" id="h47-0-350" class="i">+	}
</a><a href="#h47-0-351" id="h47-0-351" class="i">+	return true
</a><a href="#h47-0-352" id="h47-0-352" class="i">+}
</a><a href="#h47-0-353" id="h47-0-353" class="i">+
</a><a href="#h47-0-354" id="h47-0-354" class="i">+func (c *context) Write(b []byte) (int, error) {
</a><a href="#h47-0-355" id="h47-0-355" class="i">+	if c.outCode == 0 {
</a><a href="#h47-0-356" id="h47-0-356" class="i">+		c.WriteHeader(http.StatusOK)
</a><a href="#h47-0-357" id="h47-0-357" class="i">+	}
</a><a href="#h47-0-358" id="h47-0-358" class="i">+	if len(b) &gt; 0 &amp;&amp; !bodyAllowedForStatus(c.outCode) {
</a><a href="#h47-0-359" id="h47-0-359" class="i">+		return 0, http.ErrBodyNotAllowed
</a><a href="#h47-0-360" id="h47-0-360" class="i">+	}
</a><a href="#h47-0-361" id="h47-0-361" class="i">+	c.outBody = append(c.outBody, b...)
</a><a href="#h47-0-362" id="h47-0-362" class="i">+	return len(b), nil
</a><a href="#h47-0-363" id="h47-0-363" class="i">+}
</a><a href="#h47-0-364" id="h47-0-364" class="i">+
</a><a href="#h47-0-365" id="h47-0-365" class="i">+func (c *context) WriteHeader(code int) {
</a><a href="#h47-0-366" id="h47-0-366" class="i">+	if c.outCode != 0 {
</a><a href="#h47-0-367" id="h47-0-367" class="i">+		logf(c, 3, &quot;WriteHeader called multiple times on request.&quot;) // error level
</a><a href="#h47-0-368" id="h47-0-368" class="i">+		return
</a><a href="#h47-0-369" id="h47-0-369" class="i">+	}
</a><a href="#h47-0-370" id="h47-0-370" class="i">+	c.outCode = code
</a><a href="#h47-0-371" id="h47-0-371" class="i">+}
</a><a href="#h47-0-372" id="h47-0-372" class="i">+
</a><a href="#h47-0-373" id="h47-0-373" class="i">+func (c *context) post(body []byte, timeout time.Duration) (b []byte, err error) {
</a><a href="#h47-0-374" id="h47-0-374" class="i">+	hreq := &amp;http.Request{
</a><a href="#h47-0-375" id="h47-0-375" class="i">+		Method: &quot;POST&quot;,
</a><a href="#h47-0-376" id="h47-0-376" class="i">+		URL:    c.apiURL,
</a><a href="#h47-0-377" id="h47-0-377" class="i">+		Header: http.Header{
</a><a href="#h47-0-378" id="h47-0-378" class="i">+			apiEndpointHeader: apiEndpointHeaderValue,
</a><a href="#h47-0-379" id="h47-0-379" class="i">+			apiMethodHeader:   apiMethodHeaderValue,
</a><a href="#h47-0-380" id="h47-0-380" class="i">+			apiContentType:    apiContentTypeValue,
</a><a href="#h47-0-381" id="h47-0-381" class="i">+			apiDeadlineHeader: []string{strconv.FormatFloat(timeout.Seconds(), &#39;f&#39;, -1, 64)},
</a><a href="#h47-0-382" id="h47-0-382" class="i">+		},
</a><a href="#h47-0-383" id="h47-0-383" class="i">+		Body:          ioutil.NopCloser(bytes.NewReader(body)),
</a><a href="#h47-0-384" id="h47-0-384" class="i">+		ContentLength: int64(len(body)),
</a><a href="#h47-0-385" id="h47-0-385" class="i">+		Host:          c.apiURL.Host,
</a><a href="#h47-0-386" id="h47-0-386" class="i">+	}
</a><a href="#h47-0-387" id="h47-0-387" class="i">+	if info := c.req.Header.Get(dapperHeader); info != &quot;&quot; {
</a><a href="#h47-0-388" id="h47-0-388" class="i">+		hreq.Header.Set(dapperHeader, info)
</a><a href="#h47-0-389" id="h47-0-389" class="i">+	}
</a><a href="#h47-0-390" id="h47-0-390" class="i">+	if info := c.req.Header.Get(traceHeader); info != &quot;&quot; {
</a><a href="#h47-0-391" id="h47-0-391" class="i">+		hreq.Header.Set(traceHeader, info)
</a><a href="#h47-0-392" id="h47-0-392" class="i">+	}
</a><a href="#h47-0-393" id="h47-0-393" class="i">+
</a><a href="#h47-0-394" id="h47-0-394" class="i">+	tr := apiHTTPClient.Transport.(*http.Transport)
</a><a href="#h47-0-395" id="h47-0-395" class="i">+
</a><a href="#h47-0-396" id="h47-0-396" class="i">+	var timedOut int32 // atomic; set to 1 if timed out
</a><a href="#h47-0-397" id="h47-0-397" class="i">+	t := time.AfterFunc(timeout, func() {
</a><a href="#h47-0-398" id="h47-0-398" class="i">+		atomic.StoreInt32(&amp;timedOut, 1)
</a><a href="#h47-0-399" id="h47-0-399" class="i">+		tr.CancelRequest(hreq)
</a><a href="#h47-0-400" id="h47-0-400" class="i">+	})
</a><a href="#h47-0-401" id="h47-0-401" class="i">+	defer t.Stop()
</a><a href="#h47-0-402" id="h47-0-402" class="i">+	defer func() {
</a><a href="#h47-0-403" id="h47-0-403" class="i">+		// Check if timeout was exceeded.
</a><a href="#h47-0-404" id="h47-0-404" class="i">+		if atomic.LoadInt32(&amp;timedOut) != 0 {
</a><a href="#h47-0-405" id="h47-0-405" class="i">+			err = errTimeout
</a><a href="#h47-0-406" id="h47-0-406" class="i">+		}
</a><a href="#h47-0-407" id="h47-0-407" class="i">+	}()
</a><a href="#h47-0-408" id="h47-0-408" class="i">+
</a><a href="#h47-0-409" id="h47-0-409" class="i">+	hresp, err := apiHTTPClient.Do(hreq)
</a><a href="#h47-0-410" id="h47-0-410" class="i">+	if err != nil {
</a><a href="#h47-0-411" id="h47-0-411" class="i">+		return nil, &amp;CallError{
</a><a href="#h47-0-412" id="h47-0-412" class="i">+			Detail: fmt.Sprintf(&quot;service bridge HTTP failed: %v&quot;, err),
</a><a href="#h47-0-413" id="h47-0-413" class="i">+			Code:   int32(remotepb.RpcError_UNKNOWN),
</a><a href="#h47-0-414" id="h47-0-414" class="i">+		}
</a><a href="#h47-0-415" id="h47-0-415" class="i">+	}
</a><a href="#h47-0-416" id="h47-0-416" class="i">+	defer hresp.Body.Close()
</a><a href="#h47-0-417" id="h47-0-417" class="i">+	hrespBody, err := ioutil.ReadAll(hresp.Body)
</a><a href="#h47-0-418" id="h47-0-418" class="i">+	if hresp.StatusCode != 200 {
</a><a href="#h47-0-419" id="h47-0-419" class="i">+		return nil, &amp;CallError{
</a><a href="#h47-0-420" id="h47-0-420" class="i">+			Detail: fmt.Sprintf(&quot;service bridge returned HTTP %d (%q)&quot;, hresp.StatusCode, hrespBody),
</a><a href="#h47-0-421" id="h47-0-421" class="i">+			Code:   int32(remotepb.RpcError_UNKNOWN),
</a><a href="#h47-0-422" id="h47-0-422" class="i">+		}
</a><a href="#h47-0-423" id="h47-0-423" class="i">+	}
</a><a href="#h47-0-424" id="h47-0-424" class="i">+	if err != nil {
</a><a href="#h47-0-425" id="h47-0-425" class="i">+		return nil, &amp;CallError{
</a><a href="#h47-0-426" id="h47-0-426" class="i">+			Detail: fmt.Sprintf(&quot;service bridge response bad: %v&quot;, err),
</a><a href="#h47-0-427" id="h47-0-427" class="i">+			Code:   int32(remotepb.RpcError_UNKNOWN),
</a><a href="#h47-0-428" id="h47-0-428" class="i">+		}
</a><a href="#h47-0-429" id="h47-0-429" class="i">+	}
</a><a href="#h47-0-430" id="h47-0-430" class="i">+	return hrespBody, nil
</a><a href="#h47-0-431" id="h47-0-431" class="i">+}
</a><a href="#h47-0-432" id="h47-0-432" class="i">+
</a><a href="#h47-0-433" id="h47-0-433" class="i">+func Call(ctx netcontext.Context, service, method string, in, out proto.Message) error {
</a><a href="#h47-0-434" id="h47-0-434" class="i">+	if ns := NamespaceFromContext(ctx); ns != &quot;&quot; {
</a><a href="#h47-0-435" id="h47-0-435" class="i">+		if fn, ok := NamespaceMods[service]; ok {
</a><a href="#h47-0-436" id="h47-0-436" class="i">+			fn(in, ns)
</a><a href="#h47-0-437" id="h47-0-437" class="i">+		}
</a><a href="#h47-0-438" id="h47-0-438" class="i">+	}
</a><a href="#h47-0-439" id="h47-0-439" class="i">+
</a><a href="#h47-0-440" id="h47-0-440" class="i">+	if f, ctx, ok := callOverrideFromContext(ctx); ok {
</a><a href="#h47-0-441" id="h47-0-441" class="i">+		return f(ctx, service, method, in, out)
</a><a href="#h47-0-442" id="h47-0-442" class="i">+	}
</a><a href="#h47-0-443" id="h47-0-443" class="i">+
</a><a href="#h47-0-444" id="h47-0-444" class="i">+	// Handle already-done contexts quickly.
</a><a href="#h47-0-445" id="h47-0-445" class="i">+	select {
</a><a href="#h47-0-446" id="h47-0-446" class="i">+	case &lt;-ctx.Done():
</a><a href="#h47-0-447" id="h47-0-447" class="i">+		return ctx.Err()
</a><a href="#h47-0-448" id="h47-0-448" class="i">+	default:
</a><a href="#h47-0-449" id="h47-0-449" class="i">+	}
</a><a href="#h47-0-450" id="h47-0-450" class="i">+
</a><a href="#h47-0-451" id="h47-0-451" class="i">+	c := fromContext(ctx)
</a><a href="#h47-0-452" id="h47-0-452" class="i">+	if c == nil {
</a><a href="#h47-0-453" id="h47-0-453" class="i">+		// Give a good error message rather than a panic lower down.
</a><a href="#h47-0-454" id="h47-0-454" class="i">+		return errors.New(&quot;not an App Engine context&quot;)
</a><a href="#h47-0-455" id="h47-0-455" class="i">+	}
</a><a href="#h47-0-456" id="h47-0-456" class="i">+
</a><a href="#h47-0-457" id="h47-0-457" class="i">+	// Apply transaction modifications if we&#39;re in a transaction.
</a><a href="#h47-0-458" id="h47-0-458" class="i">+	if t := transactionFromContext(ctx); t != nil {
</a><a href="#h47-0-459" id="h47-0-459" class="i">+		if t.finished {
</a><a href="#h47-0-460" id="h47-0-460" class="i">+			return errors.New(&quot;transaction context has expired&quot;)
</a><a href="#h47-0-461" id="h47-0-461" class="i">+		}
</a><a href="#h47-0-462" id="h47-0-462" class="i">+		applyTransaction(in, &amp;t.transaction)
</a><a href="#h47-0-463" id="h47-0-463" class="i">+	}
</a><a href="#h47-0-464" id="h47-0-464" class="i">+
</a><a href="#h47-0-465" id="h47-0-465" class="i">+	// Default RPC timeout is 60s.
</a><a href="#h47-0-466" id="h47-0-466" class="i">+	timeout := 60 * time.Second
</a><a href="#h47-0-467" id="h47-0-467" class="i">+	if deadline, ok := ctx.Deadline(); ok {
</a><a href="#h47-0-468" id="h47-0-468" class="i">+		timeout = deadline.Sub(time.Now())
</a><a href="#h47-0-469" id="h47-0-469" class="i">+	}
</a><a href="#h47-0-470" id="h47-0-470" class="i">+
</a><a href="#h47-0-471" id="h47-0-471" class="i">+	data, err := proto.Marshal(in)
</a><a href="#h47-0-472" id="h47-0-472" class="i">+	if err != nil {
</a><a href="#h47-0-473" id="h47-0-473" class="i">+		return err
</a><a href="#h47-0-474" id="h47-0-474" class="i">+	}
</a><a href="#h47-0-475" id="h47-0-475" class="i">+
</a><a href="#h47-0-476" id="h47-0-476" class="i">+	ticket := c.req.Header.Get(ticketHeader)
</a><a href="#h47-0-477" id="h47-0-477" class="i">+	req := &amp;remotepb.Request{
</a><a href="#h47-0-478" id="h47-0-478" class="i">+		ServiceName: &amp;service,
</a><a href="#h47-0-479" id="h47-0-479" class="i">+		Method:      &amp;method,
</a><a href="#h47-0-480" id="h47-0-480" class="i">+		Request:     data,
</a><a href="#h47-0-481" id="h47-0-481" class="i">+		RequestId:   &amp;ticket,
</a><a href="#h47-0-482" id="h47-0-482" class="i">+	}
</a><a href="#h47-0-483" id="h47-0-483" class="i">+	hreqBody, err := proto.Marshal(req)
</a><a href="#h47-0-484" id="h47-0-484" class="i">+	if err != nil {
</a><a href="#h47-0-485" id="h47-0-485" class="i">+		return err
</a><a href="#h47-0-486" id="h47-0-486" class="i">+	}
</a><a href="#h47-0-487" id="h47-0-487" class="i">+
</a><a href="#h47-0-488" id="h47-0-488" class="i">+	hrespBody, err := c.post(hreqBody, timeout)
</a><a href="#h47-0-489" id="h47-0-489" class="i">+	if err != nil {
</a><a href="#h47-0-490" id="h47-0-490" class="i">+		return err
</a><a href="#h47-0-491" id="h47-0-491" class="i">+	}
</a><a href="#h47-0-492" id="h47-0-492" class="i">+
</a><a href="#h47-0-493" id="h47-0-493" class="i">+	res := &amp;remotepb.Response{}
</a><a href="#h47-0-494" id="h47-0-494" class="i">+	if err := proto.Unmarshal(hrespBody, res); err != nil {
</a><a href="#h47-0-495" id="h47-0-495" class="i">+		return err
</a><a href="#h47-0-496" id="h47-0-496" class="i">+	}
</a><a href="#h47-0-497" id="h47-0-497" class="i">+	if res.RpcError != nil {
</a><a href="#h47-0-498" id="h47-0-498" class="i">+		ce := &amp;CallError{
</a><a href="#h47-0-499" id="h47-0-499" class="i">+			Detail: res.RpcError.GetDetail(),
</a><a href="#h47-0-500" id="h47-0-500" class="i">+			Code:   *res.RpcError.Code,
</a><a href="#h47-0-501" id="h47-0-501" class="i">+		}
</a><a href="#h47-0-502" id="h47-0-502" class="i">+		switch remotepb.RpcError_ErrorCode(ce.Code) {
</a><a href="#h47-0-503" id="h47-0-503" class="i">+		case remotepb.RpcError_CANCELLED, remotepb.RpcError_DEADLINE_EXCEEDED:
</a><a href="#h47-0-504" id="h47-0-504" class="i">+			ce.Timeout = true
</a><a href="#h47-0-505" id="h47-0-505" class="i">+		}
</a><a href="#h47-0-506" id="h47-0-506" class="i">+		return ce
</a><a href="#h47-0-507" id="h47-0-507" class="i">+	}
</a><a href="#h47-0-508" id="h47-0-508" class="i">+	if res.ApplicationError != nil {
</a><a href="#h47-0-509" id="h47-0-509" class="i">+		return &amp;APIError{
</a><a href="#h47-0-510" id="h47-0-510" class="i">+			Service: *req.ServiceName,
</a><a href="#h47-0-511" id="h47-0-511" class="i">+			Detail:  res.ApplicationError.GetDetail(),
</a><a href="#h47-0-512" id="h47-0-512" class="i">+			Code:    *res.ApplicationError.Code,
</a><a href="#h47-0-513" id="h47-0-513" class="i">+		}
</a><a href="#h47-0-514" id="h47-0-514" class="i">+	}
</a><a href="#h47-0-515" id="h47-0-515" class="i">+	if res.Exception != nil || res.JavaException != nil {
</a><a href="#h47-0-516" id="h47-0-516" class="i">+		// This shouldn&#39;t happen, but let&#39;s be defensive.
</a><a href="#h47-0-517" id="h47-0-517" class="i">+		return &amp;CallError{
</a><a href="#h47-0-518" id="h47-0-518" class="i">+			Detail: &quot;service bridge returned exception&quot;,
</a><a href="#h47-0-519" id="h47-0-519" class="i">+			Code:   int32(remotepb.RpcError_UNKNOWN),
</a><a href="#h47-0-520" id="h47-0-520" class="i">+		}
</a><a href="#h47-0-521" id="h47-0-521" class="i">+	}
</a><a href="#h47-0-522" id="h47-0-522" class="i">+	return proto.Unmarshal(res.Response, out)
</a><a href="#h47-0-523" id="h47-0-523" class="i">+}
</a><a href="#h47-0-524" id="h47-0-524" class="i">+
</a><a href="#h47-0-525" id="h47-0-525" class="i">+func (c *context) Request() *http.Request {
</a><a href="#h47-0-526" id="h47-0-526" class="i">+	return c.req
</a><a href="#h47-0-527" id="h47-0-527" class="i">+}
</a><a href="#h47-0-528" id="h47-0-528" class="i">+
</a><a href="#h47-0-529" id="h47-0-529" class="i">+func (c *context) addLogLine(ll *logpb.UserAppLogLine) {
</a><a href="#h47-0-530" id="h47-0-530" class="i">+	// Truncate long log lines.
</a><a href="#h47-0-531" id="h47-0-531" class="i">+	// TODO(dsymonds): Check if this is still necessary.
</a><a href="#h47-0-532" id="h47-0-532" class="i">+	const lim = 8 &lt;&lt; 10
</a><a href="#h47-0-533" id="h47-0-533" class="i">+	if len(*ll.Message) &gt; lim {
</a><a href="#h47-0-534" id="h47-0-534" class="i">+		suffix := fmt.Sprintf(&quot;...(length %d)&quot;, len(*ll.Message))
</a><a href="#h47-0-535" id="h47-0-535" class="i">+		ll.Message = proto.String((*ll.Message)[:lim-len(suffix)] + suffix)
</a><a href="#h47-0-536" id="h47-0-536" class="i">+	}
</a><a href="#h47-0-537" id="h47-0-537" class="i">+
</a><a href="#h47-0-538" id="h47-0-538" class="i">+	c.pendingLogs.Lock()
</a><a href="#h47-0-539" id="h47-0-539" class="i">+	c.pendingLogs.lines = append(c.pendingLogs.lines, ll)
</a><a href="#h47-0-540" id="h47-0-540" class="i">+	c.pendingLogs.Unlock()
</a><a href="#h47-0-541" id="h47-0-541" class="i">+}
</a><a href="#h47-0-542" id="h47-0-542" class="i">+
</a><a href="#h47-0-543" id="h47-0-543" class="i">+var logLevelName = map[int64]string{
</a><a href="#h47-0-544" id="h47-0-544" class="i">+	0: &quot;DEBUG&quot;,
</a><a href="#h47-0-545" id="h47-0-545" class="i">+	1: &quot;INFO&quot;,
</a><a href="#h47-0-546" id="h47-0-546" class="i">+	2: &quot;WARNING&quot;,
</a><a href="#h47-0-547" id="h47-0-547" class="i">+	3: &quot;ERROR&quot;,
</a><a href="#h47-0-548" id="h47-0-548" class="i">+	4: &quot;CRITICAL&quot;,
</a><a href="#h47-0-549" id="h47-0-549" class="i">+}
</a><a href="#h47-0-550" id="h47-0-550" class="i">+
</a><a href="#h47-0-551" id="h47-0-551" class="i">+func logf(c *context, level int64, format string, args ...interface{}) {
</a><a href="#h47-0-552" id="h47-0-552" class="i">+	s := fmt.Sprintf(format, args...)
</a><a href="#h47-0-553" id="h47-0-553" class="i">+	s = strings.TrimRight(s, &quot;\n&quot;) // Remove any trailing newline characters.
</a><a href="#h47-0-554" id="h47-0-554" class="i">+	c.addLogLine(&amp;logpb.UserAppLogLine{
</a><a href="#h47-0-555" id="h47-0-555" class="i">+		TimestampUsec: proto.Int64(time.Now().UnixNano() / 1e3),
</a><a href="#h47-0-556" id="h47-0-556" class="i">+		Level:         &amp;level,
</a><a href="#h47-0-557" id="h47-0-557" class="i">+		Message:       &amp;s,
</a><a href="#h47-0-558" id="h47-0-558" class="i">+	})
</a><a href="#h47-0-559" id="h47-0-559" class="i">+	log.Print(logLevelName[level] + &quot;: &quot; + s)
</a><a href="#h47-0-560" id="h47-0-560" class="i">+}
</a><a href="#h47-0-561" id="h47-0-561" class="i">+
</a><a href="#h47-0-562" id="h47-0-562" class="i">+// flushLog attempts to flush any pending logs to the appserver.
</a><a href="#h47-0-563" id="h47-0-563" class="i">+// It should not be called concurrently.
</a><a href="#h47-0-564" id="h47-0-564" class="i">+func (c *context) flushLog(force bool) (flushed bool) {
</a><a href="#h47-0-565" id="h47-0-565" class="i">+	c.pendingLogs.Lock()
</a><a href="#h47-0-566" id="h47-0-566" class="i">+	// Grab up to 30 MB. We can get away with up to 32 MB, but let&#39;s be cautious.
</a><a href="#h47-0-567" id="h47-0-567" class="i">+	n, rem := 0, 30&lt;&lt;20
</a><a href="#h47-0-568" id="h47-0-568" class="i">+	for ; n &lt; len(c.pendingLogs.lines); n++ {
</a><a href="#h47-0-569" id="h47-0-569" class="i">+		ll := c.pendingLogs.lines[n]
</a><a href="#h47-0-570" id="h47-0-570" class="i">+		// Each log line will require about 3 bytes of overhead.
</a><a href="#h47-0-571" id="h47-0-571" class="i">+		nb := proto.Size(ll) + 3
</a><a href="#h47-0-572" id="h47-0-572" class="i">+		if nb &gt; rem {
</a><a href="#h47-0-573" id="h47-0-573" class="i">+			break
</a><a href="#h47-0-574" id="h47-0-574" class="i">+		}
</a><a href="#h47-0-575" id="h47-0-575" class="i">+		rem -= nb
</a><a href="#h47-0-576" id="h47-0-576" class="i">+	}
</a><a href="#h47-0-577" id="h47-0-577" class="i">+	lines := c.pendingLogs.lines[:n]
</a><a href="#h47-0-578" id="h47-0-578" class="i">+	c.pendingLogs.lines = c.pendingLogs.lines[n:]
</a><a href="#h47-0-579" id="h47-0-579" class="i">+	c.pendingLogs.Unlock()
</a><a href="#h47-0-580" id="h47-0-580" class="i">+
</a><a href="#h47-0-581" id="h47-0-581" class="i">+	if len(lines) == 0 &amp;&amp; !force {
</a><a href="#h47-0-582" id="h47-0-582" class="i">+		// Nothing to flush.
</a><a href="#h47-0-583" id="h47-0-583" class="i">+		return false
</a><a href="#h47-0-584" id="h47-0-584" class="i">+	}
</a><a href="#h47-0-585" id="h47-0-585" class="i">+
</a><a href="#h47-0-586" id="h47-0-586" class="i">+	rescueLogs := false
</a><a href="#h47-0-587" id="h47-0-587" class="i">+	defer func() {
</a><a href="#h47-0-588" id="h47-0-588" class="i">+		if rescueLogs {
</a><a href="#h47-0-589" id="h47-0-589" class="i">+			c.pendingLogs.Lock()
</a><a href="#h47-0-590" id="h47-0-590" class="i">+			c.pendingLogs.lines = append(lines, c.pendingLogs.lines...)
</a><a href="#h47-0-591" id="h47-0-591" class="i">+			c.pendingLogs.Unlock()
</a><a href="#h47-0-592" id="h47-0-592" class="i">+		}
</a><a href="#h47-0-593" id="h47-0-593" class="i">+	}()
</a><a href="#h47-0-594" id="h47-0-594" class="i">+
</a><a href="#h47-0-595" id="h47-0-595" class="i">+	buf, err := proto.Marshal(&amp;logpb.UserAppLogGroup{
</a><a href="#h47-0-596" id="h47-0-596" class="i">+		LogLine: lines,
</a><a href="#h47-0-597" id="h47-0-597" class="i">+	})
</a><a href="#h47-0-598" id="h47-0-598" class="i">+	if err != nil {
</a><a href="#h47-0-599" id="h47-0-599" class="i">+		log.Printf(&quot;internal.flushLog: marshaling UserAppLogGroup: %v&quot;, err)
</a><a href="#h47-0-600" id="h47-0-600" class="i">+		rescueLogs = true
</a><a href="#h47-0-601" id="h47-0-601" class="i">+		return false
</a><a href="#h47-0-602" id="h47-0-602" class="i">+	}
</a><a href="#h47-0-603" id="h47-0-603" class="i">+
</a><a href="#h47-0-604" id="h47-0-604" class="i">+	req := &amp;logpb.FlushRequest{
</a><a href="#h47-0-605" id="h47-0-605" class="i">+		Logs: buf,
</a><a href="#h47-0-606" id="h47-0-606" class="i">+	}
</a><a href="#h47-0-607" id="h47-0-607" class="i">+	res := &amp;basepb.VoidProto{}
</a><a href="#h47-0-608" id="h47-0-608" class="i">+	c.pendingLogs.Lock()
</a><a href="#h47-0-609" id="h47-0-609" class="i">+	c.pendingLogs.flushes++
</a><a href="#h47-0-610" id="h47-0-610" class="i">+	c.pendingLogs.Unlock()
</a><a href="#h47-0-611" id="h47-0-611" class="i">+	if err := Call(toContext(c), &quot;logservice&quot;, &quot;Flush&quot;, req, res); err != nil {
</a><a href="#h47-0-612" id="h47-0-612" class="i">+		log.Printf(&quot;internal.flushLog: Flush RPC: %v&quot;, err)
</a><a href="#h47-0-613" id="h47-0-613" class="i">+		rescueLogs = true
</a><a href="#h47-0-614" id="h47-0-614" class="i">+		return false
</a><a href="#h47-0-615" id="h47-0-615" class="i">+	}
</a><a href="#h47-0-616" id="h47-0-616" class="i">+	return true
</a><a href="#h47-0-617" id="h47-0-617" class="i">+}
</a><a href="#h47-0-618" id="h47-0-618" class="i">+
</a><a href="#h47-0-619" id="h47-0-619" class="i">+const (
</a><a href="#h47-0-620" id="h47-0-620" class="i">+	// Log flushing parameters.
</a><a href="#h47-0-621" id="h47-0-621" class="i">+	flushInterval      = 1 * time.Second
</a><a href="#h47-0-622" id="h47-0-622" class="i">+	forceFlushInterval = 60 * time.Second
</a><a href="#h47-0-623" id="h47-0-623" class="i">+)
</a><a href="#h47-0-624" id="h47-0-624" class="i">+
</a><a href="#h47-0-625" id="h47-0-625" class="i">+func (c *context) logFlusher(stop &lt;-chan int) {
</a><a href="#h47-0-626" id="h47-0-626" class="i">+	lastFlush := time.Now()
</a><a href="#h47-0-627" id="h47-0-627" class="i">+	tick := time.NewTicker(flushInterval)
</a><a href="#h47-0-628" id="h47-0-628" class="i">+	for {
</a><a href="#h47-0-629" id="h47-0-629" class="i">+		select {
</a><a href="#h47-0-630" id="h47-0-630" class="i">+		case &lt;-stop:
</a><a href="#h47-0-631" id="h47-0-631" class="i">+			// Request finished.
</a><a href="#h47-0-632" id="h47-0-632" class="i">+			tick.Stop()
</a><a href="#h47-0-633" id="h47-0-633" class="i">+			return
</a><a href="#h47-0-634" id="h47-0-634" class="i">+		case &lt;-tick.C:
</a><a href="#h47-0-635" id="h47-0-635" class="i">+			force := time.Now().Sub(lastFlush) &gt; forceFlushInterval
</a><a href="#h47-0-636" id="h47-0-636" class="i">+			if c.flushLog(force) {
</a><a href="#h47-0-637" id="h47-0-637" class="i">+				lastFlush = time.Now()
</a><a href="#h47-0-638" id="h47-0-638" class="i">+			}
</a><a href="#h47-0-639" id="h47-0-639" class="i">+		}
</a><a href="#h47-0-640" id="h47-0-640" class="i">+	}
</a><a href="#h47-0-641" id="h47-0-641" class="i">+}
</a><a href="#h47-0-642" id="h47-0-642" class="i">+
</a><a href="#h47-0-643" id="h47-0-643" class="i">+func ContextForTesting(req *http.Request) netcontext.Context {
</a><a href="#h47-0-644" id="h47-0-644" class="i">+	return toContext(&amp;context{req: req})
</a><a href="#h47-0-645" id="h47-0-645" class="i">+}
</a><b>diff --git a/<a id="h48" href="../file/vendor/google.golang.org/appengine/internal/api_classic.go">vendor/google.golang.org/appengine/internal/api_classic.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/api_classic.go">vendor/google.golang.org/appengine/internal/api_classic.go</a></b>
<a href="#h48-0" id="h48-0" class="h">@@ -0,0 +1,159 @@
</a><a href="#h48-0-0" id="h48-0-0" class="i">+// Copyright 2015 Google Inc. All rights reserved.
</a><a href="#h48-0-1" id="h48-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h48-0-2" id="h48-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h48-0-3" id="h48-0-3" class="i">+
</a><a href="#h48-0-4" id="h48-0-4" class="i">+// +build appengine
</a><a href="#h48-0-5" id="h48-0-5" class="i">+
</a><a href="#h48-0-6" id="h48-0-6" class="i">+package internal
</a><a href="#h48-0-7" id="h48-0-7" class="i">+
</a><a href="#h48-0-8" id="h48-0-8" class="i">+import (
</a><a href="#h48-0-9" id="h48-0-9" class="i">+	&quot;errors&quot;
</a><a href="#h48-0-10" id="h48-0-10" class="i">+	&quot;fmt&quot;
</a><a href="#h48-0-11" id="h48-0-11" class="i">+	&quot;net/http&quot;
</a><a href="#h48-0-12" id="h48-0-12" class="i">+	&quot;time&quot;
</a><a href="#h48-0-13" id="h48-0-13" class="i">+
</a><a href="#h48-0-14" id="h48-0-14" class="i">+	&quot;appengine&quot;
</a><a href="#h48-0-15" id="h48-0-15" class="i">+	&quot;appengine_internal&quot;
</a><a href="#h48-0-16" id="h48-0-16" class="i">+	basepb &quot;appengine_internal/base&quot;
</a><a href="#h48-0-17" id="h48-0-17" class="i">+
</a><a href="#h48-0-18" id="h48-0-18" class="i">+	&quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h48-0-19" id="h48-0-19" class="i">+	netcontext &quot;golang.org/x/net/context&quot;
</a><a href="#h48-0-20" id="h48-0-20" class="i">+)
</a><a href="#h48-0-21" id="h48-0-21" class="i">+
</a><a href="#h48-0-22" id="h48-0-22" class="i">+var contextKey = &quot;holds an appengine.Context&quot;
</a><a href="#h48-0-23" id="h48-0-23" class="i">+
</a><a href="#h48-0-24" id="h48-0-24" class="i">+func fromContext(ctx netcontext.Context) appengine.Context {
</a><a href="#h48-0-25" id="h48-0-25" class="i">+	c, _ := ctx.Value(&amp;contextKey).(appengine.Context)
</a><a href="#h48-0-26" id="h48-0-26" class="i">+	return c
</a><a href="#h48-0-27" id="h48-0-27" class="i">+}
</a><a href="#h48-0-28" id="h48-0-28" class="i">+
</a><a href="#h48-0-29" id="h48-0-29" class="i">+// This is only for classic App Engine adapters.
</a><a href="#h48-0-30" id="h48-0-30" class="i">+func ClassicContextFromContext(ctx netcontext.Context) appengine.Context {
</a><a href="#h48-0-31" id="h48-0-31" class="i">+	return fromContext(ctx)
</a><a href="#h48-0-32" id="h48-0-32" class="i">+}
</a><a href="#h48-0-33" id="h48-0-33" class="i">+
</a><a href="#h48-0-34" id="h48-0-34" class="i">+func withContext(parent netcontext.Context, c appengine.Context) netcontext.Context {
</a><a href="#h48-0-35" id="h48-0-35" class="i">+	ctx := netcontext.WithValue(parent, &amp;contextKey, c)
</a><a href="#h48-0-36" id="h48-0-36" class="i">+
</a><a href="#h48-0-37" id="h48-0-37" class="i">+	s := &amp;basepb.StringProto{}
</a><a href="#h48-0-38" id="h48-0-38" class="i">+	c.Call(&quot;__go__&quot;, &quot;GetNamespace&quot;, &amp;basepb.VoidProto{}, s, nil)
</a><a href="#h48-0-39" id="h48-0-39" class="i">+	if ns := s.GetValue(); ns != &quot;&quot; {
</a><a href="#h48-0-40" id="h48-0-40" class="i">+		ctx = NamespacedContext(ctx, ns)
</a><a href="#h48-0-41" id="h48-0-41" class="i">+	}
</a><a href="#h48-0-42" id="h48-0-42" class="i">+
</a><a href="#h48-0-43" id="h48-0-43" class="i">+	return ctx
</a><a href="#h48-0-44" id="h48-0-44" class="i">+}
</a><a href="#h48-0-45" id="h48-0-45" class="i">+
</a><a href="#h48-0-46" id="h48-0-46" class="i">+func IncomingHeaders(ctx netcontext.Context) http.Header {
</a><a href="#h48-0-47" id="h48-0-47" class="i">+	if c := fromContext(ctx); c != nil {
</a><a href="#h48-0-48" id="h48-0-48" class="i">+		if req, ok := c.Request().(*http.Request); ok {
</a><a href="#h48-0-49" id="h48-0-49" class="i">+			return req.Header
</a><a href="#h48-0-50" id="h48-0-50" class="i">+		}
</a><a href="#h48-0-51" id="h48-0-51" class="i">+	}
</a><a href="#h48-0-52" id="h48-0-52" class="i">+	return nil
</a><a href="#h48-0-53" id="h48-0-53" class="i">+}
</a><a href="#h48-0-54" id="h48-0-54" class="i">+
</a><a href="#h48-0-55" id="h48-0-55" class="i">+func WithContext(parent netcontext.Context, req *http.Request) netcontext.Context {
</a><a href="#h48-0-56" id="h48-0-56" class="i">+	c := appengine.NewContext(req)
</a><a href="#h48-0-57" id="h48-0-57" class="i">+	return withContext(parent, c)
</a><a href="#h48-0-58" id="h48-0-58" class="i">+}
</a><a href="#h48-0-59" id="h48-0-59" class="i">+
</a><a href="#h48-0-60" id="h48-0-60" class="i">+type testingContext struct {
</a><a href="#h48-0-61" id="h48-0-61" class="i">+	appengine.Context
</a><a href="#h48-0-62" id="h48-0-62" class="i">+
</a><a href="#h48-0-63" id="h48-0-63" class="i">+	req *http.Request
</a><a href="#h48-0-64" id="h48-0-64" class="i">+}
</a><a href="#h48-0-65" id="h48-0-65" class="i">+
</a><a href="#h48-0-66" id="h48-0-66" class="i">+func (t *testingContext) FullyQualifiedAppID() string { return &quot;dev~testcontext&quot; }
</a><a href="#h48-0-67" id="h48-0-67" class="i">+func (t *testingContext) Call(service, method string, _, _ appengine_internal.ProtoMessage, _ *appengine_internal.CallOptions) error {
</a><a href="#h48-0-68" id="h48-0-68" class="i">+	if service == &quot;__go__&quot; &amp;&amp; method == &quot;GetNamespace&quot; {
</a><a href="#h48-0-69" id="h48-0-69" class="i">+		return nil
</a><a href="#h48-0-70" id="h48-0-70" class="i">+	}
</a><a href="#h48-0-71" id="h48-0-71" class="i">+	return fmt.Errorf(&quot;testingContext: unsupported Call&quot;)
</a><a href="#h48-0-72" id="h48-0-72" class="i">+}
</a><a href="#h48-0-73" id="h48-0-73" class="i">+func (t *testingContext) Request() interface{} { return t.req }
</a><a href="#h48-0-74" id="h48-0-74" class="i">+
</a><a href="#h48-0-75" id="h48-0-75" class="i">+func ContextForTesting(req *http.Request) netcontext.Context {
</a><a href="#h48-0-76" id="h48-0-76" class="i">+	return withContext(netcontext.Background(), &amp;testingContext{req: req})
</a><a href="#h48-0-77" id="h48-0-77" class="i">+}
</a><a href="#h48-0-78" id="h48-0-78" class="i">+
</a><a href="#h48-0-79" id="h48-0-79" class="i">+func Call(ctx netcontext.Context, service, method string, in, out proto.Message) error {
</a><a href="#h48-0-80" id="h48-0-80" class="i">+	if ns := NamespaceFromContext(ctx); ns != &quot;&quot; {
</a><a href="#h48-0-81" id="h48-0-81" class="i">+		if fn, ok := NamespaceMods[service]; ok {
</a><a href="#h48-0-82" id="h48-0-82" class="i">+			fn(in, ns)
</a><a href="#h48-0-83" id="h48-0-83" class="i">+		}
</a><a href="#h48-0-84" id="h48-0-84" class="i">+	}
</a><a href="#h48-0-85" id="h48-0-85" class="i">+
</a><a href="#h48-0-86" id="h48-0-86" class="i">+	if f, ctx, ok := callOverrideFromContext(ctx); ok {
</a><a href="#h48-0-87" id="h48-0-87" class="i">+		return f(ctx, service, method, in, out)
</a><a href="#h48-0-88" id="h48-0-88" class="i">+	}
</a><a href="#h48-0-89" id="h48-0-89" class="i">+
</a><a href="#h48-0-90" id="h48-0-90" class="i">+	// Handle already-done contexts quickly.
</a><a href="#h48-0-91" id="h48-0-91" class="i">+	select {
</a><a href="#h48-0-92" id="h48-0-92" class="i">+	case &lt;-ctx.Done():
</a><a href="#h48-0-93" id="h48-0-93" class="i">+		return ctx.Err()
</a><a href="#h48-0-94" id="h48-0-94" class="i">+	default:
</a><a href="#h48-0-95" id="h48-0-95" class="i">+	}
</a><a href="#h48-0-96" id="h48-0-96" class="i">+
</a><a href="#h48-0-97" id="h48-0-97" class="i">+	c := fromContext(ctx)
</a><a href="#h48-0-98" id="h48-0-98" class="i">+	if c == nil {
</a><a href="#h48-0-99" id="h48-0-99" class="i">+		// Give a good error message rather than a panic lower down.
</a><a href="#h48-0-100" id="h48-0-100" class="i">+		return errors.New(&quot;not an App Engine context&quot;)
</a><a href="#h48-0-101" id="h48-0-101" class="i">+	}
</a><a href="#h48-0-102" id="h48-0-102" class="i">+
</a><a href="#h48-0-103" id="h48-0-103" class="i">+	// Apply transaction modifications if we&#39;re in a transaction.
</a><a href="#h48-0-104" id="h48-0-104" class="i">+	if t := transactionFromContext(ctx); t != nil {
</a><a href="#h48-0-105" id="h48-0-105" class="i">+		if t.finished {
</a><a href="#h48-0-106" id="h48-0-106" class="i">+			return errors.New(&quot;transaction context has expired&quot;)
</a><a href="#h48-0-107" id="h48-0-107" class="i">+		}
</a><a href="#h48-0-108" id="h48-0-108" class="i">+		applyTransaction(in, &amp;t.transaction)
</a><a href="#h48-0-109" id="h48-0-109" class="i">+	}
</a><a href="#h48-0-110" id="h48-0-110" class="i">+
</a><a href="#h48-0-111" id="h48-0-111" class="i">+	var opts *appengine_internal.CallOptions
</a><a href="#h48-0-112" id="h48-0-112" class="i">+	if d, ok := ctx.Deadline(); ok {
</a><a href="#h48-0-113" id="h48-0-113" class="i">+		opts = &amp;appengine_internal.CallOptions{
</a><a href="#h48-0-114" id="h48-0-114" class="i">+			Timeout: d.Sub(time.Now()),
</a><a href="#h48-0-115" id="h48-0-115" class="i">+		}
</a><a href="#h48-0-116" id="h48-0-116" class="i">+	}
</a><a href="#h48-0-117" id="h48-0-117" class="i">+
</a><a href="#h48-0-118" id="h48-0-118" class="i">+	err := c.Call(service, method, in, out, opts)
</a><a href="#h48-0-119" id="h48-0-119" class="i">+	switch v := err.(type) {
</a><a href="#h48-0-120" id="h48-0-120" class="i">+	case *appengine_internal.APIError:
</a><a href="#h48-0-121" id="h48-0-121" class="i">+		return &amp;APIError{
</a><a href="#h48-0-122" id="h48-0-122" class="i">+			Service: v.Service,
</a><a href="#h48-0-123" id="h48-0-123" class="i">+			Detail:  v.Detail,
</a><a href="#h48-0-124" id="h48-0-124" class="i">+			Code:    v.Code,
</a><a href="#h48-0-125" id="h48-0-125" class="i">+		}
</a><a href="#h48-0-126" id="h48-0-126" class="i">+	case *appengine_internal.CallError:
</a><a href="#h48-0-127" id="h48-0-127" class="i">+		return &amp;CallError{
</a><a href="#h48-0-128" id="h48-0-128" class="i">+			Detail:  v.Detail,
</a><a href="#h48-0-129" id="h48-0-129" class="i">+			Code:    v.Code,
</a><a href="#h48-0-130" id="h48-0-130" class="i">+			Timeout: v.Timeout,
</a><a href="#h48-0-131" id="h48-0-131" class="i">+		}
</a><a href="#h48-0-132" id="h48-0-132" class="i">+	}
</a><a href="#h48-0-133" id="h48-0-133" class="i">+	return err
</a><a href="#h48-0-134" id="h48-0-134" class="i">+}
</a><a href="#h48-0-135" id="h48-0-135" class="i">+
</a><a href="#h48-0-136" id="h48-0-136" class="i">+func handleHTTP(w http.ResponseWriter, r *http.Request) {
</a><a href="#h48-0-137" id="h48-0-137" class="i">+	panic(&quot;handleHTTP called; this should be impossible&quot;)
</a><a href="#h48-0-138" id="h48-0-138" class="i">+}
</a><a href="#h48-0-139" id="h48-0-139" class="i">+
</a><a href="#h48-0-140" id="h48-0-140" class="i">+func logf(c appengine.Context, level int64, format string, args ...interface{}) {
</a><a href="#h48-0-141" id="h48-0-141" class="i">+	var fn func(format string, args ...interface{})
</a><a href="#h48-0-142" id="h48-0-142" class="i">+	switch level {
</a><a href="#h48-0-143" id="h48-0-143" class="i">+	case 0:
</a><a href="#h48-0-144" id="h48-0-144" class="i">+		fn = c.Debugf
</a><a href="#h48-0-145" id="h48-0-145" class="i">+	case 1:
</a><a href="#h48-0-146" id="h48-0-146" class="i">+		fn = c.Infof
</a><a href="#h48-0-147" id="h48-0-147" class="i">+	case 2:
</a><a href="#h48-0-148" id="h48-0-148" class="i">+		fn = c.Warningf
</a><a href="#h48-0-149" id="h48-0-149" class="i">+	case 3:
</a><a href="#h48-0-150" id="h48-0-150" class="i">+		fn = c.Errorf
</a><a href="#h48-0-151" id="h48-0-151" class="i">+	case 4:
</a><a href="#h48-0-152" id="h48-0-152" class="i">+		fn = c.Criticalf
</a><a href="#h48-0-153" id="h48-0-153" class="i">+	default:
</a><a href="#h48-0-154" id="h48-0-154" class="i">+		// This shouldn&#39;t happen.
</a><a href="#h48-0-155" id="h48-0-155" class="i">+		fn = c.Criticalf
</a><a href="#h48-0-156" id="h48-0-156" class="i">+	}
</a><a href="#h48-0-157" id="h48-0-157" class="i">+	fn(format, args...)
</a><a href="#h48-0-158" id="h48-0-158" class="i">+}
</a><b>diff --git a/<a id="h49" href="../file/vendor/google.golang.org/appengine/internal/api_common.go">vendor/google.golang.org/appengine/internal/api_common.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/api_common.go">vendor/google.golang.org/appengine/internal/api_common.go</a></b>
<a href="#h49-0" id="h49-0" class="h">@@ -0,0 +1,86 @@
</a><a href="#h49-0-0" id="h49-0-0" class="i">+// Copyright 2015 Google Inc. All rights reserved.
</a><a href="#h49-0-1" id="h49-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h49-0-2" id="h49-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h49-0-3" id="h49-0-3" class="i">+
</a><a href="#h49-0-4" id="h49-0-4" class="i">+package internal
</a><a href="#h49-0-5" id="h49-0-5" class="i">+
</a><a href="#h49-0-6" id="h49-0-6" class="i">+import (
</a><a href="#h49-0-7" id="h49-0-7" class="i">+	&quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h49-0-8" id="h49-0-8" class="i">+	netcontext &quot;golang.org/x/net/context&quot;
</a><a href="#h49-0-9" id="h49-0-9" class="i">+)
</a><a href="#h49-0-10" id="h49-0-10" class="i">+
</a><a href="#h49-0-11" id="h49-0-11" class="i">+type CallOverrideFunc func(ctx netcontext.Context, service, method string, in, out proto.Message) error
</a><a href="#h49-0-12" id="h49-0-12" class="i">+
</a><a href="#h49-0-13" id="h49-0-13" class="i">+var callOverrideKey = &quot;holds []CallOverrideFunc&quot;
</a><a href="#h49-0-14" id="h49-0-14" class="i">+
</a><a href="#h49-0-15" id="h49-0-15" class="i">+func WithCallOverride(ctx netcontext.Context, f CallOverrideFunc) netcontext.Context {
</a><a href="#h49-0-16" id="h49-0-16" class="i">+	// We avoid appending to any existing call override
</a><a href="#h49-0-17" id="h49-0-17" class="i">+	// so we don&#39;t risk overwriting a popped stack below.
</a><a href="#h49-0-18" id="h49-0-18" class="i">+	var cofs []CallOverrideFunc
</a><a href="#h49-0-19" id="h49-0-19" class="i">+	if uf, ok := ctx.Value(&amp;callOverrideKey).([]CallOverrideFunc); ok {
</a><a href="#h49-0-20" id="h49-0-20" class="i">+		cofs = append(cofs, uf...)
</a><a href="#h49-0-21" id="h49-0-21" class="i">+	}
</a><a href="#h49-0-22" id="h49-0-22" class="i">+	cofs = append(cofs, f)
</a><a href="#h49-0-23" id="h49-0-23" class="i">+	return netcontext.WithValue(ctx, &amp;callOverrideKey, cofs)
</a><a href="#h49-0-24" id="h49-0-24" class="i">+}
</a><a href="#h49-0-25" id="h49-0-25" class="i">+
</a><a href="#h49-0-26" id="h49-0-26" class="i">+func callOverrideFromContext(ctx netcontext.Context) (CallOverrideFunc, netcontext.Context, bool) {
</a><a href="#h49-0-27" id="h49-0-27" class="i">+	cofs, _ := ctx.Value(&amp;callOverrideKey).([]CallOverrideFunc)
</a><a href="#h49-0-28" id="h49-0-28" class="i">+	if len(cofs) == 0 {
</a><a href="#h49-0-29" id="h49-0-29" class="i">+		return nil, nil, false
</a><a href="#h49-0-30" id="h49-0-30" class="i">+	}
</a><a href="#h49-0-31" id="h49-0-31" class="i">+	// We found a list of overrides; grab the last, and reconstitute a
</a><a href="#h49-0-32" id="h49-0-32" class="i">+	// context that will hide it.
</a><a href="#h49-0-33" id="h49-0-33" class="i">+	f := cofs[len(cofs)-1]
</a><a href="#h49-0-34" id="h49-0-34" class="i">+	ctx = netcontext.WithValue(ctx, &amp;callOverrideKey, cofs[:len(cofs)-1])
</a><a href="#h49-0-35" id="h49-0-35" class="i">+	return f, ctx, true
</a><a href="#h49-0-36" id="h49-0-36" class="i">+}
</a><a href="#h49-0-37" id="h49-0-37" class="i">+
</a><a href="#h49-0-38" id="h49-0-38" class="i">+type logOverrideFunc func(level int64, format string, args ...interface{})
</a><a href="#h49-0-39" id="h49-0-39" class="i">+
</a><a href="#h49-0-40" id="h49-0-40" class="i">+var logOverrideKey = &quot;holds a logOverrideFunc&quot;
</a><a href="#h49-0-41" id="h49-0-41" class="i">+
</a><a href="#h49-0-42" id="h49-0-42" class="i">+func WithLogOverride(ctx netcontext.Context, f logOverrideFunc) netcontext.Context {
</a><a href="#h49-0-43" id="h49-0-43" class="i">+	return netcontext.WithValue(ctx, &amp;logOverrideKey, f)
</a><a href="#h49-0-44" id="h49-0-44" class="i">+}
</a><a href="#h49-0-45" id="h49-0-45" class="i">+
</a><a href="#h49-0-46" id="h49-0-46" class="i">+var appIDOverrideKey = &quot;holds a string, being the full app ID&quot;
</a><a href="#h49-0-47" id="h49-0-47" class="i">+
</a><a href="#h49-0-48" id="h49-0-48" class="i">+func WithAppIDOverride(ctx netcontext.Context, appID string) netcontext.Context {
</a><a href="#h49-0-49" id="h49-0-49" class="i">+	return netcontext.WithValue(ctx, &amp;appIDOverrideKey, appID)
</a><a href="#h49-0-50" id="h49-0-50" class="i">+}
</a><a href="#h49-0-51" id="h49-0-51" class="i">+
</a><a href="#h49-0-52" id="h49-0-52" class="i">+var namespaceKey = &quot;holds the namespace string&quot;
</a><a href="#h49-0-53" id="h49-0-53" class="i">+
</a><a href="#h49-0-54" id="h49-0-54" class="i">+func withNamespace(ctx netcontext.Context, ns string) netcontext.Context {
</a><a href="#h49-0-55" id="h49-0-55" class="i">+	return netcontext.WithValue(ctx, &amp;namespaceKey, ns)
</a><a href="#h49-0-56" id="h49-0-56" class="i">+}
</a><a href="#h49-0-57" id="h49-0-57" class="i">+
</a><a href="#h49-0-58" id="h49-0-58" class="i">+func NamespaceFromContext(ctx netcontext.Context) string {
</a><a href="#h49-0-59" id="h49-0-59" class="i">+	// If there&#39;s no namespace, return the empty string.
</a><a href="#h49-0-60" id="h49-0-60" class="i">+	ns, _ := ctx.Value(&amp;namespaceKey).(string)
</a><a href="#h49-0-61" id="h49-0-61" class="i">+	return ns
</a><a href="#h49-0-62" id="h49-0-62" class="i">+}
</a><a href="#h49-0-63" id="h49-0-63" class="i">+
</a><a href="#h49-0-64" id="h49-0-64" class="i">+// FullyQualifiedAppID returns the fully-qualified application ID.
</a><a href="#h49-0-65" id="h49-0-65" class="i">+// This may contain a partition prefix (e.g. &quot;s~&quot; for High Replication apps),
</a><a href="#h49-0-66" id="h49-0-66" class="i">+// or a domain prefix (e.g. &quot;example.com:&quot;).
</a><a href="#h49-0-67" id="h49-0-67" class="i">+func FullyQualifiedAppID(ctx netcontext.Context) string {
</a><a href="#h49-0-68" id="h49-0-68" class="i">+	if id, ok := ctx.Value(&amp;appIDOverrideKey).(string); ok {
</a><a href="#h49-0-69" id="h49-0-69" class="i">+		return id
</a><a href="#h49-0-70" id="h49-0-70" class="i">+	}
</a><a href="#h49-0-71" id="h49-0-71" class="i">+	return fullyQualifiedAppID(ctx)
</a><a href="#h49-0-72" id="h49-0-72" class="i">+}
</a><a href="#h49-0-73" id="h49-0-73" class="i">+
</a><a href="#h49-0-74" id="h49-0-74" class="i">+func Logf(ctx netcontext.Context, level int64, format string, args ...interface{}) {
</a><a href="#h49-0-75" id="h49-0-75" class="i">+	if f, ok := ctx.Value(&amp;logOverrideKey).(logOverrideFunc); ok {
</a><a href="#h49-0-76" id="h49-0-76" class="i">+		f(level, format, args...)
</a><a href="#h49-0-77" id="h49-0-77" class="i">+		return
</a><a href="#h49-0-78" id="h49-0-78" class="i">+	}
</a><a href="#h49-0-79" id="h49-0-79" class="i">+	logf(fromContext(ctx), level, format, args...)
</a><a href="#h49-0-80" id="h49-0-80" class="i">+}
</a><a href="#h49-0-81" id="h49-0-81" class="i">+
</a><a href="#h49-0-82" id="h49-0-82" class="i">+// NamespacedContext wraps a Context to support namespaces.
</a><a href="#h49-0-83" id="h49-0-83" class="i">+func NamespacedContext(ctx netcontext.Context, namespace string) netcontext.Context {
</a><a href="#h49-0-84" id="h49-0-84" class="i">+	return withNamespace(ctx, namespace)
</a><a href="#h49-0-85" id="h49-0-85" class="i">+}
</a><b>diff --git a/<a id="h50" href="../file/vendor/google.golang.org/appengine/internal/app_id.go">vendor/google.golang.org/appengine/internal/app_id.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/app_id.go">vendor/google.golang.org/appengine/internal/app_id.go</a></b>
<a href="#h50-0" id="h50-0" class="h">@@ -0,0 +1,28 @@
</a><a href="#h50-0-0" id="h50-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h50-0-1" id="h50-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h50-0-2" id="h50-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h50-0-3" id="h50-0-3" class="i">+
</a><a href="#h50-0-4" id="h50-0-4" class="i">+package internal
</a><a href="#h50-0-5" id="h50-0-5" class="i">+
</a><a href="#h50-0-6" id="h50-0-6" class="i">+import (
</a><a href="#h50-0-7" id="h50-0-7" class="i">+	&quot;strings&quot;
</a><a href="#h50-0-8" id="h50-0-8" class="i">+)
</a><a href="#h50-0-9" id="h50-0-9" class="i">+
</a><a href="#h50-0-10" id="h50-0-10" class="i">+func parseFullAppID(appid string) (partition, domain, displayID string) {
</a><a href="#h50-0-11" id="h50-0-11" class="i">+	if i := strings.Index(appid, &quot;~&quot;); i != -1 {
</a><a href="#h50-0-12" id="h50-0-12" class="i">+		partition, appid = appid[:i], appid[i+1:]
</a><a href="#h50-0-13" id="h50-0-13" class="i">+	}
</a><a href="#h50-0-14" id="h50-0-14" class="i">+	if i := strings.Index(appid, &quot;:&quot;); i != -1 {
</a><a href="#h50-0-15" id="h50-0-15" class="i">+		domain, appid = appid[:i], appid[i+1:]
</a><a href="#h50-0-16" id="h50-0-16" class="i">+	}
</a><a href="#h50-0-17" id="h50-0-17" class="i">+	return partition, domain, appid
</a><a href="#h50-0-18" id="h50-0-18" class="i">+}
</a><a href="#h50-0-19" id="h50-0-19" class="i">+
</a><a href="#h50-0-20" id="h50-0-20" class="i">+// appID returns &quot;appid&quot; or &quot;domain.com:appid&quot;.
</a><a href="#h50-0-21" id="h50-0-21" class="i">+func appID(fullAppID string) string {
</a><a href="#h50-0-22" id="h50-0-22" class="i">+	_, dom, dis := parseFullAppID(fullAppID)
</a><a href="#h50-0-23" id="h50-0-23" class="i">+	if dom != &quot;&quot; {
</a><a href="#h50-0-24" id="h50-0-24" class="i">+		return dom + &quot;:&quot; + dis
</a><a href="#h50-0-25" id="h50-0-25" class="i">+	}
</a><a href="#h50-0-26" id="h50-0-26" class="i">+	return dis
</a><a href="#h50-0-27" id="h50-0-27" class="i">+}
</a><b>diff --git a/<a id="h51" href="../file/vendor/google.golang.org/appengine/internal/base/BUILD">vendor/google.golang.org/appengine/internal/base/BUILD</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/base/BUILD">vendor/google.golang.org/appengine/internal/base/BUILD</a></b>
<a href="#h51-0" id="h51-0" class="h">@@ -0,0 +1,19 @@
</a><a href="#h51-0-0" id="h51-0-0" class="i">+
</a><a href="#h51-0-1" id="h51-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h51-0-2" id="h51-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h51-0-3" id="h51-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h51-0-4" id="h51-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h51-0-5" id="h51-0-5" class="i">+)
</a><a href="#h51-0-6" id="h51-0-6" class="i">+
</a><a href="#h51-0-7" id="h51-0-7" class="i">+go_library(
</a><a href="#h51-0-8" id="h51-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h51-0-9" id="h51-0-9" class="i">+  srcs = [
</a><a href="#h51-0-10" id="h51-0-10" class="i">+    &quot;api_base.pb.go&quot;,
</a><a href="#h51-0-11" id="h51-0-11" class="i">+  ],
</a><a href="#h51-0-12" id="h51-0-12" class="i">+  deps = [
</a><a href="#h51-0-13" id="h51-0-13" class="i">+    &quot;//vendor/github.com/golang/protobuf/proto:go_default_library&quot;,
</a><a href="#h51-0-14" id="h51-0-14" class="i">+  ],
</a><a href="#h51-0-15" id="h51-0-15" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h51-0-16" id="h51-0-16" class="i">+)
</a><a href="#h51-0-17" id="h51-0-17" class="i">+
</a><a href="#h51-0-18" id="h51-0-18" class="i">+
</a><b>diff --git a/<a id="h52" href="../file/vendor/google.golang.org/appengine/internal/base/api_base.pb.go">vendor/google.golang.org/appengine/internal/base/api_base.pb.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/base/api_base.pb.go">vendor/google.golang.org/appengine/internal/base/api_base.pb.go</a></b>
<a href="#h52-0" id="h52-0" class="h">@@ -0,0 +1,133 @@
</a><a href="#h52-0-0" id="h52-0-0" class="i">+// Code generated by protoc-gen-go.
</a><a href="#h52-0-1" id="h52-0-1" class="i">+// source: google.golang.org/appengine/internal/base/api_base.proto
</a><a href="#h52-0-2" id="h52-0-2" class="i">+// DO NOT EDIT!
</a><a href="#h52-0-3" id="h52-0-3" class="i">+
</a><a href="#h52-0-4" id="h52-0-4" class="i">+/*
</a><a href="#h52-0-5" id="h52-0-5" class="i">+Package base is a generated protocol buffer package.
</a><a href="#h52-0-6" id="h52-0-6" class="i">+
</a><a href="#h52-0-7" id="h52-0-7" class="i">+It is generated from these files:
</a><a href="#h52-0-8" id="h52-0-8" class="i">+	google.golang.org/appengine/internal/base/api_base.proto
</a><a href="#h52-0-9" id="h52-0-9" class="i">+
</a><a href="#h52-0-10" id="h52-0-10" class="i">+It has these top-level messages:
</a><a href="#h52-0-11" id="h52-0-11" class="i">+	StringProto
</a><a href="#h52-0-12" id="h52-0-12" class="i">+	Integer32Proto
</a><a href="#h52-0-13" id="h52-0-13" class="i">+	Integer64Proto
</a><a href="#h52-0-14" id="h52-0-14" class="i">+	BoolProto
</a><a href="#h52-0-15" id="h52-0-15" class="i">+	DoubleProto
</a><a href="#h52-0-16" id="h52-0-16" class="i">+	BytesProto
</a><a href="#h52-0-17" id="h52-0-17" class="i">+	VoidProto
</a><a href="#h52-0-18" id="h52-0-18" class="i">+*/
</a><a href="#h52-0-19" id="h52-0-19" class="i">+package base
</a><a href="#h52-0-20" id="h52-0-20" class="i">+
</a><a href="#h52-0-21" id="h52-0-21" class="i">+import proto &quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h52-0-22" id="h52-0-22" class="i">+import fmt &quot;fmt&quot;
</a><a href="#h52-0-23" id="h52-0-23" class="i">+import math &quot;math&quot;
</a><a href="#h52-0-24" id="h52-0-24" class="i">+
</a><a href="#h52-0-25" id="h52-0-25" class="i">+// Reference imports to suppress errors if they are not otherwise used.
</a><a href="#h52-0-26" id="h52-0-26" class="i">+var _ = proto.Marshal
</a><a href="#h52-0-27" id="h52-0-27" class="i">+var _ = fmt.Errorf
</a><a href="#h52-0-28" id="h52-0-28" class="i">+var _ = math.Inf
</a><a href="#h52-0-29" id="h52-0-29" class="i">+
</a><a href="#h52-0-30" id="h52-0-30" class="i">+type StringProto struct {
</a><a href="#h52-0-31" id="h52-0-31" class="i">+	Value            *string `protobuf:&quot;bytes,1,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h52-0-32" id="h52-0-32" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h52-0-33" id="h52-0-33" class="i">+}
</a><a href="#h52-0-34" id="h52-0-34" class="i">+
</a><a href="#h52-0-35" id="h52-0-35" class="i">+func (m *StringProto) Reset()         { *m = StringProto{} }
</a><a href="#h52-0-36" id="h52-0-36" class="i">+func (m *StringProto) String() string { return proto.CompactTextString(m) }
</a><a href="#h52-0-37" id="h52-0-37" class="i">+func (*StringProto) ProtoMessage()    {}
</a><a href="#h52-0-38" id="h52-0-38" class="i">+
</a><a href="#h52-0-39" id="h52-0-39" class="i">+func (m *StringProto) GetValue() string {
</a><a href="#h52-0-40" id="h52-0-40" class="i">+	if m != nil &amp;&amp; m.Value != nil {
</a><a href="#h52-0-41" id="h52-0-41" class="i">+		return *m.Value
</a><a href="#h52-0-42" id="h52-0-42" class="i">+	}
</a><a href="#h52-0-43" id="h52-0-43" class="i">+	return &quot;&quot;
</a><a href="#h52-0-44" id="h52-0-44" class="i">+}
</a><a href="#h52-0-45" id="h52-0-45" class="i">+
</a><a href="#h52-0-46" id="h52-0-46" class="i">+type Integer32Proto struct {
</a><a href="#h52-0-47" id="h52-0-47" class="i">+	Value            *int32 `protobuf:&quot;varint,1,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h52-0-48" id="h52-0-48" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h52-0-49" id="h52-0-49" class="i">+}
</a><a href="#h52-0-50" id="h52-0-50" class="i">+
</a><a href="#h52-0-51" id="h52-0-51" class="i">+func (m *Integer32Proto) Reset()         { *m = Integer32Proto{} }
</a><a href="#h52-0-52" id="h52-0-52" class="i">+func (m *Integer32Proto) String() string { return proto.CompactTextString(m) }
</a><a href="#h52-0-53" id="h52-0-53" class="i">+func (*Integer32Proto) ProtoMessage()    {}
</a><a href="#h52-0-54" id="h52-0-54" class="i">+
</a><a href="#h52-0-55" id="h52-0-55" class="i">+func (m *Integer32Proto) GetValue() int32 {
</a><a href="#h52-0-56" id="h52-0-56" class="i">+	if m != nil &amp;&amp; m.Value != nil {
</a><a href="#h52-0-57" id="h52-0-57" class="i">+		return *m.Value
</a><a href="#h52-0-58" id="h52-0-58" class="i">+	}
</a><a href="#h52-0-59" id="h52-0-59" class="i">+	return 0
</a><a href="#h52-0-60" id="h52-0-60" class="i">+}
</a><a href="#h52-0-61" id="h52-0-61" class="i">+
</a><a href="#h52-0-62" id="h52-0-62" class="i">+type Integer64Proto struct {
</a><a href="#h52-0-63" id="h52-0-63" class="i">+	Value            *int64 `protobuf:&quot;varint,1,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h52-0-64" id="h52-0-64" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h52-0-65" id="h52-0-65" class="i">+}
</a><a href="#h52-0-66" id="h52-0-66" class="i">+
</a><a href="#h52-0-67" id="h52-0-67" class="i">+func (m *Integer64Proto) Reset()         { *m = Integer64Proto{} }
</a><a href="#h52-0-68" id="h52-0-68" class="i">+func (m *Integer64Proto) String() string { return proto.CompactTextString(m) }
</a><a href="#h52-0-69" id="h52-0-69" class="i">+func (*Integer64Proto) ProtoMessage()    {}
</a><a href="#h52-0-70" id="h52-0-70" class="i">+
</a><a href="#h52-0-71" id="h52-0-71" class="i">+func (m *Integer64Proto) GetValue() int64 {
</a><a href="#h52-0-72" id="h52-0-72" class="i">+	if m != nil &amp;&amp; m.Value != nil {
</a><a href="#h52-0-73" id="h52-0-73" class="i">+		return *m.Value
</a><a href="#h52-0-74" id="h52-0-74" class="i">+	}
</a><a href="#h52-0-75" id="h52-0-75" class="i">+	return 0
</a><a href="#h52-0-76" id="h52-0-76" class="i">+}
</a><a href="#h52-0-77" id="h52-0-77" class="i">+
</a><a href="#h52-0-78" id="h52-0-78" class="i">+type BoolProto struct {
</a><a href="#h52-0-79" id="h52-0-79" class="i">+	Value            *bool  `protobuf:&quot;varint,1,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h52-0-80" id="h52-0-80" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h52-0-81" id="h52-0-81" class="i">+}
</a><a href="#h52-0-82" id="h52-0-82" class="i">+
</a><a href="#h52-0-83" id="h52-0-83" class="i">+func (m *BoolProto) Reset()         { *m = BoolProto{} }
</a><a href="#h52-0-84" id="h52-0-84" class="i">+func (m *BoolProto) String() string { return proto.CompactTextString(m) }
</a><a href="#h52-0-85" id="h52-0-85" class="i">+func (*BoolProto) ProtoMessage()    {}
</a><a href="#h52-0-86" id="h52-0-86" class="i">+
</a><a href="#h52-0-87" id="h52-0-87" class="i">+func (m *BoolProto) GetValue() bool {
</a><a href="#h52-0-88" id="h52-0-88" class="i">+	if m != nil &amp;&amp; m.Value != nil {
</a><a href="#h52-0-89" id="h52-0-89" class="i">+		return *m.Value
</a><a href="#h52-0-90" id="h52-0-90" class="i">+	}
</a><a href="#h52-0-91" id="h52-0-91" class="i">+	return false
</a><a href="#h52-0-92" id="h52-0-92" class="i">+}
</a><a href="#h52-0-93" id="h52-0-93" class="i">+
</a><a href="#h52-0-94" id="h52-0-94" class="i">+type DoubleProto struct {
</a><a href="#h52-0-95" id="h52-0-95" class="i">+	Value            *float64 `protobuf:&quot;fixed64,1,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h52-0-96" id="h52-0-96" class="i">+	XXX_unrecognized []byte   `json:&quot;-&quot;`
</a><a href="#h52-0-97" id="h52-0-97" class="i">+}
</a><a href="#h52-0-98" id="h52-0-98" class="i">+
</a><a href="#h52-0-99" id="h52-0-99" class="i">+func (m *DoubleProto) Reset()         { *m = DoubleProto{} }
</a><a href="#h52-0-100" id="h52-0-100" class="i">+func (m *DoubleProto) String() string { return proto.CompactTextString(m) }
</a><a href="#h52-0-101" id="h52-0-101" class="i">+func (*DoubleProto) ProtoMessage()    {}
</a><a href="#h52-0-102" id="h52-0-102" class="i">+
</a><a href="#h52-0-103" id="h52-0-103" class="i">+func (m *DoubleProto) GetValue() float64 {
</a><a href="#h52-0-104" id="h52-0-104" class="i">+	if m != nil &amp;&amp; m.Value != nil {
</a><a href="#h52-0-105" id="h52-0-105" class="i">+		return *m.Value
</a><a href="#h52-0-106" id="h52-0-106" class="i">+	}
</a><a href="#h52-0-107" id="h52-0-107" class="i">+	return 0
</a><a href="#h52-0-108" id="h52-0-108" class="i">+}
</a><a href="#h52-0-109" id="h52-0-109" class="i">+
</a><a href="#h52-0-110" id="h52-0-110" class="i">+type BytesProto struct {
</a><a href="#h52-0-111" id="h52-0-111" class="i">+	Value            []byte `protobuf:&quot;bytes,1,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h52-0-112" id="h52-0-112" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h52-0-113" id="h52-0-113" class="i">+}
</a><a href="#h52-0-114" id="h52-0-114" class="i">+
</a><a href="#h52-0-115" id="h52-0-115" class="i">+func (m *BytesProto) Reset()         { *m = BytesProto{} }
</a><a href="#h52-0-116" id="h52-0-116" class="i">+func (m *BytesProto) String() string { return proto.CompactTextString(m) }
</a><a href="#h52-0-117" id="h52-0-117" class="i">+func (*BytesProto) ProtoMessage()    {}
</a><a href="#h52-0-118" id="h52-0-118" class="i">+
</a><a href="#h52-0-119" id="h52-0-119" class="i">+func (m *BytesProto) GetValue() []byte {
</a><a href="#h52-0-120" id="h52-0-120" class="i">+	if m != nil {
</a><a href="#h52-0-121" id="h52-0-121" class="i">+		return m.Value
</a><a href="#h52-0-122" id="h52-0-122" class="i">+	}
</a><a href="#h52-0-123" id="h52-0-123" class="i">+	return nil
</a><a href="#h52-0-124" id="h52-0-124" class="i">+}
</a><a href="#h52-0-125" id="h52-0-125" class="i">+
</a><a href="#h52-0-126" id="h52-0-126" class="i">+type VoidProto struct {
</a><a href="#h52-0-127" id="h52-0-127" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h52-0-128" id="h52-0-128" class="i">+}
</a><a href="#h52-0-129" id="h52-0-129" class="i">+
</a><a href="#h52-0-130" id="h52-0-130" class="i">+func (m *VoidProto) Reset()         { *m = VoidProto{} }
</a><a href="#h52-0-131" id="h52-0-131" class="i">+func (m *VoidProto) String() string { return proto.CompactTextString(m) }
</a><a href="#h52-0-132" id="h52-0-132" class="i">+func (*VoidProto) ProtoMessage()    {}
</a><b>diff --git a/<a id="h53" href="../file/vendor/google.golang.org/appengine/internal/base/api_base.proto">vendor/google.golang.org/appengine/internal/base/api_base.proto</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/base/api_base.proto">vendor/google.golang.org/appengine/internal/base/api_base.proto</a></b>
<a href="#h53-0" id="h53-0" class="h">@@ -0,0 +1,33 @@
</a><a href="#h53-0-0" id="h53-0-0" class="i">+// Built-in base types for API calls. Primarily useful as return types.
</a><a href="#h53-0-1" id="h53-0-1" class="i">+
</a><a href="#h53-0-2" id="h53-0-2" class="i">+syntax = &quot;proto2&quot;;
</a><a href="#h53-0-3" id="h53-0-3" class="i">+option go_package = &quot;base&quot;;
</a><a href="#h53-0-4" id="h53-0-4" class="i">+
</a><a href="#h53-0-5" id="h53-0-5" class="i">+package appengine.base;
</a><a href="#h53-0-6" id="h53-0-6" class="i">+
</a><a href="#h53-0-7" id="h53-0-7" class="i">+message StringProto {
</a><a href="#h53-0-8" id="h53-0-8" class="i">+  required string value = 1;
</a><a href="#h53-0-9" id="h53-0-9" class="i">+}
</a><a href="#h53-0-10" id="h53-0-10" class="i">+
</a><a href="#h53-0-11" id="h53-0-11" class="i">+message Integer32Proto {
</a><a href="#h53-0-12" id="h53-0-12" class="i">+  required int32 value = 1;
</a><a href="#h53-0-13" id="h53-0-13" class="i">+}
</a><a href="#h53-0-14" id="h53-0-14" class="i">+
</a><a href="#h53-0-15" id="h53-0-15" class="i">+message Integer64Proto {
</a><a href="#h53-0-16" id="h53-0-16" class="i">+  required int64 value = 1;
</a><a href="#h53-0-17" id="h53-0-17" class="i">+}
</a><a href="#h53-0-18" id="h53-0-18" class="i">+
</a><a href="#h53-0-19" id="h53-0-19" class="i">+message BoolProto {
</a><a href="#h53-0-20" id="h53-0-20" class="i">+  required bool value = 1;
</a><a href="#h53-0-21" id="h53-0-21" class="i">+}
</a><a href="#h53-0-22" id="h53-0-22" class="i">+
</a><a href="#h53-0-23" id="h53-0-23" class="i">+message DoubleProto {
</a><a href="#h53-0-24" id="h53-0-24" class="i">+  required double value = 1;
</a><a href="#h53-0-25" id="h53-0-25" class="i">+}
</a><a href="#h53-0-26" id="h53-0-26" class="i">+
</a><a href="#h53-0-27" id="h53-0-27" class="i">+message BytesProto {
</a><a href="#h53-0-28" id="h53-0-28" class="i">+  required bytes value = 1 [ctype=CORD];
</a><a href="#h53-0-29" id="h53-0-29" class="i">+}
</a><a href="#h53-0-30" id="h53-0-30" class="i">+
</a><a href="#h53-0-31" id="h53-0-31" class="i">+message VoidProto {
</a><a href="#h53-0-32" id="h53-0-32" class="i">+}
</a><b>diff --git a/<a id="h54" href="../file/vendor/google.golang.org/appengine/internal/datastore/BUILD">vendor/google.golang.org/appengine/internal/datastore/BUILD</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/datastore/BUILD">vendor/google.golang.org/appengine/internal/datastore/BUILD</a></b>
<a href="#h54-0" id="h54-0" class="h">@@ -0,0 +1,19 @@
</a><a href="#h54-0-0" id="h54-0-0" class="i">+
</a><a href="#h54-0-1" id="h54-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h54-0-2" id="h54-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h54-0-3" id="h54-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h54-0-4" id="h54-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h54-0-5" id="h54-0-5" class="i">+)
</a><a href="#h54-0-6" id="h54-0-6" class="i">+
</a><a href="#h54-0-7" id="h54-0-7" class="i">+go_library(
</a><a href="#h54-0-8" id="h54-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h54-0-9" id="h54-0-9" class="i">+  srcs = [
</a><a href="#h54-0-10" id="h54-0-10" class="i">+    &quot;datastore_v3.pb.go&quot;,
</a><a href="#h54-0-11" id="h54-0-11" class="i">+  ],
</a><a href="#h54-0-12" id="h54-0-12" class="i">+  deps = [
</a><a href="#h54-0-13" id="h54-0-13" class="i">+    &quot;//vendor/github.com/golang/protobuf/proto:go_default_library&quot;,
</a><a href="#h54-0-14" id="h54-0-14" class="i">+  ],
</a><a href="#h54-0-15" id="h54-0-15" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h54-0-16" id="h54-0-16" class="i">+)
</a><a href="#h54-0-17" id="h54-0-17" class="i">+
</a><a href="#h54-0-18" id="h54-0-18" class="i">+
</a><b>diff --git a/<a id="h55" href="../file/vendor/google.golang.org/appengine/internal/datastore/datastore_v3.pb.go">vendor/google.golang.org/appengine/internal/datastore/datastore_v3.pb.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/datastore/datastore_v3.pb.go">vendor/google.golang.org/appengine/internal/datastore/datastore_v3.pb.go</a></b>
<a href="#h55-0" id="h55-0" class="h">@@ -0,0 +1,2778 @@
</a><a href="#h55-0-0" id="h55-0-0" class="i">+// Code generated by protoc-gen-go.
</a><a href="#h55-0-1" id="h55-0-1" class="i">+// source: google.golang.org/appengine/internal/datastore/datastore_v3.proto
</a><a href="#h55-0-2" id="h55-0-2" class="i">+// DO NOT EDIT!
</a><a href="#h55-0-3" id="h55-0-3" class="i">+
</a><a href="#h55-0-4" id="h55-0-4" class="i">+/*
</a><a href="#h55-0-5" id="h55-0-5" class="i">+Package datastore is a generated protocol buffer package.
</a><a href="#h55-0-6" id="h55-0-6" class="i">+
</a><a href="#h55-0-7" id="h55-0-7" class="i">+It is generated from these files:
</a><a href="#h55-0-8" id="h55-0-8" class="i">+	google.golang.org/appengine/internal/datastore/datastore_v3.proto
</a><a href="#h55-0-9" id="h55-0-9" class="i">+
</a><a href="#h55-0-10" id="h55-0-10" class="i">+It has these top-level messages:
</a><a href="#h55-0-11" id="h55-0-11" class="i">+	Action
</a><a href="#h55-0-12" id="h55-0-12" class="i">+	PropertyValue
</a><a href="#h55-0-13" id="h55-0-13" class="i">+	Property
</a><a href="#h55-0-14" id="h55-0-14" class="i">+	Path
</a><a href="#h55-0-15" id="h55-0-15" class="i">+	Reference
</a><a href="#h55-0-16" id="h55-0-16" class="i">+	User
</a><a href="#h55-0-17" id="h55-0-17" class="i">+	EntityProto
</a><a href="#h55-0-18" id="h55-0-18" class="i">+	CompositeProperty
</a><a href="#h55-0-19" id="h55-0-19" class="i">+	Index
</a><a href="#h55-0-20" id="h55-0-20" class="i">+	CompositeIndex
</a><a href="#h55-0-21" id="h55-0-21" class="i">+	IndexPostfix
</a><a href="#h55-0-22" id="h55-0-22" class="i">+	IndexPosition
</a><a href="#h55-0-23" id="h55-0-23" class="i">+	Snapshot
</a><a href="#h55-0-24" id="h55-0-24" class="i">+	InternalHeader
</a><a href="#h55-0-25" id="h55-0-25" class="i">+	Transaction
</a><a href="#h55-0-26" id="h55-0-26" class="i">+	Query
</a><a href="#h55-0-27" id="h55-0-27" class="i">+	CompiledQuery
</a><a href="#h55-0-28" id="h55-0-28" class="i">+	CompiledCursor
</a><a href="#h55-0-29" id="h55-0-29" class="i">+	Cursor
</a><a href="#h55-0-30" id="h55-0-30" class="i">+	Error
</a><a href="#h55-0-31" id="h55-0-31" class="i">+	Cost
</a><a href="#h55-0-32" id="h55-0-32" class="i">+	GetRequest
</a><a href="#h55-0-33" id="h55-0-33" class="i">+	GetResponse
</a><a href="#h55-0-34" id="h55-0-34" class="i">+	PutRequest
</a><a href="#h55-0-35" id="h55-0-35" class="i">+	PutResponse
</a><a href="#h55-0-36" id="h55-0-36" class="i">+	TouchRequest
</a><a href="#h55-0-37" id="h55-0-37" class="i">+	TouchResponse
</a><a href="#h55-0-38" id="h55-0-38" class="i">+	DeleteRequest
</a><a href="#h55-0-39" id="h55-0-39" class="i">+	DeleteResponse
</a><a href="#h55-0-40" id="h55-0-40" class="i">+	NextRequest
</a><a href="#h55-0-41" id="h55-0-41" class="i">+	QueryResult
</a><a href="#h55-0-42" id="h55-0-42" class="i">+	AllocateIdsRequest
</a><a href="#h55-0-43" id="h55-0-43" class="i">+	AllocateIdsResponse
</a><a href="#h55-0-44" id="h55-0-44" class="i">+	CompositeIndices
</a><a href="#h55-0-45" id="h55-0-45" class="i">+	AddActionsRequest
</a><a href="#h55-0-46" id="h55-0-46" class="i">+	AddActionsResponse
</a><a href="#h55-0-47" id="h55-0-47" class="i">+	BeginTransactionRequest
</a><a href="#h55-0-48" id="h55-0-48" class="i">+	CommitResponse
</a><a href="#h55-0-49" id="h55-0-49" class="i">+*/
</a><a href="#h55-0-50" id="h55-0-50" class="i">+package datastore
</a><a href="#h55-0-51" id="h55-0-51" class="i">+
</a><a href="#h55-0-52" id="h55-0-52" class="i">+import proto &quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h55-0-53" id="h55-0-53" class="i">+import fmt &quot;fmt&quot;
</a><a href="#h55-0-54" id="h55-0-54" class="i">+import math &quot;math&quot;
</a><a href="#h55-0-55" id="h55-0-55" class="i">+
</a><a href="#h55-0-56" id="h55-0-56" class="i">+// Reference imports to suppress errors if they are not otherwise used.
</a><a href="#h55-0-57" id="h55-0-57" class="i">+var _ = proto.Marshal
</a><a href="#h55-0-58" id="h55-0-58" class="i">+var _ = fmt.Errorf
</a><a href="#h55-0-59" id="h55-0-59" class="i">+var _ = math.Inf
</a><a href="#h55-0-60" id="h55-0-60" class="i">+
</a><a href="#h55-0-61" id="h55-0-61" class="i">+type Property_Meaning int32
</a><a href="#h55-0-62" id="h55-0-62" class="i">+
</a><a href="#h55-0-63" id="h55-0-63" class="i">+const (
</a><a href="#h55-0-64" id="h55-0-64" class="i">+	Property_NO_MEANING       Property_Meaning = 0
</a><a href="#h55-0-65" id="h55-0-65" class="i">+	Property_BLOB             Property_Meaning = 14
</a><a href="#h55-0-66" id="h55-0-66" class="i">+	Property_TEXT             Property_Meaning = 15
</a><a href="#h55-0-67" id="h55-0-67" class="i">+	Property_BYTESTRING       Property_Meaning = 16
</a><a href="#h55-0-68" id="h55-0-68" class="i">+	Property_ATOM_CATEGORY    Property_Meaning = 1
</a><a href="#h55-0-69" id="h55-0-69" class="i">+	Property_ATOM_LINK        Property_Meaning = 2
</a><a href="#h55-0-70" id="h55-0-70" class="i">+	Property_ATOM_TITLE       Property_Meaning = 3
</a><a href="#h55-0-71" id="h55-0-71" class="i">+	Property_ATOM_CONTENT     Property_Meaning = 4
</a><a href="#h55-0-72" id="h55-0-72" class="i">+	Property_ATOM_SUMMARY     Property_Meaning = 5
</a><a href="#h55-0-73" id="h55-0-73" class="i">+	Property_ATOM_AUTHOR      Property_Meaning = 6
</a><a href="#h55-0-74" id="h55-0-74" class="i">+	Property_GD_WHEN          Property_Meaning = 7
</a><a href="#h55-0-75" id="h55-0-75" class="i">+	Property_GD_EMAIL         Property_Meaning = 8
</a><a href="#h55-0-76" id="h55-0-76" class="i">+	Property_GEORSS_POINT     Property_Meaning = 9
</a><a href="#h55-0-77" id="h55-0-77" class="i">+	Property_GD_IM            Property_Meaning = 10
</a><a href="#h55-0-78" id="h55-0-78" class="i">+	Property_GD_PHONENUMBER   Property_Meaning = 11
</a><a href="#h55-0-79" id="h55-0-79" class="i">+	Property_GD_POSTALADDRESS Property_Meaning = 12
</a><a href="#h55-0-80" id="h55-0-80" class="i">+	Property_GD_RATING        Property_Meaning = 13
</a><a href="#h55-0-81" id="h55-0-81" class="i">+	Property_BLOBKEY          Property_Meaning = 17
</a><a href="#h55-0-82" id="h55-0-82" class="i">+	Property_ENTITY_PROTO     Property_Meaning = 19
</a><a href="#h55-0-83" id="h55-0-83" class="i">+	Property_INDEX_VALUE      Property_Meaning = 18
</a><a href="#h55-0-84" id="h55-0-84" class="i">+)
</a><a href="#h55-0-85" id="h55-0-85" class="i">+
</a><a href="#h55-0-86" id="h55-0-86" class="i">+var Property_Meaning_name = map[int32]string{
</a><a href="#h55-0-87" id="h55-0-87" class="i">+	0:  &quot;NO_MEANING&quot;,
</a><a href="#h55-0-88" id="h55-0-88" class="i">+	14: &quot;BLOB&quot;,
</a><a href="#h55-0-89" id="h55-0-89" class="i">+	15: &quot;TEXT&quot;,
</a><a href="#h55-0-90" id="h55-0-90" class="i">+	16: &quot;BYTESTRING&quot;,
</a><a href="#h55-0-91" id="h55-0-91" class="i">+	1:  &quot;ATOM_CATEGORY&quot;,
</a><a href="#h55-0-92" id="h55-0-92" class="i">+	2:  &quot;ATOM_LINK&quot;,
</a><a href="#h55-0-93" id="h55-0-93" class="i">+	3:  &quot;ATOM_TITLE&quot;,
</a><a href="#h55-0-94" id="h55-0-94" class="i">+	4:  &quot;ATOM_CONTENT&quot;,
</a><a href="#h55-0-95" id="h55-0-95" class="i">+	5:  &quot;ATOM_SUMMARY&quot;,
</a><a href="#h55-0-96" id="h55-0-96" class="i">+	6:  &quot;ATOM_AUTHOR&quot;,
</a><a href="#h55-0-97" id="h55-0-97" class="i">+	7:  &quot;GD_WHEN&quot;,
</a><a href="#h55-0-98" id="h55-0-98" class="i">+	8:  &quot;GD_EMAIL&quot;,
</a><a href="#h55-0-99" id="h55-0-99" class="i">+	9:  &quot;GEORSS_POINT&quot;,
</a><a href="#h55-0-100" id="h55-0-100" class="i">+	10: &quot;GD_IM&quot;,
</a><a href="#h55-0-101" id="h55-0-101" class="i">+	11: &quot;GD_PHONENUMBER&quot;,
</a><a href="#h55-0-102" id="h55-0-102" class="i">+	12: &quot;GD_POSTALADDRESS&quot;,
</a><a href="#h55-0-103" id="h55-0-103" class="i">+	13: &quot;GD_RATING&quot;,
</a><a href="#h55-0-104" id="h55-0-104" class="i">+	17: &quot;BLOBKEY&quot;,
</a><a href="#h55-0-105" id="h55-0-105" class="i">+	19: &quot;ENTITY_PROTO&quot;,
</a><a href="#h55-0-106" id="h55-0-106" class="i">+	18: &quot;INDEX_VALUE&quot;,
</a><a href="#h55-0-107" id="h55-0-107" class="i">+}
</a><a href="#h55-0-108" id="h55-0-108" class="i">+var Property_Meaning_value = map[string]int32{
</a><a href="#h55-0-109" id="h55-0-109" class="i">+	&quot;NO_MEANING&quot;:       0,
</a><a href="#h55-0-110" id="h55-0-110" class="i">+	&quot;BLOB&quot;:             14,
</a><a href="#h55-0-111" id="h55-0-111" class="i">+	&quot;TEXT&quot;:             15,
</a><a href="#h55-0-112" id="h55-0-112" class="i">+	&quot;BYTESTRING&quot;:       16,
</a><a href="#h55-0-113" id="h55-0-113" class="i">+	&quot;ATOM_CATEGORY&quot;:    1,
</a><a href="#h55-0-114" id="h55-0-114" class="i">+	&quot;ATOM_LINK&quot;:        2,
</a><a href="#h55-0-115" id="h55-0-115" class="i">+	&quot;ATOM_TITLE&quot;:       3,
</a><a href="#h55-0-116" id="h55-0-116" class="i">+	&quot;ATOM_CONTENT&quot;:     4,
</a><a href="#h55-0-117" id="h55-0-117" class="i">+	&quot;ATOM_SUMMARY&quot;:     5,
</a><a href="#h55-0-118" id="h55-0-118" class="i">+	&quot;ATOM_AUTHOR&quot;:      6,
</a><a href="#h55-0-119" id="h55-0-119" class="i">+	&quot;GD_WHEN&quot;:          7,
</a><a href="#h55-0-120" id="h55-0-120" class="i">+	&quot;GD_EMAIL&quot;:         8,
</a><a href="#h55-0-121" id="h55-0-121" class="i">+	&quot;GEORSS_POINT&quot;:     9,
</a><a href="#h55-0-122" id="h55-0-122" class="i">+	&quot;GD_IM&quot;:            10,
</a><a href="#h55-0-123" id="h55-0-123" class="i">+	&quot;GD_PHONENUMBER&quot;:   11,
</a><a href="#h55-0-124" id="h55-0-124" class="i">+	&quot;GD_POSTALADDRESS&quot;: 12,
</a><a href="#h55-0-125" id="h55-0-125" class="i">+	&quot;GD_RATING&quot;:        13,
</a><a href="#h55-0-126" id="h55-0-126" class="i">+	&quot;BLOBKEY&quot;:          17,
</a><a href="#h55-0-127" id="h55-0-127" class="i">+	&quot;ENTITY_PROTO&quot;:     19,
</a><a href="#h55-0-128" id="h55-0-128" class="i">+	&quot;INDEX_VALUE&quot;:      18,
</a><a href="#h55-0-129" id="h55-0-129" class="i">+}
</a><a href="#h55-0-130" id="h55-0-130" class="i">+
</a><a href="#h55-0-131" id="h55-0-131" class="i">+func (x Property_Meaning) Enum() *Property_Meaning {
</a><a href="#h55-0-132" id="h55-0-132" class="i">+	p := new(Property_Meaning)
</a><a href="#h55-0-133" id="h55-0-133" class="i">+	*p = x
</a><a href="#h55-0-134" id="h55-0-134" class="i">+	return p
</a><a href="#h55-0-135" id="h55-0-135" class="i">+}
</a><a href="#h55-0-136" id="h55-0-136" class="i">+func (x Property_Meaning) String() string {
</a><a href="#h55-0-137" id="h55-0-137" class="i">+	return proto.EnumName(Property_Meaning_name, int32(x))
</a><a href="#h55-0-138" id="h55-0-138" class="i">+}
</a><a href="#h55-0-139" id="h55-0-139" class="i">+func (x *Property_Meaning) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-140" id="h55-0-140" class="i">+	value, err := proto.UnmarshalJSONEnum(Property_Meaning_value, data, &quot;Property_Meaning&quot;)
</a><a href="#h55-0-141" id="h55-0-141" class="i">+	if err != nil {
</a><a href="#h55-0-142" id="h55-0-142" class="i">+		return err
</a><a href="#h55-0-143" id="h55-0-143" class="i">+	}
</a><a href="#h55-0-144" id="h55-0-144" class="i">+	*x = Property_Meaning(value)
</a><a href="#h55-0-145" id="h55-0-145" class="i">+	return nil
</a><a href="#h55-0-146" id="h55-0-146" class="i">+}
</a><a href="#h55-0-147" id="h55-0-147" class="i">+
</a><a href="#h55-0-148" id="h55-0-148" class="i">+type Property_FtsTokenizationOption int32
</a><a href="#h55-0-149" id="h55-0-149" class="i">+
</a><a href="#h55-0-150" id="h55-0-150" class="i">+const (
</a><a href="#h55-0-151" id="h55-0-151" class="i">+	Property_HTML Property_FtsTokenizationOption = 1
</a><a href="#h55-0-152" id="h55-0-152" class="i">+	Property_ATOM Property_FtsTokenizationOption = 2
</a><a href="#h55-0-153" id="h55-0-153" class="i">+)
</a><a href="#h55-0-154" id="h55-0-154" class="i">+
</a><a href="#h55-0-155" id="h55-0-155" class="i">+var Property_FtsTokenizationOption_name = map[int32]string{
</a><a href="#h55-0-156" id="h55-0-156" class="i">+	1: &quot;HTML&quot;,
</a><a href="#h55-0-157" id="h55-0-157" class="i">+	2: &quot;ATOM&quot;,
</a><a href="#h55-0-158" id="h55-0-158" class="i">+}
</a><a href="#h55-0-159" id="h55-0-159" class="i">+var Property_FtsTokenizationOption_value = map[string]int32{
</a><a href="#h55-0-160" id="h55-0-160" class="i">+	&quot;HTML&quot;: 1,
</a><a href="#h55-0-161" id="h55-0-161" class="i">+	&quot;ATOM&quot;: 2,
</a><a href="#h55-0-162" id="h55-0-162" class="i">+}
</a><a href="#h55-0-163" id="h55-0-163" class="i">+
</a><a href="#h55-0-164" id="h55-0-164" class="i">+func (x Property_FtsTokenizationOption) Enum() *Property_FtsTokenizationOption {
</a><a href="#h55-0-165" id="h55-0-165" class="i">+	p := new(Property_FtsTokenizationOption)
</a><a href="#h55-0-166" id="h55-0-166" class="i">+	*p = x
</a><a href="#h55-0-167" id="h55-0-167" class="i">+	return p
</a><a href="#h55-0-168" id="h55-0-168" class="i">+}
</a><a href="#h55-0-169" id="h55-0-169" class="i">+func (x Property_FtsTokenizationOption) String() string {
</a><a href="#h55-0-170" id="h55-0-170" class="i">+	return proto.EnumName(Property_FtsTokenizationOption_name, int32(x))
</a><a href="#h55-0-171" id="h55-0-171" class="i">+}
</a><a href="#h55-0-172" id="h55-0-172" class="i">+func (x *Property_FtsTokenizationOption) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-173" id="h55-0-173" class="i">+	value, err := proto.UnmarshalJSONEnum(Property_FtsTokenizationOption_value, data, &quot;Property_FtsTokenizationOption&quot;)
</a><a href="#h55-0-174" id="h55-0-174" class="i">+	if err != nil {
</a><a href="#h55-0-175" id="h55-0-175" class="i">+		return err
</a><a href="#h55-0-176" id="h55-0-176" class="i">+	}
</a><a href="#h55-0-177" id="h55-0-177" class="i">+	*x = Property_FtsTokenizationOption(value)
</a><a href="#h55-0-178" id="h55-0-178" class="i">+	return nil
</a><a href="#h55-0-179" id="h55-0-179" class="i">+}
</a><a href="#h55-0-180" id="h55-0-180" class="i">+
</a><a href="#h55-0-181" id="h55-0-181" class="i">+type EntityProto_Kind int32
</a><a href="#h55-0-182" id="h55-0-182" class="i">+
</a><a href="#h55-0-183" id="h55-0-183" class="i">+const (
</a><a href="#h55-0-184" id="h55-0-184" class="i">+	EntityProto_GD_CONTACT EntityProto_Kind = 1
</a><a href="#h55-0-185" id="h55-0-185" class="i">+	EntityProto_GD_EVENT   EntityProto_Kind = 2
</a><a href="#h55-0-186" id="h55-0-186" class="i">+	EntityProto_GD_MESSAGE EntityProto_Kind = 3
</a><a href="#h55-0-187" id="h55-0-187" class="i">+)
</a><a href="#h55-0-188" id="h55-0-188" class="i">+
</a><a href="#h55-0-189" id="h55-0-189" class="i">+var EntityProto_Kind_name = map[int32]string{
</a><a href="#h55-0-190" id="h55-0-190" class="i">+	1: &quot;GD_CONTACT&quot;,
</a><a href="#h55-0-191" id="h55-0-191" class="i">+	2: &quot;GD_EVENT&quot;,
</a><a href="#h55-0-192" id="h55-0-192" class="i">+	3: &quot;GD_MESSAGE&quot;,
</a><a href="#h55-0-193" id="h55-0-193" class="i">+}
</a><a href="#h55-0-194" id="h55-0-194" class="i">+var EntityProto_Kind_value = map[string]int32{
</a><a href="#h55-0-195" id="h55-0-195" class="i">+	&quot;GD_CONTACT&quot;: 1,
</a><a href="#h55-0-196" id="h55-0-196" class="i">+	&quot;GD_EVENT&quot;:   2,
</a><a href="#h55-0-197" id="h55-0-197" class="i">+	&quot;GD_MESSAGE&quot;: 3,
</a><a href="#h55-0-198" id="h55-0-198" class="i">+}
</a><a href="#h55-0-199" id="h55-0-199" class="i">+
</a><a href="#h55-0-200" id="h55-0-200" class="i">+func (x EntityProto_Kind) Enum() *EntityProto_Kind {
</a><a href="#h55-0-201" id="h55-0-201" class="i">+	p := new(EntityProto_Kind)
</a><a href="#h55-0-202" id="h55-0-202" class="i">+	*p = x
</a><a href="#h55-0-203" id="h55-0-203" class="i">+	return p
</a><a href="#h55-0-204" id="h55-0-204" class="i">+}
</a><a href="#h55-0-205" id="h55-0-205" class="i">+func (x EntityProto_Kind) String() string {
</a><a href="#h55-0-206" id="h55-0-206" class="i">+	return proto.EnumName(EntityProto_Kind_name, int32(x))
</a><a href="#h55-0-207" id="h55-0-207" class="i">+}
</a><a href="#h55-0-208" id="h55-0-208" class="i">+func (x *EntityProto_Kind) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-209" id="h55-0-209" class="i">+	value, err := proto.UnmarshalJSONEnum(EntityProto_Kind_value, data, &quot;EntityProto_Kind&quot;)
</a><a href="#h55-0-210" id="h55-0-210" class="i">+	if err != nil {
</a><a href="#h55-0-211" id="h55-0-211" class="i">+		return err
</a><a href="#h55-0-212" id="h55-0-212" class="i">+	}
</a><a href="#h55-0-213" id="h55-0-213" class="i">+	*x = EntityProto_Kind(value)
</a><a href="#h55-0-214" id="h55-0-214" class="i">+	return nil
</a><a href="#h55-0-215" id="h55-0-215" class="i">+}
</a><a href="#h55-0-216" id="h55-0-216" class="i">+
</a><a href="#h55-0-217" id="h55-0-217" class="i">+type Index_Property_Direction int32
</a><a href="#h55-0-218" id="h55-0-218" class="i">+
</a><a href="#h55-0-219" id="h55-0-219" class="i">+const (
</a><a href="#h55-0-220" id="h55-0-220" class="i">+	Index_Property_ASCENDING  Index_Property_Direction = 1
</a><a href="#h55-0-221" id="h55-0-221" class="i">+	Index_Property_DESCENDING Index_Property_Direction = 2
</a><a href="#h55-0-222" id="h55-0-222" class="i">+)
</a><a href="#h55-0-223" id="h55-0-223" class="i">+
</a><a href="#h55-0-224" id="h55-0-224" class="i">+var Index_Property_Direction_name = map[int32]string{
</a><a href="#h55-0-225" id="h55-0-225" class="i">+	1: &quot;ASCENDING&quot;,
</a><a href="#h55-0-226" id="h55-0-226" class="i">+	2: &quot;DESCENDING&quot;,
</a><a href="#h55-0-227" id="h55-0-227" class="i">+}
</a><a href="#h55-0-228" id="h55-0-228" class="i">+var Index_Property_Direction_value = map[string]int32{
</a><a href="#h55-0-229" id="h55-0-229" class="i">+	&quot;ASCENDING&quot;:  1,
</a><a href="#h55-0-230" id="h55-0-230" class="i">+	&quot;DESCENDING&quot;: 2,
</a><a href="#h55-0-231" id="h55-0-231" class="i">+}
</a><a href="#h55-0-232" id="h55-0-232" class="i">+
</a><a href="#h55-0-233" id="h55-0-233" class="i">+func (x Index_Property_Direction) Enum() *Index_Property_Direction {
</a><a href="#h55-0-234" id="h55-0-234" class="i">+	p := new(Index_Property_Direction)
</a><a href="#h55-0-235" id="h55-0-235" class="i">+	*p = x
</a><a href="#h55-0-236" id="h55-0-236" class="i">+	return p
</a><a href="#h55-0-237" id="h55-0-237" class="i">+}
</a><a href="#h55-0-238" id="h55-0-238" class="i">+func (x Index_Property_Direction) String() string {
</a><a href="#h55-0-239" id="h55-0-239" class="i">+	return proto.EnumName(Index_Property_Direction_name, int32(x))
</a><a href="#h55-0-240" id="h55-0-240" class="i">+}
</a><a href="#h55-0-241" id="h55-0-241" class="i">+func (x *Index_Property_Direction) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-242" id="h55-0-242" class="i">+	value, err := proto.UnmarshalJSONEnum(Index_Property_Direction_value, data, &quot;Index_Property_Direction&quot;)
</a><a href="#h55-0-243" id="h55-0-243" class="i">+	if err != nil {
</a><a href="#h55-0-244" id="h55-0-244" class="i">+		return err
</a><a href="#h55-0-245" id="h55-0-245" class="i">+	}
</a><a href="#h55-0-246" id="h55-0-246" class="i">+	*x = Index_Property_Direction(value)
</a><a href="#h55-0-247" id="h55-0-247" class="i">+	return nil
</a><a href="#h55-0-248" id="h55-0-248" class="i">+}
</a><a href="#h55-0-249" id="h55-0-249" class="i">+
</a><a href="#h55-0-250" id="h55-0-250" class="i">+type CompositeIndex_State int32
</a><a href="#h55-0-251" id="h55-0-251" class="i">+
</a><a href="#h55-0-252" id="h55-0-252" class="i">+const (
</a><a href="#h55-0-253" id="h55-0-253" class="i">+	CompositeIndex_WRITE_ONLY CompositeIndex_State = 1
</a><a href="#h55-0-254" id="h55-0-254" class="i">+	CompositeIndex_READ_WRITE CompositeIndex_State = 2
</a><a href="#h55-0-255" id="h55-0-255" class="i">+	CompositeIndex_DELETED    CompositeIndex_State = 3
</a><a href="#h55-0-256" id="h55-0-256" class="i">+	CompositeIndex_ERROR      CompositeIndex_State = 4
</a><a href="#h55-0-257" id="h55-0-257" class="i">+)
</a><a href="#h55-0-258" id="h55-0-258" class="i">+
</a><a href="#h55-0-259" id="h55-0-259" class="i">+var CompositeIndex_State_name = map[int32]string{
</a><a href="#h55-0-260" id="h55-0-260" class="i">+	1: &quot;WRITE_ONLY&quot;,
</a><a href="#h55-0-261" id="h55-0-261" class="i">+	2: &quot;READ_WRITE&quot;,
</a><a href="#h55-0-262" id="h55-0-262" class="i">+	3: &quot;DELETED&quot;,
</a><a href="#h55-0-263" id="h55-0-263" class="i">+	4: &quot;ERROR&quot;,
</a><a href="#h55-0-264" id="h55-0-264" class="i">+}
</a><a href="#h55-0-265" id="h55-0-265" class="i">+var CompositeIndex_State_value = map[string]int32{
</a><a href="#h55-0-266" id="h55-0-266" class="i">+	&quot;WRITE_ONLY&quot;: 1,
</a><a href="#h55-0-267" id="h55-0-267" class="i">+	&quot;READ_WRITE&quot;: 2,
</a><a href="#h55-0-268" id="h55-0-268" class="i">+	&quot;DELETED&quot;:    3,
</a><a href="#h55-0-269" id="h55-0-269" class="i">+	&quot;ERROR&quot;:      4,
</a><a href="#h55-0-270" id="h55-0-270" class="i">+}
</a><a href="#h55-0-271" id="h55-0-271" class="i">+
</a><a href="#h55-0-272" id="h55-0-272" class="i">+func (x CompositeIndex_State) Enum() *CompositeIndex_State {
</a><a href="#h55-0-273" id="h55-0-273" class="i">+	p := new(CompositeIndex_State)
</a><a href="#h55-0-274" id="h55-0-274" class="i">+	*p = x
</a><a href="#h55-0-275" id="h55-0-275" class="i">+	return p
</a><a href="#h55-0-276" id="h55-0-276" class="i">+}
</a><a href="#h55-0-277" id="h55-0-277" class="i">+func (x CompositeIndex_State) String() string {
</a><a href="#h55-0-278" id="h55-0-278" class="i">+	return proto.EnumName(CompositeIndex_State_name, int32(x))
</a><a href="#h55-0-279" id="h55-0-279" class="i">+}
</a><a href="#h55-0-280" id="h55-0-280" class="i">+func (x *CompositeIndex_State) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-281" id="h55-0-281" class="i">+	value, err := proto.UnmarshalJSONEnum(CompositeIndex_State_value, data, &quot;CompositeIndex_State&quot;)
</a><a href="#h55-0-282" id="h55-0-282" class="i">+	if err != nil {
</a><a href="#h55-0-283" id="h55-0-283" class="i">+		return err
</a><a href="#h55-0-284" id="h55-0-284" class="i">+	}
</a><a href="#h55-0-285" id="h55-0-285" class="i">+	*x = CompositeIndex_State(value)
</a><a href="#h55-0-286" id="h55-0-286" class="i">+	return nil
</a><a href="#h55-0-287" id="h55-0-287" class="i">+}
</a><a href="#h55-0-288" id="h55-0-288" class="i">+
</a><a href="#h55-0-289" id="h55-0-289" class="i">+type Snapshot_Status int32
</a><a href="#h55-0-290" id="h55-0-290" class="i">+
</a><a href="#h55-0-291" id="h55-0-291" class="i">+const (
</a><a href="#h55-0-292" id="h55-0-292" class="i">+	Snapshot_INACTIVE Snapshot_Status = 0
</a><a href="#h55-0-293" id="h55-0-293" class="i">+	Snapshot_ACTIVE   Snapshot_Status = 1
</a><a href="#h55-0-294" id="h55-0-294" class="i">+)
</a><a href="#h55-0-295" id="h55-0-295" class="i">+
</a><a href="#h55-0-296" id="h55-0-296" class="i">+var Snapshot_Status_name = map[int32]string{
</a><a href="#h55-0-297" id="h55-0-297" class="i">+	0: &quot;INACTIVE&quot;,
</a><a href="#h55-0-298" id="h55-0-298" class="i">+	1: &quot;ACTIVE&quot;,
</a><a href="#h55-0-299" id="h55-0-299" class="i">+}
</a><a href="#h55-0-300" id="h55-0-300" class="i">+var Snapshot_Status_value = map[string]int32{
</a><a href="#h55-0-301" id="h55-0-301" class="i">+	&quot;INACTIVE&quot;: 0,
</a><a href="#h55-0-302" id="h55-0-302" class="i">+	&quot;ACTIVE&quot;:   1,
</a><a href="#h55-0-303" id="h55-0-303" class="i">+}
</a><a href="#h55-0-304" id="h55-0-304" class="i">+
</a><a href="#h55-0-305" id="h55-0-305" class="i">+func (x Snapshot_Status) Enum() *Snapshot_Status {
</a><a href="#h55-0-306" id="h55-0-306" class="i">+	p := new(Snapshot_Status)
</a><a href="#h55-0-307" id="h55-0-307" class="i">+	*p = x
</a><a href="#h55-0-308" id="h55-0-308" class="i">+	return p
</a><a href="#h55-0-309" id="h55-0-309" class="i">+}
</a><a href="#h55-0-310" id="h55-0-310" class="i">+func (x Snapshot_Status) String() string {
</a><a href="#h55-0-311" id="h55-0-311" class="i">+	return proto.EnumName(Snapshot_Status_name, int32(x))
</a><a href="#h55-0-312" id="h55-0-312" class="i">+}
</a><a href="#h55-0-313" id="h55-0-313" class="i">+func (x *Snapshot_Status) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-314" id="h55-0-314" class="i">+	value, err := proto.UnmarshalJSONEnum(Snapshot_Status_value, data, &quot;Snapshot_Status&quot;)
</a><a href="#h55-0-315" id="h55-0-315" class="i">+	if err != nil {
</a><a href="#h55-0-316" id="h55-0-316" class="i">+		return err
</a><a href="#h55-0-317" id="h55-0-317" class="i">+	}
</a><a href="#h55-0-318" id="h55-0-318" class="i">+	*x = Snapshot_Status(value)
</a><a href="#h55-0-319" id="h55-0-319" class="i">+	return nil
</a><a href="#h55-0-320" id="h55-0-320" class="i">+}
</a><a href="#h55-0-321" id="h55-0-321" class="i">+
</a><a href="#h55-0-322" id="h55-0-322" class="i">+type Query_Hint int32
</a><a href="#h55-0-323" id="h55-0-323" class="i">+
</a><a href="#h55-0-324" id="h55-0-324" class="i">+const (
</a><a href="#h55-0-325" id="h55-0-325" class="i">+	Query_ORDER_FIRST    Query_Hint = 1
</a><a href="#h55-0-326" id="h55-0-326" class="i">+	Query_ANCESTOR_FIRST Query_Hint = 2
</a><a href="#h55-0-327" id="h55-0-327" class="i">+	Query_FILTER_FIRST   Query_Hint = 3
</a><a href="#h55-0-328" id="h55-0-328" class="i">+)
</a><a href="#h55-0-329" id="h55-0-329" class="i">+
</a><a href="#h55-0-330" id="h55-0-330" class="i">+var Query_Hint_name = map[int32]string{
</a><a href="#h55-0-331" id="h55-0-331" class="i">+	1: &quot;ORDER_FIRST&quot;,
</a><a href="#h55-0-332" id="h55-0-332" class="i">+	2: &quot;ANCESTOR_FIRST&quot;,
</a><a href="#h55-0-333" id="h55-0-333" class="i">+	3: &quot;FILTER_FIRST&quot;,
</a><a href="#h55-0-334" id="h55-0-334" class="i">+}
</a><a href="#h55-0-335" id="h55-0-335" class="i">+var Query_Hint_value = map[string]int32{
</a><a href="#h55-0-336" id="h55-0-336" class="i">+	&quot;ORDER_FIRST&quot;:    1,
</a><a href="#h55-0-337" id="h55-0-337" class="i">+	&quot;ANCESTOR_FIRST&quot;: 2,
</a><a href="#h55-0-338" id="h55-0-338" class="i">+	&quot;FILTER_FIRST&quot;:   3,
</a><a href="#h55-0-339" id="h55-0-339" class="i">+}
</a><a href="#h55-0-340" id="h55-0-340" class="i">+
</a><a href="#h55-0-341" id="h55-0-341" class="i">+func (x Query_Hint) Enum() *Query_Hint {
</a><a href="#h55-0-342" id="h55-0-342" class="i">+	p := new(Query_Hint)
</a><a href="#h55-0-343" id="h55-0-343" class="i">+	*p = x
</a><a href="#h55-0-344" id="h55-0-344" class="i">+	return p
</a><a href="#h55-0-345" id="h55-0-345" class="i">+}
</a><a href="#h55-0-346" id="h55-0-346" class="i">+func (x Query_Hint) String() string {
</a><a href="#h55-0-347" id="h55-0-347" class="i">+	return proto.EnumName(Query_Hint_name, int32(x))
</a><a href="#h55-0-348" id="h55-0-348" class="i">+}
</a><a href="#h55-0-349" id="h55-0-349" class="i">+func (x *Query_Hint) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-350" id="h55-0-350" class="i">+	value, err := proto.UnmarshalJSONEnum(Query_Hint_value, data, &quot;Query_Hint&quot;)
</a><a href="#h55-0-351" id="h55-0-351" class="i">+	if err != nil {
</a><a href="#h55-0-352" id="h55-0-352" class="i">+		return err
</a><a href="#h55-0-353" id="h55-0-353" class="i">+	}
</a><a href="#h55-0-354" id="h55-0-354" class="i">+	*x = Query_Hint(value)
</a><a href="#h55-0-355" id="h55-0-355" class="i">+	return nil
</a><a href="#h55-0-356" id="h55-0-356" class="i">+}
</a><a href="#h55-0-357" id="h55-0-357" class="i">+
</a><a href="#h55-0-358" id="h55-0-358" class="i">+type Query_Filter_Operator int32
</a><a href="#h55-0-359" id="h55-0-359" class="i">+
</a><a href="#h55-0-360" id="h55-0-360" class="i">+const (
</a><a href="#h55-0-361" id="h55-0-361" class="i">+	Query_Filter_LESS_THAN             Query_Filter_Operator = 1
</a><a href="#h55-0-362" id="h55-0-362" class="i">+	Query_Filter_LESS_THAN_OR_EQUAL    Query_Filter_Operator = 2
</a><a href="#h55-0-363" id="h55-0-363" class="i">+	Query_Filter_GREATER_THAN          Query_Filter_Operator = 3
</a><a href="#h55-0-364" id="h55-0-364" class="i">+	Query_Filter_GREATER_THAN_OR_EQUAL Query_Filter_Operator = 4
</a><a href="#h55-0-365" id="h55-0-365" class="i">+	Query_Filter_EQUAL                 Query_Filter_Operator = 5
</a><a href="#h55-0-366" id="h55-0-366" class="i">+	Query_Filter_IN                    Query_Filter_Operator = 6
</a><a href="#h55-0-367" id="h55-0-367" class="i">+	Query_Filter_EXISTS                Query_Filter_Operator = 7
</a><a href="#h55-0-368" id="h55-0-368" class="i">+)
</a><a href="#h55-0-369" id="h55-0-369" class="i">+
</a><a href="#h55-0-370" id="h55-0-370" class="i">+var Query_Filter_Operator_name = map[int32]string{
</a><a href="#h55-0-371" id="h55-0-371" class="i">+	1: &quot;LESS_THAN&quot;,
</a><a href="#h55-0-372" id="h55-0-372" class="i">+	2: &quot;LESS_THAN_OR_EQUAL&quot;,
</a><a href="#h55-0-373" id="h55-0-373" class="i">+	3: &quot;GREATER_THAN&quot;,
</a><a href="#h55-0-374" id="h55-0-374" class="i">+	4: &quot;GREATER_THAN_OR_EQUAL&quot;,
</a><a href="#h55-0-375" id="h55-0-375" class="i">+	5: &quot;EQUAL&quot;,
</a><a href="#h55-0-376" id="h55-0-376" class="i">+	6: &quot;IN&quot;,
</a><a href="#h55-0-377" id="h55-0-377" class="i">+	7: &quot;EXISTS&quot;,
</a><a href="#h55-0-378" id="h55-0-378" class="i">+}
</a><a href="#h55-0-379" id="h55-0-379" class="i">+var Query_Filter_Operator_value = map[string]int32{
</a><a href="#h55-0-380" id="h55-0-380" class="i">+	&quot;LESS_THAN&quot;:             1,
</a><a href="#h55-0-381" id="h55-0-381" class="i">+	&quot;LESS_THAN_OR_EQUAL&quot;:    2,
</a><a href="#h55-0-382" id="h55-0-382" class="i">+	&quot;GREATER_THAN&quot;:          3,
</a><a href="#h55-0-383" id="h55-0-383" class="i">+	&quot;GREATER_THAN_OR_EQUAL&quot;: 4,
</a><a href="#h55-0-384" id="h55-0-384" class="i">+	&quot;EQUAL&quot;:                 5,
</a><a href="#h55-0-385" id="h55-0-385" class="i">+	&quot;IN&quot;:                    6,
</a><a href="#h55-0-386" id="h55-0-386" class="i">+	&quot;EXISTS&quot;:                7,
</a><a href="#h55-0-387" id="h55-0-387" class="i">+}
</a><a href="#h55-0-388" id="h55-0-388" class="i">+
</a><a href="#h55-0-389" id="h55-0-389" class="i">+func (x Query_Filter_Operator) Enum() *Query_Filter_Operator {
</a><a href="#h55-0-390" id="h55-0-390" class="i">+	p := new(Query_Filter_Operator)
</a><a href="#h55-0-391" id="h55-0-391" class="i">+	*p = x
</a><a href="#h55-0-392" id="h55-0-392" class="i">+	return p
</a><a href="#h55-0-393" id="h55-0-393" class="i">+}
</a><a href="#h55-0-394" id="h55-0-394" class="i">+func (x Query_Filter_Operator) String() string {
</a><a href="#h55-0-395" id="h55-0-395" class="i">+	return proto.EnumName(Query_Filter_Operator_name, int32(x))
</a><a href="#h55-0-396" id="h55-0-396" class="i">+}
</a><a href="#h55-0-397" id="h55-0-397" class="i">+func (x *Query_Filter_Operator) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-398" id="h55-0-398" class="i">+	value, err := proto.UnmarshalJSONEnum(Query_Filter_Operator_value, data, &quot;Query_Filter_Operator&quot;)
</a><a href="#h55-0-399" id="h55-0-399" class="i">+	if err != nil {
</a><a href="#h55-0-400" id="h55-0-400" class="i">+		return err
</a><a href="#h55-0-401" id="h55-0-401" class="i">+	}
</a><a href="#h55-0-402" id="h55-0-402" class="i">+	*x = Query_Filter_Operator(value)
</a><a href="#h55-0-403" id="h55-0-403" class="i">+	return nil
</a><a href="#h55-0-404" id="h55-0-404" class="i">+}
</a><a href="#h55-0-405" id="h55-0-405" class="i">+
</a><a href="#h55-0-406" id="h55-0-406" class="i">+type Query_Order_Direction int32
</a><a href="#h55-0-407" id="h55-0-407" class="i">+
</a><a href="#h55-0-408" id="h55-0-408" class="i">+const (
</a><a href="#h55-0-409" id="h55-0-409" class="i">+	Query_Order_ASCENDING  Query_Order_Direction = 1
</a><a href="#h55-0-410" id="h55-0-410" class="i">+	Query_Order_DESCENDING Query_Order_Direction = 2
</a><a href="#h55-0-411" id="h55-0-411" class="i">+)
</a><a href="#h55-0-412" id="h55-0-412" class="i">+
</a><a href="#h55-0-413" id="h55-0-413" class="i">+var Query_Order_Direction_name = map[int32]string{
</a><a href="#h55-0-414" id="h55-0-414" class="i">+	1: &quot;ASCENDING&quot;,
</a><a href="#h55-0-415" id="h55-0-415" class="i">+	2: &quot;DESCENDING&quot;,
</a><a href="#h55-0-416" id="h55-0-416" class="i">+}
</a><a href="#h55-0-417" id="h55-0-417" class="i">+var Query_Order_Direction_value = map[string]int32{
</a><a href="#h55-0-418" id="h55-0-418" class="i">+	&quot;ASCENDING&quot;:  1,
</a><a href="#h55-0-419" id="h55-0-419" class="i">+	&quot;DESCENDING&quot;: 2,
</a><a href="#h55-0-420" id="h55-0-420" class="i">+}
</a><a href="#h55-0-421" id="h55-0-421" class="i">+
</a><a href="#h55-0-422" id="h55-0-422" class="i">+func (x Query_Order_Direction) Enum() *Query_Order_Direction {
</a><a href="#h55-0-423" id="h55-0-423" class="i">+	p := new(Query_Order_Direction)
</a><a href="#h55-0-424" id="h55-0-424" class="i">+	*p = x
</a><a href="#h55-0-425" id="h55-0-425" class="i">+	return p
</a><a href="#h55-0-426" id="h55-0-426" class="i">+}
</a><a href="#h55-0-427" id="h55-0-427" class="i">+func (x Query_Order_Direction) String() string {
</a><a href="#h55-0-428" id="h55-0-428" class="i">+	return proto.EnumName(Query_Order_Direction_name, int32(x))
</a><a href="#h55-0-429" id="h55-0-429" class="i">+}
</a><a href="#h55-0-430" id="h55-0-430" class="i">+func (x *Query_Order_Direction) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-431" id="h55-0-431" class="i">+	value, err := proto.UnmarshalJSONEnum(Query_Order_Direction_value, data, &quot;Query_Order_Direction&quot;)
</a><a href="#h55-0-432" id="h55-0-432" class="i">+	if err != nil {
</a><a href="#h55-0-433" id="h55-0-433" class="i">+		return err
</a><a href="#h55-0-434" id="h55-0-434" class="i">+	}
</a><a href="#h55-0-435" id="h55-0-435" class="i">+	*x = Query_Order_Direction(value)
</a><a href="#h55-0-436" id="h55-0-436" class="i">+	return nil
</a><a href="#h55-0-437" id="h55-0-437" class="i">+}
</a><a href="#h55-0-438" id="h55-0-438" class="i">+
</a><a href="#h55-0-439" id="h55-0-439" class="i">+type Error_ErrorCode int32
</a><a href="#h55-0-440" id="h55-0-440" class="i">+
</a><a href="#h55-0-441" id="h55-0-441" class="i">+const (
</a><a href="#h55-0-442" id="h55-0-442" class="i">+	Error_BAD_REQUEST                  Error_ErrorCode = 1
</a><a href="#h55-0-443" id="h55-0-443" class="i">+	Error_CONCURRENT_TRANSACTION       Error_ErrorCode = 2
</a><a href="#h55-0-444" id="h55-0-444" class="i">+	Error_INTERNAL_ERROR               Error_ErrorCode = 3
</a><a href="#h55-0-445" id="h55-0-445" class="i">+	Error_NEED_INDEX                   Error_ErrorCode = 4
</a><a href="#h55-0-446" id="h55-0-446" class="i">+	Error_TIMEOUT                      Error_ErrorCode = 5
</a><a href="#h55-0-447" id="h55-0-447" class="i">+	Error_PERMISSION_DENIED            Error_ErrorCode = 6
</a><a href="#h55-0-448" id="h55-0-448" class="i">+	Error_BIGTABLE_ERROR               Error_ErrorCode = 7
</a><a href="#h55-0-449" id="h55-0-449" class="i">+	Error_COMMITTED_BUT_STILL_APPLYING Error_ErrorCode = 8
</a><a href="#h55-0-450" id="h55-0-450" class="i">+	Error_CAPABILITY_DISABLED          Error_ErrorCode = 9
</a><a href="#h55-0-451" id="h55-0-451" class="i">+	Error_TRY_ALTERNATE_BACKEND        Error_ErrorCode = 10
</a><a href="#h55-0-452" id="h55-0-452" class="i">+	Error_SAFE_TIME_TOO_OLD            Error_ErrorCode = 11
</a><a href="#h55-0-453" id="h55-0-453" class="i">+)
</a><a href="#h55-0-454" id="h55-0-454" class="i">+
</a><a href="#h55-0-455" id="h55-0-455" class="i">+var Error_ErrorCode_name = map[int32]string{
</a><a href="#h55-0-456" id="h55-0-456" class="i">+	1:  &quot;BAD_REQUEST&quot;,
</a><a href="#h55-0-457" id="h55-0-457" class="i">+	2:  &quot;CONCURRENT_TRANSACTION&quot;,
</a><a href="#h55-0-458" id="h55-0-458" class="i">+	3:  &quot;INTERNAL_ERROR&quot;,
</a><a href="#h55-0-459" id="h55-0-459" class="i">+	4:  &quot;NEED_INDEX&quot;,
</a><a href="#h55-0-460" id="h55-0-460" class="i">+	5:  &quot;TIMEOUT&quot;,
</a><a href="#h55-0-461" id="h55-0-461" class="i">+	6:  &quot;PERMISSION_DENIED&quot;,
</a><a href="#h55-0-462" id="h55-0-462" class="i">+	7:  &quot;BIGTABLE_ERROR&quot;,
</a><a href="#h55-0-463" id="h55-0-463" class="i">+	8:  &quot;COMMITTED_BUT_STILL_APPLYING&quot;,
</a><a href="#h55-0-464" id="h55-0-464" class="i">+	9:  &quot;CAPABILITY_DISABLED&quot;,
</a><a href="#h55-0-465" id="h55-0-465" class="i">+	10: &quot;TRY_ALTERNATE_BACKEND&quot;,
</a><a href="#h55-0-466" id="h55-0-466" class="i">+	11: &quot;SAFE_TIME_TOO_OLD&quot;,
</a><a href="#h55-0-467" id="h55-0-467" class="i">+}
</a><a href="#h55-0-468" id="h55-0-468" class="i">+var Error_ErrorCode_value = map[string]int32{
</a><a href="#h55-0-469" id="h55-0-469" class="i">+	&quot;BAD_REQUEST&quot;:                  1,
</a><a href="#h55-0-470" id="h55-0-470" class="i">+	&quot;CONCURRENT_TRANSACTION&quot;:       2,
</a><a href="#h55-0-471" id="h55-0-471" class="i">+	&quot;INTERNAL_ERROR&quot;:               3,
</a><a href="#h55-0-472" id="h55-0-472" class="i">+	&quot;NEED_INDEX&quot;:                   4,
</a><a href="#h55-0-473" id="h55-0-473" class="i">+	&quot;TIMEOUT&quot;:                      5,
</a><a href="#h55-0-474" id="h55-0-474" class="i">+	&quot;PERMISSION_DENIED&quot;:            6,
</a><a href="#h55-0-475" id="h55-0-475" class="i">+	&quot;BIGTABLE_ERROR&quot;:               7,
</a><a href="#h55-0-476" id="h55-0-476" class="i">+	&quot;COMMITTED_BUT_STILL_APPLYING&quot;: 8,
</a><a href="#h55-0-477" id="h55-0-477" class="i">+	&quot;CAPABILITY_DISABLED&quot;:          9,
</a><a href="#h55-0-478" id="h55-0-478" class="i">+	&quot;TRY_ALTERNATE_BACKEND&quot;:        10,
</a><a href="#h55-0-479" id="h55-0-479" class="i">+	&quot;SAFE_TIME_TOO_OLD&quot;:            11,
</a><a href="#h55-0-480" id="h55-0-480" class="i">+}
</a><a href="#h55-0-481" id="h55-0-481" class="i">+
</a><a href="#h55-0-482" id="h55-0-482" class="i">+func (x Error_ErrorCode) Enum() *Error_ErrorCode {
</a><a href="#h55-0-483" id="h55-0-483" class="i">+	p := new(Error_ErrorCode)
</a><a href="#h55-0-484" id="h55-0-484" class="i">+	*p = x
</a><a href="#h55-0-485" id="h55-0-485" class="i">+	return p
</a><a href="#h55-0-486" id="h55-0-486" class="i">+}
</a><a href="#h55-0-487" id="h55-0-487" class="i">+func (x Error_ErrorCode) String() string {
</a><a href="#h55-0-488" id="h55-0-488" class="i">+	return proto.EnumName(Error_ErrorCode_name, int32(x))
</a><a href="#h55-0-489" id="h55-0-489" class="i">+}
</a><a href="#h55-0-490" id="h55-0-490" class="i">+func (x *Error_ErrorCode) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-491" id="h55-0-491" class="i">+	value, err := proto.UnmarshalJSONEnum(Error_ErrorCode_value, data, &quot;Error_ErrorCode&quot;)
</a><a href="#h55-0-492" id="h55-0-492" class="i">+	if err != nil {
</a><a href="#h55-0-493" id="h55-0-493" class="i">+		return err
</a><a href="#h55-0-494" id="h55-0-494" class="i">+	}
</a><a href="#h55-0-495" id="h55-0-495" class="i">+	*x = Error_ErrorCode(value)
</a><a href="#h55-0-496" id="h55-0-496" class="i">+	return nil
</a><a href="#h55-0-497" id="h55-0-497" class="i">+}
</a><a href="#h55-0-498" id="h55-0-498" class="i">+
</a><a href="#h55-0-499" id="h55-0-499" class="i">+type PutRequest_AutoIdPolicy int32
</a><a href="#h55-0-500" id="h55-0-500" class="i">+
</a><a href="#h55-0-501" id="h55-0-501" class="i">+const (
</a><a href="#h55-0-502" id="h55-0-502" class="i">+	PutRequest_CURRENT    PutRequest_AutoIdPolicy = 0
</a><a href="#h55-0-503" id="h55-0-503" class="i">+	PutRequest_SEQUENTIAL PutRequest_AutoIdPolicy = 1
</a><a href="#h55-0-504" id="h55-0-504" class="i">+)
</a><a href="#h55-0-505" id="h55-0-505" class="i">+
</a><a href="#h55-0-506" id="h55-0-506" class="i">+var PutRequest_AutoIdPolicy_name = map[int32]string{
</a><a href="#h55-0-507" id="h55-0-507" class="i">+	0: &quot;CURRENT&quot;,
</a><a href="#h55-0-508" id="h55-0-508" class="i">+	1: &quot;SEQUENTIAL&quot;,
</a><a href="#h55-0-509" id="h55-0-509" class="i">+}
</a><a href="#h55-0-510" id="h55-0-510" class="i">+var PutRequest_AutoIdPolicy_value = map[string]int32{
</a><a href="#h55-0-511" id="h55-0-511" class="i">+	&quot;CURRENT&quot;:    0,
</a><a href="#h55-0-512" id="h55-0-512" class="i">+	&quot;SEQUENTIAL&quot;: 1,
</a><a href="#h55-0-513" id="h55-0-513" class="i">+}
</a><a href="#h55-0-514" id="h55-0-514" class="i">+
</a><a href="#h55-0-515" id="h55-0-515" class="i">+func (x PutRequest_AutoIdPolicy) Enum() *PutRequest_AutoIdPolicy {
</a><a href="#h55-0-516" id="h55-0-516" class="i">+	p := new(PutRequest_AutoIdPolicy)
</a><a href="#h55-0-517" id="h55-0-517" class="i">+	*p = x
</a><a href="#h55-0-518" id="h55-0-518" class="i">+	return p
</a><a href="#h55-0-519" id="h55-0-519" class="i">+}
</a><a href="#h55-0-520" id="h55-0-520" class="i">+func (x PutRequest_AutoIdPolicy) String() string {
</a><a href="#h55-0-521" id="h55-0-521" class="i">+	return proto.EnumName(PutRequest_AutoIdPolicy_name, int32(x))
</a><a href="#h55-0-522" id="h55-0-522" class="i">+}
</a><a href="#h55-0-523" id="h55-0-523" class="i">+func (x *PutRequest_AutoIdPolicy) UnmarshalJSON(data []byte) error {
</a><a href="#h55-0-524" id="h55-0-524" class="i">+	value, err := proto.UnmarshalJSONEnum(PutRequest_AutoIdPolicy_value, data, &quot;PutRequest_AutoIdPolicy&quot;)
</a><a href="#h55-0-525" id="h55-0-525" class="i">+	if err != nil {
</a><a href="#h55-0-526" id="h55-0-526" class="i">+		return err
</a><a href="#h55-0-527" id="h55-0-527" class="i">+	}
</a><a href="#h55-0-528" id="h55-0-528" class="i">+	*x = PutRequest_AutoIdPolicy(value)
</a><a href="#h55-0-529" id="h55-0-529" class="i">+	return nil
</a><a href="#h55-0-530" id="h55-0-530" class="i">+}
</a><a href="#h55-0-531" id="h55-0-531" class="i">+
</a><a href="#h55-0-532" id="h55-0-532" class="i">+type Action struct {
</a><a href="#h55-0-533" id="h55-0-533" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h55-0-534" id="h55-0-534" class="i">+}
</a><a href="#h55-0-535" id="h55-0-535" class="i">+
</a><a href="#h55-0-536" id="h55-0-536" class="i">+func (m *Action) Reset()         { *m = Action{} }
</a><a href="#h55-0-537" id="h55-0-537" class="i">+func (m *Action) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-538" id="h55-0-538" class="i">+func (*Action) ProtoMessage()    {}
</a><a href="#h55-0-539" id="h55-0-539" class="i">+
</a><a href="#h55-0-540" id="h55-0-540" class="i">+type PropertyValue struct {
</a><a href="#h55-0-541" id="h55-0-541" class="i">+	Int64Value       *int64                        `protobuf:&quot;varint,1,opt,name=int64Value&quot; json:&quot;int64Value,omitempty&quot;`
</a><a href="#h55-0-542" id="h55-0-542" class="i">+	BooleanValue     *bool                         `protobuf:&quot;varint,2,opt,name=booleanValue&quot; json:&quot;booleanValue,omitempty&quot;`
</a><a href="#h55-0-543" id="h55-0-543" class="i">+	StringValue      *string                       `protobuf:&quot;bytes,3,opt,name=stringValue&quot; json:&quot;stringValue,omitempty&quot;`
</a><a href="#h55-0-544" id="h55-0-544" class="i">+	DoubleValue      *float64                      `protobuf:&quot;fixed64,4,opt,name=doubleValue&quot; json:&quot;doubleValue,omitempty&quot;`
</a><a href="#h55-0-545" id="h55-0-545" class="i">+	Pointvalue       *PropertyValue_PointValue     `protobuf:&quot;group,5,opt,name=PointValue&quot; json:&quot;pointvalue,omitempty&quot;`
</a><a href="#h55-0-546" id="h55-0-546" class="i">+	Uservalue        *PropertyValue_UserValue      `protobuf:&quot;group,8,opt,name=UserValue&quot; json:&quot;uservalue,omitempty&quot;`
</a><a href="#h55-0-547" id="h55-0-547" class="i">+	Referencevalue   *PropertyValue_ReferenceValue `protobuf:&quot;group,12,opt,name=ReferenceValue&quot; json:&quot;referencevalue,omitempty&quot;`
</a><a href="#h55-0-548" id="h55-0-548" class="i">+	XXX_unrecognized []byte                        `json:&quot;-&quot;`
</a><a href="#h55-0-549" id="h55-0-549" class="i">+}
</a><a href="#h55-0-550" id="h55-0-550" class="i">+
</a><a href="#h55-0-551" id="h55-0-551" class="i">+func (m *PropertyValue) Reset()         { *m = PropertyValue{} }
</a><a href="#h55-0-552" id="h55-0-552" class="i">+func (m *PropertyValue) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-553" id="h55-0-553" class="i">+func (*PropertyValue) ProtoMessage()    {}
</a><a href="#h55-0-554" id="h55-0-554" class="i">+
</a><a href="#h55-0-555" id="h55-0-555" class="i">+func (m *PropertyValue) GetInt64Value() int64 {
</a><a href="#h55-0-556" id="h55-0-556" class="i">+	if m != nil &amp;&amp; m.Int64Value != nil {
</a><a href="#h55-0-557" id="h55-0-557" class="i">+		return *m.Int64Value
</a><a href="#h55-0-558" id="h55-0-558" class="i">+	}
</a><a href="#h55-0-559" id="h55-0-559" class="i">+	return 0
</a><a href="#h55-0-560" id="h55-0-560" class="i">+}
</a><a href="#h55-0-561" id="h55-0-561" class="i">+
</a><a href="#h55-0-562" id="h55-0-562" class="i">+func (m *PropertyValue) GetBooleanValue() bool {
</a><a href="#h55-0-563" id="h55-0-563" class="i">+	if m != nil &amp;&amp; m.BooleanValue != nil {
</a><a href="#h55-0-564" id="h55-0-564" class="i">+		return *m.BooleanValue
</a><a href="#h55-0-565" id="h55-0-565" class="i">+	}
</a><a href="#h55-0-566" id="h55-0-566" class="i">+	return false
</a><a href="#h55-0-567" id="h55-0-567" class="i">+}
</a><a href="#h55-0-568" id="h55-0-568" class="i">+
</a><a href="#h55-0-569" id="h55-0-569" class="i">+func (m *PropertyValue) GetStringValue() string {
</a><a href="#h55-0-570" id="h55-0-570" class="i">+	if m != nil &amp;&amp; m.StringValue != nil {
</a><a href="#h55-0-571" id="h55-0-571" class="i">+		return *m.StringValue
</a><a href="#h55-0-572" id="h55-0-572" class="i">+	}
</a><a href="#h55-0-573" id="h55-0-573" class="i">+	return &quot;&quot;
</a><a href="#h55-0-574" id="h55-0-574" class="i">+}
</a><a href="#h55-0-575" id="h55-0-575" class="i">+
</a><a href="#h55-0-576" id="h55-0-576" class="i">+func (m *PropertyValue) GetDoubleValue() float64 {
</a><a href="#h55-0-577" id="h55-0-577" class="i">+	if m != nil &amp;&amp; m.DoubleValue != nil {
</a><a href="#h55-0-578" id="h55-0-578" class="i">+		return *m.DoubleValue
</a><a href="#h55-0-579" id="h55-0-579" class="i">+	}
</a><a href="#h55-0-580" id="h55-0-580" class="i">+	return 0
</a><a href="#h55-0-581" id="h55-0-581" class="i">+}
</a><a href="#h55-0-582" id="h55-0-582" class="i">+
</a><a href="#h55-0-583" id="h55-0-583" class="i">+func (m *PropertyValue) GetPointvalue() *PropertyValue_PointValue {
</a><a href="#h55-0-584" id="h55-0-584" class="i">+	if m != nil {
</a><a href="#h55-0-585" id="h55-0-585" class="i">+		return m.Pointvalue
</a><a href="#h55-0-586" id="h55-0-586" class="i">+	}
</a><a href="#h55-0-587" id="h55-0-587" class="i">+	return nil
</a><a href="#h55-0-588" id="h55-0-588" class="i">+}
</a><a href="#h55-0-589" id="h55-0-589" class="i">+
</a><a href="#h55-0-590" id="h55-0-590" class="i">+func (m *PropertyValue) GetUservalue() *PropertyValue_UserValue {
</a><a href="#h55-0-591" id="h55-0-591" class="i">+	if m != nil {
</a><a href="#h55-0-592" id="h55-0-592" class="i">+		return m.Uservalue
</a><a href="#h55-0-593" id="h55-0-593" class="i">+	}
</a><a href="#h55-0-594" id="h55-0-594" class="i">+	return nil
</a><a href="#h55-0-595" id="h55-0-595" class="i">+}
</a><a href="#h55-0-596" id="h55-0-596" class="i">+
</a><a href="#h55-0-597" id="h55-0-597" class="i">+func (m *PropertyValue) GetReferencevalue() *PropertyValue_ReferenceValue {
</a><a href="#h55-0-598" id="h55-0-598" class="i">+	if m != nil {
</a><a href="#h55-0-599" id="h55-0-599" class="i">+		return m.Referencevalue
</a><a href="#h55-0-600" id="h55-0-600" class="i">+	}
</a><a href="#h55-0-601" id="h55-0-601" class="i">+	return nil
</a><a href="#h55-0-602" id="h55-0-602" class="i">+}
</a><a href="#h55-0-603" id="h55-0-603" class="i">+
</a><a href="#h55-0-604" id="h55-0-604" class="i">+type PropertyValue_PointValue struct {
</a><a href="#h55-0-605" id="h55-0-605" class="i">+	X                *float64 `protobuf:&quot;fixed64,6,req,name=x&quot; json:&quot;x,omitempty&quot;`
</a><a href="#h55-0-606" id="h55-0-606" class="i">+	Y                *float64 `protobuf:&quot;fixed64,7,req,name=y&quot; json:&quot;y,omitempty&quot;`
</a><a href="#h55-0-607" id="h55-0-607" class="i">+	XXX_unrecognized []byte   `json:&quot;-&quot;`
</a><a href="#h55-0-608" id="h55-0-608" class="i">+}
</a><a href="#h55-0-609" id="h55-0-609" class="i">+
</a><a href="#h55-0-610" id="h55-0-610" class="i">+func (m *PropertyValue_PointValue) Reset()         { *m = PropertyValue_PointValue{} }
</a><a href="#h55-0-611" id="h55-0-611" class="i">+func (m *PropertyValue_PointValue) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-612" id="h55-0-612" class="i">+func (*PropertyValue_PointValue) ProtoMessage()    {}
</a><a href="#h55-0-613" id="h55-0-613" class="i">+
</a><a href="#h55-0-614" id="h55-0-614" class="i">+func (m *PropertyValue_PointValue) GetX() float64 {
</a><a href="#h55-0-615" id="h55-0-615" class="i">+	if m != nil &amp;&amp; m.X != nil {
</a><a href="#h55-0-616" id="h55-0-616" class="i">+		return *m.X
</a><a href="#h55-0-617" id="h55-0-617" class="i">+	}
</a><a href="#h55-0-618" id="h55-0-618" class="i">+	return 0
</a><a href="#h55-0-619" id="h55-0-619" class="i">+}
</a><a href="#h55-0-620" id="h55-0-620" class="i">+
</a><a href="#h55-0-621" id="h55-0-621" class="i">+func (m *PropertyValue_PointValue) GetY() float64 {
</a><a href="#h55-0-622" id="h55-0-622" class="i">+	if m != nil &amp;&amp; m.Y != nil {
</a><a href="#h55-0-623" id="h55-0-623" class="i">+		return *m.Y
</a><a href="#h55-0-624" id="h55-0-624" class="i">+	}
</a><a href="#h55-0-625" id="h55-0-625" class="i">+	return 0
</a><a href="#h55-0-626" id="h55-0-626" class="i">+}
</a><a href="#h55-0-627" id="h55-0-627" class="i">+
</a><a href="#h55-0-628" id="h55-0-628" class="i">+type PropertyValue_UserValue struct {
</a><a href="#h55-0-629" id="h55-0-629" class="i">+	Email             *string `protobuf:&quot;bytes,9,req,name=email&quot; json:&quot;email,omitempty&quot;`
</a><a href="#h55-0-630" id="h55-0-630" class="i">+	AuthDomain        *string `protobuf:&quot;bytes,10,req,name=auth_domain&quot; json:&quot;auth_domain,omitempty&quot;`
</a><a href="#h55-0-631" id="h55-0-631" class="i">+	Nickname          *string `protobuf:&quot;bytes,11,opt,name=nickname&quot; json:&quot;nickname,omitempty&quot;`
</a><a href="#h55-0-632" id="h55-0-632" class="i">+	FederatedIdentity *string `protobuf:&quot;bytes,21,opt,name=federated_identity&quot; json:&quot;federated_identity,omitempty&quot;`
</a><a href="#h55-0-633" id="h55-0-633" class="i">+	FederatedProvider *string `protobuf:&quot;bytes,22,opt,name=federated_provider&quot; json:&quot;federated_provider,omitempty&quot;`
</a><a href="#h55-0-634" id="h55-0-634" class="i">+	XXX_unrecognized  []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-635" id="h55-0-635" class="i">+}
</a><a href="#h55-0-636" id="h55-0-636" class="i">+
</a><a href="#h55-0-637" id="h55-0-637" class="i">+func (m *PropertyValue_UserValue) Reset()         { *m = PropertyValue_UserValue{} }
</a><a href="#h55-0-638" id="h55-0-638" class="i">+func (m *PropertyValue_UserValue) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-639" id="h55-0-639" class="i">+func (*PropertyValue_UserValue) ProtoMessage()    {}
</a><a href="#h55-0-640" id="h55-0-640" class="i">+
</a><a href="#h55-0-641" id="h55-0-641" class="i">+func (m *PropertyValue_UserValue) GetEmail() string {
</a><a href="#h55-0-642" id="h55-0-642" class="i">+	if m != nil &amp;&amp; m.Email != nil {
</a><a href="#h55-0-643" id="h55-0-643" class="i">+		return *m.Email
</a><a href="#h55-0-644" id="h55-0-644" class="i">+	}
</a><a href="#h55-0-645" id="h55-0-645" class="i">+	return &quot;&quot;
</a><a href="#h55-0-646" id="h55-0-646" class="i">+}
</a><a href="#h55-0-647" id="h55-0-647" class="i">+
</a><a href="#h55-0-648" id="h55-0-648" class="i">+func (m *PropertyValue_UserValue) GetAuthDomain() string {
</a><a href="#h55-0-649" id="h55-0-649" class="i">+	if m != nil &amp;&amp; m.AuthDomain != nil {
</a><a href="#h55-0-650" id="h55-0-650" class="i">+		return *m.AuthDomain
</a><a href="#h55-0-651" id="h55-0-651" class="i">+	}
</a><a href="#h55-0-652" id="h55-0-652" class="i">+	return &quot;&quot;
</a><a href="#h55-0-653" id="h55-0-653" class="i">+}
</a><a href="#h55-0-654" id="h55-0-654" class="i">+
</a><a href="#h55-0-655" id="h55-0-655" class="i">+func (m *PropertyValue_UserValue) GetNickname() string {
</a><a href="#h55-0-656" id="h55-0-656" class="i">+	if m != nil &amp;&amp; m.Nickname != nil {
</a><a href="#h55-0-657" id="h55-0-657" class="i">+		return *m.Nickname
</a><a href="#h55-0-658" id="h55-0-658" class="i">+	}
</a><a href="#h55-0-659" id="h55-0-659" class="i">+	return &quot;&quot;
</a><a href="#h55-0-660" id="h55-0-660" class="i">+}
</a><a href="#h55-0-661" id="h55-0-661" class="i">+
</a><a href="#h55-0-662" id="h55-0-662" class="i">+func (m *PropertyValue_UserValue) GetFederatedIdentity() string {
</a><a href="#h55-0-663" id="h55-0-663" class="i">+	if m != nil &amp;&amp; m.FederatedIdentity != nil {
</a><a href="#h55-0-664" id="h55-0-664" class="i">+		return *m.FederatedIdentity
</a><a href="#h55-0-665" id="h55-0-665" class="i">+	}
</a><a href="#h55-0-666" id="h55-0-666" class="i">+	return &quot;&quot;
</a><a href="#h55-0-667" id="h55-0-667" class="i">+}
</a><a href="#h55-0-668" id="h55-0-668" class="i">+
</a><a href="#h55-0-669" id="h55-0-669" class="i">+func (m *PropertyValue_UserValue) GetFederatedProvider() string {
</a><a href="#h55-0-670" id="h55-0-670" class="i">+	if m != nil &amp;&amp; m.FederatedProvider != nil {
</a><a href="#h55-0-671" id="h55-0-671" class="i">+		return *m.FederatedProvider
</a><a href="#h55-0-672" id="h55-0-672" class="i">+	}
</a><a href="#h55-0-673" id="h55-0-673" class="i">+	return &quot;&quot;
</a><a href="#h55-0-674" id="h55-0-674" class="i">+}
</a><a href="#h55-0-675" id="h55-0-675" class="i">+
</a><a href="#h55-0-676" id="h55-0-676" class="i">+type PropertyValue_ReferenceValue struct {
</a><a href="#h55-0-677" id="h55-0-677" class="i">+	App              *string                                     `protobuf:&quot;bytes,13,req,name=app&quot; json:&quot;app,omitempty&quot;`
</a><a href="#h55-0-678" id="h55-0-678" class="i">+	NameSpace        *string                                     `protobuf:&quot;bytes,20,opt,name=name_space&quot; json:&quot;name_space,omitempty&quot;`
</a><a href="#h55-0-679" id="h55-0-679" class="i">+	Pathelement      []*PropertyValue_ReferenceValue_PathElement `protobuf:&quot;group,14,rep,name=PathElement&quot; json:&quot;pathelement,omitempty&quot;`
</a><a href="#h55-0-680" id="h55-0-680" class="i">+	XXX_unrecognized []byte                                      `json:&quot;-&quot;`
</a><a href="#h55-0-681" id="h55-0-681" class="i">+}
</a><a href="#h55-0-682" id="h55-0-682" class="i">+
</a><a href="#h55-0-683" id="h55-0-683" class="i">+func (m *PropertyValue_ReferenceValue) Reset()         { *m = PropertyValue_ReferenceValue{} }
</a><a href="#h55-0-684" id="h55-0-684" class="i">+func (m *PropertyValue_ReferenceValue) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-685" id="h55-0-685" class="i">+func (*PropertyValue_ReferenceValue) ProtoMessage()    {}
</a><a href="#h55-0-686" id="h55-0-686" class="i">+
</a><a href="#h55-0-687" id="h55-0-687" class="i">+func (m *PropertyValue_ReferenceValue) GetApp() string {
</a><a href="#h55-0-688" id="h55-0-688" class="i">+	if m != nil &amp;&amp; m.App != nil {
</a><a href="#h55-0-689" id="h55-0-689" class="i">+		return *m.App
</a><a href="#h55-0-690" id="h55-0-690" class="i">+	}
</a><a href="#h55-0-691" id="h55-0-691" class="i">+	return &quot;&quot;
</a><a href="#h55-0-692" id="h55-0-692" class="i">+}
</a><a href="#h55-0-693" id="h55-0-693" class="i">+
</a><a href="#h55-0-694" id="h55-0-694" class="i">+func (m *PropertyValue_ReferenceValue) GetNameSpace() string {
</a><a href="#h55-0-695" id="h55-0-695" class="i">+	if m != nil &amp;&amp; m.NameSpace != nil {
</a><a href="#h55-0-696" id="h55-0-696" class="i">+		return *m.NameSpace
</a><a href="#h55-0-697" id="h55-0-697" class="i">+	}
</a><a href="#h55-0-698" id="h55-0-698" class="i">+	return &quot;&quot;
</a><a href="#h55-0-699" id="h55-0-699" class="i">+}
</a><a href="#h55-0-700" id="h55-0-700" class="i">+
</a><a href="#h55-0-701" id="h55-0-701" class="i">+func (m *PropertyValue_ReferenceValue) GetPathelement() []*PropertyValue_ReferenceValue_PathElement {
</a><a href="#h55-0-702" id="h55-0-702" class="i">+	if m != nil {
</a><a href="#h55-0-703" id="h55-0-703" class="i">+		return m.Pathelement
</a><a href="#h55-0-704" id="h55-0-704" class="i">+	}
</a><a href="#h55-0-705" id="h55-0-705" class="i">+	return nil
</a><a href="#h55-0-706" id="h55-0-706" class="i">+}
</a><a href="#h55-0-707" id="h55-0-707" class="i">+
</a><a href="#h55-0-708" id="h55-0-708" class="i">+type PropertyValue_ReferenceValue_PathElement struct {
</a><a href="#h55-0-709" id="h55-0-709" class="i">+	Type             *string `protobuf:&quot;bytes,15,req,name=type&quot; json:&quot;type,omitempty&quot;`
</a><a href="#h55-0-710" id="h55-0-710" class="i">+	Id               *int64  `protobuf:&quot;varint,16,opt,name=id&quot; json:&quot;id,omitempty&quot;`
</a><a href="#h55-0-711" id="h55-0-711" class="i">+	Name             *string `protobuf:&quot;bytes,17,opt,name=name&quot; json:&quot;name,omitempty&quot;`
</a><a href="#h55-0-712" id="h55-0-712" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-713" id="h55-0-713" class="i">+}
</a><a href="#h55-0-714" id="h55-0-714" class="i">+
</a><a href="#h55-0-715" id="h55-0-715" class="i">+func (m *PropertyValue_ReferenceValue_PathElement) Reset() {
</a><a href="#h55-0-716" id="h55-0-716" class="i">+	*m = PropertyValue_ReferenceValue_PathElement{}
</a><a href="#h55-0-717" id="h55-0-717" class="i">+}
</a><a href="#h55-0-718" id="h55-0-718" class="i">+func (m *PropertyValue_ReferenceValue_PathElement) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-719" id="h55-0-719" class="i">+func (*PropertyValue_ReferenceValue_PathElement) ProtoMessage()    {}
</a><a href="#h55-0-720" id="h55-0-720" class="i">+
</a><a href="#h55-0-721" id="h55-0-721" class="i">+func (m *PropertyValue_ReferenceValue_PathElement) GetType() string {
</a><a href="#h55-0-722" id="h55-0-722" class="i">+	if m != nil &amp;&amp; m.Type != nil {
</a><a href="#h55-0-723" id="h55-0-723" class="i">+		return *m.Type
</a><a href="#h55-0-724" id="h55-0-724" class="i">+	}
</a><a href="#h55-0-725" id="h55-0-725" class="i">+	return &quot;&quot;
</a><a href="#h55-0-726" id="h55-0-726" class="i">+}
</a><a href="#h55-0-727" id="h55-0-727" class="i">+
</a><a href="#h55-0-728" id="h55-0-728" class="i">+func (m *PropertyValue_ReferenceValue_PathElement) GetId() int64 {
</a><a href="#h55-0-729" id="h55-0-729" class="i">+	if m != nil &amp;&amp; m.Id != nil {
</a><a href="#h55-0-730" id="h55-0-730" class="i">+		return *m.Id
</a><a href="#h55-0-731" id="h55-0-731" class="i">+	}
</a><a href="#h55-0-732" id="h55-0-732" class="i">+	return 0
</a><a href="#h55-0-733" id="h55-0-733" class="i">+}
</a><a href="#h55-0-734" id="h55-0-734" class="i">+
</a><a href="#h55-0-735" id="h55-0-735" class="i">+func (m *PropertyValue_ReferenceValue_PathElement) GetName() string {
</a><a href="#h55-0-736" id="h55-0-736" class="i">+	if m != nil &amp;&amp; m.Name != nil {
</a><a href="#h55-0-737" id="h55-0-737" class="i">+		return *m.Name
</a><a href="#h55-0-738" id="h55-0-738" class="i">+	}
</a><a href="#h55-0-739" id="h55-0-739" class="i">+	return &quot;&quot;
</a><a href="#h55-0-740" id="h55-0-740" class="i">+}
</a><a href="#h55-0-741" id="h55-0-741" class="i">+
</a><a href="#h55-0-742" id="h55-0-742" class="i">+type Property struct {
</a><a href="#h55-0-743" id="h55-0-743" class="i">+	Meaning               *Property_Meaning               `protobuf:&quot;varint,1,opt,name=meaning,enum=appengine.Property_Meaning,def=0&quot; json:&quot;meaning,omitempty&quot;`
</a><a href="#h55-0-744" id="h55-0-744" class="i">+	MeaningUri            *string                         `protobuf:&quot;bytes,2,opt,name=meaning_uri&quot; json:&quot;meaning_uri,omitempty&quot;`
</a><a href="#h55-0-745" id="h55-0-745" class="i">+	Name                  *string                         `protobuf:&quot;bytes,3,req,name=name&quot; json:&quot;name,omitempty&quot;`
</a><a href="#h55-0-746" id="h55-0-746" class="i">+	Value                 *PropertyValue                  `protobuf:&quot;bytes,5,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h55-0-747" id="h55-0-747" class="i">+	Multiple              *bool                           `protobuf:&quot;varint,4,req,name=multiple&quot; json:&quot;multiple,omitempty&quot;`
</a><a href="#h55-0-748" id="h55-0-748" class="i">+	Searchable            *bool                           `protobuf:&quot;varint,6,opt,name=searchable,def=0&quot; json:&quot;searchable,omitempty&quot;`
</a><a href="#h55-0-749" id="h55-0-749" class="i">+	FtsTokenizationOption *Property_FtsTokenizationOption `protobuf:&quot;varint,8,opt,name=fts_tokenization_option,enum=appengine.Property_FtsTokenizationOption&quot; json:&quot;fts_tokenization_option,omitempty&quot;`
</a><a href="#h55-0-750" id="h55-0-750" class="i">+	Locale                *string                         `protobuf:&quot;bytes,9,opt,name=locale,def=en&quot; json:&quot;locale,omitempty&quot;`
</a><a href="#h55-0-751" id="h55-0-751" class="i">+	XXX_unrecognized      []byte                          `json:&quot;-&quot;`
</a><a href="#h55-0-752" id="h55-0-752" class="i">+}
</a><a href="#h55-0-753" id="h55-0-753" class="i">+
</a><a href="#h55-0-754" id="h55-0-754" class="i">+func (m *Property) Reset()         { *m = Property{} }
</a><a href="#h55-0-755" id="h55-0-755" class="i">+func (m *Property) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-756" id="h55-0-756" class="i">+func (*Property) ProtoMessage()    {}
</a><a href="#h55-0-757" id="h55-0-757" class="i">+
</a><a href="#h55-0-758" id="h55-0-758" class="i">+const Default_Property_Meaning Property_Meaning = Property_NO_MEANING
</a><a href="#h55-0-759" id="h55-0-759" class="i">+const Default_Property_Searchable bool = false
</a><a href="#h55-0-760" id="h55-0-760" class="i">+const Default_Property_Locale string = &quot;en&quot;
</a><a href="#h55-0-761" id="h55-0-761" class="i">+
</a><a href="#h55-0-762" id="h55-0-762" class="i">+func (m *Property) GetMeaning() Property_Meaning {
</a><a href="#h55-0-763" id="h55-0-763" class="i">+	if m != nil &amp;&amp; m.Meaning != nil {
</a><a href="#h55-0-764" id="h55-0-764" class="i">+		return *m.Meaning
</a><a href="#h55-0-765" id="h55-0-765" class="i">+	}
</a><a href="#h55-0-766" id="h55-0-766" class="i">+	return Default_Property_Meaning
</a><a href="#h55-0-767" id="h55-0-767" class="i">+}
</a><a href="#h55-0-768" id="h55-0-768" class="i">+
</a><a href="#h55-0-769" id="h55-0-769" class="i">+func (m *Property) GetMeaningUri() string {
</a><a href="#h55-0-770" id="h55-0-770" class="i">+	if m != nil &amp;&amp; m.MeaningUri != nil {
</a><a href="#h55-0-771" id="h55-0-771" class="i">+		return *m.MeaningUri
</a><a href="#h55-0-772" id="h55-0-772" class="i">+	}
</a><a href="#h55-0-773" id="h55-0-773" class="i">+	return &quot;&quot;
</a><a href="#h55-0-774" id="h55-0-774" class="i">+}
</a><a href="#h55-0-775" id="h55-0-775" class="i">+
</a><a href="#h55-0-776" id="h55-0-776" class="i">+func (m *Property) GetName() string {
</a><a href="#h55-0-777" id="h55-0-777" class="i">+	if m != nil &amp;&amp; m.Name != nil {
</a><a href="#h55-0-778" id="h55-0-778" class="i">+		return *m.Name
</a><a href="#h55-0-779" id="h55-0-779" class="i">+	}
</a><a href="#h55-0-780" id="h55-0-780" class="i">+	return &quot;&quot;
</a><a href="#h55-0-781" id="h55-0-781" class="i">+}
</a><a href="#h55-0-782" id="h55-0-782" class="i">+
</a><a href="#h55-0-783" id="h55-0-783" class="i">+func (m *Property) GetValue() *PropertyValue {
</a><a href="#h55-0-784" id="h55-0-784" class="i">+	if m != nil {
</a><a href="#h55-0-785" id="h55-0-785" class="i">+		return m.Value
</a><a href="#h55-0-786" id="h55-0-786" class="i">+	}
</a><a href="#h55-0-787" id="h55-0-787" class="i">+	return nil
</a><a href="#h55-0-788" id="h55-0-788" class="i">+}
</a><a href="#h55-0-789" id="h55-0-789" class="i">+
</a><a href="#h55-0-790" id="h55-0-790" class="i">+func (m *Property) GetMultiple() bool {
</a><a href="#h55-0-791" id="h55-0-791" class="i">+	if m != nil &amp;&amp; m.Multiple != nil {
</a><a href="#h55-0-792" id="h55-0-792" class="i">+		return *m.Multiple
</a><a href="#h55-0-793" id="h55-0-793" class="i">+	}
</a><a href="#h55-0-794" id="h55-0-794" class="i">+	return false
</a><a href="#h55-0-795" id="h55-0-795" class="i">+}
</a><a href="#h55-0-796" id="h55-0-796" class="i">+
</a><a href="#h55-0-797" id="h55-0-797" class="i">+func (m *Property) GetSearchable() bool {
</a><a href="#h55-0-798" id="h55-0-798" class="i">+	if m != nil &amp;&amp; m.Searchable != nil {
</a><a href="#h55-0-799" id="h55-0-799" class="i">+		return *m.Searchable
</a><a href="#h55-0-800" id="h55-0-800" class="i">+	}
</a><a href="#h55-0-801" id="h55-0-801" class="i">+	return Default_Property_Searchable
</a><a href="#h55-0-802" id="h55-0-802" class="i">+}
</a><a href="#h55-0-803" id="h55-0-803" class="i">+
</a><a href="#h55-0-804" id="h55-0-804" class="i">+func (m *Property) GetFtsTokenizationOption() Property_FtsTokenizationOption {
</a><a href="#h55-0-805" id="h55-0-805" class="i">+	if m != nil &amp;&amp; m.FtsTokenizationOption != nil {
</a><a href="#h55-0-806" id="h55-0-806" class="i">+		return *m.FtsTokenizationOption
</a><a href="#h55-0-807" id="h55-0-807" class="i">+	}
</a><a href="#h55-0-808" id="h55-0-808" class="i">+	return Property_HTML
</a><a href="#h55-0-809" id="h55-0-809" class="i">+}
</a><a href="#h55-0-810" id="h55-0-810" class="i">+
</a><a href="#h55-0-811" id="h55-0-811" class="i">+func (m *Property) GetLocale() string {
</a><a href="#h55-0-812" id="h55-0-812" class="i">+	if m != nil &amp;&amp; m.Locale != nil {
</a><a href="#h55-0-813" id="h55-0-813" class="i">+		return *m.Locale
</a><a href="#h55-0-814" id="h55-0-814" class="i">+	}
</a><a href="#h55-0-815" id="h55-0-815" class="i">+	return Default_Property_Locale
</a><a href="#h55-0-816" id="h55-0-816" class="i">+}
</a><a href="#h55-0-817" id="h55-0-817" class="i">+
</a><a href="#h55-0-818" id="h55-0-818" class="i">+type Path struct {
</a><a href="#h55-0-819" id="h55-0-819" class="i">+	Element          []*Path_Element `protobuf:&quot;group,1,rep,name=Element&quot; json:&quot;element,omitempty&quot;`
</a><a href="#h55-0-820" id="h55-0-820" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-821" id="h55-0-821" class="i">+}
</a><a href="#h55-0-822" id="h55-0-822" class="i">+
</a><a href="#h55-0-823" id="h55-0-823" class="i">+func (m *Path) Reset()         { *m = Path{} }
</a><a href="#h55-0-824" id="h55-0-824" class="i">+func (m *Path) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-825" id="h55-0-825" class="i">+func (*Path) ProtoMessage()    {}
</a><a href="#h55-0-826" id="h55-0-826" class="i">+
</a><a href="#h55-0-827" id="h55-0-827" class="i">+func (m *Path) GetElement() []*Path_Element {
</a><a href="#h55-0-828" id="h55-0-828" class="i">+	if m != nil {
</a><a href="#h55-0-829" id="h55-0-829" class="i">+		return m.Element
</a><a href="#h55-0-830" id="h55-0-830" class="i">+	}
</a><a href="#h55-0-831" id="h55-0-831" class="i">+	return nil
</a><a href="#h55-0-832" id="h55-0-832" class="i">+}
</a><a href="#h55-0-833" id="h55-0-833" class="i">+
</a><a href="#h55-0-834" id="h55-0-834" class="i">+type Path_Element struct {
</a><a href="#h55-0-835" id="h55-0-835" class="i">+	Type             *string `protobuf:&quot;bytes,2,req,name=type&quot; json:&quot;type,omitempty&quot;`
</a><a href="#h55-0-836" id="h55-0-836" class="i">+	Id               *int64  `protobuf:&quot;varint,3,opt,name=id&quot; json:&quot;id,omitempty&quot;`
</a><a href="#h55-0-837" id="h55-0-837" class="i">+	Name             *string `protobuf:&quot;bytes,4,opt,name=name&quot; json:&quot;name,omitempty&quot;`
</a><a href="#h55-0-838" id="h55-0-838" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-839" id="h55-0-839" class="i">+}
</a><a href="#h55-0-840" id="h55-0-840" class="i">+
</a><a href="#h55-0-841" id="h55-0-841" class="i">+func (m *Path_Element) Reset()         { *m = Path_Element{} }
</a><a href="#h55-0-842" id="h55-0-842" class="i">+func (m *Path_Element) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-843" id="h55-0-843" class="i">+func (*Path_Element) ProtoMessage()    {}
</a><a href="#h55-0-844" id="h55-0-844" class="i">+
</a><a href="#h55-0-845" id="h55-0-845" class="i">+func (m *Path_Element) GetType() string {
</a><a href="#h55-0-846" id="h55-0-846" class="i">+	if m != nil &amp;&amp; m.Type != nil {
</a><a href="#h55-0-847" id="h55-0-847" class="i">+		return *m.Type
</a><a href="#h55-0-848" id="h55-0-848" class="i">+	}
</a><a href="#h55-0-849" id="h55-0-849" class="i">+	return &quot;&quot;
</a><a href="#h55-0-850" id="h55-0-850" class="i">+}
</a><a href="#h55-0-851" id="h55-0-851" class="i">+
</a><a href="#h55-0-852" id="h55-0-852" class="i">+func (m *Path_Element) GetId() int64 {
</a><a href="#h55-0-853" id="h55-0-853" class="i">+	if m != nil &amp;&amp; m.Id != nil {
</a><a href="#h55-0-854" id="h55-0-854" class="i">+		return *m.Id
</a><a href="#h55-0-855" id="h55-0-855" class="i">+	}
</a><a href="#h55-0-856" id="h55-0-856" class="i">+	return 0
</a><a href="#h55-0-857" id="h55-0-857" class="i">+}
</a><a href="#h55-0-858" id="h55-0-858" class="i">+
</a><a href="#h55-0-859" id="h55-0-859" class="i">+func (m *Path_Element) GetName() string {
</a><a href="#h55-0-860" id="h55-0-860" class="i">+	if m != nil &amp;&amp; m.Name != nil {
</a><a href="#h55-0-861" id="h55-0-861" class="i">+		return *m.Name
</a><a href="#h55-0-862" id="h55-0-862" class="i">+	}
</a><a href="#h55-0-863" id="h55-0-863" class="i">+	return &quot;&quot;
</a><a href="#h55-0-864" id="h55-0-864" class="i">+}
</a><a href="#h55-0-865" id="h55-0-865" class="i">+
</a><a href="#h55-0-866" id="h55-0-866" class="i">+type Reference struct {
</a><a href="#h55-0-867" id="h55-0-867" class="i">+	App              *string `protobuf:&quot;bytes,13,req,name=app&quot; json:&quot;app,omitempty&quot;`
</a><a href="#h55-0-868" id="h55-0-868" class="i">+	NameSpace        *string `protobuf:&quot;bytes,20,opt,name=name_space&quot; json:&quot;name_space,omitempty&quot;`
</a><a href="#h55-0-869" id="h55-0-869" class="i">+	Path             *Path   `protobuf:&quot;bytes,14,req,name=path&quot; json:&quot;path,omitempty&quot;`
</a><a href="#h55-0-870" id="h55-0-870" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-871" id="h55-0-871" class="i">+}
</a><a href="#h55-0-872" id="h55-0-872" class="i">+
</a><a href="#h55-0-873" id="h55-0-873" class="i">+func (m *Reference) Reset()         { *m = Reference{} }
</a><a href="#h55-0-874" id="h55-0-874" class="i">+func (m *Reference) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-875" id="h55-0-875" class="i">+func (*Reference) ProtoMessage()    {}
</a><a href="#h55-0-876" id="h55-0-876" class="i">+
</a><a href="#h55-0-877" id="h55-0-877" class="i">+func (m *Reference) GetApp() string {
</a><a href="#h55-0-878" id="h55-0-878" class="i">+	if m != nil &amp;&amp; m.App != nil {
</a><a href="#h55-0-879" id="h55-0-879" class="i">+		return *m.App
</a><a href="#h55-0-880" id="h55-0-880" class="i">+	}
</a><a href="#h55-0-881" id="h55-0-881" class="i">+	return &quot;&quot;
</a><a href="#h55-0-882" id="h55-0-882" class="i">+}
</a><a href="#h55-0-883" id="h55-0-883" class="i">+
</a><a href="#h55-0-884" id="h55-0-884" class="i">+func (m *Reference) GetNameSpace() string {
</a><a href="#h55-0-885" id="h55-0-885" class="i">+	if m != nil &amp;&amp; m.NameSpace != nil {
</a><a href="#h55-0-886" id="h55-0-886" class="i">+		return *m.NameSpace
</a><a href="#h55-0-887" id="h55-0-887" class="i">+	}
</a><a href="#h55-0-888" id="h55-0-888" class="i">+	return &quot;&quot;
</a><a href="#h55-0-889" id="h55-0-889" class="i">+}
</a><a href="#h55-0-890" id="h55-0-890" class="i">+
</a><a href="#h55-0-891" id="h55-0-891" class="i">+func (m *Reference) GetPath() *Path {
</a><a href="#h55-0-892" id="h55-0-892" class="i">+	if m != nil {
</a><a href="#h55-0-893" id="h55-0-893" class="i">+		return m.Path
</a><a href="#h55-0-894" id="h55-0-894" class="i">+	}
</a><a href="#h55-0-895" id="h55-0-895" class="i">+	return nil
</a><a href="#h55-0-896" id="h55-0-896" class="i">+}
</a><a href="#h55-0-897" id="h55-0-897" class="i">+
</a><a href="#h55-0-898" id="h55-0-898" class="i">+type User struct {
</a><a href="#h55-0-899" id="h55-0-899" class="i">+	Email             *string `protobuf:&quot;bytes,1,req,name=email&quot; json:&quot;email,omitempty&quot;`
</a><a href="#h55-0-900" id="h55-0-900" class="i">+	AuthDomain        *string `protobuf:&quot;bytes,2,req,name=auth_domain&quot; json:&quot;auth_domain,omitempty&quot;`
</a><a href="#h55-0-901" id="h55-0-901" class="i">+	Nickname          *string `protobuf:&quot;bytes,3,opt,name=nickname&quot; json:&quot;nickname,omitempty&quot;`
</a><a href="#h55-0-902" id="h55-0-902" class="i">+	FederatedIdentity *string `protobuf:&quot;bytes,6,opt,name=federated_identity&quot; json:&quot;federated_identity,omitempty&quot;`
</a><a href="#h55-0-903" id="h55-0-903" class="i">+	FederatedProvider *string `protobuf:&quot;bytes,7,opt,name=federated_provider&quot; json:&quot;federated_provider,omitempty&quot;`
</a><a href="#h55-0-904" id="h55-0-904" class="i">+	XXX_unrecognized  []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-905" id="h55-0-905" class="i">+}
</a><a href="#h55-0-906" id="h55-0-906" class="i">+
</a><a href="#h55-0-907" id="h55-0-907" class="i">+func (m *User) Reset()         { *m = User{} }
</a><a href="#h55-0-908" id="h55-0-908" class="i">+func (m *User) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-909" id="h55-0-909" class="i">+func (*User) ProtoMessage()    {}
</a><a href="#h55-0-910" id="h55-0-910" class="i">+
</a><a href="#h55-0-911" id="h55-0-911" class="i">+func (m *User) GetEmail() string {
</a><a href="#h55-0-912" id="h55-0-912" class="i">+	if m != nil &amp;&amp; m.Email != nil {
</a><a href="#h55-0-913" id="h55-0-913" class="i">+		return *m.Email
</a><a href="#h55-0-914" id="h55-0-914" class="i">+	}
</a><a href="#h55-0-915" id="h55-0-915" class="i">+	return &quot;&quot;
</a><a href="#h55-0-916" id="h55-0-916" class="i">+}
</a><a href="#h55-0-917" id="h55-0-917" class="i">+
</a><a href="#h55-0-918" id="h55-0-918" class="i">+func (m *User) GetAuthDomain() string {
</a><a href="#h55-0-919" id="h55-0-919" class="i">+	if m != nil &amp;&amp; m.AuthDomain != nil {
</a><a href="#h55-0-920" id="h55-0-920" class="i">+		return *m.AuthDomain
</a><a href="#h55-0-921" id="h55-0-921" class="i">+	}
</a><a href="#h55-0-922" id="h55-0-922" class="i">+	return &quot;&quot;
</a><a href="#h55-0-923" id="h55-0-923" class="i">+}
</a><a href="#h55-0-924" id="h55-0-924" class="i">+
</a><a href="#h55-0-925" id="h55-0-925" class="i">+func (m *User) GetNickname() string {
</a><a href="#h55-0-926" id="h55-0-926" class="i">+	if m != nil &amp;&amp; m.Nickname != nil {
</a><a href="#h55-0-927" id="h55-0-927" class="i">+		return *m.Nickname
</a><a href="#h55-0-928" id="h55-0-928" class="i">+	}
</a><a href="#h55-0-929" id="h55-0-929" class="i">+	return &quot;&quot;
</a><a href="#h55-0-930" id="h55-0-930" class="i">+}
</a><a href="#h55-0-931" id="h55-0-931" class="i">+
</a><a href="#h55-0-932" id="h55-0-932" class="i">+func (m *User) GetFederatedIdentity() string {
</a><a href="#h55-0-933" id="h55-0-933" class="i">+	if m != nil &amp;&amp; m.FederatedIdentity != nil {
</a><a href="#h55-0-934" id="h55-0-934" class="i">+		return *m.FederatedIdentity
</a><a href="#h55-0-935" id="h55-0-935" class="i">+	}
</a><a href="#h55-0-936" id="h55-0-936" class="i">+	return &quot;&quot;
</a><a href="#h55-0-937" id="h55-0-937" class="i">+}
</a><a href="#h55-0-938" id="h55-0-938" class="i">+
</a><a href="#h55-0-939" id="h55-0-939" class="i">+func (m *User) GetFederatedProvider() string {
</a><a href="#h55-0-940" id="h55-0-940" class="i">+	if m != nil &amp;&amp; m.FederatedProvider != nil {
</a><a href="#h55-0-941" id="h55-0-941" class="i">+		return *m.FederatedProvider
</a><a href="#h55-0-942" id="h55-0-942" class="i">+	}
</a><a href="#h55-0-943" id="h55-0-943" class="i">+	return &quot;&quot;
</a><a href="#h55-0-944" id="h55-0-944" class="i">+}
</a><a href="#h55-0-945" id="h55-0-945" class="i">+
</a><a href="#h55-0-946" id="h55-0-946" class="i">+type EntityProto struct {
</a><a href="#h55-0-947" id="h55-0-947" class="i">+	Key              *Reference        `protobuf:&quot;bytes,13,req,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-948" id="h55-0-948" class="i">+	EntityGroup      *Path             `protobuf:&quot;bytes,16,req,name=entity_group&quot; json:&quot;entity_group,omitempty&quot;`
</a><a href="#h55-0-949" id="h55-0-949" class="i">+	Owner            *User             `protobuf:&quot;bytes,17,opt,name=owner&quot; json:&quot;owner,omitempty&quot;`
</a><a href="#h55-0-950" id="h55-0-950" class="i">+	Kind             *EntityProto_Kind `protobuf:&quot;varint,4,opt,name=kind,enum=appengine.EntityProto_Kind&quot; json:&quot;kind,omitempty&quot;`
</a><a href="#h55-0-951" id="h55-0-951" class="i">+	KindUri          *string           `protobuf:&quot;bytes,5,opt,name=kind_uri&quot; json:&quot;kind_uri,omitempty&quot;`
</a><a href="#h55-0-952" id="h55-0-952" class="i">+	Property         []*Property       `protobuf:&quot;bytes,14,rep,name=property&quot; json:&quot;property,omitempty&quot;`
</a><a href="#h55-0-953" id="h55-0-953" class="i">+	RawProperty      []*Property       `protobuf:&quot;bytes,15,rep,name=raw_property&quot; json:&quot;raw_property,omitempty&quot;`
</a><a href="#h55-0-954" id="h55-0-954" class="i">+	Rank             *int32            `protobuf:&quot;varint,18,opt,name=rank&quot; json:&quot;rank,omitempty&quot;`
</a><a href="#h55-0-955" id="h55-0-955" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h55-0-956" id="h55-0-956" class="i">+}
</a><a href="#h55-0-957" id="h55-0-957" class="i">+
</a><a href="#h55-0-958" id="h55-0-958" class="i">+func (m *EntityProto) Reset()         { *m = EntityProto{} }
</a><a href="#h55-0-959" id="h55-0-959" class="i">+func (m *EntityProto) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-960" id="h55-0-960" class="i">+func (*EntityProto) ProtoMessage()    {}
</a><a href="#h55-0-961" id="h55-0-961" class="i">+
</a><a href="#h55-0-962" id="h55-0-962" class="i">+func (m *EntityProto) GetKey() *Reference {
</a><a href="#h55-0-963" id="h55-0-963" class="i">+	if m != nil {
</a><a href="#h55-0-964" id="h55-0-964" class="i">+		return m.Key
</a><a href="#h55-0-965" id="h55-0-965" class="i">+	}
</a><a href="#h55-0-966" id="h55-0-966" class="i">+	return nil
</a><a href="#h55-0-967" id="h55-0-967" class="i">+}
</a><a href="#h55-0-968" id="h55-0-968" class="i">+
</a><a href="#h55-0-969" id="h55-0-969" class="i">+func (m *EntityProto) GetEntityGroup() *Path {
</a><a href="#h55-0-970" id="h55-0-970" class="i">+	if m != nil {
</a><a href="#h55-0-971" id="h55-0-971" class="i">+		return m.EntityGroup
</a><a href="#h55-0-972" id="h55-0-972" class="i">+	}
</a><a href="#h55-0-973" id="h55-0-973" class="i">+	return nil
</a><a href="#h55-0-974" id="h55-0-974" class="i">+}
</a><a href="#h55-0-975" id="h55-0-975" class="i">+
</a><a href="#h55-0-976" id="h55-0-976" class="i">+func (m *EntityProto) GetOwner() *User {
</a><a href="#h55-0-977" id="h55-0-977" class="i">+	if m != nil {
</a><a href="#h55-0-978" id="h55-0-978" class="i">+		return m.Owner
</a><a href="#h55-0-979" id="h55-0-979" class="i">+	}
</a><a href="#h55-0-980" id="h55-0-980" class="i">+	return nil
</a><a href="#h55-0-981" id="h55-0-981" class="i">+}
</a><a href="#h55-0-982" id="h55-0-982" class="i">+
</a><a href="#h55-0-983" id="h55-0-983" class="i">+func (m *EntityProto) GetKind() EntityProto_Kind {
</a><a href="#h55-0-984" id="h55-0-984" class="i">+	if m != nil &amp;&amp; m.Kind != nil {
</a><a href="#h55-0-985" id="h55-0-985" class="i">+		return *m.Kind
</a><a href="#h55-0-986" id="h55-0-986" class="i">+	}
</a><a href="#h55-0-987" id="h55-0-987" class="i">+	return EntityProto_GD_CONTACT
</a><a href="#h55-0-988" id="h55-0-988" class="i">+}
</a><a href="#h55-0-989" id="h55-0-989" class="i">+
</a><a href="#h55-0-990" id="h55-0-990" class="i">+func (m *EntityProto) GetKindUri() string {
</a><a href="#h55-0-991" id="h55-0-991" class="i">+	if m != nil &amp;&amp; m.KindUri != nil {
</a><a href="#h55-0-992" id="h55-0-992" class="i">+		return *m.KindUri
</a><a href="#h55-0-993" id="h55-0-993" class="i">+	}
</a><a href="#h55-0-994" id="h55-0-994" class="i">+	return &quot;&quot;
</a><a href="#h55-0-995" id="h55-0-995" class="i">+}
</a><a href="#h55-0-996" id="h55-0-996" class="i">+
</a><a href="#h55-0-997" id="h55-0-997" class="i">+func (m *EntityProto) GetProperty() []*Property {
</a><a href="#h55-0-998" id="h55-0-998" class="i">+	if m != nil {
</a><a href="#h55-0-999" id="h55-0-999" class="i">+		return m.Property
</a><a href="#h55-0-1000" id="h55-0-1000" class="i">+	}
</a><a href="#h55-0-1001" id="h55-0-1001" class="i">+	return nil
</a><a href="#h55-0-1002" id="h55-0-1002" class="i">+}
</a><a href="#h55-0-1003" id="h55-0-1003" class="i">+
</a><a href="#h55-0-1004" id="h55-0-1004" class="i">+func (m *EntityProto) GetRawProperty() []*Property {
</a><a href="#h55-0-1005" id="h55-0-1005" class="i">+	if m != nil {
</a><a href="#h55-0-1006" id="h55-0-1006" class="i">+		return m.RawProperty
</a><a href="#h55-0-1007" id="h55-0-1007" class="i">+	}
</a><a href="#h55-0-1008" id="h55-0-1008" class="i">+	return nil
</a><a href="#h55-0-1009" id="h55-0-1009" class="i">+}
</a><a href="#h55-0-1010" id="h55-0-1010" class="i">+
</a><a href="#h55-0-1011" id="h55-0-1011" class="i">+func (m *EntityProto) GetRank() int32 {
</a><a href="#h55-0-1012" id="h55-0-1012" class="i">+	if m != nil &amp;&amp; m.Rank != nil {
</a><a href="#h55-0-1013" id="h55-0-1013" class="i">+		return *m.Rank
</a><a href="#h55-0-1014" id="h55-0-1014" class="i">+	}
</a><a href="#h55-0-1015" id="h55-0-1015" class="i">+	return 0
</a><a href="#h55-0-1016" id="h55-0-1016" class="i">+}
</a><a href="#h55-0-1017" id="h55-0-1017" class="i">+
</a><a href="#h55-0-1018" id="h55-0-1018" class="i">+type CompositeProperty struct {
</a><a href="#h55-0-1019" id="h55-0-1019" class="i">+	IndexId          *int64   `protobuf:&quot;varint,1,req,name=index_id&quot; json:&quot;index_id,omitempty&quot;`
</a><a href="#h55-0-1020" id="h55-0-1020" class="i">+	Value            []string `protobuf:&quot;bytes,2,rep,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h55-0-1021" id="h55-0-1021" class="i">+	XXX_unrecognized []byte   `json:&quot;-&quot;`
</a><a href="#h55-0-1022" id="h55-0-1022" class="i">+}
</a><a href="#h55-0-1023" id="h55-0-1023" class="i">+
</a><a href="#h55-0-1024" id="h55-0-1024" class="i">+func (m *CompositeProperty) Reset()         { *m = CompositeProperty{} }
</a><a href="#h55-0-1025" id="h55-0-1025" class="i">+func (m *CompositeProperty) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1026" id="h55-0-1026" class="i">+func (*CompositeProperty) ProtoMessage()    {}
</a><a href="#h55-0-1027" id="h55-0-1027" class="i">+
</a><a href="#h55-0-1028" id="h55-0-1028" class="i">+func (m *CompositeProperty) GetIndexId() int64 {
</a><a href="#h55-0-1029" id="h55-0-1029" class="i">+	if m != nil &amp;&amp; m.IndexId != nil {
</a><a href="#h55-0-1030" id="h55-0-1030" class="i">+		return *m.IndexId
</a><a href="#h55-0-1031" id="h55-0-1031" class="i">+	}
</a><a href="#h55-0-1032" id="h55-0-1032" class="i">+	return 0
</a><a href="#h55-0-1033" id="h55-0-1033" class="i">+}
</a><a href="#h55-0-1034" id="h55-0-1034" class="i">+
</a><a href="#h55-0-1035" id="h55-0-1035" class="i">+func (m *CompositeProperty) GetValue() []string {
</a><a href="#h55-0-1036" id="h55-0-1036" class="i">+	if m != nil {
</a><a href="#h55-0-1037" id="h55-0-1037" class="i">+		return m.Value
</a><a href="#h55-0-1038" id="h55-0-1038" class="i">+	}
</a><a href="#h55-0-1039" id="h55-0-1039" class="i">+	return nil
</a><a href="#h55-0-1040" id="h55-0-1040" class="i">+}
</a><a href="#h55-0-1041" id="h55-0-1041" class="i">+
</a><a href="#h55-0-1042" id="h55-0-1042" class="i">+type Index struct {
</a><a href="#h55-0-1043" id="h55-0-1043" class="i">+	EntityType       *string           `protobuf:&quot;bytes,1,req,name=entity_type&quot; json:&quot;entity_type,omitempty&quot;`
</a><a href="#h55-0-1044" id="h55-0-1044" class="i">+	Ancestor         *bool             `protobuf:&quot;varint,5,req,name=ancestor&quot; json:&quot;ancestor,omitempty&quot;`
</a><a href="#h55-0-1045" id="h55-0-1045" class="i">+	Property         []*Index_Property `protobuf:&quot;group,2,rep,name=Property&quot; json:&quot;property,omitempty&quot;`
</a><a href="#h55-0-1046" id="h55-0-1046" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h55-0-1047" id="h55-0-1047" class="i">+}
</a><a href="#h55-0-1048" id="h55-0-1048" class="i">+
</a><a href="#h55-0-1049" id="h55-0-1049" class="i">+func (m *Index) Reset()         { *m = Index{} }
</a><a href="#h55-0-1050" id="h55-0-1050" class="i">+func (m *Index) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1051" id="h55-0-1051" class="i">+func (*Index) ProtoMessage()    {}
</a><a href="#h55-0-1052" id="h55-0-1052" class="i">+
</a><a href="#h55-0-1053" id="h55-0-1053" class="i">+func (m *Index) GetEntityType() string {
</a><a href="#h55-0-1054" id="h55-0-1054" class="i">+	if m != nil &amp;&amp; m.EntityType != nil {
</a><a href="#h55-0-1055" id="h55-0-1055" class="i">+		return *m.EntityType
</a><a href="#h55-0-1056" id="h55-0-1056" class="i">+	}
</a><a href="#h55-0-1057" id="h55-0-1057" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1058" id="h55-0-1058" class="i">+}
</a><a href="#h55-0-1059" id="h55-0-1059" class="i">+
</a><a href="#h55-0-1060" id="h55-0-1060" class="i">+func (m *Index) GetAncestor() bool {
</a><a href="#h55-0-1061" id="h55-0-1061" class="i">+	if m != nil &amp;&amp; m.Ancestor != nil {
</a><a href="#h55-0-1062" id="h55-0-1062" class="i">+		return *m.Ancestor
</a><a href="#h55-0-1063" id="h55-0-1063" class="i">+	}
</a><a href="#h55-0-1064" id="h55-0-1064" class="i">+	return false
</a><a href="#h55-0-1065" id="h55-0-1065" class="i">+}
</a><a href="#h55-0-1066" id="h55-0-1066" class="i">+
</a><a href="#h55-0-1067" id="h55-0-1067" class="i">+func (m *Index) GetProperty() []*Index_Property {
</a><a href="#h55-0-1068" id="h55-0-1068" class="i">+	if m != nil {
</a><a href="#h55-0-1069" id="h55-0-1069" class="i">+		return m.Property
</a><a href="#h55-0-1070" id="h55-0-1070" class="i">+	}
</a><a href="#h55-0-1071" id="h55-0-1071" class="i">+	return nil
</a><a href="#h55-0-1072" id="h55-0-1072" class="i">+}
</a><a href="#h55-0-1073" id="h55-0-1073" class="i">+
</a><a href="#h55-0-1074" id="h55-0-1074" class="i">+type Index_Property struct {
</a><a href="#h55-0-1075" id="h55-0-1075" class="i">+	Name             *string                   `protobuf:&quot;bytes,3,req,name=name&quot; json:&quot;name,omitempty&quot;`
</a><a href="#h55-0-1076" id="h55-0-1076" class="i">+	Direction        *Index_Property_Direction `protobuf:&quot;varint,4,opt,name=direction,enum=appengine.Index_Property_Direction,def=1&quot; json:&quot;direction,omitempty&quot;`
</a><a href="#h55-0-1077" id="h55-0-1077" class="i">+	XXX_unrecognized []byte                    `json:&quot;-&quot;`
</a><a href="#h55-0-1078" id="h55-0-1078" class="i">+}
</a><a href="#h55-0-1079" id="h55-0-1079" class="i">+
</a><a href="#h55-0-1080" id="h55-0-1080" class="i">+func (m *Index_Property) Reset()         { *m = Index_Property{} }
</a><a href="#h55-0-1081" id="h55-0-1081" class="i">+func (m *Index_Property) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1082" id="h55-0-1082" class="i">+func (*Index_Property) ProtoMessage()    {}
</a><a href="#h55-0-1083" id="h55-0-1083" class="i">+
</a><a href="#h55-0-1084" id="h55-0-1084" class="i">+const Default_Index_Property_Direction Index_Property_Direction = Index_Property_ASCENDING
</a><a href="#h55-0-1085" id="h55-0-1085" class="i">+
</a><a href="#h55-0-1086" id="h55-0-1086" class="i">+func (m *Index_Property) GetName() string {
</a><a href="#h55-0-1087" id="h55-0-1087" class="i">+	if m != nil &amp;&amp; m.Name != nil {
</a><a href="#h55-0-1088" id="h55-0-1088" class="i">+		return *m.Name
</a><a href="#h55-0-1089" id="h55-0-1089" class="i">+	}
</a><a href="#h55-0-1090" id="h55-0-1090" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1091" id="h55-0-1091" class="i">+}
</a><a href="#h55-0-1092" id="h55-0-1092" class="i">+
</a><a href="#h55-0-1093" id="h55-0-1093" class="i">+func (m *Index_Property) GetDirection() Index_Property_Direction {
</a><a href="#h55-0-1094" id="h55-0-1094" class="i">+	if m != nil &amp;&amp; m.Direction != nil {
</a><a href="#h55-0-1095" id="h55-0-1095" class="i">+		return *m.Direction
</a><a href="#h55-0-1096" id="h55-0-1096" class="i">+	}
</a><a href="#h55-0-1097" id="h55-0-1097" class="i">+	return Default_Index_Property_Direction
</a><a href="#h55-0-1098" id="h55-0-1098" class="i">+}
</a><a href="#h55-0-1099" id="h55-0-1099" class="i">+
</a><a href="#h55-0-1100" id="h55-0-1100" class="i">+type CompositeIndex struct {
</a><a href="#h55-0-1101" id="h55-0-1101" class="i">+	AppId             *string               `protobuf:&quot;bytes,1,req,name=app_id&quot; json:&quot;app_id,omitempty&quot;`
</a><a href="#h55-0-1102" id="h55-0-1102" class="i">+	Id                *int64                `protobuf:&quot;varint,2,req,name=id&quot; json:&quot;id,omitempty&quot;`
</a><a href="#h55-0-1103" id="h55-0-1103" class="i">+	Definition        *Index                `protobuf:&quot;bytes,3,req,name=definition&quot; json:&quot;definition,omitempty&quot;`
</a><a href="#h55-0-1104" id="h55-0-1104" class="i">+	State             *CompositeIndex_State `protobuf:&quot;varint,4,req,name=state,enum=appengine.CompositeIndex_State&quot; json:&quot;state,omitempty&quot;`
</a><a href="#h55-0-1105" id="h55-0-1105" class="i">+	OnlyUseIfRequired *bool                 `protobuf:&quot;varint,6,opt,name=only_use_if_required,def=0&quot; json:&quot;only_use_if_required,omitempty&quot;`
</a><a href="#h55-0-1106" id="h55-0-1106" class="i">+	XXX_unrecognized  []byte                `json:&quot;-&quot;`
</a><a href="#h55-0-1107" id="h55-0-1107" class="i">+}
</a><a href="#h55-0-1108" id="h55-0-1108" class="i">+
</a><a href="#h55-0-1109" id="h55-0-1109" class="i">+func (m *CompositeIndex) Reset()         { *m = CompositeIndex{} }
</a><a href="#h55-0-1110" id="h55-0-1110" class="i">+func (m *CompositeIndex) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1111" id="h55-0-1111" class="i">+func (*CompositeIndex) ProtoMessage()    {}
</a><a href="#h55-0-1112" id="h55-0-1112" class="i">+
</a><a href="#h55-0-1113" id="h55-0-1113" class="i">+const Default_CompositeIndex_OnlyUseIfRequired bool = false
</a><a href="#h55-0-1114" id="h55-0-1114" class="i">+
</a><a href="#h55-0-1115" id="h55-0-1115" class="i">+func (m *CompositeIndex) GetAppId() string {
</a><a href="#h55-0-1116" id="h55-0-1116" class="i">+	if m != nil &amp;&amp; m.AppId != nil {
</a><a href="#h55-0-1117" id="h55-0-1117" class="i">+		return *m.AppId
</a><a href="#h55-0-1118" id="h55-0-1118" class="i">+	}
</a><a href="#h55-0-1119" id="h55-0-1119" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1120" id="h55-0-1120" class="i">+}
</a><a href="#h55-0-1121" id="h55-0-1121" class="i">+
</a><a href="#h55-0-1122" id="h55-0-1122" class="i">+func (m *CompositeIndex) GetId() int64 {
</a><a href="#h55-0-1123" id="h55-0-1123" class="i">+	if m != nil &amp;&amp; m.Id != nil {
</a><a href="#h55-0-1124" id="h55-0-1124" class="i">+		return *m.Id
</a><a href="#h55-0-1125" id="h55-0-1125" class="i">+	}
</a><a href="#h55-0-1126" id="h55-0-1126" class="i">+	return 0
</a><a href="#h55-0-1127" id="h55-0-1127" class="i">+}
</a><a href="#h55-0-1128" id="h55-0-1128" class="i">+
</a><a href="#h55-0-1129" id="h55-0-1129" class="i">+func (m *CompositeIndex) GetDefinition() *Index {
</a><a href="#h55-0-1130" id="h55-0-1130" class="i">+	if m != nil {
</a><a href="#h55-0-1131" id="h55-0-1131" class="i">+		return m.Definition
</a><a href="#h55-0-1132" id="h55-0-1132" class="i">+	}
</a><a href="#h55-0-1133" id="h55-0-1133" class="i">+	return nil
</a><a href="#h55-0-1134" id="h55-0-1134" class="i">+}
</a><a href="#h55-0-1135" id="h55-0-1135" class="i">+
</a><a href="#h55-0-1136" id="h55-0-1136" class="i">+func (m *CompositeIndex) GetState() CompositeIndex_State {
</a><a href="#h55-0-1137" id="h55-0-1137" class="i">+	if m != nil &amp;&amp; m.State != nil {
</a><a href="#h55-0-1138" id="h55-0-1138" class="i">+		return *m.State
</a><a href="#h55-0-1139" id="h55-0-1139" class="i">+	}
</a><a href="#h55-0-1140" id="h55-0-1140" class="i">+	return CompositeIndex_WRITE_ONLY
</a><a href="#h55-0-1141" id="h55-0-1141" class="i">+}
</a><a href="#h55-0-1142" id="h55-0-1142" class="i">+
</a><a href="#h55-0-1143" id="h55-0-1143" class="i">+func (m *CompositeIndex) GetOnlyUseIfRequired() bool {
</a><a href="#h55-0-1144" id="h55-0-1144" class="i">+	if m != nil &amp;&amp; m.OnlyUseIfRequired != nil {
</a><a href="#h55-0-1145" id="h55-0-1145" class="i">+		return *m.OnlyUseIfRequired
</a><a href="#h55-0-1146" id="h55-0-1146" class="i">+	}
</a><a href="#h55-0-1147" id="h55-0-1147" class="i">+	return Default_CompositeIndex_OnlyUseIfRequired
</a><a href="#h55-0-1148" id="h55-0-1148" class="i">+}
</a><a href="#h55-0-1149" id="h55-0-1149" class="i">+
</a><a href="#h55-0-1150" id="h55-0-1150" class="i">+type IndexPostfix struct {
</a><a href="#h55-0-1151" id="h55-0-1151" class="i">+	IndexValue       []*IndexPostfix_IndexValue `protobuf:&quot;bytes,1,rep,name=index_value&quot; json:&quot;index_value,omitempty&quot;`
</a><a href="#h55-0-1152" id="h55-0-1152" class="i">+	Key              *Reference                 `protobuf:&quot;bytes,2,opt,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-1153" id="h55-0-1153" class="i">+	Before           *bool                      `protobuf:&quot;varint,3,opt,name=before,def=1&quot; json:&quot;before,omitempty&quot;`
</a><a href="#h55-0-1154" id="h55-0-1154" class="i">+	XXX_unrecognized []byte                     `json:&quot;-&quot;`
</a><a href="#h55-0-1155" id="h55-0-1155" class="i">+}
</a><a href="#h55-0-1156" id="h55-0-1156" class="i">+
</a><a href="#h55-0-1157" id="h55-0-1157" class="i">+func (m *IndexPostfix) Reset()         { *m = IndexPostfix{} }
</a><a href="#h55-0-1158" id="h55-0-1158" class="i">+func (m *IndexPostfix) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1159" id="h55-0-1159" class="i">+func (*IndexPostfix) ProtoMessage()    {}
</a><a href="#h55-0-1160" id="h55-0-1160" class="i">+
</a><a href="#h55-0-1161" id="h55-0-1161" class="i">+const Default_IndexPostfix_Before bool = true
</a><a href="#h55-0-1162" id="h55-0-1162" class="i">+
</a><a href="#h55-0-1163" id="h55-0-1163" class="i">+func (m *IndexPostfix) GetIndexValue() []*IndexPostfix_IndexValue {
</a><a href="#h55-0-1164" id="h55-0-1164" class="i">+	if m != nil {
</a><a href="#h55-0-1165" id="h55-0-1165" class="i">+		return m.IndexValue
</a><a href="#h55-0-1166" id="h55-0-1166" class="i">+	}
</a><a href="#h55-0-1167" id="h55-0-1167" class="i">+	return nil
</a><a href="#h55-0-1168" id="h55-0-1168" class="i">+}
</a><a href="#h55-0-1169" id="h55-0-1169" class="i">+
</a><a href="#h55-0-1170" id="h55-0-1170" class="i">+func (m *IndexPostfix) GetKey() *Reference {
</a><a href="#h55-0-1171" id="h55-0-1171" class="i">+	if m != nil {
</a><a href="#h55-0-1172" id="h55-0-1172" class="i">+		return m.Key
</a><a href="#h55-0-1173" id="h55-0-1173" class="i">+	}
</a><a href="#h55-0-1174" id="h55-0-1174" class="i">+	return nil
</a><a href="#h55-0-1175" id="h55-0-1175" class="i">+}
</a><a href="#h55-0-1176" id="h55-0-1176" class="i">+
</a><a href="#h55-0-1177" id="h55-0-1177" class="i">+func (m *IndexPostfix) GetBefore() bool {
</a><a href="#h55-0-1178" id="h55-0-1178" class="i">+	if m != nil &amp;&amp; m.Before != nil {
</a><a href="#h55-0-1179" id="h55-0-1179" class="i">+		return *m.Before
</a><a href="#h55-0-1180" id="h55-0-1180" class="i">+	}
</a><a href="#h55-0-1181" id="h55-0-1181" class="i">+	return Default_IndexPostfix_Before
</a><a href="#h55-0-1182" id="h55-0-1182" class="i">+}
</a><a href="#h55-0-1183" id="h55-0-1183" class="i">+
</a><a href="#h55-0-1184" id="h55-0-1184" class="i">+type IndexPostfix_IndexValue struct {
</a><a href="#h55-0-1185" id="h55-0-1185" class="i">+	PropertyName     *string        `protobuf:&quot;bytes,1,req,name=property_name&quot; json:&quot;property_name,omitempty&quot;`
</a><a href="#h55-0-1186" id="h55-0-1186" class="i">+	Value            *PropertyValue `protobuf:&quot;bytes,2,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h55-0-1187" id="h55-0-1187" class="i">+	XXX_unrecognized []byte         `json:&quot;-&quot;`
</a><a href="#h55-0-1188" id="h55-0-1188" class="i">+}
</a><a href="#h55-0-1189" id="h55-0-1189" class="i">+
</a><a href="#h55-0-1190" id="h55-0-1190" class="i">+func (m *IndexPostfix_IndexValue) Reset()         { *m = IndexPostfix_IndexValue{} }
</a><a href="#h55-0-1191" id="h55-0-1191" class="i">+func (m *IndexPostfix_IndexValue) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1192" id="h55-0-1192" class="i">+func (*IndexPostfix_IndexValue) ProtoMessage()    {}
</a><a href="#h55-0-1193" id="h55-0-1193" class="i">+
</a><a href="#h55-0-1194" id="h55-0-1194" class="i">+func (m *IndexPostfix_IndexValue) GetPropertyName() string {
</a><a href="#h55-0-1195" id="h55-0-1195" class="i">+	if m != nil &amp;&amp; m.PropertyName != nil {
</a><a href="#h55-0-1196" id="h55-0-1196" class="i">+		return *m.PropertyName
</a><a href="#h55-0-1197" id="h55-0-1197" class="i">+	}
</a><a href="#h55-0-1198" id="h55-0-1198" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1199" id="h55-0-1199" class="i">+}
</a><a href="#h55-0-1200" id="h55-0-1200" class="i">+
</a><a href="#h55-0-1201" id="h55-0-1201" class="i">+func (m *IndexPostfix_IndexValue) GetValue() *PropertyValue {
</a><a href="#h55-0-1202" id="h55-0-1202" class="i">+	if m != nil {
</a><a href="#h55-0-1203" id="h55-0-1203" class="i">+		return m.Value
</a><a href="#h55-0-1204" id="h55-0-1204" class="i">+	}
</a><a href="#h55-0-1205" id="h55-0-1205" class="i">+	return nil
</a><a href="#h55-0-1206" id="h55-0-1206" class="i">+}
</a><a href="#h55-0-1207" id="h55-0-1207" class="i">+
</a><a href="#h55-0-1208" id="h55-0-1208" class="i">+type IndexPosition struct {
</a><a href="#h55-0-1209" id="h55-0-1209" class="i">+	Key              *string `protobuf:&quot;bytes,1,opt,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-1210" id="h55-0-1210" class="i">+	Before           *bool   `protobuf:&quot;varint,2,opt,name=before,def=1&quot; json:&quot;before,omitempty&quot;`
</a><a href="#h55-0-1211" id="h55-0-1211" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-1212" id="h55-0-1212" class="i">+}
</a><a href="#h55-0-1213" id="h55-0-1213" class="i">+
</a><a href="#h55-0-1214" id="h55-0-1214" class="i">+func (m *IndexPosition) Reset()         { *m = IndexPosition{} }
</a><a href="#h55-0-1215" id="h55-0-1215" class="i">+func (m *IndexPosition) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1216" id="h55-0-1216" class="i">+func (*IndexPosition) ProtoMessage()    {}
</a><a href="#h55-0-1217" id="h55-0-1217" class="i">+
</a><a href="#h55-0-1218" id="h55-0-1218" class="i">+const Default_IndexPosition_Before bool = true
</a><a href="#h55-0-1219" id="h55-0-1219" class="i">+
</a><a href="#h55-0-1220" id="h55-0-1220" class="i">+func (m *IndexPosition) GetKey() string {
</a><a href="#h55-0-1221" id="h55-0-1221" class="i">+	if m != nil &amp;&amp; m.Key != nil {
</a><a href="#h55-0-1222" id="h55-0-1222" class="i">+		return *m.Key
</a><a href="#h55-0-1223" id="h55-0-1223" class="i">+	}
</a><a href="#h55-0-1224" id="h55-0-1224" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1225" id="h55-0-1225" class="i">+}
</a><a href="#h55-0-1226" id="h55-0-1226" class="i">+
</a><a href="#h55-0-1227" id="h55-0-1227" class="i">+func (m *IndexPosition) GetBefore() bool {
</a><a href="#h55-0-1228" id="h55-0-1228" class="i">+	if m != nil &amp;&amp; m.Before != nil {
</a><a href="#h55-0-1229" id="h55-0-1229" class="i">+		return *m.Before
</a><a href="#h55-0-1230" id="h55-0-1230" class="i">+	}
</a><a href="#h55-0-1231" id="h55-0-1231" class="i">+	return Default_IndexPosition_Before
</a><a href="#h55-0-1232" id="h55-0-1232" class="i">+}
</a><a href="#h55-0-1233" id="h55-0-1233" class="i">+
</a><a href="#h55-0-1234" id="h55-0-1234" class="i">+type Snapshot struct {
</a><a href="#h55-0-1235" id="h55-0-1235" class="i">+	Ts               *int64 `protobuf:&quot;varint,1,req,name=ts&quot; json:&quot;ts,omitempty&quot;`
</a><a href="#h55-0-1236" id="h55-0-1236" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h55-0-1237" id="h55-0-1237" class="i">+}
</a><a href="#h55-0-1238" id="h55-0-1238" class="i">+
</a><a href="#h55-0-1239" id="h55-0-1239" class="i">+func (m *Snapshot) Reset()         { *m = Snapshot{} }
</a><a href="#h55-0-1240" id="h55-0-1240" class="i">+func (m *Snapshot) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1241" id="h55-0-1241" class="i">+func (*Snapshot) ProtoMessage()    {}
</a><a href="#h55-0-1242" id="h55-0-1242" class="i">+
</a><a href="#h55-0-1243" id="h55-0-1243" class="i">+func (m *Snapshot) GetTs() int64 {
</a><a href="#h55-0-1244" id="h55-0-1244" class="i">+	if m != nil &amp;&amp; m.Ts != nil {
</a><a href="#h55-0-1245" id="h55-0-1245" class="i">+		return *m.Ts
</a><a href="#h55-0-1246" id="h55-0-1246" class="i">+	}
</a><a href="#h55-0-1247" id="h55-0-1247" class="i">+	return 0
</a><a href="#h55-0-1248" id="h55-0-1248" class="i">+}
</a><a href="#h55-0-1249" id="h55-0-1249" class="i">+
</a><a href="#h55-0-1250" id="h55-0-1250" class="i">+type InternalHeader struct {
</a><a href="#h55-0-1251" id="h55-0-1251" class="i">+	Qos              *string `protobuf:&quot;bytes,1,opt,name=qos&quot; json:&quot;qos,omitempty&quot;`
</a><a href="#h55-0-1252" id="h55-0-1252" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-1253" id="h55-0-1253" class="i">+}
</a><a href="#h55-0-1254" id="h55-0-1254" class="i">+
</a><a href="#h55-0-1255" id="h55-0-1255" class="i">+func (m *InternalHeader) Reset()         { *m = InternalHeader{} }
</a><a href="#h55-0-1256" id="h55-0-1256" class="i">+func (m *InternalHeader) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1257" id="h55-0-1257" class="i">+func (*InternalHeader) ProtoMessage()    {}
</a><a href="#h55-0-1258" id="h55-0-1258" class="i">+
</a><a href="#h55-0-1259" id="h55-0-1259" class="i">+func (m *InternalHeader) GetQos() string {
</a><a href="#h55-0-1260" id="h55-0-1260" class="i">+	if m != nil &amp;&amp; m.Qos != nil {
</a><a href="#h55-0-1261" id="h55-0-1261" class="i">+		return *m.Qos
</a><a href="#h55-0-1262" id="h55-0-1262" class="i">+	}
</a><a href="#h55-0-1263" id="h55-0-1263" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1264" id="h55-0-1264" class="i">+}
</a><a href="#h55-0-1265" id="h55-0-1265" class="i">+
</a><a href="#h55-0-1266" id="h55-0-1266" class="i">+type Transaction struct {
</a><a href="#h55-0-1267" id="h55-0-1267" class="i">+	Header           *InternalHeader `protobuf:&quot;bytes,4,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-1268" id="h55-0-1268" class="i">+	Handle           *uint64         `protobuf:&quot;fixed64,1,req,name=handle&quot; json:&quot;handle,omitempty&quot;`
</a><a href="#h55-0-1269" id="h55-0-1269" class="i">+	App              *string         `protobuf:&quot;bytes,2,req,name=app&quot; json:&quot;app,omitempty&quot;`
</a><a href="#h55-0-1270" id="h55-0-1270" class="i">+	MarkChanges      *bool           `protobuf:&quot;varint,3,opt,name=mark_changes,def=0&quot; json:&quot;mark_changes,omitempty&quot;`
</a><a href="#h55-0-1271" id="h55-0-1271" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-1272" id="h55-0-1272" class="i">+}
</a><a href="#h55-0-1273" id="h55-0-1273" class="i">+
</a><a href="#h55-0-1274" id="h55-0-1274" class="i">+func (m *Transaction) Reset()         { *m = Transaction{} }
</a><a href="#h55-0-1275" id="h55-0-1275" class="i">+func (m *Transaction) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1276" id="h55-0-1276" class="i">+func (*Transaction) ProtoMessage()    {}
</a><a href="#h55-0-1277" id="h55-0-1277" class="i">+
</a><a href="#h55-0-1278" id="h55-0-1278" class="i">+const Default_Transaction_MarkChanges bool = false
</a><a href="#h55-0-1279" id="h55-0-1279" class="i">+
</a><a href="#h55-0-1280" id="h55-0-1280" class="i">+func (m *Transaction) GetHeader() *InternalHeader {
</a><a href="#h55-0-1281" id="h55-0-1281" class="i">+	if m != nil {
</a><a href="#h55-0-1282" id="h55-0-1282" class="i">+		return m.Header
</a><a href="#h55-0-1283" id="h55-0-1283" class="i">+	}
</a><a href="#h55-0-1284" id="h55-0-1284" class="i">+	return nil
</a><a href="#h55-0-1285" id="h55-0-1285" class="i">+}
</a><a href="#h55-0-1286" id="h55-0-1286" class="i">+
</a><a href="#h55-0-1287" id="h55-0-1287" class="i">+func (m *Transaction) GetHandle() uint64 {
</a><a href="#h55-0-1288" id="h55-0-1288" class="i">+	if m != nil &amp;&amp; m.Handle != nil {
</a><a href="#h55-0-1289" id="h55-0-1289" class="i">+		return *m.Handle
</a><a href="#h55-0-1290" id="h55-0-1290" class="i">+	}
</a><a href="#h55-0-1291" id="h55-0-1291" class="i">+	return 0
</a><a href="#h55-0-1292" id="h55-0-1292" class="i">+}
</a><a href="#h55-0-1293" id="h55-0-1293" class="i">+
</a><a href="#h55-0-1294" id="h55-0-1294" class="i">+func (m *Transaction) GetApp() string {
</a><a href="#h55-0-1295" id="h55-0-1295" class="i">+	if m != nil &amp;&amp; m.App != nil {
</a><a href="#h55-0-1296" id="h55-0-1296" class="i">+		return *m.App
</a><a href="#h55-0-1297" id="h55-0-1297" class="i">+	}
</a><a href="#h55-0-1298" id="h55-0-1298" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1299" id="h55-0-1299" class="i">+}
</a><a href="#h55-0-1300" id="h55-0-1300" class="i">+
</a><a href="#h55-0-1301" id="h55-0-1301" class="i">+func (m *Transaction) GetMarkChanges() bool {
</a><a href="#h55-0-1302" id="h55-0-1302" class="i">+	if m != nil &amp;&amp; m.MarkChanges != nil {
</a><a href="#h55-0-1303" id="h55-0-1303" class="i">+		return *m.MarkChanges
</a><a href="#h55-0-1304" id="h55-0-1304" class="i">+	}
</a><a href="#h55-0-1305" id="h55-0-1305" class="i">+	return Default_Transaction_MarkChanges
</a><a href="#h55-0-1306" id="h55-0-1306" class="i">+}
</a><a href="#h55-0-1307" id="h55-0-1307" class="i">+
</a><a href="#h55-0-1308" id="h55-0-1308" class="i">+type Query struct {
</a><a href="#h55-0-1309" id="h55-0-1309" class="i">+	Header              *InternalHeader   `protobuf:&quot;bytes,39,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-1310" id="h55-0-1310" class="i">+	App                 *string           `protobuf:&quot;bytes,1,req,name=app&quot; json:&quot;app,omitempty&quot;`
</a><a href="#h55-0-1311" id="h55-0-1311" class="i">+	NameSpace           *string           `protobuf:&quot;bytes,29,opt,name=name_space&quot; json:&quot;name_space,omitempty&quot;`
</a><a href="#h55-0-1312" id="h55-0-1312" class="i">+	Kind                *string           `protobuf:&quot;bytes,3,opt,name=kind&quot; json:&quot;kind,omitempty&quot;`
</a><a href="#h55-0-1313" id="h55-0-1313" class="i">+	Ancestor            *Reference        `protobuf:&quot;bytes,17,opt,name=ancestor&quot; json:&quot;ancestor,omitempty&quot;`
</a><a href="#h55-0-1314" id="h55-0-1314" class="i">+	Filter              []*Query_Filter   `protobuf:&quot;group,4,rep,name=Filter&quot; json:&quot;filter,omitempty&quot;`
</a><a href="#h55-0-1315" id="h55-0-1315" class="i">+	SearchQuery         *string           `protobuf:&quot;bytes,8,opt,name=search_query&quot; json:&quot;search_query,omitempty&quot;`
</a><a href="#h55-0-1316" id="h55-0-1316" class="i">+	Order               []*Query_Order    `protobuf:&quot;group,9,rep,name=Order&quot; json:&quot;order,omitempty&quot;`
</a><a href="#h55-0-1317" id="h55-0-1317" class="i">+	Hint                *Query_Hint       `protobuf:&quot;varint,18,opt,name=hint,enum=appengine.Query_Hint&quot; json:&quot;hint,omitempty&quot;`
</a><a href="#h55-0-1318" id="h55-0-1318" class="i">+	Count               *int32            `protobuf:&quot;varint,23,opt,name=count&quot; json:&quot;count,omitempty&quot;`
</a><a href="#h55-0-1319" id="h55-0-1319" class="i">+	Offset              *int32            `protobuf:&quot;varint,12,opt,name=offset,def=0&quot; json:&quot;offset,omitempty&quot;`
</a><a href="#h55-0-1320" id="h55-0-1320" class="i">+	Limit               *int32            `protobuf:&quot;varint,16,opt,name=limit&quot; json:&quot;limit,omitempty&quot;`
</a><a href="#h55-0-1321" id="h55-0-1321" class="i">+	CompiledCursor      *CompiledCursor   `protobuf:&quot;bytes,30,opt,name=compiled_cursor&quot; json:&quot;compiled_cursor,omitempty&quot;`
</a><a href="#h55-0-1322" id="h55-0-1322" class="i">+	EndCompiledCursor   *CompiledCursor   `protobuf:&quot;bytes,31,opt,name=end_compiled_cursor&quot; json:&quot;end_compiled_cursor,omitempty&quot;`
</a><a href="#h55-0-1323" id="h55-0-1323" class="i">+	CompositeIndex      []*CompositeIndex `protobuf:&quot;bytes,19,rep,name=composite_index&quot; json:&quot;composite_index,omitempty&quot;`
</a><a href="#h55-0-1324" id="h55-0-1324" class="i">+	RequirePerfectPlan  *bool             `protobuf:&quot;varint,20,opt,name=require_perfect_plan,def=0&quot; json:&quot;require_perfect_plan,omitempty&quot;`
</a><a href="#h55-0-1325" id="h55-0-1325" class="i">+	KeysOnly            *bool             `protobuf:&quot;varint,21,opt,name=keys_only,def=0&quot; json:&quot;keys_only,omitempty&quot;`
</a><a href="#h55-0-1326" id="h55-0-1326" class="i">+	Transaction         *Transaction      `protobuf:&quot;bytes,22,opt,name=transaction&quot; json:&quot;transaction,omitempty&quot;`
</a><a href="#h55-0-1327" id="h55-0-1327" class="i">+	Compile             *bool             `protobuf:&quot;varint,25,opt,name=compile,def=0&quot; json:&quot;compile,omitempty&quot;`
</a><a href="#h55-0-1328" id="h55-0-1328" class="i">+	FailoverMs          *int64            `protobuf:&quot;varint,26,opt,name=failover_ms&quot; json:&quot;failover_ms,omitempty&quot;`
</a><a href="#h55-0-1329" id="h55-0-1329" class="i">+	Strong              *bool             `protobuf:&quot;varint,32,opt,name=strong&quot; json:&quot;strong,omitempty&quot;`
</a><a href="#h55-0-1330" id="h55-0-1330" class="i">+	PropertyName        []string          `protobuf:&quot;bytes,33,rep,name=property_name&quot; json:&quot;property_name,omitempty&quot;`
</a><a href="#h55-0-1331" id="h55-0-1331" class="i">+	GroupByPropertyName []string          `protobuf:&quot;bytes,34,rep,name=group_by_property_name&quot; json:&quot;group_by_property_name,omitempty&quot;`
</a><a href="#h55-0-1332" id="h55-0-1332" class="i">+	Distinct            *bool             `protobuf:&quot;varint,24,opt,name=distinct&quot; json:&quot;distinct,omitempty&quot;`
</a><a href="#h55-0-1333" id="h55-0-1333" class="i">+	MinSafeTimeSeconds  *int64            `protobuf:&quot;varint,35,opt,name=min_safe_time_seconds&quot; json:&quot;min_safe_time_seconds,omitempty&quot;`
</a><a href="#h55-0-1334" id="h55-0-1334" class="i">+	SafeReplicaName     []string          `protobuf:&quot;bytes,36,rep,name=safe_replica_name&quot; json:&quot;safe_replica_name,omitempty&quot;`
</a><a href="#h55-0-1335" id="h55-0-1335" class="i">+	PersistOffset       *bool             `protobuf:&quot;varint,37,opt,name=persist_offset,def=0&quot; json:&quot;persist_offset,omitempty&quot;`
</a><a href="#h55-0-1336" id="h55-0-1336" class="i">+	XXX_unrecognized    []byte            `json:&quot;-&quot;`
</a><a href="#h55-0-1337" id="h55-0-1337" class="i">+}
</a><a href="#h55-0-1338" id="h55-0-1338" class="i">+
</a><a href="#h55-0-1339" id="h55-0-1339" class="i">+func (m *Query) Reset()         { *m = Query{} }
</a><a href="#h55-0-1340" id="h55-0-1340" class="i">+func (m *Query) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1341" id="h55-0-1341" class="i">+func (*Query) ProtoMessage()    {}
</a><a href="#h55-0-1342" id="h55-0-1342" class="i">+
</a><a href="#h55-0-1343" id="h55-0-1343" class="i">+const Default_Query_Offset int32 = 0
</a><a href="#h55-0-1344" id="h55-0-1344" class="i">+const Default_Query_RequirePerfectPlan bool = false
</a><a href="#h55-0-1345" id="h55-0-1345" class="i">+const Default_Query_KeysOnly bool = false
</a><a href="#h55-0-1346" id="h55-0-1346" class="i">+const Default_Query_Compile bool = false
</a><a href="#h55-0-1347" id="h55-0-1347" class="i">+const Default_Query_PersistOffset bool = false
</a><a href="#h55-0-1348" id="h55-0-1348" class="i">+
</a><a href="#h55-0-1349" id="h55-0-1349" class="i">+func (m *Query) GetHeader() *InternalHeader {
</a><a href="#h55-0-1350" id="h55-0-1350" class="i">+	if m != nil {
</a><a href="#h55-0-1351" id="h55-0-1351" class="i">+		return m.Header
</a><a href="#h55-0-1352" id="h55-0-1352" class="i">+	}
</a><a href="#h55-0-1353" id="h55-0-1353" class="i">+	return nil
</a><a href="#h55-0-1354" id="h55-0-1354" class="i">+}
</a><a href="#h55-0-1355" id="h55-0-1355" class="i">+
</a><a href="#h55-0-1356" id="h55-0-1356" class="i">+func (m *Query) GetApp() string {
</a><a href="#h55-0-1357" id="h55-0-1357" class="i">+	if m != nil &amp;&amp; m.App != nil {
</a><a href="#h55-0-1358" id="h55-0-1358" class="i">+		return *m.App
</a><a href="#h55-0-1359" id="h55-0-1359" class="i">+	}
</a><a href="#h55-0-1360" id="h55-0-1360" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1361" id="h55-0-1361" class="i">+}
</a><a href="#h55-0-1362" id="h55-0-1362" class="i">+
</a><a href="#h55-0-1363" id="h55-0-1363" class="i">+func (m *Query) GetNameSpace() string {
</a><a href="#h55-0-1364" id="h55-0-1364" class="i">+	if m != nil &amp;&amp; m.NameSpace != nil {
</a><a href="#h55-0-1365" id="h55-0-1365" class="i">+		return *m.NameSpace
</a><a href="#h55-0-1366" id="h55-0-1366" class="i">+	}
</a><a href="#h55-0-1367" id="h55-0-1367" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1368" id="h55-0-1368" class="i">+}
</a><a href="#h55-0-1369" id="h55-0-1369" class="i">+
</a><a href="#h55-0-1370" id="h55-0-1370" class="i">+func (m *Query) GetKind() string {
</a><a href="#h55-0-1371" id="h55-0-1371" class="i">+	if m != nil &amp;&amp; m.Kind != nil {
</a><a href="#h55-0-1372" id="h55-0-1372" class="i">+		return *m.Kind
</a><a href="#h55-0-1373" id="h55-0-1373" class="i">+	}
</a><a href="#h55-0-1374" id="h55-0-1374" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1375" id="h55-0-1375" class="i">+}
</a><a href="#h55-0-1376" id="h55-0-1376" class="i">+
</a><a href="#h55-0-1377" id="h55-0-1377" class="i">+func (m *Query) GetAncestor() *Reference {
</a><a href="#h55-0-1378" id="h55-0-1378" class="i">+	if m != nil {
</a><a href="#h55-0-1379" id="h55-0-1379" class="i">+		return m.Ancestor
</a><a href="#h55-0-1380" id="h55-0-1380" class="i">+	}
</a><a href="#h55-0-1381" id="h55-0-1381" class="i">+	return nil
</a><a href="#h55-0-1382" id="h55-0-1382" class="i">+}
</a><a href="#h55-0-1383" id="h55-0-1383" class="i">+
</a><a href="#h55-0-1384" id="h55-0-1384" class="i">+func (m *Query) GetFilter() []*Query_Filter {
</a><a href="#h55-0-1385" id="h55-0-1385" class="i">+	if m != nil {
</a><a href="#h55-0-1386" id="h55-0-1386" class="i">+		return m.Filter
</a><a href="#h55-0-1387" id="h55-0-1387" class="i">+	}
</a><a href="#h55-0-1388" id="h55-0-1388" class="i">+	return nil
</a><a href="#h55-0-1389" id="h55-0-1389" class="i">+}
</a><a href="#h55-0-1390" id="h55-0-1390" class="i">+
</a><a href="#h55-0-1391" id="h55-0-1391" class="i">+func (m *Query) GetSearchQuery() string {
</a><a href="#h55-0-1392" id="h55-0-1392" class="i">+	if m != nil &amp;&amp; m.SearchQuery != nil {
</a><a href="#h55-0-1393" id="h55-0-1393" class="i">+		return *m.SearchQuery
</a><a href="#h55-0-1394" id="h55-0-1394" class="i">+	}
</a><a href="#h55-0-1395" id="h55-0-1395" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1396" id="h55-0-1396" class="i">+}
</a><a href="#h55-0-1397" id="h55-0-1397" class="i">+
</a><a href="#h55-0-1398" id="h55-0-1398" class="i">+func (m *Query) GetOrder() []*Query_Order {
</a><a href="#h55-0-1399" id="h55-0-1399" class="i">+	if m != nil {
</a><a href="#h55-0-1400" id="h55-0-1400" class="i">+		return m.Order
</a><a href="#h55-0-1401" id="h55-0-1401" class="i">+	}
</a><a href="#h55-0-1402" id="h55-0-1402" class="i">+	return nil
</a><a href="#h55-0-1403" id="h55-0-1403" class="i">+}
</a><a href="#h55-0-1404" id="h55-0-1404" class="i">+
</a><a href="#h55-0-1405" id="h55-0-1405" class="i">+func (m *Query) GetHint() Query_Hint {
</a><a href="#h55-0-1406" id="h55-0-1406" class="i">+	if m != nil &amp;&amp; m.Hint != nil {
</a><a href="#h55-0-1407" id="h55-0-1407" class="i">+		return *m.Hint
</a><a href="#h55-0-1408" id="h55-0-1408" class="i">+	}
</a><a href="#h55-0-1409" id="h55-0-1409" class="i">+	return Query_ORDER_FIRST
</a><a href="#h55-0-1410" id="h55-0-1410" class="i">+}
</a><a href="#h55-0-1411" id="h55-0-1411" class="i">+
</a><a href="#h55-0-1412" id="h55-0-1412" class="i">+func (m *Query) GetCount() int32 {
</a><a href="#h55-0-1413" id="h55-0-1413" class="i">+	if m != nil &amp;&amp; m.Count != nil {
</a><a href="#h55-0-1414" id="h55-0-1414" class="i">+		return *m.Count
</a><a href="#h55-0-1415" id="h55-0-1415" class="i">+	}
</a><a href="#h55-0-1416" id="h55-0-1416" class="i">+	return 0
</a><a href="#h55-0-1417" id="h55-0-1417" class="i">+}
</a><a href="#h55-0-1418" id="h55-0-1418" class="i">+
</a><a href="#h55-0-1419" id="h55-0-1419" class="i">+func (m *Query) GetOffset() int32 {
</a><a href="#h55-0-1420" id="h55-0-1420" class="i">+	if m != nil &amp;&amp; m.Offset != nil {
</a><a href="#h55-0-1421" id="h55-0-1421" class="i">+		return *m.Offset
</a><a href="#h55-0-1422" id="h55-0-1422" class="i">+	}
</a><a href="#h55-0-1423" id="h55-0-1423" class="i">+	return Default_Query_Offset
</a><a href="#h55-0-1424" id="h55-0-1424" class="i">+}
</a><a href="#h55-0-1425" id="h55-0-1425" class="i">+
</a><a href="#h55-0-1426" id="h55-0-1426" class="i">+func (m *Query) GetLimit() int32 {
</a><a href="#h55-0-1427" id="h55-0-1427" class="i">+	if m != nil &amp;&amp; m.Limit != nil {
</a><a href="#h55-0-1428" id="h55-0-1428" class="i">+		return *m.Limit
</a><a href="#h55-0-1429" id="h55-0-1429" class="i">+	}
</a><a href="#h55-0-1430" id="h55-0-1430" class="i">+	return 0
</a><a href="#h55-0-1431" id="h55-0-1431" class="i">+}
</a><a href="#h55-0-1432" id="h55-0-1432" class="i">+
</a><a href="#h55-0-1433" id="h55-0-1433" class="i">+func (m *Query) GetCompiledCursor() *CompiledCursor {
</a><a href="#h55-0-1434" id="h55-0-1434" class="i">+	if m != nil {
</a><a href="#h55-0-1435" id="h55-0-1435" class="i">+		return m.CompiledCursor
</a><a href="#h55-0-1436" id="h55-0-1436" class="i">+	}
</a><a href="#h55-0-1437" id="h55-0-1437" class="i">+	return nil
</a><a href="#h55-0-1438" id="h55-0-1438" class="i">+}
</a><a href="#h55-0-1439" id="h55-0-1439" class="i">+
</a><a href="#h55-0-1440" id="h55-0-1440" class="i">+func (m *Query) GetEndCompiledCursor() *CompiledCursor {
</a><a href="#h55-0-1441" id="h55-0-1441" class="i">+	if m != nil {
</a><a href="#h55-0-1442" id="h55-0-1442" class="i">+		return m.EndCompiledCursor
</a><a href="#h55-0-1443" id="h55-0-1443" class="i">+	}
</a><a href="#h55-0-1444" id="h55-0-1444" class="i">+	return nil
</a><a href="#h55-0-1445" id="h55-0-1445" class="i">+}
</a><a href="#h55-0-1446" id="h55-0-1446" class="i">+
</a><a href="#h55-0-1447" id="h55-0-1447" class="i">+func (m *Query) GetCompositeIndex() []*CompositeIndex {
</a><a href="#h55-0-1448" id="h55-0-1448" class="i">+	if m != nil {
</a><a href="#h55-0-1449" id="h55-0-1449" class="i">+		return m.CompositeIndex
</a><a href="#h55-0-1450" id="h55-0-1450" class="i">+	}
</a><a href="#h55-0-1451" id="h55-0-1451" class="i">+	return nil
</a><a href="#h55-0-1452" id="h55-0-1452" class="i">+}
</a><a href="#h55-0-1453" id="h55-0-1453" class="i">+
</a><a href="#h55-0-1454" id="h55-0-1454" class="i">+func (m *Query) GetRequirePerfectPlan() bool {
</a><a href="#h55-0-1455" id="h55-0-1455" class="i">+	if m != nil &amp;&amp; m.RequirePerfectPlan != nil {
</a><a href="#h55-0-1456" id="h55-0-1456" class="i">+		return *m.RequirePerfectPlan
</a><a href="#h55-0-1457" id="h55-0-1457" class="i">+	}
</a><a href="#h55-0-1458" id="h55-0-1458" class="i">+	return Default_Query_RequirePerfectPlan
</a><a href="#h55-0-1459" id="h55-0-1459" class="i">+}
</a><a href="#h55-0-1460" id="h55-0-1460" class="i">+
</a><a href="#h55-0-1461" id="h55-0-1461" class="i">+func (m *Query) GetKeysOnly() bool {
</a><a href="#h55-0-1462" id="h55-0-1462" class="i">+	if m != nil &amp;&amp; m.KeysOnly != nil {
</a><a href="#h55-0-1463" id="h55-0-1463" class="i">+		return *m.KeysOnly
</a><a href="#h55-0-1464" id="h55-0-1464" class="i">+	}
</a><a href="#h55-0-1465" id="h55-0-1465" class="i">+	return Default_Query_KeysOnly
</a><a href="#h55-0-1466" id="h55-0-1466" class="i">+}
</a><a href="#h55-0-1467" id="h55-0-1467" class="i">+
</a><a href="#h55-0-1468" id="h55-0-1468" class="i">+func (m *Query) GetTransaction() *Transaction {
</a><a href="#h55-0-1469" id="h55-0-1469" class="i">+	if m != nil {
</a><a href="#h55-0-1470" id="h55-0-1470" class="i">+		return m.Transaction
</a><a href="#h55-0-1471" id="h55-0-1471" class="i">+	}
</a><a href="#h55-0-1472" id="h55-0-1472" class="i">+	return nil
</a><a href="#h55-0-1473" id="h55-0-1473" class="i">+}
</a><a href="#h55-0-1474" id="h55-0-1474" class="i">+
</a><a href="#h55-0-1475" id="h55-0-1475" class="i">+func (m *Query) GetCompile() bool {
</a><a href="#h55-0-1476" id="h55-0-1476" class="i">+	if m != nil &amp;&amp; m.Compile != nil {
</a><a href="#h55-0-1477" id="h55-0-1477" class="i">+		return *m.Compile
</a><a href="#h55-0-1478" id="h55-0-1478" class="i">+	}
</a><a href="#h55-0-1479" id="h55-0-1479" class="i">+	return Default_Query_Compile
</a><a href="#h55-0-1480" id="h55-0-1480" class="i">+}
</a><a href="#h55-0-1481" id="h55-0-1481" class="i">+
</a><a href="#h55-0-1482" id="h55-0-1482" class="i">+func (m *Query) GetFailoverMs() int64 {
</a><a href="#h55-0-1483" id="h55-0-1483" class="i">+	if m != nil &amp;&amp; m.FailoverMs != nil {
</a><a href="#h55-0-1484" id="h55-0-1484" class="i">+		return *m.FailoverMs
</a><a href="#h55-0-1485" id="h55-0-1485" class="i">+	}
</a><a href="#h55-0-1486" id="h55-0-1486" class="i">+	return 0
</a><a href="#h55-0-1487" id="h55-0-1487" class="i">+}
</a><a href="#h55-0-1488" id="h55-0-1488" class="i">+
</a><a href="#h55-0-1489" id="h55-0-1489" class="i">+func (m *Query) GetStrong() bool {
</a><a href="#h55-0-1490" id="h55-0-1490" class="i">+	if m != nil &amp;&amp; m.Strong != nil {
</a><a href="#h55-0-1491" id="h55-0-1491" class="i">+		return *m.Strong
</a><a href="#h55-0-1492" id="h55-0-1492" class="i">+	}
</a><a href="#h55-0-1493" id="h55-0-1493" class="i">+	return false
</a><a href="#h55-0-1494" id="h55-0-1494" class="i">+}
</a><a href="#h55-0-1495" id="h55-0-1495" class="i">+
</a><a href="#h55-0-1496" id="h55-0-1496" class="i">+func (m *Query) GetPropertyName() []string {
</a><a href="#h55-0-1497" id="h55-0-1497" class="i">+	if m != nil {
</a><a href="#h55-0-1498" id="h55-0-1498" class="i">+		return m.PropertyName
</a><a href="#h55-0-1499" id="h55-0-1499" class="i">+	}
</a><a href="#h55-0-1500" id="h55-0-1500" class="i">+	return nil
</a><a href="#h55-0-1501" id="h55-0-1501" class="i">+}
</a><a href="#h55-0-1502" id="h55-0-1502" class="i">+
</a><a href="#h55-0-1503" id="h55-0-1503" class="i">+func (m *Query) GetGroupByPropertyName() []string {
</a><a href="#h55-0-1504" id="h55-0-1504" class="i">+	if m != nil {
</a><a href="#h55-0-1505" id="h55-0-1505" class="i">+		return m.GroupByPropertyName
</a><a href="#h55-0-1506" id="h55-0-1506" class="i">+	}
</a><a href="#h55-0-1507" id="h55-0-1507" class="i">+	return nil
</a><a href="#h55-0-1508" id="h55-0-1508" class="i">+}
</a><a href="#h55-0-1509" id="h55-0-1509" class="i">+
</a><a href="#h55-0-1510" id="h55-0-1510" class="i">+func (m *Query) GetDistinct() bool {
</a><a href="#h55-0-1511" id="h55-0-1511" class="i">+	if m != nil &amp;&amp; m.Distinct != nil {
</a><a href="#h55-0-1512" id="h55-0-1512" class="i">+		return *m.Distinct
</a><a href="#h55-0-1513" id="h55-0-1513" class="i">+	}
</a><a href="#h55-0-1514" id="h55-0-1514" class="i">+	return false
</a><a href="#h55-0-1515" id="h55-0-1515" class="i">+}
</a><a href="#h55-0-1516" id="h55-0-1516" class="i">+
</a><a href="#h55-0-1517" id="h55-0-1517" class="i">+func (m *Query) GetMinSafeTimeSeconds() int64 {
</a><a href="#h55-0-1518" id="h55-0-1518" class="i">+	if m != nil &amp;&amp; m.MinSafeTimeSeconds != nil {
</a><a href="#h55-0-1519" id="h55-0-1519" class="i">+		return *m.MinSafeTimeSeconds
</a><a href="#h55-0-1520" id="h55-0-1520" class="i">+	}
</a><a href="#h55-0-1521" id="h55-0-1521" class="i">+	return 0
</a><a href="#h55-0-1522" id="h55-0-1522" class="i">+}
</a><a href="#h55-0-1523" id="h55-0-1523" class="i">+
</a><a href="#h55-0-1524" id="h55-0-1524" class="i">+func (m *Query) GetSafeReplicaName() []string {
</a><a href="#h55-0-1525" id="h55-0-1525" class="i">+	if m != nil {
</a><a href="#h55-0-1526" id="h55-0-1526" class="i">+		return m.SafeReplicaName
</a><a href="#h55-0-1527" id="h55-0-1527" class="i">+	}
</a><a href="#h55-0-1528" id="h55-0-1528" class="i">+	return nil
</a><a href="#h55-0-1529" id="h55-0-1529" class="i">+}
</a><a href="#h55-0-1530" id="h55-0-1530" class="i">+
</a><a href="#h55-0-1531" id="h55-0-1531" class="i">+func (m *Query) GetPersistOffset() bool {
</a><a href="#h55-0-1532" id="h55-0-1532" class="i">+	if m != nil &amp;&amp; m.PersistOffset != nil {
</a><a href="#h55-0-1533" id="h55-0-1533" class="i">+		return *m.PersistOffset
</a><a href="#h55-0-1534" id="h55-0-1534" class="i">+	}
</a><a href="#h55-0-1535" id="h55-0-1535" class="i">+	return Default_Query_PersistOffset
</a><a href="#h55-0-1536" id="h55-0-1536" class="i">+}
</a><a href="#h55-0-1537" id="h55-0-1537" class="i">+
</a><a href="#h55-0-1538" id="h55-0-1538" class="i">+type Query_Filter struct {
</a><a href="#h55-0-1539" id="h55-0-1539" class="i">+	Op               *Query_Filter_Operator `protobuf:&quot;varint,6,req,name=op,enum=appengine.Query_Filter_Operator&quot; json:&quot;op,omitempty&quot;`
</a><a href="#h55-0-1540" id="h55-0-1540" class="i">+	Property         []*Property            `protobuf:&quot;bytes,14,rep,name=property&quot; json:&quot;property,omitempty&quot;`
</a><a href="#h55-0-1541" id="h55-0-1541" class="i">+	XXX_unrecognized []byte                 `json:&quot;-&quot;`
</a><a href="#h55-0-1542" id="h55-0-1542" class="i">+}
</a><a href="#h55-0-1543" id="h55-0-1543" class="i">+
</a><a href="#h55-0-1544" id="h55-0-1544" class="i">+func (m *Query_Filter) Reset()         { *m = Query_Filter{} }
</a><a href="#h55-0-1545" id="h55-0-1545" class="i">+func (m *Query_Filter) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1546" id="h55-0-1546" class="i">+func (*Query_Filter) ProtoMessage()    {}
</a><a href="#h55-0-1547" id="h55-0-1547" class="i">+
</a><a href="#h55-0-1548" id="h55-0-1548" class="i">+func (m *Query_Filter) GetOp() Query_Filter_Operator {
</a><a href="#h55-0-1549" id="h55-0-1549" class="i">+	if m != nil &amp;&amp; m.Op != nil {
</a><a href="#h55-0-1550" id="h55-0-1550" class="i">+		return *m.Op
</a><a href="#h55-0-1551" id="h55-0-1551" class="i">+	}
</a><a href="#h55-0-1552" id="h55-0-1552" class="i">+	return Query_Filter_LESS_THAN
</a><a href="#h55-0-1553" id="h55-0-1553" class="i">+}
</a><a href="#h55-0-1554" id="h55-0-1554" class="i">+
</a><a href="#h55-0-1555" id="h55-0-1555" class="i">+func (m *Query_Filter) GetProperty() []*Property {
</a><a href="#h55-0-1556" id="h55-0-1556" class="i">+	if m != nil {
</a><a href="#h55-0-1557" id="h55-0-1557" class="i">+		return m.Property
</a><a href="#h55-0-1558" id="h55-0-1558" class="i">+	}
</a><a href="#h55-0-1559" id="h55-0-1559" class="i">+	return nil
</a><a href="#h55-0-1560" id="h55-0-1560" class="i">+}
</a><a href="#h55-0-1561" id="h55-0-1561" class="i">+
</a><a href="#h55-0-1562" id="h55-0-1562" class="i">+type Query_Order struct {
</a><a href="#h55-0-1563" id="h55-0-1563" class="i">+	Property         *string                `protobuf:&quot;bytes,10,req,name=property&quot; json:&quot;property,omitempty&quot;`
</a><a href="#h55-0-1564" id="h55-0-1564" class="i">+	Direction        *Query_Order_Direction `protobuf:&quot;varint,11,opt,name=direction,enum=appengine.Query_Order_Direction,def=1&quot; json:&quot;direction,omitempty&quot;`
</a><a href="#h55-0-1565" id="h55-0-1565" class="i">+	XXX_unrecognized []byte                 `json:&quot;-&quot;`
</a><a href="#h55-0-1566" id="h55-0-1566" class="i">+}
</a><a href="#h55-0-1567" id="h55-0-1567" class="i">+
</a><a href="#h55-0-1568" id="h55-0-1568" class="i">+func (m *Query_Order) Reset()         { *m = Query_Order{} }
</a><a href="#h55-0-1569" id="h55-0-1569" class="i">+func (m *Query_Order) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1570" id="h55-0-1570" class="i">+func (*Query_Order) ProtoMessage()    {}
</a><a href="#h55-0-1571" id="h55-0-1571" class="i">+
</a><a href="#h55-0-1572" id="h55-0-1572" class="i">+const Default_Query_Order_Direction Query_Order_Direction = Query_Order_ASCENDING
</a><a href="#h55-0-1573" id="h55-0-1573" class="i">+
</a><a href="#h55-0-1574" id="h55-0-1574" class="i">+func (m *Query_Order) GetProperty() string {
</a><a href="#h55-0-1575" id="h55-0-1575" class="i">+	if m != nil &amp;&amp; m.Property != nil {
</a><a href="#h55-0-1576" id="h55-0-1576" class="i">+		return *m.Property
</a><a href="#h55-0-1577" id="h55-0-1577" class="i">+	}
</a><a href="#h55-0-1578" id="h55-0-1578" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1579" id="h55-0-1579" class="i">+}
</a><a href="#h55-0-1580" id="h55-0-1580" class="i">+
</a><a href="#h55-0-1581" id="h55-0-1581" class="i">+func (m *Query_Order) GetDirection() Query_Order_Direction {
</a><a href="#h55-0-1582" id="h55-0-1582" class="i">+	if m != nil &amp;&amp; m.Direction != nil {
</a><a href="#h55-0-1583" id="h55-0-1583" class="i">+		return *m.Direction
</a><a href="#h55-0-1584" id="h55-0-1584" class="i">+	}
</a><a href="#h55-0-1585" id="h55-0-1585" class="i">+	return Default_Query_Order_Direction
</a><a href="#h55-0-1586" id="h55-0-1586" class="i">+}
</a><a href="#h55-0-1587" id="h55-0-1587" class="i">+
</a><a href="#h55-0-1588" id="h55-0-1588" class="i">+type CompiledQuery struct {
</a><a href="#h55-0-1589" id="h55-0-1589" class="i">+	Primaryscan       *CompiledQuery_PrimaryScan     `protobuf:&quot;group,1,req,name=PrimaryScan&quot; json:&quot;primaryscan,omitempty&quot;`
</a><a href="#h55-0-1590" id="h55-0-1590" class="i">+	Mergejoinscan     []*CompiledQuery_MergeJoinScan `protobuf:&quot;group,7,rep,name=MergeJoinScan&quot; json:&quot;mergejoinscan,omitempty&quot;`
</a><a href="#h55-0-1591" id="h55-0-1591" class="i">+	IndexDef          *Index                         `protobuf:&quot;bytes,21,opt,name=index_def&quot; json:&quot;index_def,omitempty&quot;`
</a><a href="#h55-0-1592" id="h55-0-1592" class="i">+	Offset            *int32                         `protobuf:&quot;varint,10,opt,name=offset,def=0&quot; json:&quot;offset,omitempty&quot;`
</a><a href="#h55-0-1593" id="h55-0-1593" class="i">+	Limit             *int32                         `protobuf:&quot;varint,11,opt,name=limit&quot; json:&quot;limit,omitempty&quot;`
</a><a href="#h55-0-1594" id="h55-0-1594" class="i">+	KeysOnly          *bool                          `protobuf:&quot;varint,12,req,name=keys_only&quot; json:&quot;keys_only,omitempty&quot;`
</a><a href="#h55-0-1595" id="h55-0-1595" class="i">+	PropertyName      []string                       `protobuf:&quot;bytes,24,rep,name=property_name&quot; json:&quot;property_name,omitempty&quot;`
</a><a href="#h55-0-1596" id="h55-0-1596" class="i">+	DistinctInfixSize *int32                         `protobuf:&quot;varint,25,opt,name=distinct_infix_size&quot; json:&quot;distinct_infix_size,omitempty&quot;`
</a><a href="#h55-0-1597" id="h55-0-1597" class="i">+	Entityfilter      *CompiledQuery_EntityFilter    `protobuf:&quot;group,13,opt,name=EntityFilter&quot; json:&quot;entityfilter,omitempty&quot;`
</a><a href="#h55-0-1598" id="h55-0-1598" class="i">+	XXX_unrecognized  []byte                         `json:&quot;-&quot;`
</a><a href="#h55-0-1599" id="h55-0-1599" class="i">+}
</a><a href="#h55-0-1600" id="h55-0-1600" class="i">+
</a><a href="#h55-0-1601" id="h55-0-1601" class="i">+func (m *CompiledQuery) Reset()         { *m = CompiledQuery{} }
</a><a href="#h55-0-1602" id="h55-0-1602" class="i">+func (m *CompiledQuery) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1603" id="h55-0-1603" class="i">+func (*CompiledQuery) ProtoMessage()    {}
</a><a href="#h55-0-1604" id="h55-0-1604" class="i">+
</a><a href="#h55-0-1605" id="h55-0-1605" class="i">+const Default_CompiledQuery_Offset int32 = 0
</a><a href="#h55-0-1606" id="h55-0-1606" class="i">+
</a><a href="#h55-0-1607" id="h55-0-1607" class="i">+func (m *CompiledQuery) GetPrimaryscan() *CompiledQuery_PrimaryScan {
</a><a href="#h55-0-1608" id="h55-0-1608" class="i">+	if m != nil {
</a><a href="#h55-0-1609" id="h55-0-1609" class="i">+		return m.Primaryscan
</a><a href="#h55-0-1610" id="h55-0-1610" class="i">+	}
</a><a href="#h55-0-1611" id="h55-0-1611" class="i">+	return nil
</a><a href="#h55-0-1612" id="h55-0-1612" class="i">+}
</a><a href="#h55-0-1613" id="h55-0-1613" class="i">+
</a><a href="#h55-0-1614" id="h55-0-1614" class="i">+func (m *CompiledQuery) GetMergejoinscan() []*CompiledQuery_MergeJoinScan {
</a><a href="#h55-0-1615" id="h55-0-1615" class="i">+	if m != nil {
</a><a href="#h55-0-1616" id="h55-0-1616" class="i">+		return m.Mergejoinscan
</a><a href="#h55-0-1617" id="h55-0-1617" class="i">+	}
</a><a href="#h55-0-1618" id="h55-0-1618" class="i">+	return nil
</a><a href="#h55-0-1619" id="h55-0-1619" class="i">+}
</a><a href="#h55-0-1620" id="h55-0-1620" class="i">+
</a><a href="#h55-0-1621" id="h55-0-1621" class="i">+func (m *CompiledQuery) GetIndexDef() *Index {
</a><a href="#h55-0-1622" id="h55-0-1622" class="i">+	if m != nil {
</a><a href="#h55-0-1623" id="h55-0-1623" class="i">+		return m.IndexDef
</a><a href="#h55-0-1624" id="h55-0-1624" class="i">+	}
</a><a href="#h55-0-1625" id="h55-0-1625" class="i">+	return nil
</a><a href="#h55-0-1626" id="h55-0-1626" class="i">+}
</a><a href="#h55-0-1627" id="h55-0-1627" class="i">+
</a><a href="#h55-0-1628" id="h55-0-1628" class="i">+func (m *CompiledQuery) GetOffset() int32 {
</a><a href="#h55-0-1629" id="h55-0-1629" class="i">+	if m != nil &amp;&amp; m.Offset != nil {
</a><a href="#h55-0-1630" id="h55-0-1630" class="i">+		return *m.Offset
</a><a href="#h55-0-1631" id="h55-0-1631" class="i">+	}
</a><a href="#h55-0-1632" id="h55-0-1632" class="i">+	return Default_CompiledQuery_Offset
</a><a href="#h55-0-1633" id="h55-0-1633" class="i">+}
</a><a href="#h55-0-1634" id="h55-0-1634" class="i">+
</a><a href="#h55-0-1635" id="h55-0-1635" class="i">+func (m *CompiledQuery) GetLimit() int32 {
</a><a href="#h55-0-1636" id="h55-0-1636" class="i">+	if m != nil &amp;&amp; m.Limit != nil {
</a><a href="#h55-0-1637" id="h55-0-1637" class="i">+		return *m.Limit
</a><a href="#h55-0-1638" id="h55-0-1638" class="i">+	}
</a><a href="#h55-0-1639" id="h55-0-1639" class="i">+	return 0
</a><a href="#h55-0-1640" id="h55-0-1640" class="i">+}
</a><a href="#h55-0-1641" id="h55-0-1641" class="i">+
</a><a href="#h55-0-1642" id="h55-0-1642" class="i">+func (m *CompiledQuery) GetKeysOnly() bool {
</a><a href="#h55-0-1643" id="h55-0-1643" class="i">+	if m != nil &amp;&amp; m.KeysOnly != nil {
</a><a href="#h55-0-1644" id="h55-0-1644" class="i">+		return *m.KeysOnly
</a><a href="#h55-0-1645" id="h55-0-1645" class="i">+	}
</a><a href="#h55-0-1646" id="h55-0-1646" class="i">+	return false
</a><a href="#h55-0-1647" id="h55-0-1647" class="i">+}
</a><a href="#h55-0-1648" id="h55-0-1648" class="i">+
</a><a href="#h55-0-1649" id="h55-0-1649" class="i">+func (m *CompiledQuery) GetPropertyName() []string {
</a><a href="#h55-0-1650" id="h55-0-1650" class="i">+	if m != nil {
</a><a href="#h55-0-1651" id="h55-0-1651" class="i">+		return m.PropertyName
</a><a href="#h55-0-1652" id="h55-0-1652" class="i">+	}
</a><a href="#h55-0-1653" id="h55-0-1653" class="i">+	return nil
</a><a href="#h55-0-1654" id="h55-0-1654" class="i">+}
</a><a href="#h55-0-1655" id="h55-0-1655" class="i">+
</a><a href="#h55-0-1656" id="h55-0-1656" class="i">+func (m *CompiledQuery) GetDistinctInfixSize() int32 {
</a><a href="#h55-0-1657" id="h55-0-1657" class="i">+	if m != nil &amp;&amp; m.DistinctInfixSize != nil {
</a><a href="#h55-0-1658" id="h55-0-1658" class="i">+		return *m.DistinctInfixSize
</a><a href="#h55-0-1659" id="h55-0-1659" class="i">+	}
</a><a href="#h55-0-1660" id="h55-0-1660" class="i">+	return 0
</a><a href="#h55-0-1661" id="h55-0-1661" class="i">+}
</a><a href="#h55-0-1662" id="h55-0-1662" class="i">+
</a><a href="#h55-0-1663" id="h55-0-1663" class="i">+func (m *CompiledQuery) GetEntityfilter() *CompiledQuery_EntityFilter {
</a><a href="#h55-0-1664" id="h55-0-1664" class="i">+	if m != nil {
</a><a href="#h55-0-1665" id="h55-0-1665" class="i">+		return m.Entityfilter
</a><a href="#h55-0-1666" id="h55-0-1666" class="i">+	}
</a><a href="#h55-0-1667" id="h55-0-1667" class="i">+	return nil
</a><a href="#h55-0-1668" id="h55-0-1668" class="i">+}
</a><a href="#h55-0-1669" id="h55-0-1669" class="i">+
</a><a href="#h55-0-1670" id="h55-0-1670" class="i">+type CompiledQuery_PrimaryScan struct {
</a><a href="#h55-0-1671" id="h55-0-1671" class="i">+	IndexName                  *string  `protobuf:&quot;bytes,2,opt,name=index_name&quot; json:&quot;index_name,omitempty&quot;`
</a><a href="#h55-0-1672" id="h55-0-1672" class="i">+	StartKey                   *string  `protobuf:&quot;bytes,3,opt,name=start_key&quot; json:&quot;start_key,omitempty&quot;`
</a><a href="#h55-0-1673" id="h55-0-1673" class="i">+	StartInclusive             *bool    `protobuf:&quot;varint,4,opt,name=start_inclusive&quot; json:&quot;start_inclusive,omitempty&quot;`
</a><a href="#h55-0-1674" id="h55-0-1674" class="i">+	EndKey                     *string  `protobuf:&quot;bytes,5,opt,name=end_key&quot; json:&quot;end_key,omitempty&quot;`
</a><a href="#h55-0-1675" id="h55-0-1675" class="i">+	EndInclusive               *bool    `protobuf:&quot;varint,6,opt,name=end_inclusive&quot; json:&quot;end_inclusive,omitempty&quot;`
</a><a href="#h55-0-1676" id="h55-0-1676" class="i">+	StartPostfixValue          []string `protobuf:&quot;bytes,22,rep,name=start_postfix_value&quot; json:&quot;start_postfix_value,omitempty&quot;`
</a><a href="#h55-0-1677" id="h55-0-1677" class="i">+	EndPostfixValue            []string `protobuf:&quot;bytes,23,rep,name=end_postfix_value&quot; json:&quot;end_postfix_value,omitempty&quot;`
</a><a href="#h55-0-1678" id="h55-0-1678" class="i">+	EndUnappliedLogTimestampUs *int64   `protobuf:&quot;varint,19,opt,name=end_unapplied_log_timestamp_us&quot; json:&quot;end_unapplied_log_timestamp_us,omitempty&quot;`
</a><a href="#h55-0-1679" id="h55-0-1679" class="i">+	XXX_unrecognized           []byte   `json:&quot;-&quot;`
</a><a href="#h55-0-1680" id="h55-0-1680" class="i">+}
</a><a href="#h55-0-1681" id="h55-0-1681" class="i">+
</a><a href="#h55-0-1682" id="h55-0-1682" class="i">+func (m *CompiledQuery_PrimaryScan) Reset()         { *m = CompiledQuery_PrimaryScan{} }
</a><a href="#h55-0-1683" id="h55-0-1683" class="i">+func (m *CompiledQuery_PrimaryScan) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1684" id="h55-0-1684" class="i">+func (*CompiledQuery_PrimaryScan) ProtoMessage()    {}
</a><a href="#h55-0-1685" id="h55-0-1685" class="i">+
</a><a href="#h55-0-1686" id="h55-0-1686" class="i">+func (m *CompiledQuery_PrimaryScan) GetIndexName() string {
</a><a href="#h55-0-1687" id="h55-0-1687" class="i">+	if m != nil &amp;&amp; m.IndexName != nil {
</a><a href="#h55-0-1688" id="h55-0-1688" class="i">+		return *m.IndexName
</a><a href="#h55-0-1689" id="h55-0-1689" class="i">+	}
</a><a href="#h55-0-1690" id="h55-0-1690" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1691" id="h55-0-1691" class="i">+}
</a><a href="#h55-0-1692" id="h55-0-1692" class="i">+
</a><a href="#h55-0-1693" id="h55-0-1693" class="i">+func (m *CompiledQuery_PrimaryScan) GetStartKey() string {
</a><a href="#h55-0-1694" id="h55-0-1694" class="i">+	if m != nil &amp;&amp; m.StartKey != nil {
</a><a href="#h55-0-1695" id="h55-0-1695" class="i">+		return *m.StartKey
</a><a href="#h55-0-1696" id="h55-0-1696" class="i">+	}
</a><a href="#h55-0-1697" id="h55-0-1697" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1698" id="h55-0-1698" class="i">+}
</a><a href="#h55-0-1699" id="h55-0-1699" class="i">+
</a><a href="#h55-0-1700" id="h55-0-1700" class="i">+func (m *CompiledQuery_PrimaryScan) GetStartInclusive() bool {
</a><a href="#h55-0-1701" id="h55-0-1701" class="i">+	if m != nil &amp;&amp; m.StartInclusive != nil {
</a><a href="#h55-0-1702" id="h55-0-1702" class="i">+		return *m.StartInclusive
</a><a href="#h55-0-1703" id="h55-0-1703" class="i">+	}
</a><a href="#h55-0-1704" id="h55-0-1704" class="i">+	return false
</a><a href="#h55-0-1705" id="h55-0-1705" class="i">+}
</a><a href="#h55-0-1706" id="h55-0-1706" class="i">+
</a><a href="#h55-0-1707" id="h55-0-1707" class="i">+func (m *CompiledQuery_PrimaryScan) GetEndKey() string {
</a><a href="#h55-0-1708" id="h55-0-1708" class="i">+	if m != nil &amp;&amp; m.EndKey != nil {
</a><a href="#h55-0-1709" id="h55-0-1709" class="i">+		return *m.EndKey
</a><a href="#h55-0-1710" id="h55-0-1710" class="i">+	}
</a><a href="#h55-0-1711" id="h55-0-1711" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1712" id="h55-0-1712" class="i">+}
</a><a href="#h55-0-1713" id="h55-0-1713" class="i">+
</a><a href="#h55-0-1714" id="h55-0-1714" class="i">+func (m *CompiledQuery_PrimaryScan) GetEndInclusive() bool {
</a><a href="#h55-0-1715" id="h55-0-1715" class="i">+	if m != nil &amp;&amp; m.EndInclusive != nil {
</a><a href="#h55-0-1716" id="h55-0-1716" class="i">+		return *m.EndInclusive
</a><a href="#h55-0-1717" id="h55-0-1717" class="i">+	}
</a><a href="#h55-0-1718" id="h55-0-1718" class="i">+	return false
</a><a href="#h55-0-1719" id="h55-0-1719" class="i">+}
</a><a href="#h55-0-1720" id="h55-0-1720" class="i">+
</a><a href="#h55-0-1721" id="h55-0-1721" class="i">+func (m *CompiledQuery_PrimaryScan) GetStartPostfixValue() []string {
</a><a href="#h55-0-1722" id="h55-0-1722" class="i">+	if m != nil {
</a><a href="#h55-0-1723" id="h55-0-1723" class="i">+		return m.StartPostfixValue
</a><a href="#h55-0-1724" id="h55-0-1724" class="i">+	}
</a><a href="#h55-0-1725" id="h55-0-1725" class="i">+	return nil
</a><a href="#h55-0-1726" id="h55-0-1726" class="i">+}
</a><a href="#h55-0-1727" id="h55-0-1727" class="i">+
</a><a href="#h55-0-1728" id="h55-0-1728" class="i">+func (m *CompiledQuery_PrimaryScan) GetEndPostfixValue() []string {
</a><a href="#h55-0-1729" id="h55-0-1729" class="i">+	if m != nil {
</a><a href="#h55-0-1730" id="h55-0-1730" class="i">+		return m.EndPostfixValue
</a><a href="#h55-0-1731" id="h55-0-1731" class="i">+	}
</a><a href="#h55-0-1732" id="h55-0-1732" class="i">+	return nil
</a><a href="#h55-0-1733" id="h55-0-1733" class="i">+}
</a><a href="#h55-0-1734" id="h55-0-1734" class="i">+
</a><a href="#h55-0-1735" id="h55-0-1735" class="i">+func (m *CompiledQuery_PrimaryScan) GetEndUnappliedLogTimestampUs() int64 {
</a><a href="#h55-0-1736" id="h55-0-1736" class="i">+	if m != nil &amp;&amp; m.EndUnappliedLogTimestampUs != nil {
</a><a href="#h55-0-1737" id="h55-0-1737" class="i">+		return *m.EndUnappliedLogTimestampUs
</a><a href="#h55-0-1738" id="h55-0-1738" class="i">+	}
</a><a href="#h55-0-1739" id="h55-0-1739" class="i">+	return 0
</a><a href="#h55-0-1740" id="h55-0-1740" class="i">+}
</a><a href="#h55-0-1741" id="h55-0-1741" class="i">+
</a><a href="#h55-0-1742" id="h55-0-1742" class="i">+type CompiledQuery_MergeJoinScan struct {
</a><a href="#h55-0-1743" id="h55-0-1743" class="i">+	IndexName        *string  `protobuf:&quot;bytes,8,req,name=index_name&quot; json:&quot;index_name,omitempty&quot;`
</a><a href="#h55-0-1744" id="h55-0-1744" class="i">+	PrefixValue      []string `protobuf:&quot;bytes,9,rep,name=prefix_value&quot; json:&quot;prefix_value,omitempty&quot;`
</a><a href="#h55-0-1745" id="h55-0-1745" class="i">+	ValuePrefix      *bool    `protobuf:&quot;varint,20,opt,name=value_prefix,def=0&quot; json:&quot;value_prefix,omitempty&quot;`
</a><a href="#h55-0-1746" id="h55-0-1746" class="i">+	XXX_unrecognized []byte   `json:&quot;-&quot;`
</a><a href="#h55-0-1747" id="h55-0-1747" class="i">+}
</a><a href="#h55-0-1748" id="h55-0-1748" class="i">+
</a><a href="#h55-0-1749" id="h55-0-1749" class="i">+func (m *CompiledQuery_MergeJoinScan) Reset()         { *m = CompiledQuery_MergeJoinScan{} }
</a><a href="#h55-0-1750" id="h55-0-1750" class="i">+func (m *CompiledQuery_MergeJoinScan) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1751" id="h55-0-1751" class="i">+func (*CompiledQuery_MergeJoinScan) ProtoMessage()    {}
</a><a href="#h55-0-1752" id="h55-0-1752" class="i">+
</a><a href="#h55-0-1753" id="h55-0-1753" class="i">+const Default_CompiledQuery_MergeJoinScan_ValuePrefix bool = false
</a><a href="#h55-0-1754" id="h55-0-1754" class="i">+
</a><a href="#h55-0-1755" id="h55-0-1755" class="i">+func (m *CompiledQuery_MergeJoinScan) GetIndexName() string {
</a><a href="#h55-0-1756" id="h55-0-1756" class="i">+	if m != nil &amp;&amp; m.IndexName != nil {
</a><a href="#h55-0-1757" id="h55-0-1757" class="i">+		return *m.IndexName
</a><a href="#h55-0-1758" id="h55-0-1758" class="i">+	}
</a><a href="#h55-0-1759" id="h55-0-1759" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1760" id="h55-0-1760" class="i">+}
</a><a href="#h55-0-1761" id="h55-0-1761" class="i">+
</a><a href="#h55-0-1762" id="h55-0-1762" class="i">+func (m *CompiledQuery_MergeJoinScan) GetPrefixValue() []string {
</a><a href="#h55-0-1763" id="h55-0-1763" class="i">+	if m != nil {
</a><a href="#h55-0-1764" id="h55-0-1764" class="i">+		return m.PrefixValue
</a><a href="#h55-0-1765" id="h55-0-1765" class="i">+	}
</a><a href="#h55-0-1766" id="h55-0-1766" class="i">+	return nil
</a><a href="#h55-0-1767" id="h55-0-1767" class="i">+}
</a><a href="#h55-0-1768" id="h55-0-1768" class="i">+
</a><a href="#h55-0-1769" id="h55-0-1769" class="i">+func (m *CompiledQuery_MergeJoinScan) GetValuePrefix() bool {
</a><a href="#h55-0-1770" id="h55-0-1770" class="i">+	if m != nil &amp;&amp; m.ValuePrefix != nil {
</a><a href="#h55-0-1771" id="h55-0-1771" class="i">+		return *m.ValuePrefix
</a><a href="#h55-0-1772" id="h55-0-1772" class="i">+	}
</a><a href="#h55-0-1773" id="h55-0-1773" class="i">+	return Default_CompiledQuery_MergeJoinScan_ValuePrefix
</a><a href="#h55-0-1774" id="h55-0-1774" class="i">+}
</a><a href="#h55-0-1775" id="h55-0-1775" class="i">+
</a><a href="#h55-0-1776" id="h55-0-1776" class="i">+type CompiledQuery_EntityFilter struct {
</a><a href="#h55-0-1777" id="h55-0-1777" class="i">+	Distinct         *bool      `protobuf:&quot;varint,14,opt,name=distinct,def=0&quot; json:&quot;distinct,omitempty&quot;`
</a><a href="#h55-0-1778" id="h55-0-1778" class="i">+	Kind             *string    `protobuf:&quot;bytes,17,opt,name=kind&quot; json:&quot;kind,omitempty&quot;`
</a><a href="#h55-0-1779" id="h55-0-1779" class="i">+	Ancestor         *Reference `protobuf:&quot;bytes,18,opt,name=ancestor&quot; json:&quot;ancestor,omitempty&quot;`
</a><a href="#h55-0-1780" id="h55-0-1780" class="i">+	XXX_unrecognized []byte     `json:&quot;-&quot;`
</a><a href="#h55-0-1781" id="h55-0-1781" class="i">+}
</a><a href="#h55-0-1782" id="h55-0-1782" class="i">+
</a><a href="#h55-0-1783" id="h55-0-1783" class="i">+func (m *CompiledQuery_EntityFilter) Reset()         { *m = CompiledQuery_EntityFilter{} }
</a><a href="#h55-0-1784" id="h55-0-1784" class="i">+func (m *CompiledQuery_EntityFilter) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1785" id="h55-0-1785" class="i">+func (*CompiledQuery_EntityFilter) ProtoMessage()    {}
</a><a href="#h55-0-1786" id="h55-0-1786" class="i">+
</a><a href="#h55-0-1787" id="h55-0-1787" class="i">+const Default_CompiledQuery_EntityFilter_Distinct bool = false
</a><a href="#h55-0-1788" id="h55-0-1788" class="i">+
</a><a href="#h55-0-1789" id="h55-0-1789" class="i">+func (m *CompiledQuery_EntityFilter) GetDistinct() bool {
</a><a href="#h55-0-1790" id="h55-0-1790" class="i">+	if m != nil &amp;&amp; m.Distinct != nil {
</a><a href="#h55-0-1791" id="h55-0-1791" class="i">+		return *m.Distinct
</a><a href="#h55-0-1792" id="h55-0-1792" class="i">+	}
</a><a href="#h55-0-1793" id="h55-0-1793" class="i">+	return Default_CompiledQuery_EntityFilter_Distinct
</a><a href="#h55-0-1794" id="h55-0-1794" class="i">+}
</a><a href="#h55-0-1795" id="h55-0-1795" class="i">+
</a><a href="#h55-0-1796" id="h55-0-1796" class="i">+func (m *CompiledQuery_EntityFilter) GetKind() string {
</a><a href="#h55-0-1797" id="h55-0-1797" class="i">+	if m != nil &amp;&amp; m.Kind != nil {
</a><a href="#h55-0-1798" id="h55-0-1798" class="i">+		return *m.Kind
</a><a href="#h55-0-1799" id="h55-0-1799" class="i">+	}
</a><a href="#h55-0-1800" id="h55-0-1800" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1801" id="h55-0-1801" class="i">+}
</a><a href="#h55-0-1802" id="h55-0-1802" class="i">+
</a><a href="#h55-0-1803" id="h55-0-1803" class="i">+func (m *CompiledQuery_EntityFilter) GetAncestor() *Reference {
</a><a href="#h55-0-1804" id="h55-0-1804" class="i">+	if m != nil {
</a><a href="#h55-0-1805" id="h55-0-1805" class="i">+		return m.Ancestor
</a><a href="#h55-0-1806" id="h55-0-1806" class="i">+	}
</a><a href="#h55-0-1807" id="h55-0-1807" class="i">+	return nil
</a><a href="#h55-0-1808" id="h55-0-1808" class="i">+}
</a><a href="#h55-0-1809" id="h55-0-1809" class="i">+
</a><a href="#h55-0-1810" id="h55-0-1810" class="i">+type CompiledCursor struct {
</a><a href="#h55-0-1811" id="h55-0-1811" class="i">+	Position         *CompiledCursor_Position `protobuf:&quot;group,2,opt,name=Position&quot; json:&quot;position,omitempty&quot;`
</a><a href="#h55-0-1812" id="h55-0-1812" class="i">+	XXX_unrecognized []byte                   `json:&quot;-&quot;`
</a><a href="#h55-0-1813" id="h55-0-1813" class="i">+}
</a><a href="#h55-0-1814" id="h55-0-1814" class="i">+
</a><a href="#h55-0-1815" id="h55-0-1815" class="i">+func (m *CompiledCursor) Reset()         { *m = CompiledCursor{} }
</a><a href="#h55-0-1816" id="h55-0-1816" class="i">+func (m *CompiledCursor) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1817" id="h55-0-1817" class="i">+func (*CompiledCursor) ProtoMessage()    {}
</a><a href="#h55-0-1818" id="h55-0-1818" class="i">+
</a><a href="#h55-0-1819" id="h55-0-1819" class="i">+func (m *CompiledCursor) GetPosition() *CompiledCursor_Position {
</a><a href="#h55-0-1820" id="h55-0-1820" class="i">+	if m != nil {
</a><a href="#h55-0-1821" id="h55-0-1821" class="i">+		return m.Position
</a><a href="#h55-0-1822" id="h55-0-1822" class="i">+	}
</a><a href="#h55-0-1823" id="h55-0-1823" class="i">+	return nil
</a><a href="#h55-0-1824" id="h55-0-1824" class="i">+}
</a><a href="#h55-0-1825" id="h55-0-1825" class="i">+
</a><a href="#h55-0-1826" id="h55-0-1826" class="i">+type CompiledCursor_Position struct {
</a><a href="#h55-0-1827" id="h55-0-1827" class="i">+	StartKey         *string                               `protobuf:&quot;bytes,27,opt,name=start_key&quot; json:&quot;start_key,omitempty&quot;`
</a><a href="#h55-0-1828" id="h55-0-1828" class="i">+	Indexvalue       []*CompiledCursor_Position_IndexValue `protobuf:&quot;group,29,rep,name=IndexValue&quot; json:&quot;indexvalue,omitempty&quot;`
</a><a href="#h55-0-1829" id="h55-0-1829" class="i">+	Key              *Reference                            `protobuf:&quot;bytes,32,opt,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-1830" id="h55-0-1830" class="i">+	StartInclusive   *bool                                 `protobuf:&quot;varint,28,opt,name=start_inclusive,def=1&quot; json:&quot;start_inclusive,omitempty&quot;`
</a><a href="#h55-0-1831" id="h55-0-1831" class="i">+	XXX_unrecognized []byte                                `json:&quot;-&quot;`
</a><a href="#h55-0-1832" id="h55-0-1832" class="i">+}
</a><a href="#h55-0-1833" id="h55-0-1833" class="i">+
</a><a href="#h55-0-1834" id="h55-0-1834" class="i">+func (m *CompiledCursor_Position) Reset()         { *m = CompiledCursor_Position{} }
</a><a href="#h55-0-1835" id="h55-0-1835" class="i">+func (m *CompiledCursor_Position) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1836" id="h55-0-1836" class="i">+func (*CompiledCursor_Position) ProtoMessage()    {}
</a><a href="#h55-0-1837" id="h55-0-1837" class="i">+
</a><a href="#h55-0-1838" id="h55-0-1838" class="i">+const Default_CompiledCursor_Position_StartInclusive bool = true
</a><a href="#h55-0-1839" id="h55-0-1839" class="i">+
</a><a href="#h55-0-1840" id="h55-0-1840" class="i">+func (m *CompiledCursor_Position) GetStartKey() string {
</a><a href="#h55-0-1841" id="h55-0-1841" class="i">+	if m != nil &amp;&amp; m.StartKey != nil {
</a><a href="#h55-0-1842" id="h55-0-1842" class="i">+		return *m.StartKey
</a><a href="#h55-0-1843" id="h55-0-1843" class="i">+	}
</a><a href="#h55-0-1844" id="h55-0-1844" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1845" id="h55-0-1845" class="i">+}
</a><a href="#h55-0-1846" id="h55-0-1846" class="i">+
</a><a href="#h55-0-1847" id="h55-0-1847" class="i">+func (m *CompiledCursor_Position) GetIndexvalue() []*CompiledCursor_Position_IndexValue {
</a><a href="#h55-0-1848" id="h55-0-1848" class="i">+	if m != nil {
</a><a href="#h55-0-1849" id="h55-0-1849" class="i">+		return m.Indexvalue
</a><a href="#h55-0-1850" id="h55-0-1850" class="i">+	}
</a><a href="#h55-0-1851" id="h55-0-1851" class="i">+	return nil
</a><a href="#h55-0-1852" id="h55-0-1852" class="i">+}
</a><a href="#h55-0-1853" id="h55-0-1853" class="i">+
</a><a href="#h55-0-1854" id="h55-0-1854" class="i">+func (m *CompiledCursor_Position) GetKey() *Reference {
</a><a href="#h55-0-1855" id="h55-0-1855" class="i">+	if m != nil {
</a><a href="#h55-0-1856" id="h55-0-1856" class="i">+		return m.Key
</a><a href="#h55-0-1857" id="h55-0-1857" class="i">+	}
</a><a href="#h55-0-1858" id="h55-0-1858" class="i">+	return nil
</a><a href="#h55-0-1859" id="h55-0-1859" class="i">+}
</a><a href="#h55-0-1860" id="h55-0-1860" class="i">+
</a><a href="#h55-0-1861" id="h55-0-1861" class="i">+func (m *CompiledCursor_Position) GetStartInclusive() bool {
</a><a href="#h55-0-1862" id="h55-0-1862" class="i">+	if m != nil &amp;&amp; m.StartInclusive != nil {
</a><a href="#h55-0-1863" id="h55-0-1863" class="i">+		return *m.StartInclusive
</a><a href="#h55-0-1864" id="h55-0-1864" class="i">+	}
</a><a href="#h55-0-1865" id="h55-0-1865" class="i">+	return Default_CompiledCursor_Position_StartInclusive
</a><a href="#h55-0-1866" id="h55-0-1866" class="i">+}
</a><a href="#h55-0-1867" id="h55-0-1867" class="i">+
</a><a href="#h55-0-1868" id="h55-0-1868" class="i">+type CompiledCursor_Position_IndexValue struct {
</a><a href="#h55-0-1869" id="h55-0-1869" class="i">+	Property         *string        `protobuf:&quot;bytes,30,opt,name=property&quot; json:&quot;property,omitempty&quot;`
</a><a href="#h55-0-1870" id="h55-0-1870" class="i">+	Value            *PropertyValue `protobuf:&quot;bytes,31,req,name=value&quot; json:&quot;value,omitempty&quot;`
</a><a href="#h55-0-1871" id="h55-0-1871" class="i">+	XXX_unrecognized []byte         `json:&quot;-&quot;`
</a><a href="#h55-0-1872" id="h55-0-1872" class="i">+}
</a><a href="#h55-0-1873" id="h55-0-1873" class="i">+
</a><a href="#h55-0-1874" id="h55-0-1874" class="i">+func (m *CompiledCursor_Position_IndexValue) Reset()         { *m = CompiledCursor_Position_IndexValue{} }
</a><a href="#h55-0-1875" id="h55-0-1875" class="i">+func (m *CompiledCursor_Position_IndexValue) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1876" id="h55-0-1876" class="i">+func (*CompiledCursor_Position_IndexValue) ProtoMessage()    {}
</a><a href="#h55-0-1877" id="h55-0-1877" class="i">+
</a><a href="#h55-0-1878" id="h55-0-1878" class="i">+func (m *CompiledCursor_Position_IndexValue) GetProperty() string {
</a><a href="#h55-0-1879" id="h55-0-1879" class="i">+	if m != nil &amp;&amp; m.Property != nil {
</a><a href="#h55-0-1880" id="h55-0-1880" class="i">+		return *m.Property
</a><a href="#h55-0-1881" id="h55-0-1881" class="i">+	}
</a><a href="#h55-0-1882" id="h55-0-1882" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1883" id="h55-0-1883" class="i">+}
</a><a href="#h55-0-1884" id="h55-0-1884" class="i">+
</a><a href="#h55-0-1885" id="h55-0-1885" class="i">+func (m *CompiledCursor_Position_IndexValue) GetValue() *PropertyValue {
</a><a href="#h55-0-1886" id="h55-0-1886" class="i">+	if m != nil {
</a><a href="#h55-0-1887" id="h55-0-1887" class="i">+		return m.Value
</a><a href="#h55-0-1888" id="h55-0-1888" class="i">+	}
</a><a href="#h55-0-1889" id="h55-0-1889" class="i">+	return nil
</a><a href="#h55-0-1890" id="h55-0-1890" class="i">+}
</a><a href="#h55-0-1891" id="h55-0-1891" class="i">+
</a><a href="#h55-0-1892" id="h55-0-1892" class="i">+type Cursor struct {
</a><a href="#h55-0-1893" id="h55-0-1893" class="i">+	Cursor           *uint64 `protobuf:&quot;fixed64,1,req,name=cursor&quot; json:&quot;cursor,omitempty&quot;`
</a><a href="#h55-0-1894" id="h55-0-1894" class="i">+	App              *string `protobuf:&quot;bytes,2,opt,name=app&quot; json:&quot;app,omitempty&quot;`
</a><a href="#h55-0-1895" id="h55-0-1895" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-1896" id="h55-0-1896" class="i">+}
</a><a href="#h55-0-1897" id="h55-0-1897" class="i">+
</a><a href="#h55-0-1898" id="h55-0-1898" class="i">+func (m *Cursor) Reset()         { *m = Cursor{} }
</a><a href="#h55-0-1899" id="h55-0-1899" class="i">+func (m *Cursor) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1900" id="h55-0-1900" class="i">+func (*Cursor) ProtoMessage()    {}
</a><a href="#h55-0-1901" id="h55-0-1901" class="i">+
</a><a href="#h55-0-1902" id="h55-0-1902" class="i">+func (m *Cursor) GetCursor() uint64 {
</a><a href="#h55-0-1903" id="h55-0-1903" class="i">+	if m != nil &amp;&amp; m.Cursor != nil {
</a><a href="#h55-0-1904" id="h55-0-1904" class="i">+		return *m.Cursor
</a><a href="#h55-0-1905" id="h55-0-1905" class="i">+	}
</a><a href="#h55-0-1906" id="h55-0-1906" class="i">+	return 0
</a><a href="#h55-0-1907" id="h55-0-1907" class="i">+}
</a><a href="#h55-0-1908" id="h55-0-1908" class="i">+
</a><a href="#h55-0-1909" id="h55-0-1909" class="i">+func (m *Cursor) GetApp() string {
</a><a href="#h55-0-1910" id="h55-0-1910" class="i">+	if m != nil &amp;&amp; m.App != nil {
</a><a href="#h55-0-1911" id="h55-0-1911" class="i">+		return *m.App
</a><a href="#h55-0-1912" id="h55-0-1912" class="i">+	}
</a><a href="#h55-0-1913" id="h55-0-1913" class="i">+	return &quot;&quot;
</a><a href="#h55-0-1914" id="h55-0-1914" class="i">+}
</a><a href="#h55-0-1915" id="h55-0-1915" class="i">+
</a><a href="#h55-0-1916" id="h55-0-1916" class="i">+type Error struct {
</a><a href="#h55-0-1917" id="h55-0-1917" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h55-0-1918" id="h55-0-1918" class="i">+}
</a><a href="#h55-0-1919" id="h55-0-1919" class="i">+
</a><a href="#h55-0-1920" id="h55-0-1920" class="i">+func (m *Error) Reset()         { *m = Error{} }
</a><a href="#h55-0-1921" id="h55-0-1921" class="i">+func (m *Error) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1922" id="h55-0-1922" class="i">+func (*Error) ProtoMessage()    {}
</a><a href="#h55-0-1923" id="h55-0-1923" class="i">+
</a><a href="#h55-0-1924" id="h55-0-1924" class="i">+type Cost struct {
</a><a href="#h55-0-1925" id="h55-0-1925" class="i">+	IndexWrites             *int32           `protobuf:&quot;varint,1,opt,name=index_writes&quot; json:&quot;index_writes,omitempty&quot;`
</a><a href="#h55-0-1926" id="h55-0-1926" class="i">+	IndexWriteBytes         *int32           `protobuf:&quot;varint,2,opt,name=index_write_bytes&quot; json:&quot;index_write_bytes,omitempty&quot;`
</a><a href="#h55-0-1927" id="h55-0-1927" class="i">+	EntityWrites            *int32           `protobuf:&quot;varint,3,opt,name=entity_writes&quot; json:&quot;entity_writes,omitempty&quot;`
</a><a href="#h55-0-1928" id="h55-0-1928" class="i">+	EntityWriteBytes        *int32           `protobuf:&quot;varint,4,opt,name=entity_write_bytes&quot; json:&quot;entity_write_bytes,omitempty&quot;`
</a><a href="#h55-0-1929" id="h55-0-1929" class="i">+	Commitcost              *Cost_CommitCost `protobuf:&quot;group,5,opt,name=CommitCost&quot; json:&quot;commitcost,omitempty&quot;`
</a><a href="#h55-0-1930" id="h55-0-1930" class="i">+	ApproximateStorageDelta *int32           `protobuf:&quot;varint,8,opt,name=approximate_storage_delta&quot; json:&quot;approximate_storage_delta,omitempty&quot;`
</a><a href="#h55-0-1931" id="h55-0-1931" class="i">+	IdSequenceUpdates       *int32           `protobuf:&quot;varint,9,opt,name=id_sequence_updates&quot; json:&quot;id_sequence_updates,omitempty&quot;`
</a><a href="#h55-0-1932" id="h55-0-1932" class="i">+	XXX_unrecognized        []byte           `json:&quot;-&quot;`
</a><a href="#h55-0-1933" id="h55-0-1933" class="i">+}
</a><a href="#h55-0-1934" id="h55-0-1934" class="i">+
</a><a href="#h55-0-1935" id="h55-0-1935" class="i">+func (m *Cost) Reset()         { *m = Cost{} }
</a><a href="#h55-0-1936" id="h55-0-1936" class="i">+func (m *Cost) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1937" id="h55-0-1937" class="i">+func (*Cost) ProtoMessage()    {}
</a><a href="#h55-0-1938" id="h55-0-1938" class="i">+
</a><a href="#h55-0-1939" id="h55-0-1939" class="i">+func (m *Cost) GetIndexWrites() int32 {
</a><a href="#h55-0-1940" id="h55-0-1940" class="i">+	if m != nil &amp;&amp; m.IndexWrites != nil {
</a><a href="#h55-0-1941" id="h55-0-1941" class="i">+		return *m.IndexWrites
</a><a href="#h55-0-1942" id="h55-0-1942" class="i">+	}
</a><a href="#h55-0-1943" id="h55-0-1943" class="i">+	return 0
</a><a href="#h55-0-1944" id="h55-0-1944" class="i">+}
</a><a href="#h55-0-1945" id="h55-0-1945" class="i">+
</a><a href="#h55-0-1946" id="h55-0-1946" class="i">+func (m *Cost) GetIndexWriteBytes() int32 {
</a><a href="#h55-0-1947" id="h55-0-1947" class="i">+	if m != nil &amp;&amp; m.IndexWriteBytes != nil {
</a><a href="#h55-0-1948" id="h55-0-1948" class="i">+		return *m.IndexWriteBytes
</a><a href="#h55-0-1949" id="h55-0-1949" class="i">+	}
</a><a href="#h55-0-1950" id="h55-0-1950" class="i">+	return 0
</a><a href="#h55-0-1951" id="h55-0-1951" class="i">+}
</a><a href="#h55-0-1952" id="h55-0-1952" class="i">+
</a><a href="#h55-0-1953" id="h55-0-1953" class="i">+func (m *Cost) GetEntityWrites() int32 {
</a><a href="#h55-0-1954" id="h55-0-1954" class="i">+	if m != nil &amp;&amp; m.EntityWrites != nil {
</a><a href="#h55-0-1955" id="h55-0-1955" class="i">+		return *m.EntityWrites
</a><a href="#h55-0-1956" id="h55-0-1956" class="i">+	}
</a><a href="#h55-0-1957" id="h55-0-1957" class="i">+	return 0
</a><a href="#h55-0-1958" id="h55-0-1958" class="i">+}
</a><a href="#h55-0-1959" id="h55-0-1959" class="i">+
</a><a href="#h55-0-1960" id="h55-0-1960" class="i">+func (m *Cost) GetEntityWriteBytes() int32 {
</a><a href="#h55-0-1961" id="h55-0-1961" class="i">+	if m != nil &amp;&amp; m.EntityWriteBytes != nil {
</a><a href="#h55-0-1962" id="h55-0-1962" class="i">+		return *m.EntityWriteBytes
</a><a href="#h55-0-1963" id="h55-0-1963" class="i">+	}
</a><a href="#h55-0-1964" id="h55-0-1964" class="i">+	return 0
</a><a href="#h55-0-1965" id="h55-0-1965" class="i">+}
</a><a href="#h55-0-1966" id="h55-0-1966" class="i">+
</a><a href="#h55-0-1967" id="h55-0-1967" class="i">+func (m *Cost) GetCommitcost() *Cost_CommitCost {
</a><a href="#h55-0-1968" id="h55-0-1968" class="i">+	if m != nil {
</a><a href="#h55-0-1969" id="h55-0-1969" class="i">+		return m.Commitcost
</a><a href="#h55-0-1970" id="h55-0-1970" class="i">+	}
</a><a href="#h55-0-1971" id="h55-0-1971" class="i">+	return nil
</a><a href="#h55-0-1972" id="h55-0-1972" class="i">+}
</a><a href="#h55-0-1973" id="h55-0-1973" class="i">+
</a><a href="#h55-0-1974" id="h55-0-1974" class="i">+func (m *Cost) GetApproximateStorageDelta() int32 {
</a><a href="#h55-0-1975" id="h55-0-1975" class="i">+	if m != nil &amp;&amp; m.ApproximateStorageDelta != nil {
</a><a href="#h55-0-1976" id="h55-0-1976" class="i">+		return *m.ApproximateStorageDelta
</a><a href="#h55-0-1977" id="h55-0-1977" class="i">+	}
</a><a href="#h55-0-1978" id="h55-0-1978" class="i">+	return 0
</a><a href="#h55-0-1979" id="h55-0-1979" class="i">+}
</a><a href="#h55-0-1980" id="h55-0-1980" class="i">+
</a><a href="#h55-0-1981" id="h55-0-1981" class="i">+func (m *Cost) GetIdSequenceUpdates() int32 {
</a><a href="#h55-0-1982" id="h55-0-1982" class="i">+	if m != nil &amp;&amp; m.IdSequenceUpdates != nil {
</a><a href="#h55-0-1983" id="h55-0-1983" class="i">+		return *m.IdSequenceUpdates
</a><a href="#h55-0-1984" id="h55-0-1984" class="i">+	}
</a><a href="#h55-0-1985" id="h55-0-1985" class="i">+	return 0
</a><a href="#h55-0-1986" id="h55-0-1986" class="i">+}
</a><a href="#h55-0-1987" id="h55-0-1987" class="i">+
</a><a href="#h55-0-1988" id="h55-0-1988" class="i">+type Cost_CommitCost struct {
</a><a href="#h55-0-1989" id="h55-0-1989" class="i">+	RequestedEntityPuts    *int32 `protobuf:&quot;varint,6,opt,name=requested_entity_puts&quot; json:&quot;requested_entity_puts,omitempty&quot;`
</a><a href="#h55-0-1990" id="h55-0-1990" class="i">+	RequestedEntityDeletes *int32 `protobuf:&quot;varint,7,opt,name=requested_entity_deletes&quot; json:&quot;requested_entity_deletes,omitempty&quot;`
</a><a href="#h55-0-1991" id="h55-0-1991" class="i">+	XXX_unrecognized       []byte `json:&quot;-&quot;`
</a><a href="#h55-0-1992" id="h55-0-1992" class="i">+}
</a><a href="#h55-0-1993" id="h55-0-1993" class="i">+
</a><a href="#h55-0-1994" id="h55-0-1994" class="i">+func (m *Cost_CommitCost) Reset()         { *m = Cost_CommitCost{} }
</a><a href="#h55-0-1995" id="h55-0-1995" class="i">+func (m *Cost_CommitCost) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-1996" id="h55-0-1996" class="i">+func (*Cost_CommitCost) ProtoMessage()    {}
</a><a href="#h55-0-1997" id="h55-0-1997" class="i">+
</a><a href="#h55-0-1998" id="h55-0-1998" class="i">+func (m *Cost_CommitCost) GetRequestedEntityPuts() int32 {
</a><a href="#h55-0-1999" id="h55-0-1999" class="i">+	if m != nil &amp;&amp; m.RequestedEntityPuts != nil {
</a><a href="#h55-0-2000" id="h55-0-2000" class="i">+		return *m.RequestedEntityPuts
</a><a href="#h55-0-2001" id="h55-0-2001" class="i">+	}
</a><a href="#h55-0-2002" id="h55-0-2002" class="i">+	return 0
</a><a href="#h55-0-2003" id="h55-0-2003" class="i">+}
</a><a href="#h55-0-2004" id="h55-0-2004" class="i">+
</a><a href="#h55-0-2005" id="h55-0-2005" class="i">+func (m *Cost_CommitCost) GetRequestedEntityDeletes() int32 {
</a><a href="#h55-0-2006" id="h55-0-2006" class="i">+	if m != nil &amp;&amp; m.RequestedEntityDeletes != nil {
</a><a href="#h55-0-2007" id="h55-0-2007" class="i">+		return *m.RequestedEntityDeletes
</a><a href="#h55-0-2008" id="h55-0-2008" class="i">+	}
</a><a href="#h55-0-2009" id="h55-0-2009" class="i">+	return 0
</a><a href="#h55-0-2010" id="h55-0-2010" class="i">+}
</a><a href="#h55-0-2011" id="h55-0-2011" class="i">+
</a><a href="#h55-0-2012" id="h55-0-2012" class="i">+type GetRequest struct {
</a><a href="#h55-0-2013" id="h55-0-2013" class="i">+	Header           *InternalHeader `protobuf:&quot;bytes,6,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2014" id="h55-0-2014" class="i">+	Key              []*Reference    `protobuf:&quot;bytes,1,rep,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-2015" id="h55-0-2015" class="i">+	Transaction      *Transaction    `protobuf:&quot;bytes,2,opt,name=transaction&quot; json:&quot;transaction,omitempty&quot;`
</a><a href="#h55-0-2016" id="h55-0-2016" class="i">+	FailoverMs       *int64          `protobuf:&quot;varint,3,opt,name=failover_ms&quot; json:&quot;failover_ms,omitempty&quot;`
</a><a href="#h55-0-2017" id="h55-0-2017" class="i">+	Strong           *bool           `protobuf:&quot;varint,4,opt,name=strong&quot; json:&quot;strong,omitempty&quot;`
</a><a href="#h55-0-2018" id="h55-0-2018" class="i">+	AllowDeferred    *bool           `protobuf:&quot;varint,5,opt,name=allow_deferred,def=0&quot; json:&quot;allow_deferred,omitempty&quot;`
</a><a href="#h55-0-2019" id="h55-0-2019" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-2020" id="h55-0-2020" class="i">+}
</a><a href="#h55-0-2021" id="h55-0-2021" class="i">+
</a><a href="#h55-0-2022" id="h55-0-2022" class="i">+func (m *GetRequest) Reset()         { *m = GetRequest{} }
</a><a href="#h55-0-2023" id="h55-0-2023" class="i">+func (m *GetRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2024" id="h55-0-2024" class="i">+func (*GetRequest) ProtoMessage()    {}
</a><a href="#h55-0-2025" id="h55-0-2025" class="i">+
</a><a href="#h55-0-2026" id="h55-0-2026" class="i">+const Default_GetRequest_AllowDeferred bool = false
</a><a href="#h55-0-2027" id="h55-0-2027" class="i">+
</a><a href="#h55-0-2028" id="h55-0-2028" class="i">+func (m *GetRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2029" id="h55-0-2029" class="i">+	if m != nil {
</a><a href="#h55-0-2030" id="h55-0-2030" class="i">+		return m.Header
</a><a href="#h55-0-2031" id="h55-0-2031" class="i">+	}
</a><a href="#h55-0-2032" id="h55-0-2032" class="i">+	return nil
</a><a href="#h55-0-2033" id="h55-0-2033" class="i">+}
</a><a href="#h55-0-2034" id="h55-0-2034" class="i">+
</a><a href="#h55-0-2035" id="h55-0-2035" class="i">+func (m *GetRequest) GetKey() []*Reference {
</a><a href="#h55-0-2036" id="h55-0-2036" class="i">+	if m != nil {
</a><a href="#h55-0-2037" id="h55-0-2037" class="i">+		return m.Key
</a><a href="#h55-0-2038" id="h55-0-2038" class="i">+	}
</a><a href="#h55-0-2039" id="h55-0-2039" class="i">+	return nil
</a><a href="#h55-0-2040" id="h55-0-2040" class="i">+}
</a><a href="#h55-0-2041" id="h55-0-2041" class="i">+
</a><a href="#h55-0-2042" id="h55-0-2042" class="i">+func (m *GetRequest) GetTransaction() *Transaction {
</a><a href="#h55-0-2043" id="h55-0-2043" class="i">+	if m != nil {
</a><a href="#h55-0-2044" id="h55-0-2044" class="i">+		return m.Transaction
</a><a href="#h55-0-2045" id="h55-0-2045" class="i">+	}
</a><a href="#h55-0-2046" id="h55-0-2046" class="i">+	return nil
</a><a href="#h55-0-2047" id="h55-0-2047" class="i">+}
</a><a href="#h55-0-2048" id="h55-0-2048" class="i">+
</a><a href="#h55-0-2049" id="h55-0-2049" class="i">+func (m *GetRequest) GetFailoverMs() int64 {
</a><a href="#h55-0-2050" id="h55-0-2050" class="i">+	if m != nil &amp;&amp; m.FailoverMs != nil {
</a><a href="#h55-0-2051" id="h55-0-2051" class="i">+		return *m.FailoverMs
</a><a href="#h55-0-2052" id="h55-0-2052" class="i">+	}
</a><a href="#h55-0-2053" id="h55-0-2053" class="i">+	return 0
</a><a href="#h55-0-2054" id="h55-0-2054" class="i">+}
</a><a href="#h55-0-2055" id="h55-0-2055" class="i">+
</a><a href="#h55-0-2056" id="h55-0-2056" class="i">+func (m *GetRequest) GetStrong() bool {
</a><a href="#h55-0-2057" id="h55-0-2057" class="i">+	if m != nil &amp;&amp; m.Strong != nil {
</a><a href="#h55-0-2058" id="h55-0-2058" class="i">+		return *m.Strong
</a><a href="#h55-0-2059" id="h55-0-2059" class="i">+	}
</a><a href="#h55-0-2060" id="h55-0-2060" class="i">+	return false
</a><a href="#h55-0-2061" id="h55-0-2061" class="i">+}
</a><a href="#h55-0-2062" id="h55-0-2062" class="i">+
</a><a href="#h55-0-2063" id="h55-0-2063" class="i">+func (m *GetRequest) GetAllowDeferred() bool {
</a><a href="#h55-0-2064" id="h55-0-2064" class="i">+	if m != nil &amp;&amp; m.AllowDeferred != nil {
</a><a href="#h55-0-2065" id="h55-0-2065" class="i">+		return *m.AllowDeferred
</a><a href="#h55-0-2066" id="h55-0-2066" class="i">+	}
</a><a href="#h55-0-2067" id="h55-0-2067" class="i">+	return Default_GetRequest_AllowDeferred
</a><a href="#h55-0-2068" id="h55-0-2068" class="i">+}
</a><a href="#h55-0-2069" id="h55-0-2069" class="i">+
</a><a href="#h55-0-2070" id="h55-0-2070" class="i">+type GetResponse struct {
</a><a href="#h55-0-2071" id="h55-0-2071" class="i">+	Entity           []*GetResponse_Entity `protobuf:&quot;group,1,rep,name=Entity&quot; json:&quot;entity,omitempty&quot;`
</a><a href="#h55-0-2072" id="h55-0-2072" class="i">+	Deferred         []*Reference          `protobuf:&quot;bytes,5,rep,name=deferred&quot; json:&quot;deferred,omitempty&quot;`
</a><a href="#h55-0-2073" id="h55-0-2073" class="i">+	InOrder          *bool                 `protobuf:&quot;varint,6,opt,name=in_order,def=1&quot; json:&quot;in_order,omitempty&quot;`
</a><a href="#h55-0-2074" id="h55-0-2074" class="i">+	XXX_unrecognized []byte                `json:&quot;-&quot;`
</a><a href="#h55-0-2075" id="h55-0-2075" class="i">+}
</a><a href="#h55-0-2076" id="h55-0-2076" class="i">+
</a><a href="#h55-0-2077" id="h55-0-2077" class="i">+func (m *GetResponse) Reset()         { *m = GetResponse{} }
</a><a href="#h55-0-2078" id="h55-0-2078" class="i">+func (m *GetResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2079" id="h55-0-2079" class="i">+func (*GetResponse) ProtoMessage()    {}
</a><a href="#h55-0-2080" id="h55-0-2080" class="i">+
</a><a href="#h55-0-2081" id="h55-0-2081" class="i">+const Default_GetResponse_InOrder bool = true
</a><a href="#h55-0-2082" id="h55-0-2082" class="i">+
</a><a href="#h55-0-2083" id="h55-0-2083" class="i">+func (m *GetResponse) GetEntity() []*GetResponse_Entity {
</a><a href="#h55-0-2084" id="h55-0-2084" class="i">+	if m != nil {
</a><a href="#h55-0-2085" id="h55-0-2085" class="i">+		return m.Entity
</a><a href="#h55-0-2086" id="h55-0-2086" class="i">+	}
</a><a href="#h55-0-2087" id="h55-0-2087" class="i">+	return nil
</a><a href="#h55-0-2088" id="h55-0-2088" class="i">+}
</a><a href="#h55-0-2089" id="h55-0-2089" class="i">+
</a><a href="#h55-0-2090" id="h55-0-2090" class="i">+func (m *GetResponse) GetDeferred() []*Reference {
</a><a href="#h55-0-2091" id="h55-0-2091" class="i">+	if m != nil {
</a><a href="#h55-0-2092" id="h55-0-2092" class="i">+		return m.Deferred
</a><a href="#h55-0-2093" id="h55-0-2093" class="i">+	}
</a><a href="#h55-0-2094" id="h55-0-2094" class="i">+	return nil
</a><a href="#h55-0-2095" id="h55-0-2095" class="i">+}
</a><a href="#h55-0-2096" id="h55-0-2096" class="i">+
</a><a href="#h55-0-2097" id="h55-0-2097" class="i">+func (m *GetResponse) GetInOrder() bool {
</a><a href="#h55-0-2098" id="h55-0-2098" class="i">+	if m != nil &amp;&amp; m.InOrder != nil {
</a><a href="#h55-0-2099" id="h55-0-2099" class="i">+		return *m.InOrder
</a><a href="#h55-0-2100" id="h55-0-2100" class="i">+	}
</a><a href="#h55-0-2101" id="h55-0-2101" class="i">+	return Default_GetResponse_InOrder
</a><a href="#h55-0-2102" id="h55-0-2102" class="i">+}
</a><a href="#h55-0-2103" id="h55-0-2103" class="i">+
</a><a href="#h55-0-2104" id="h55-0-2104" class="i">+type GetResponse_Entity struct {
</a><a href="#h55-0-2105" id="h55-0-2105" class="i">+	Entity           *EntityProto `protobuf:&quot;bytes,2,opt,name=entity&quot; json:&quot;entity,omitempty&quot;`
</a><a href="#h55-0-2106" id="h55-0-2106" class="i">+	Key              *Reference   `protobuf:&quot;bytes,4,opt,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-2107" id="h55-0-2107" class="i">+	Version          *int64       `protobuf:&quot;varint,3,opt,name=version&quot; json:&quot;version,omitempty&quot;`
</a><a href="#h55-0-2108" id="h55-0-2108" class="i">+	XXX_unrecognized []byte       `json:&quot;-&quot;`
</a><a href="#h55-0-2109" id="h55-0-2109" class="i">+}
</a><a href="#h55-0-2110" id="h55-0-2110" class="i">+
</a><a href="#h55-0-2111" id="h55-0-2111" class="i">+func (m *GetResponse_Entity) Reset()         { *m = GetResponse_Entity{} }
</a><a href="#h55-0-2112" id="h55-0-2112" class="i">+func (m *GetResponse_Entity) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2113" id="h55-0-2113" class="i">+func (*GetResponse_Entity) ProtoMessage()    {}
</a><a href="#h55-0-2114" id="h55-0-2114" class="i">+
</a><a href="#h55-0-2115" id="h55-0-2115" class="i">+func (m *GetResponse_Entity) GetEntity() *EntityProto {
</a><a href="#h55-0-2116" id="h55-0-2116" class="i">+	if m != nil {
</a><a href="#h55-0-2117" id="h55-0-2117" class="i">+		return m.Entity
</a><a href="#h55-0-2118" id="h55-0-2118" class="i">+	}
</a><a href="#h55-0-2119" id="h55-0-2119" class="i">+	return nil
</a><a href="#h55-0-2120" id="h55-0-2120" class="i">+}
</a><a href="#h55-0-2121" id="h55-0-2121" class="i">+
</a><a href="#h55-0-2122" id="h55-0-2122" class="i">+func (m *GetResponse_Entity) GetKey() *Reference {
</a><a href="#h55-0-2123" id="h55-0-2123" class="i">+	if m != nil {
</a><a href="#h55-0-2124" id="h55-0-2124" class="i">+		return m.Key
</a><a href="#h55-0-2125" id="h55-0-2125" class="i">+	}
</a><a href="#h55-0-2126" id="h55-0-2126" class="i">+	return nil
</a><a href="#h55-0-2127" id="h55-0-2127" class="i">+}
</a><a href="#h55-0-2128" id="h55-0-2128" class="i">+
</a><a href="#h55-0-2129" id="h55-0-2129" class="i">+func (m *GetResponse_Entity) GetVersion() int64 {
</a><a href="#h55-0-2130" id="h55-0-2130" class="i">+	if m != nil &amp;&amp; m.Version != nil {
</a><a href="#h55-0-2131" id="h55-0-2131" class="i">+		return *m.Version
</a><a href="#h55-0-2132" id="h55-0-2132" class="i">+	}
</a><a href="#h55-0-2133" id="h55-0-2133" class="i">+	return 0
</a><a href="#h55-0-2134" id="h55-0-2134" class="i">+}
</a><a href="#h55-0-2135" id="h55-0-2135" class="i">+
</a><a href="#h55-0-2136" id="h55-0-2136" class="i">+type PutRequest struct {
</a><a href="#h55-0-2137" id="h55-0-2137" class="i">+	Header           *InternalHeader          `protobuf:&quot;bytes,11,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2138" id="h55-0-2138" class="i">+	Entity           []*EntityProto           `protobuf:&quot;bytes,1,rep,name=entity&quot; json:&quot;entity,omitempty&quot;`
</a><a href="#h55-0-2139" id="h55-0-2139" class="i">+	Transaction      *Transaction             `protobuf:&quot;bytes,2,opt,name=transaction&quot; json:&quot;transaction,omitempty&quot;`
</a><a href="#h55-0-2140" id="h55-0-2140" class="i">+	CompositeIndex   []*CompositeIndex        `protobuf:&quot;bytes,3,rep,name=composite_index&quot; json:&quot;composite_index,omitempty&quot;`
</a><a href="#h55-0-2141" id="h55-0-2141" class="i">+	Trusted          *bool                    `protobuf:&quot;varint,4,opt,name=trusted,def=0&quot; json:&quot;trusted,omitempty&quot;`
</a><a href="#h55-0-2142" id="h55-0-2142" class="i">+	Force            *bool                    `protobuf:&quot;varint,7,opt,name=force,def=0&quot; json:&quot;force,omitempty&quot;`
</a><a href="#h55-0-2143" id="h55-0-2143" class="i">+	MarkChanges      *bool                    `protobuf:&quot;varint,8,opt,name=mark_changes,def=0&quot; json:&quot;mark_changes,omitempty&quot;`
</a><a href="#h55-0-2144" id="h55-0-2144" class="i">+	Snapshot         []*Snapshot              `protobuf:&quot;bytes,9,rep,name=snapshot&quot; json:&quot;snapshot,omitempty&quot;`
</a><a href="#h55-0-2145" id="h55-0-2145" class="i">+	AutoIdPolicy     *PutRequest_AutoIdPolicy `protobuf:&quot;varint,10,opt,name=auto_id_policy,enum=appengine.PutRequest_AutoIdPolicy,def=0&quot; json:&quot;auto_id_policy,omitempty&quot;`
</a><a href="#h55-0-2146" id="h55-0-2146" class="i">+	XXX_unrecognized []byte                   `json:&quot;-&quot;`
</a><a href="#h55-0-2147" id="h55-0-2147" class="i">+}
</a><a href="#h55-0-2148" id="h55-0-2148" class="i">+
</a><a href="#h55-0-2149" id="h55-0-2149" class="i">+func (m *PutRequest) Reset()         { *m = PutRequest{} }
</a><a href="#h55-0-2150" id="h55-0-2150" class="i">+func (m *PutRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2151" id="h55-0-2151" class="i">+func (*PutRequest) ProtoMessage()    {}
</a><a href="#h55-0-2152" id="h55-0-2152" class="i">+
</a><a href="#h55-0-2153" id="h55-0-2153" class="i">+const Default_PutRequest_Trusted bool = false
</a><a href="#h55-0-2154" id="h55-0-2154" class="i">+const Default_PutRequest_Force bool = false
</a><a href="#h55-0-2155" id="h55-0-2155" class="i">+const Default_PutRequest_MarkChanges bool = false
</a><a href="#h55-0-2156" id="h55-0-2156" class="i">+const Default_PutRequest_AutoIdPolicy PutRequest_AutoIdPolicy = PutRequest_CURRENT
</a><a href="#h55-0-2157" id="h55-0-2157" class="i">+
</a><a href="#h55-0-2158" id="h55-0-2158" class="i">+func (m *PutRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2159" id="h55-0-2159" class="i">+	if m != nil {
</a><a href="#h55-0-2160" id="h55-0-2160" class="i">+		return m.Header
</a><a href="#h55-0-2161" id="h55-0-2161" class="i">+	}
</a><a href="#h55-0-2162" id="h55-0-2162" class="i">+	return nil
</a><a href="#h55-0-2163" id="h55-0-2163" class="i">+}
</a><a href="#h55-0-2164" id="h55-0-2164" class="i">+
</a><a href="#h55-0-2165" id="h55-0-2165" class="i">+func (m *PutRequest) GetEntity() []*EntityProto {
</a><a href="#h55-0-2166" id="h55-0-2166" class="i">+	if m != nil {
</a><a href="#h55-0-2167" id="h55-0-2167" class="i">+		return m.Entity
</a><a href="#h55-0-2168" id="h55-0-2168" class="i">+	}
</a><a href="#h55-0-2169" id="h55-0-2169" class="i">+	return nil
</a><a href="#h55-0-2170" id="h55-0-2170" class="i">+}
</a><a href="#h55-0-2171" id="h55-0-2171" class="i">+
</a><a href="#h55-0-2172" id="h55-0-2172" class="i">+func (m *PutRequest) GetTransaction() *Transaction {
</a><a href="#h55-0-2173" id="h55-0-2173" class="i">+	if m != nil {
</a><a href="#h55-0-2174" id="h55-0-2174" class="i">+		return m.Transaction
</a><a href="#h55-0-2175" id="h55-0-2175" class="i">+	}
</a><a href="#h55-0-2176" id="h55-0-2176" class="i">+	return nil
</a><a href="#h55-0-2177" id="h55-0-2177" class="i">+}
</a><a href="#h55-0-2178" id="h55-0-2178" class="i">+
</a><a href="#h55-0-2179" id="h55-0-2179" class="i">+func (m *PutRequest) GetCompositeIndex() []*CompositeIndex {
</a><a href="#h55-0-2180" id="h55-0-2180" class="i">+	if m != nil {
</a><a href="#h55-0-2181" id="h55-0-2181" class="i">+		return m.CompositeIndex
</a><a href="#h55-0-2182" id="h55-0-2182" class="i">+	}
</a><a href="#h55-0-2183" id="h55-0-2183" class="i">+	return nil
</a><a href="#h55-0-2184" id="h55-0-2184" class="i">+}
</a><a href="#h55-0-2185" id="h55-0-2185" class="i">+
</a><a href="#h55-0-2186" id="h55-0-2186" class="i">+func (m *PutRequest) GetTrusted() bool {
</a><a href="#h55-0-2187" id="h55-0-2187" class="i">+	if m != nil &amp;&amp; m.Trusted != nil {
</a><a href="#h55-0-2188" id="h55-0-2188" class="i">+		return *m.Trusted
</a><a href="#h55-0-2189" id="h55-0-2189" class="i">+	}
</a><a href="#h55-0-2190" id="h55-0-2190" class="i">+	return Default_PutRequest_Trusted
</a><a href="#h55-0-2191" id="h55-0-2191" class="i">+}
</a><a href="#h55-0-2192" id="h55-0-2192" class="i">+
</a><a href="#h55-0-2193" id="h55-0-2193" class="i">+func (m *PutRequest) GetForce() bool {
</a><a href="#h55-0-2194" id="h55-0-2194" class="i">+	if m != nil &amp;&amp; m.Force != nil {
</a><a href="#h55-0-2195" id="h55-0-2195" class="i">+		return *m.Force
</a><a href="#h55-0-2196" id="h55-0-2196" class="i">+	}
</a><a href="#h55-0-2197" id="h55-0-2197" class="i">+	return Default_PutRequest_Force
</a><a href="#h55-0-2198" id="h55-0-2198" class="i">+}
</a><a href="#h55-0-2199" id="h55-0-2199" class="i">+
</a><a href="#h55-0-2200" id="h55-0-2200" class="i">+func (m *PutRequest) GetMarkChanges() bool {
</a><a href="#h55-0-2201" id="h55-0-2201" class="i">+	if m != nil &amp;&amp; m.MarkChanges != nil {
</a><a href="#h55-0-2202" id="h55-0-2202" class="i">+		return *m.MarkChanges
</a><a href="#h55-0-2203" id="h55-0-2203" class="i">+	}
</a><a href="#h55-0-2204" id="h55-0-2204" class="i">+	return Default_PutRequest_MarkChanges
</a><a href="#h55-0-2205" id="h55-0-2205" class="i">+}
</a><a href="#h55-0-2206" id="h55-0-2206" class="i">+
</a><a href="#h55-0-2207" id="h55-0-2207" class="i">+func (m *PutRequest) GetSnapshot() []*Snapshot {
</a><a href="#h55-0-2208" id="h55-0-2208" class="i">+	if m != nil {
</a><a href="#h55-0-2209" id="h55-0-2209" class="i">+		return m.Snapshot
</a><a href="#h55-0-2210" id="h55-0-2210" class="i">+	}
</a><a href="#h55-0-2211" id="h55-0-2211" class="i">+	return nil
</a><a href="#h55-0-2212" id="h55-0-2212" class="i">+}
</a><a href="#h55-0-2213" id="h55-0-2213" class="i">+
</a><a href="#h55-0-2214" id="h55-0-2214" class="i">+func (m *PutRequest) GetAutoIdPolicy() PutRequest_AutoIdPolicy {
</a><a href="#h55-0-2215" id="h55-0-2215" class="i">+	if m != nil &amp;&amp; m.AutoIdPolicy != nil {
</a><a href="#h55-0-2216" id="h55-0-2216" class="i">+		return *m.AutoIdPolicy
</a><a href="#h55-0-2217" id="h55-0-2217" class="i">+	}
</a><a href="#h55-0-2218" id="h55-0-2218" class="i">+	return Default_PutRequest_AutoIdPolicy
</a><a href="#h55-0-2219" id="h55-0-2219" class="i">+}
</a><a href="#h55-0-2220" id="h55-0-2220" class="i">+
</a><a href="#h55-0-2221" id="h55-0-2221" class="i">+type PutResponse struct {
</a><a href="#h55-0-2222" id="h55-0-2222" class="i">+	Key              []*Reference `protobuf:&quot;bytes,1,rep,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-2223" id="h55-0-2223" class="i">+	Cost             *Cost        `protobuf:&quot;bytes,2,opt,name=cost&quot; json:&quot;cost,omitempty&quot;`
</a><a href="#h55-0-2224" id="h55-0-2224" class="i">+	Version          []int64      `protobuf:&quot;varint,3,rep,name=version&quot; json:&quot;version,omitempty&quot;`
</a><a href="#h55-0-2225" id="h55-0-2225" class="i">+	XXX_unrecognized []byte       `json:&quot;-&quot;`
</a><a href="#h55-0-2226" id="h55-0-2226" class="i">+}
</a><a href="#h55-0-2227" id="h55-0-2227" class="i">+
</a><a href="#h55-0-2228" id="h55-0-2228" class="i">+func (m *PutResponse) Reset()         { *m = PutResponse{} }
</a><a href="#h55-0-2229" id="h55-0-2229" class="i">+func (m *PutResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2230" id="h55-0-2230" class="i">+func (*PutResponse) ProtoMessage()    {}
</a><a href="#h55-0-2231" id="h55-0-2231" class="i">+
</a><a href="#h55-0-2232" id="h55-0-2232" class="i">+func (m *PutResponse) GetKey() []*Reference {
</a><a href="#h55-0-2233" id="h55-0-2233" class="i">+	if m != nil {
</a><a href="#h55-0-2234" id="h55-0-2234" class="i">+		return m.Key
</a><a href="#h55-0-2235" id="h55-0-2235" class="i">+	}
</a><a href="#h55-0-2236" id="h55-0-2236" class="i">+	return nil
</a><a href="#h55-0-2237" id="h55-0-2237" class="i">+}
</a><a href="#h55-0-2238" id="h55-0-2238" class="i">+
</a><a href="#h55-0-2239" id="h55-0-2239" class="i">+func (m *PutResponse) GetCost() *Cost {
</a><a href="#h55-0-2240" id="h55-0-2240" class="i">+	if m != nil {
</a><a href="#h55-0-2241" id="h55-0-2241" class="i">+		return m.Cost
</a><a href="#h55-0-2242" id="h55-0-2242" class="i">+	}
</a><a href="#h55-0-2243" id="h55-0-2243" class="i">+	return nil
</a><a href="#h55-0-2244" id="h55-0-2244" class="i">+}
</a><a href="#h55-0-2245" id="h55-0-2245" class="i">+
</a><a href="#h55-0-2246" id="h55-0-2246" class="i">+func (m *PutResponse) GetVersion() []int64 {
</a><a href="#h55-0-2247" id="h55-0-2247" class="i">+	if m != nil {
</a><a href="#h55-0-2248" id="h55-0-2248" class="i">+		return m.Version
</a><a href="#h55-0-2249" id="h55-0-2249" class="i">+	}
</a><a href="#h55-0-2250" id="h55-0-2250" class="i">+	return nil
</a><a href="#h55-0-2251" id="h55-0-2251" class="i">+}
</a><a href="#h55-0-2252" id="h55-0-2252" class="i">+
</a><a href="#h55-0-2253" id="h55-0-2253" class="i">+type TouchRequest struct {
</a><a href="#h55-0-2254" id="h55-0-2254" class="i">+	Header           *InternalHeader   `protobuf:&quot;bytes,10,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2255" id="h55-0-2255" class="i">+	Key              []*Reference      `protobuf:&quot;bytes,1,rep,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-2256" id="h55-0-2256" class="i">+	CompositeIndex   []*CompositeIndex `protobuf:&quot;bytes,2,rep,name=composite_index&quot; json:&quot;composite_index,omitempty&quot;`
</a><a href="#h55-0-2257" id="h55-0-2257" class="i">+	Force            *bool             `protobuf:&quot;varint,3,opt,name=force,def=0&quot; json:&quot;force,omitempty&quot;`
</a><a href="#h55-0-2258" id="h55-0-2258" class="i">+	Snapshot         []*Snapshot       `protobuf:&quot;bytes,9,rep,name=snapshot&quot; json:&quot;snapshot,omitempty&quot;`
</a><a href="#h55-0-2259" id="h55-0-2259" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h55-0-2260" id="h55-0-2260" class="i">+}
</a><a href="#h55-0-2261" id="h55-0-2261" class="i">+
</a><a href="#h55-0-2262" id="h55-0-2262" class="i">+func (m *TouchRequest) Reset()         { *m = TouchRequest{} }
</a><a href="#h55-0-2263" id="h55-0-2263" class="i">+func (m *TouchRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2264" id="h55-0-2264" class="i">+func (*TouchRequest) ProtoMessage()    {}
</a><a href="#h55-0-2265" id="h55-0-2265" class="i">+
</a><a href="#h55-0-2266" id="h55-0-2266" class="i">+const Default_TouchRequest_Force bool = false
</a><a href="#h55-0-2267" id="h55-0-2267" class="i">+
</a><a href="#h55-0-2268" id="h55-0-2268" class="i">+func (m *TouchRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2269" id="h55-0-2269" class="i">+	if m != nil {
</a><a href="#h55-0-2270" id="h55-0-2270" class="i">+		return m.Header
</a><a href="#h55-0-2271" id="h55-0-2271" class="i">+	}
</a><a href="#h55-0-2272" id="h55-0-2272" class="i">+	return nil
</a><a href="#h55-0-2273" id="h55-0-2273" class="i">+}
</a><a href="#h55-0-2274" id="h55-0-2274" class="i">+
</a><a href="#h55-0-2275" id="h55-0-2275" class="i">+func (m *TouchRequest) GetKey() []*Reference {
</a><a href="#h55-0-2276" id="h55-0-2276" class="i">+	if m != nil {
</a><a href="#h55-0-2277" id="h55-0-2277" class="i">+		return m.Key
</a><a href="#h55-0-2278" id="h55-0-2278" class="i">+	}
</a><a href="#h55-0-2279" id="h55-0-2279" class="i">+	return nil
</a><a href="#h55-0-2280" id="h55-0-2280" class="i">+}
</a><a href="#h55-0-2281" id="h55-0-2281" class="i">+
</a><a href="#h55-0-2282" id="h55-0-2282" class="i">+func (m *TouchRequest) GetCompositeIndex() []*CompositeIndex {
</a><a href="#h55-0-2283" id="h55-0-2283" class="i">+	if m != nil {
</a><a href="#h55-0-2284" id="h55-0-2284" class="i">+		return m.CompositeIndex
</a><a href="#h55-0-2285" id="h55-0-2285" class="i">+	}
</a><a href="#h55-0-2286" id="h55-0-2286" class="i">+	return nil
</a><a href="#h55-0-2287" id="h55-0-2287" class="i">+}
</a><a href="#h55-0-2288" id="h55-0-2288" class="i">+
</a><a href="#h55-0-2289" id="h55-0-2289" class="i">+func (m *TouchRequest) GetForce() bool {
</a><a href="#h55-0-2290" id="h55-0-2290" class="i">+	if m != nil &amp;&amp; m.Force != nil {
</a><a href="#h55-0-2291" id="h55-0-2291" class="i">+		return *m.Force
</a><a href="#h55-0-2292" id="h55-0-2292" class="i">+	}
</a><a href="#h55-0-2293" id="h55-0-2293" class="i">+	return Default_TouchRequest_Force
</a><a href="#h55-0-2294" id="h55-0-2294" class="i">+}
</a><a href="#h55-0-2295" id="h55-0-2295" class="i">+
</a><a href="#h55-0-2296" id="h55-0-2296" class="i">+func (m *TouchRequest) GetSnapshot() []*Snapshot {
</a><a href="#h55-0-2297" id="h55-0-2297" class="i">+	if m != nil {
</a><a href="#h55-0-2298" id="h55-0-2298" class="i">+		return m.Snapshot
</a><a href="#h55-0-2299" id="h55-0-2299" class="i">+	}
</a><a href="#h55-0-2300" id="h55-0-2300" class="i">+	return nil
</a><a href="#h55-0-2301" id="h55-0-2301" class="i">+}
</a><a href="#h55-0-2302" id="h55-0-2302" class="i">+
</a><a href="#h55-0-2303" id="h55-0-2303" class="i">+type TouchResponse struct {
</a><a href="#h55-0-2304" id="h55-0-2304" class="i">+	Cost             *Cost  `protobuf:&quot;bytes,1,opt,name=cost&quot; json:&quot;cost,omitempty&quot;`
</a><a href="#h55-0-2305" id="h55-0-2305" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h55-0-2306" id="h55-0-2306" class="i">+}
</a><a href="#h55-0-2307" id="h55-0-2307" class="i">+
</a><a href="#h55-0-2308" id="h55-0-2308" class="i">+func (m *TouchResponse) Reset()         { *m = TouchResponse{} }
</a><a href="#h55-0-2309" id="h55-0-2309" class="i">+func (m *TouchResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2310" id="h55-0-2310" class="i">+func (*TouchResponse) ProtoMessage()    {}
</a><a href="#h55-0-2311" id="h55-0-2311" class="i">+
</a><a href="#h55-0-2312" id="h55-0-2312" class="i">+func (m *TouchResponse) GetCost() *Cost {
</a><a href="#h55-0-2313" id="h55-0-2313" class="i">+	if m != nil {
</a><a href="#h55-0-2314" id="h55-0-2314" class="i">+		return m.Cost
</a><a href="#h55-0-2315" id="h55-0-2315" class="i">+	}
</a><a href="#h55-0-2316" id="h55-0-2316" class="i">+	return nil
</a><a href="#h55-0-2317" id="h55-0-2317" class="i">+}
</a><a href="#h55-0-2318" id="h55-0-2318" class="i">+
</a><a href="#h55-0-2319" id="h55-0-2319" class="i">+type DeleteRequest struct {
</a><a href="#h55-0-2320" id="h55-0-2320" class="i">+	Header           *InternalHeader `protobuf:&quot;bytes,10,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2321" id="h55-0-2321" class="i">+	Key              []*Reference    `protobuf:&quot;bytes,6,rep,name=key&quot; json:&quot;key,omitempty&quot;`
</a><a href="#h55-0-2322" id="h55-0-2322" class="i">+	Transaction      *Transaction    `protobuf:&quot;bytes,5,opt,name=transaction&quot; json:&quot;transaction,omitempty&quot;`
</a><a href="#h55-0-2323" id="h55-0-2323" class="i">+	Trusted          *bool           `protobuf:&quot;varint,4,opt,name=trusted,def=0&quot; json:&quot;trusted,omitempty&quot;`
</a><a href="#h55-0-2324" id="h55-0-2324" class="i">+	Force            *bool           `protobuf:&quot;varint,7,opt,name=force,def=0&quot; json:&quot;force,omitempty&quot;`
</a><a href="#h55-0-2325" id="h55-0-2325" class="i">+	MarkChanges      *bool           `protobuf:&quot;varint,8,opt,name=mark_changes,def=0&quot; json:&quot;mark_changes,omitempty&quot;`
</a><a href="#h55-0-2326" id="h55-0-2326" class="i">+	Snapshot         []*Snapshot     `protobuf:&quot;bytes,9,rep,name=snapshot&quot; json:&quot;snapshot,omitempty&quot;`
</a><a href="#h55-0-2327" id="h55-0-2327" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-2328" id="h55-0-2328" class="i">+}
</a><a href="#h55-0-2329" id="h55-0-2329" class="i">+
</a><a href="#h55-0-2330" id="h55-0-2330" class="i">+func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
</a><a href="#h55-0-2331" id="h55-0-2331" class="i">+func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2332" id="h55-0-2332" class="i">+func (*DeleteRequest) ProtoMessage()    {}
</a><a href="#h55-0-2333" id="h55-0-2333" class="i">+
</a><a href="#h55-0-2334" id="h55-0-2334" class="i">+const Default_DeleteRequest_Trusted bool = false
</a><a href="#h55-0-2335" id="h55-0-2335" class="i">+const Default_DeleteRequest_Force bool = false
</a><a href="#h55-0-2336" id="h55-0-2336" class="i">+const Default_DeleteRequest_MarkChanges bool = false
</a><a href="#h55-0-2337" id="h55-0-2337" class="i">+
</a><a href="#h55-0-2338" id="h55-0-2338" class="i">+func (m *DeleteRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2339" id="h55-0-2339" class="i">+	if m != nil {
</a><a href="#h55-0-2340" id="h55-0-2340" class="i">+		return m.Header
</a><a href="#h55-0-2341" id="h55-0-2341" class="i">+	}
</a><a href="#h55-0-2342" id="h55-0-2342" class="i">+	return nil
</a><a href="#h55-0-2343" id="h55-0-2343" class="i">+}
</a><a href="#h55-0-2344" id="h55-0-2344" class="i">+
</a><a href="#h55-0-2345" id="h55-0-2345" class="i">+func (m *DeleteRequest) GetKey() []*Reference {
</a><a href="#h55-0-2346" id="h55-0-2346" class="i">+	if m != nil {
</a><a href="#h55-0-2347" id="h55-0-2347" class="i">+		return m.Key
</a><a href="#h55-0-2348" id="h55-0-2348" class="i">+	}
</a><a href="#h55-0-2349" id="h55-0-2349" class="i">+	return nil
</a><a href="#h55-0-2350" id="h55-0-2350" class="i">+}
</a><a href="#h55-0-2351" id="h55-0-2351" class="i">+
</a><a href="#h55-0-2352" id="h55-0-2352" class="i">+func (m *DeleteRequest) GetTransaction() *Transaction {
</a><a href="#h55-0-2353" id="h55-0-2353" class="i">+	if m != nil {
</a><a href="#h55-0-2354" id="h55-0-2354" class="i">+		return m.Transaction
</a><a href="#h55-0-2355" id="h55-0-2355" class="i">+	}
</a><a href="#h55-0-2356" id="h55-0-2356" class="i">+	return nil
</a><a href="#h55-0-2357" id="h55-0-2357" class="i">+}
</a><a href="#h55-0-2358" id="h55-0-2358" class="i">+
</a><a href="#h55-0-2359" id="h55-0-2359" class="i">+func (m *DeleteRequest) GetTrusted() bool {
</a><a href="#h55-0-2360" id="h55-0-2360" class="i">+	if m != nil &amp;&amp; m.Trusted != nil {
</a><a href="#h55-0-2361" id="h55-0-2361" class="i">+		return *m.Trusted
</a><a href="#h55-0-2362" id="h55-0-2362" class="i">+	}
</a><a href="#h55-0-2363" id="h55-0-2363" class="i">+	return Default_DeleteRequest_Trusted
</a><a href="#h55-0-2364" id="h55-0-2364" class="i">+}
</a><a href="#h55-0-2365" id="h55-0-2365" class="i">+
</a><a href="#h55-0-2366" id="h55-0-2366" class="i">+func (m *DeleteRequest) GetForce() bool {
</a><a href="#h55-0-2367" id="h55-0-2367" class="i">+	if m != nil &amp;&amp; m.Force != nil {
</a><a href="#h55-0-2368" id="h55-0-2368" class="i">+		return *m.Force
</a><a href="#h55-0-2369" id="h55-0-2369" class="i">+	}
</a><a href="#h55-0-2370" id="h55-0-2370" class="i">+	return Default_DeleteRequest_Force
</a><a href="#h55-0-2371" id="h55-0-2371" class="i">+}
</a><a href="#h55-0-2372" id="h55-0-2372" class="i">+
</a><a href="#h55-0-2373" id="h55-0-2373" class="i">+func (m *DeleteRequest) GetMarkChanges() bool {
</a><a href="#h55-0-2374" id="h55-0-2374" class="i">+	if m != nil &amp;&amp; m.MarkChanges != nil {
</a><a href="#h55-0-2375" id="h55-0-2375" class="i">+		return *m.MarkChanges
</a><a href="#h55-0-2376" id="h55-0-2376" class="i">+	}
</a><a href="#h55-0-2377" id="h55-0-2377" class="i">+	return Default_DeleteRequest_MarkChanges
</a><a href="#h55-0-2378" id="h55-0-2378" class="i">+}
</a><a href="#h55-0-2379" id="h55-0-2379" class="i">+
</a><a href="#h55-0-2380" id="h55-0-2380" class="i">+func (m *DeleteRequest) GetSnapshot() []*Snapshot {
</a><a href="#h55-0-2381" id="h55-0-2381" class="i">+	if m != nil {
</a><a href="#h55-0-2382" id="h55-0-2382" class="i">+		return m.Snapshot
</a><a href="#h55-0-2383" id="h55-0-2383" class="i">+	}
</a><a href="#h55-0-2384" id="h55-0-2384" class="i">+	return nil
</a><a href="#h55-0-2385" id="h55-0-2385" class="i">+}
</a><a href="#h55-0-2386" id="h55-0-2386" class="i">+
</a><a href="#h55-0-2387" id="h55-0-2387" class="i">+type DeleteResponse struct {
</a><a href="#h55-0-2388" id="h55-0-2388" class="i">+	Cost             *Cost   `protobuf:&quot;bytes,1,opt,name=cost&quot; json:&quot;cost,omitempty&quot;`
</a><a href="#h55-0-2389" id="h55-0-2389" class="i">+	Version          []int64 `protobuf:&quot;varint,3,rep,name=version&quot; json:&quot;version,omitempty&quot;`
</a><a href="#h55-0-2390" id="h55-0-2390" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h55-0-2391" id="h55-0-2391" class="i">+}
</a><a href="#h55-0-2392" id="h55-0-2392" class="i">+
</a><a href="#h55-0-2393" id="h55-0-2393" class="i">+func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
</a><a href="#h55-0-2394" id="h55-0-2394" class="i">+func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2395" id="h55-0-2395" class="i">+func (*DeleteResponse) ProtoMessage()    {}
</a><a href="#h55-0-2396" id="h55-0-2396" class="i">+
</a><a href="#h55-0-2397" id="h55-0-2397" class="i">+func (m *DeleteResponse) GetCost() *Cost {
</a><a href="#h55-0-2398" id="h55-0-2398" class="i">+	if m != nil {
</a><a href="#h55-0-2399" id="h55-0-2399" class="i">+		return m.Cost
</a><a href="#h55-0-2400" id="h55-0-2400" class="i">+	}
</a><a href="#h55-0-2401" id="h55-0-2401" class="i">+	return nil
</a><a href="#h55-0-2402" id="h55-0-2402" class="i">+}
</a><a href="#h55-0-2403" id="h55-0-2403" class="i">+
</a><a href="#h55-0-2404" id="h55-0-2404" class="i">+func (m *DeleteResponse) GetVersion() []int64 {
</a><a href="#h55-0-2405" id="h55-0-2405" class="i">+	if m != nil {
</a><a href="#h55-0-2406" id="h55-0-2406" class="i">+		return m.Version
</a><a href="#h55-0-2407" id="h55-0-2407" class="i">+	}
</a><a href="#h55-0-2408" id="h55-0-2408" class="i">+	return nil
</a><a href="#h55-0-2409" id="h55-0-2409" class="i">+}
</a><a href="#h55-0-2410" id="h55-0-2410" class="i">+
</a><a href="#h55-0-2411" id="h55-0-2411" class="i">+type NextRequest struct {
</a><a href="#h55-0-2412" id="h55-0-2412" class="i">+	Header           *InternalHeader `protobuf:&quot;bytes,5,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2413" id="h55-0-2413" class="i">+	Cursor           *Cursor         `protobuf:&quot;bytes,1,req,name=cursor&quot; json:&quot;cursor,omitempty&quot;`
</a><a href="#h55-0-2414" id="h55-0-2414" class="i">+	Count            *int32          `protobuf:&quot;varint,2,opt,name=count&quot; json:&quot;count,omitempty&quot;`
</a><a href="#h55-0-2415" id="h55-0-2415" class="i">+	Offset           *int32          `protobuf:&quot;varint,4,opt,name=offset,def=0&quot; json:&quot;offset,omitempty&quot;`
</a><a href="#h55-0-2416" id="h55-0-2416" class="i">+	Compile          *bool           `protobuf:&quot;varint,3,opt,name=compile,def=0&quot; json:&quot;compile,omitempty&quot;`
</a><a href="#h55-0-2417" id="h55-0-2417" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-2418" id="h55-0-2418" class="i">+}
</a><a href="#h55-0-2419" id="h55-0-2419" class="i">+
</a><a href="#h55-0-2420" id="h55-0-2420" class="i">+func (m *NextRequest) Reset()         { *m = NextRequest{} }
</a><a href="#h55-0-2421" id="h55-0-2421" class="i">+func (m *NextRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2422" id="h55-0-2422" class="i">+func (*NextRequest) ProtoMessage()    {}
</a><a href="#h55-0-2423" id="h55-0-2423" class="i">+
</a><a href="#h55-0-2424" id="h55-0-2424" class="i">+const Default_NextRequest_Offset int32 = 0
</a><a href="#h55-0-2425" id="h55-0-2425" class="i">+const Default_NextRequest_Compile bool = false
</a><a href="#h55-0-2426" id="h55-0-2426" class="i">+
</a><a href="#h55-0-2427" id="h55-0-2427" class="i">+func (m *NextRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2428" id="h55-0-2428" class="i">+	if m != nil {
</a><a href="#h55-0-2429" id="h55-0-2429" class="i">+		return m.Header
</a><a href="#h55-0-2430" id="h55-0-2430" class="i">+	}
</a><a href="#h55-0-2431" id="h55-0-2431" class="i">+	return nil
</a><a href="#h55-0-2432" id="h55-0-2432" class="i">+}
</a><a href="#h55-0-2433" id="h55-0-2433" class="i">+
</a><a href="#h55-0-2434" id="h55-0-2434" class="i">+func (m *NextRequest) GetCursor() *Cursor {
</a><a href="#h55-0-2435" id="h55-0-2435" class="i">+	if m != nil {
</a><a href="#h55-0-2436" id="h55-0-2436" class="i">+		return m.Cursor
</a><a href="#h55-0-2437" id="h55-0-2437" class="i">+	}
</a><a href="#h55-0-2438" id="h55-0-2438" class="i">+	return nil
</a><a href="#h55-0-2439" id="h55-0-2439" class="i">+}
</a><a href="#h55-0-2440" id="h55-0-2440" class="i">+
</a><a href="#h55-0-2441" id="h55-0-2441" class="i">+func (m *NextRequest) GetCount() int32 {
</a><a href="#h55-0-2442" id="h55-0-2442" class="i">+	if m != nil &amp;&amp; m.Count != nil {
</a><a href="#h55-0-2443" id="h55-0-2443" class="i">+		return *m.Count
</a><a href="#h55-0-2444" id="h55-0-2444" class="i">+	}
</a><a href="#h55-0-2445" id="h55-0-2445" class="i">+	return 0
</a><a href="#h55-0-2446" id="h55-0-2446" class="i">+}
</a><a href="#h55-0-2447" id="h55-0-2447" class="i">+
</a><a href="#h55-0-2448" id="h55-0-2448" class="i">+func (m *NextRequest) GetOffset() int32 {
</a><a href="#h55-0-2449" id="h55-0-2449" class="i">+	if m != nil &amp;&amp; m.Offset != nil {
</a><a href="#h55-0-2450" id="h55-0-2450" class="i">+		return *m.Offset
</a><a href="#h55-0-2451" id="h55-0-2451" class="i">+	}
</a><a href="#h55-0-2452" id="h55-0-2452" class="i">+	return Default_NextRequest_Offset
</a><a href="#h55-0-2453" id="h55-0-2453" class="i">+}
</a><a href="#h55-0-2454" id="h55-0-2454" class="i">+
</a><a href="#h55-0-2455" id="h55-0-2455" class="i">+func (m *NextRequest) GetCompile() bool {
</a><a href="#h55-0-2456" id="h55-0-2456" class="i">+	if m != nil &amp;&amp; m.Compile != nil {
</a><a href="#h55-0-2457" id="h55-0-2457" class="i">+		return *m.Compile
</a><a href="#h55-0-2458" id="h55-0-2458" class="i">+	}
</a><a href="#h55-0-2459" id="h55-0-2459" class="i">+	return Default_NextRequest_Compile
</a><a href="#h55-0-2460" id="h55-0-2460" class="i">+}
</a><a href="#h55-0-2461" id="h55-0-2461" class="i">+
</a><a href="#h55-0-2462" id="h55-0-2462" class="i">+type QueryResult struct {
</a><a href="#h55-0-2463" id="h55-0-2463" class="i">+	Cursor           *Cursor           `protobuf:&quot;bytes,1,opt,name=cursor&quot; json:&quot;cursor,omitempty&quot;`
</a><a href="#h55-0-2464" id="h55-0-2464" class="i">+	Result           []*EntityProto    `protobuf:&quot;bytes,2,rep,name=result&quot; json:&quot;result,omitempty&quot;`
</a><a href="#h55-0-2465" id="h55-0-2465" class="i">+	SkippedResults   *int32            `protobuf:&quot;varint,7,opt,name=skipped_results&quot; json:&quot;skipped_results,omitempty&quot;`
</a><a href="#h55-0-2466" id="h55-0-2466" class="i">+	MoreResults      *bool             `protobuf:&quot;varint,3,req,name=more_results&quot; json:&quot;more_results,omitempty&quot;`
</a><a href="#h55-0-2467" id="h55-0-2467" class="i">+	KeysOnly         *bool             `protobuf:&quot;varint,4,opt,name=keys_only&quot; json:&quot;keys_only,omitempty&quot;`
</a><a href="#h55-0-2468" id="h55-0-2468" class="i">+	IndexOnly        *bool             `protobuf:&quot;varint,9,opt,name=index_only&quot; json:&quot;index_only,omitempty&quot;`
</a><a href="#h55-0-2469" id="h55-0-2469" class="i">+	SmallOps         *bool             `protobuf:&quot;varint,10,opt,name=small_ops&quot; json:&quot;small_ops,omitempty&quot;`
</a><a href="#h55-0-2470" id="h55-0-2470" class="i">+	CompiledQuery    *CompiledQuery    `protobuf:&quot;bytes,5,opt,name=compiled_query&quot; json:&quot;compiled_query,omitempty&quot;`
</a><a href="#h55-0-2471" id="h55-0-2471" class="i">+	CompiledCursor   *CompiledCursor   `protobuf:&quot;bytes,6,opt,name=compiled_cursor&quot; json:&quot;compiled_cursor,omitempty&quot;`
</a><a href="#h55-0-2472" id="h55-0-2472" class="i">+	Index            []*CompositeIndex `protobuf:&quot;bytes,8,rep,name=index&quot; json:&quot;index,omitempty&quot;`
</a><a href="#h55-0-2473" id="h55-0-2473" class="i">+	Version          []int64           `protobuf:&quot;varint,11,rep,name=version&quot; json:&quot;version,omitempty&quot;`
</a><a href="#h55-0-2474" id="h55-0-2474" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h55-0-2475" id="h55-0-2475" class="i">+}
</a><a href="#h55-0-2476" id="h55-0-2476" class="i">+
</a><a href="#h55-0-2477" id="h55-0-2477" class="i">+func (m *QueryResult) Reset()         { *m = QueryResult{} }
</a><a href="#h55-0-2478" id="h55-0-2478" class="i">+func (m *QueryResult) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2479" id="h55-0-2479" class="i">+func (*QueryResult) ProtoMessage()    {}
</a><a href="#h55-0-2480" id="h55-0-2480" class="i">+
</a><a href="#h55-0-2481" id="h55-0-2481" class="i">+func (m *QueryResult) GetCursor() *Cursor {
</a><a href="#h55-0-2482" id="h55-0-2482" class="i">+	if m != nil {
</a><a href="#h55-0-2483" id="h55-0-2483" class="i">+		return m.Cursor
</a><a href="#h55-0-2484" id="h55-0-2484" class="i">+	}
</a><a href="#h55-0-2485" id="h55-0-2485" class="i">+	return nil
</a><a href="#h55-0-2486" id="h55-0-2486" class="i">+}
</a><a href="#h55-0-2487" id="h55-0-2487" class="i">+
</a><a href="#h55-0-2488" id="h55-0-2488" class="i">+func (m *QueryResult) GetResult() []*EntityProto {
</a><a href="#h55-0-2489" id="h55-0-2489" class="i">+	if m != nil {
</a><a href="#h55-0-2490" id="h55-0-2490" class="i">+		return m.Result
</a><a href="#h55-0-2491" id="h55-0-2491" class="i">+	}
</a><a href="#h55-0-2492" id="h55-0-2492" class="i">+	return nil
</a><a href="#h55-0-2493" id="h55-0-2493" class="i">+}
</a><a href="#h55-0-2494" id="h55-0-2494" class="i">+
</a><a href="#h55-0-2495" id="h55-0-2495" class="i">+func (m *QueryResult) GetSkippedResults() int32 {
</a><a href="#h55-0-2496" id="h55-0-2496" class="i">+	if m != nil &amp;&amp; m.SkippedResults != nil {
</a><a href="#h55-0-2497" id="h55-0-2497" class="i">+		return *m.SkippedResults
</a><a href="#h55-0-2498" id="h55-0-2498" class="i">+	}
</a><a href="#h55-0-2499" id="h55-0-2499" class="i">+	return 0
</a><a href="#h55-0-2500" id="h55-0-2500" class="i">+}
</a><a href="#h55-0-2501" id="h55-0-2501" class="i">+
</a><a href="#h55-0-2502" id="h55-0-2502" class="i">+func (m *QueryResult) GetMoreResults() bool {
</a><a href="#h55-0-2503" id="h55-0-2503" class="i">+	if m != nil &amp;&amp; m.MoreResults != nil {
</a><a href="#h55-0-2504" id="h55-0-2504" class="i">+		return *m.MoreResults
</a><a href="#h55-0-2505" id="h55-0-2505" class="i">+	}
</a><a href="#h55-0-2506" id="h55-0-2506" class="i">+	return false
</a><a href="#h55-0-2507" id="h55-0-2507" class="i">+}
</a><a href="#h55-0-2508" id="h55-0-2508" class="i">+
</a><a href="#h55-0-2509" id="h55-0-2509" class="i">+func (m *QueryResult) GetKeysOnly() bool {
</a><a href="#h55-0-2510" id="h55-0-2510" class="i">+	if m != nil &amp;&amp; m.KeysOnly != nil {
</a><a href="#h55-0-2511" id="h55-0-2511" class="i">+		return *m.KeysOnly
</a><a href="#h55-0-2512" id="h55-0-2512" class="i">+	}
</a><a href="#h55-0-2513" id="h55-0-2513" class="i">+	return false
</a><a href="#h55-0-2514" id="h55-0-2514" class="i">+}
</a><a href="#h55-0-2515" id="h55-0-2515" class="i">+
</a><a href="#h55-0-2516" id="h55-0-2516" class="i">+func (m *QueryResult) GetIndexOnly() bool {
</a><a href="#h55-0-2517" id="h55-0-2517" class="i">+	if m != nil &amp;&amp; m.IndexOnly != nil {
</a><a href="#h55-0-2518" id="h55-0-2518" class="i">+		return *m.IndexOnly
</a><a href="#h55-0-2519" id="h55-0-2519" class="i">+	}
</a><a href="#h55-0-2520" id="h55-0-2520" class="i">+	return false
</a><a href="#h55-0-2521" id="h55-0-2521" class="i">+}
</a><a href="#h55-0-2522" id="h55-0-2522" class="i">+
</a><a href="#h55-0-2523" id="h55-0-2523" class="i">+func (m *QueryResult) GetSmallOps() bool {
</a><a href="#h55-0-2524" id="h55-0-2524" class="i">+	if m != nil &amp;&amp; m.SmallOps != nil {
</a><a href="#h55-0-2525" id="h55-0-2525" class="i">+		return *m.SmallOps
</a><a href="#h55-0-2526" id="h55-0-2526" class="i">+	}
</a><a href="#h55-0-2527" id="h55-0-2527" class="i">+	return false
</a><a href="#h55-0-2528" id="h55-0-2528" class="i">+}
</a><a href="#h55-0-2529" id="h55-0-2529" class="i">+
</a><a href="#h55-0-2530" id="h55-0-2530" class="i">+func (m *QueryResult) GetCompiledQuery() *CompiledQuery {
</a><a href="#h55-0-2531" id="h55-0-2531" class="i">+	if m != nil {
</a><a href="#h55-0-2532" id="h55-0-2532" class="i">+		return m.CompiledQuery
</a><a href="#h55-0-2533" id="h55-0-2533" class="i">+	}
</a><a href="#h55-0-2534" id="h55-0-2534" class="i">+	return nil
</a><a href="#h55-0-2535" id="h55-0-2535" class="i">+}
</a><a href="#h55-0-2536" id="h55-0-2536" class="i">+
</a><a href="#h55-0-2537" id="h55-0-2537" class="i">+func (m *QueryResult) GetCompiledCursor() *CompiledCursor {
</a><a href="#h55-0-2538" id="h55-0-2538" class="i">+	if m != nil {
</a><a href="#h55-0-2539" id="h55-0-2539" class="i">+		return m.CompiledCursor
</a><a href="#h55-0-2540" id="h55-0-2540" class="i">+	}
</a><a href="#h55-0-2541" id="h55-0-2541" class="i">+	return nil
</a><a href="#h55-0-2542" id="h55-0-2542" class="i">+}
</a><a href="#h55-0-2543" id="h55-0-2543" class="i">+
</a><a href="#h55-0-2544" id="h55-0-2544" class="i">+func (m *QueryResult) GetIndex() []*CompositeIndex {
</a><a href="#h55-0-2545" id="h55-0-2545" class="i">+	if m != nil {
</a><a href="#h55-0-2546" id="h55-0-2546" class="i">+		return m.Index
</a><a href="#h55-0-2547" id="h55-0-2547" class="i">+	}
</a><a href="#h55-0-2548" id="h55-0-2548" class="i">+	return nil
</a><a href="#h55-0-2549" id="h55-0-2549" class="i">+}
</a><a href="#h55-0-2550" id="h55-0-2550" class="i">+
</a><a href="#h55-0-2551" id="h55-0-2551" class="i">+func (m *QueryResult) GetVersion() []int64 {
</a><a href="#h55-0-2552" id="h55-0-2552" class="i">+	if m != nil {
</a><a href="#h55-0-2553" id="h55-0-2553" class="i">+		return m.Version
</a><a href="#h55-0-2554" id="h55-0-2554" class="i">+	}
</a><a href="#h55-0-2555" id="h55-0-2555" class="i">+	return nil
</a><a href="#h55-0-2556" id="h55-0-2556" class="i">+}
</a><a href="#h55-0-2557" id="h55-0-2557" class="i">+
</a><a href="#h55-0-2558" id="h55-0-2558" class="i">+type AllocateIdsRequest struct {
</a><a href="#h55-0-2559" id="h55-0-2559" class="i">+	Header           *InternalHeader `protobuf:&quot;bytes,4,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2560" id="h55-0-2560" class="i">+	ModelKey         *Reference      `protobuf:&quot;bytes,1,opt,name=model_key&quot; json:&quot;model_key,omitempty&quot;`
</a><a href="#h55-0-2561" id="h55-0-2561" class="i">+	Size             *int64          `protobuf:&quot;varint,2,opt,name=size&quot; json:&quot;size,omitempty&quot;`
</a><a href="#h55-0-2562" id="h55-0-2562" class="i">+	Max              *int64          `protobuf:&quot;varint,3,opt,name=max&quot; json:&quot;max,omitempty&quot;`
</a><a href="#h55-0-2563" id="h55-0-2563" class="i">+	Reserve          []*Reference    `protobuf:&quot;bytes,5,rep,name=reserve&quot; json:&quot;reserve,omitempty&quot;`
</a><a href="#h55-0-2564" id="h55-0-2564" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-2565" id="h55-0-2565" class="i">+}
</a><a href="#h55-0-2566" id="h55-0-2566" class="i">+
</a><a href="#h55-0-2567" id="h55-0-2567" class="i">+func (m *AllocateIdsRequest) Reset()         { *m = AllocateIdsRequest{} }
</a><a href="#h55-0-2568" id="h55-0-2568" class="i">+func (m *AllocateIdsRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2569" id="h55-0-2569" class="i">+func (*AllocateIdsRequest) ProtoMessage()    {}
</a><a href="#h55-0-2570" id="h55-0-2570" class="i">+
</a><a href="#h55-0-2571" id="h55-0-2571" class="i">+func (m *AllocateIdsRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2572" id="h55-0-2572" class="i">+	if m != nil {
</a><a href="#h55-0-2573" id="h55-0-2573" class="i">+		return m.Header
</a><a href="#h55-0-2574" id="h55-0-2574" class="i">+	}
</a><a href="#h55-0-2575" id="h55-0-2575" class="i">+	return nil
</a><a href="#h55-0-2576" id="h55-0-2576" class="i">+}
</a><a href="#h55-0-2577" id="h55-0-2577" class="i">+
</a><a href="#h55-0-2578" id="h55-0-2578" class="i">+func (m *AllocateIdsRequest) GetModelKey() *Reference {
</a><a href="#h55-0-2579" id="h55-0-2579" class="i">+	if m != nil {
</a><a href="#h55-0-2580" id="h55-0-2580" class="i">+		return m.ModelKey
</a><a href="#h55-0-2581" id="h55-0-2581" class="i">+	}
</a><a href="#h55-0-2582" id="h55-0-2582" class="i">+	return nil
</a><a href="#h55-0-2583" id="h55-0-2583" class="i">+}
</a><a href="#h55-0-2584" id="h55-0-2584" class="i">+
</a><a href="#h55-0-2585" id="h55-0-2585" class="i">+func (m *AllocateIdsRequest) GetSize() int64 {
</a><a href="#h55-0-2586" id="h55-0-2586" class="i">+	if m != nil &amp;&amp; m.Size != nil {
</a><a href="#h55-0-2587" id="h55-0-2587" class="i">+		return *m.Size
</a><a href="#h55-0-2588" id="h55-0-2588" class="i">+	}
</a><a href="#h55-0-2589" id="h55-0-2589" class="i">+	return 0
</a><a href="#h55-0-2590" id="h55-0-2590" class="i">+}
</a><a href="#h55-0-2591" id="h55-0-2591" class="i">+
</a><a href="#h55-0-2592" id="h55-0-2592" class="i">+func (m *AllocateIdsRequest) GetMax() int64 {
</a><a href="#h55-0-2593" id="h55-0-2593" class="i">+	if m != nil &amp;&amp; m.Max != nil {
</a><a href="#h55-0-2594" id="h55-0-2594" class="i">+		return *m.Max
</a><a href="#h55-0-2595" id="h55-0-2595" class="i">+	}
</a><a href="#h55-0-2596" id="h55-0-2596" class="i">+	return 0
</a><a href="#h55-0-2597" id="h55-0-2597" class="i">+}
</a><a href="#h55-0-2598" id="h55-0-2598" class="i">+
</a><a href="#h55-0-2599" id="h55-0-2599" class="i">+func (m *AllocateIdsRequest) GetReserve() []*Reference {
</a><a href="#h55-0-2600" id="h55-0-2600" class="i">+	if m != nil {
</a><a href="#h55-0-2601" id="h55-0-2601" class="i">+		return m.Reserve
</a><a href="#h55-0-2602" id="h55-0-2602" class="i">+	}
</a><a href="#h55-0-2603" id="h55-0-2603" class="i">+	return nil
</a><a href="#h55-0-2604" id="h55-0-2604" class="i">+}
</a><a href="#h55-0-2605" id="h55-0-2605" class="i">+
</a><a href="#h55-0-2606" id="h55-0-2606" class="i">+type AllocateIdsResponse struct {
</a><a href="#h55-0-2607" id="h55-0-2607" class="i">+	Start            *int64 `protobuf:&quot;varint,1,req,name=start&quot; json:&quot;start,omitempty&quot;`
</a><a href="#h55-0-2608" id="h55-0-2608" class="i">+	End              *int64 `protobuf:&quot;varint,2,req,name=end&quot; json:&quot;end,omitempty&quot;`
</a><a href="#h55-0-2609" id="h55-0-2609" class="i">+	Cost             *Cost  `protobuf:&quot;bytes,3,opt,name=cost&quot; json:&quot;cost,omitempty&quot;`
</a><a href="#h55-0-2610" id="h55-0-2610" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h55-0-2611" id="h55-0-2611" class="i">+}
</a><a href="#h55-0-2612" id="h55-0-2612" class="i">+
</a><a href="#h55-0-2613" id="h55-0-2613" class="i">+func (m *AllocateIdsResponse) Reset()         { *m = AllocateIdsResponse{} }
</a><a href="#h55-0-2614" id="h55-0-2614" class="i">+func (m *AllocateIdsResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2615" id="h55-0-2615" class="i">+func (*AllocateIdsResponse) ProtoMessage()    {}
</a><a href="#h55-0-2616" id="h55-0-2616" class="i">+
</a><a href="#h55-0-2617" id="h55-0-2617" class="i">+func (m *AllocateIdsResponse) GetStart() int64 {
</a><a href="#h55-0-2618" id="h55-0-2618" class="i">+	if m != nil &amp;&amp; m.Start != nil {
</a><a href="#h55-0-2619" id="h55-0-2619" class="i">+		return *m.Start
</a><a href="#h55-0-2620" id="h55-0-2620" class="i">+	}
</a><a href="#h55-0-2621" id="h55-0-2621" class="i">+	return 0
</a><a href="#h55-0-2622" id="h55-0-2622" class="i">+}
</a><a href="#h55-0-2623" id="h55-0-2623" class="i">+
</a><a href="#h55-0-2624" id="h55-0-2624" class="i">+func (m *AllocateIdsResponse) GetEnd() int64 {
</a><a href="#h55-0-2625" id="h55-0-2625" class="i">+	if m != nil &amp;&amp; m.End != nil {
</a><a href="#h55-0-2626" id="h55-0-2626" class="i">+		return *m.End
</a><a href="#h55-0-2627" id="h55-0-2627" class="i">+	}
</a><a href="#h55-0-2628" id="h55-0-2628" class="i">+	return 0
</a><a href="#h55-0-2629" id="h55-0-2629" class="i">+}
</a><a href="#h55-0-2630" id="h55-0-2630" class="i">+
</a><a href="#h55-0-2631" id="h55-0-2631" class="i">+func (m *AllocateIdsResponse) GetCost() *Cost {
</a><a href="#h55-0-2632" id="h55-0-2632" class="i">+	if m != nil {
</a><a href="#h55-0-2633" id="h55-0-2633" class="i">+		return m.Cost
</a><a href="#h55-0-2634" id="h55-0-2634" class="i">+	}
</a><a href="#h55-0-2635" id="h55-0-2635" class="i">+	return nil
</a><a href="#h55-0-2636" id="h55-0-2636" class="i">+}
</a><a href="#h55-0-2637" id="h55-0-2637" class="i">+
</a><a href="#h55-0-2638" id="h55-0-2638" class="i">+type CompositeIndices struct {
</a><a href="#h55-0-2639" id="h55-0-2639" class="i">+	Index            []*CompositeIndex `protobuf:&quot;bytes,1,rep,name=index&quot; json:&quot;index,omitempty&quot;`
</a><a href="#h55-0-2640" id="h55-0-2640" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h55-0-2641" id="h55-0-2641" class="i">+}
</a><a href="#h55-0-2642" id="h55-0-2642" class="i">+
</a><a href="#h55-0-2643" id="h55-0-2643" class="i">+func (m *CompositeIndices) Reset()         { *m = CompositeIndices{} }
</a><a href="#h55-0-2644" id="h55-0-2644" class="i">+func (m *CompositeIndices) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2645" id="h55-0-2645" class="i">+func (*CompositeIndices) ProtoMessage()    {}
</a><a href="#h55-0-2646" id="h55-0-2646" class="i">+
</a><a href="#h55-0-2647" id="h55-0-2647" class="i">+func (m *CompositeIndices) GetIndex() []*CompositeIndex {
</a><a href="#h55-0-2648" id="h55-0-2648" class="i">+	if m != nil {
</a><a href="#h55-0-2649" id="h55-0-2649" class="i">+		return m.Index
</a><a href="#h55-0-2650" id="h55-0-2650" class="i">+	}
</a><a href="#h55-0-2651" id="h55-0-2651" class="i">+	return nil
</a><a href="#h55-0-2652" id="h55-0-2652" class="i">+}
</a><a href="#h55-0-2653" id="h55-0-2653" class="i">+
</a><a href="#h55-0-2654" id="h55-0-2654" class="i">+type AddActionsRequest struct {
</a><a href="#h55-0-2655" id="h55-0-2655" class="i">+	Header           *InternalHeader `protobuf:&quot;bytes,3,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2656" id="h55-0-2656" class="i">+	Transaction      *Transaction    `protobuf:&quot;bytes,1,req,name=transaction&quot; json:&quot;transaction,omitempty&quot;`
</a><a href="#h55-0-2657" id="h55-0-2657" class="i">+	Action           []*Action       `protobuf:&quot;bytes,2,rep,name=action&quot; json:&quot;action,omitempty&quot;`
</a><a href="#h55-0-2658" id="h55-0-2658" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-2659" id="h55-0-2659" class="i">+}
</a><a href="#h55-0-2660" id="h55-0-2660" class="i">+
</a><a href="#h55-0-2661" id="h55-0-2661" class="i">+func (m *AddActionsRequest) Reset()         { *m = AddActionsRequest{} }
</a><a href="#h55-0-2662" id="h55-0-2662" class="i">+func (m *AddActionsRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2663" id="h55-0-2663" class="i">+func (*AddActionsRequest) ProtoMessage()    {}
</a><a href="#h55-0-2664" id="h55-0-2664" class="i">+
</a><a href="#h55-0-2665" id="h55-0-2665" class="i">+func (m *AddActionsRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2666" id="h55-0-2666" class="i">+	if m != nil {
</a><a href="#h55-0-2667" id="h55-0-2667" class="i">+		return m.Header
</a><a href="#h55-0-2668" id="h55-0-2668" class="i">+	}
</a><a href="#h55-0-2669" id="h55-0-2669" class="i">+	return nil
</a><a href="#h55-0-2670" id="h55-0-2670" class="i">+}
</a><a href="#h55-0-2671" id="h55-0-2671" class="i">+
</a><a href="#h55-0-2672" id="h55-0-2672" class="i">+func (m *AddActionsRequest) GetTransaction() *Transaction {
</a><a href="#h55-0-2673" id="h55-0-2673" class="i">+	if m != nil {
</a><a href="#h55-0-2674" id="h55-0-2674" class="i">+		return m.Transaction
</a><a href="#h55-0-2675" id="h55-0-2675" class="i">+	}
</a><a href="#h55-0-2676" id="h55-0-2676" class="i">+	return nil
</a><a href="#h55-0-2677" id="h55-0-2677" class="i">+}
</a><a href="#h55-0-2678" id="h55-0-2678" class="i">+
</a><a href="#h55-0-2679" id="h55-0-2679" class="i">+func (m *AddActionsRequest) GetAction() []*Action {
</a><a href="#h55-0-2680" id="h55-0-2680" class="i">+	if m != nil {
</a><a href="#h55-0-2681" id="h55-0-2681" class="i">+		return m.Action
</a><a href="#h55-0-2682" id="h55-0-2682" class="i">+	}
</a><a href="#h55-0-2683" id="h55-0-2683" class="i">+	return nil
</a><a href="#h55-0-2684" id="h55-0-2684" class="i">+}
</a><a href="#h55-0-2685" id="h55-0-2685" class="i">+
</a><a href="#h55-0-2686" id="h55-0-2686" class="i">+type AddActionsResponse struct {
</a><a href="#h55-0-2687" id="h55-0-2687" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h55-0-2688" id="h55-0-2688" class="i">+}
</a><a href="#h55-0-2689" id="h55-0-2689" class="i">+
</a><a href="#h55-0-2690" id="h55-0-2690" class="i">+func (m *AddActionsResponse) Reset()         { *m = AddActionsResponse{} }
</a><a href="#h55-0-2691" id="h55-0-2691" class="i">+func (m *AddActionsResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2692" id="h55-0-2692" class="i">+func (*AddActionsResponse) ProtoMessage()    {}
</a><a href="#h55-0-2693" id="h55-0-2693" class="i">+
</a><a href="#h55-0-2694" id="h55-0-2694" class="i">+type BeginTransactionRequest struct {
</a><a href="#h55-0-2695" id="h55-0-2695" class="i">+	Header           *InternalHeader `protobuf:&quot;bytes,3,opt,name=header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h55-0-2696" id="h55-0-2696" class="i">+	App              *string         `protobuf:&quot;bytes,1,req,name=app&quot; json:&quot;app,omitempty&quot;`
</a><a href="#h55-0-2697" id="h55-0-2697" class="i">+	AllowMultipleEg  *bool           `protobuf:&quot;varint,2,opt,name=allow_multiple_eg,def=0&quot; json:&quot;allow_multiple_eg,omitempty&quot;`
</a><a href="#h55-0-2698" id="h55-0-2698" class="i">+	XXX_unrecognized []byte          `json:&quot;-&quot;`
</a><a href="#h55-0-2699" id="h55-0-2699" class="i">+}
</a><a href="#h55-0-2700" id="h55-0-2700" class="i">+
</a><a href="#h55-0-2701" id="h55-0-2701" class="i">+func (m *BeginTransactionRequest) Reset()         { *m = BeginTransactionRequest{} }
</a><a href="#h55-0-2702" id="h55-0-2702" class="i">+func (m *BeginTransactionRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2703" id="h55-0-2703" class="i">+func (*BeginTransactionRequest) ProtoMessage()    {}
</a><a href="#h55-0-2704" id="h55-0-2704" class="i">+
</a><a href="#h55-0-2705" id="h55-0-2705" class="i">+const Default_BeginTransactionRequest_AllowMultipleEg bool = false
</a><a href="#h55-0-2706" id="h55-0-2706" class="i">+
</a><a href="#h55-0-2707" id="h55-0-2707" class="i">+func (m *BeginTransactionRequest) GetHeader() *InternalHeader {
</a><a href="#h55-0-2708" id="h55-0-2708" class="i">+	if m != nil {
</a><a href="#h55-0-2709" id="h55-0-2709" class="i">+		return m.Header
</a><a href="#h55-0-2710" id="h55-0-2710" class="i">+	}
</a><a href="#h55-0-2711" id="h55-0-2711" class="i">+	return nil
</a><a href="#h55-0-2712" id="h55-0-2712" class="i">+}
</a><a href="#h55-0-2713" id="h55-0-2713" class="i">+
</a><a href="#h55-0-2714" id="h55-0-2714" class="i">+func (m *BeginTransactionRequest) GetApp() string {
</a><a href="#h55-0-2715" id="h55-0-2715" class="i">+	if m != nil &amp;&amp; m.App != nil {
</a><a href="#h55-0-2716" id="h55-0-2716" class="i">+		return *m.App
</a><a href="#h55-0-2717" id="h55-0-2717" class="i">+	}
</a><a href="#h55-0-2718" id="h55-0-2718" class="i">+	return &quot;&quot;
</a><a href="#h55-0-2719" id="h55-0-2719" class="i">+}
</a><a href="#h55-0-2720" id="h55-0-2720" class="i">+
</a><a href="#h55-0-2721" id="h55-0-2721" class="i">+func (m *BeginTransactionRequest) GetAllowMultipleEg() bool {
</a><a href="#h55-0-2722" id="h55-0-2722" class="i">+	if m != nil &amp;&amp; m.AllowMultipleEg != nil {
</a><a href="#h55-0-2723" id="h55-0-2723" class="i">+		return *m.AllowMultipleEg
</a><a href="#h55-0-2724" id="h55-0-2724" class="i">+	}
</a><a href="#h55-0-2725" id="h55-0-2725" class="i">+	return Default_BeginTransactionRequest_AllowMultipleEg
</a><a href="#h55-0-2726" id="h55-0-2726" class="i">+}
</a><a href="#h55-0-2727" id="h55-0-2727" class="i">+
</a><a href="#h55-0-2728" id="h55-0-2728" class="i">+type CommitResponse struct {
</a><a href="#h55-0-2729" id="h55-0-2729" class="i">+	Cost             *Cost                     `protobuf:&quot;bytes,1,opt,name=cost&quot; json:&quot;cost,omitempty&quot;`
</a><a href="#h55-0-2730" id="h55-0-2730" class="i">+	Version          []*CommitResponse_Version `protobuf:&quot;group,3,rep,name=Version&quot; json:&quot;version,omitempty&quot;`
</a><a href="#h55-0-2731" id="h55-0-2731" class="i">+	XXX_unrecognized []byte                    `json:&quot;-&quot;`
</a><a href="#h55-0-2732" id="h55-0-2732" class="i">+}
</a><a href="#h55-0-2733" id="h55-0-2733" class="i">+
</a><a href="#h55-0-2734" id="h55-0-2734" class="i">+func (m *CommitResponse) Reset()         { *m = CommitResponse{} }
</a><a href="#h55-0-2735" id="h55-0-2735" class="i">+func (m *CommitResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2736" id="h55-0-2736" class="i">+func (*CommitResponse) ProtoMessage()    {}
</a><a href="#h55-0-2737" id="h55-0-2737" class="i">+
</a><a href="#h55-0-2738" id="h55-0-2738" class="i">+func (m *CommitResponse) GetCost() *Cost {
</a><a href="#h55-0-2739" id="h55-0-2739" class="i">+	if m != nil {
</a><a href="#h55-0-2740" id="h55-0-2740" class="i">+		return m.Cost
</a><a href="#h55-0-2741" id="h55-0-2741" class="i">+	}
</a><a href="#h55-0-2742" id="h55-0-2742" class="i">+	return nil
</a><a href="#h55-0-2743" id="h55-0-2743" class="i">+}
</a><a href="#h55-0-2744" id="h55-0-2744" class="i">+
</a><a href="#h55-0-2745" id="h55-0-2745" class="i">+func (m *CommitResponse) GetVersion() []*CommitResponse_Version {
</a><a href="#h55-0-2746" id="h55-0-2746" class="i">+	if m != nil {
</a><a href="#h55-0-2747" id="h55-0-2747" class="i">+		return m.Version
</a><a href="#h55-0-2748" id="h55-0-2748" class="i">+	}
</a><a href="#h55-0-2749" id="h55-0-2749" class="i">+	return nil
</a><a href="#h55-0-2750" id="h55-0-2750" class="i">+}
</a><a href="#h55-0-2751" id="h55-0-2751" class="i">+
</a><a href="#h55-0-2752" id="h55-0-2752" class="i">+type CommitResponse_Version struct {
</a><a href="#h55-0-2753" id="h55-0-2753" class="i">+	RootEntityKey    *Reference `protobuf:&quot;bytes,4,req,name=root_entity_key&quot; json:&quot;root_entity_key,omitempty&quot;`
</a><a href="#h55-0-2754" id="h55-0-2754" class="i">+	Version          *int64     `protobuf:&quot;varint,5,req,name=version&quot; json:&quot;version,omitempty&quot;`
</a><a href="#h55-0-2755" id="h55-0-2755" class="i">+	XXX_unrecognized []byte     `json:&quot;-&quot;`
</a><a href="#h55-0-2756" id="h55-0-2756" class="i">+}
</a><a href="#h55-0-2757" id="h55-0-2757" class="i">+
</a><a href="#h55-0-2758" id="h55-0-2758" class="i">+func (m *CommitResponse_Version) Reset()         { *m = CommitResponse_Version{} }
</a><a href="#h55-0-2759" id="h55-0-2759" class="i">+func (m *CommitResponse_Version) String() string { return proto.CompactTextString(m) }
</a><a href="#h55-0-2760" id="h55-0-2760" class="i">+func (*CommitResponse_Version) ProtoMessage()    {}
</a><a href="#h55-0-2761" id="h55-0-2761" class="i">+
</a><a href="#h55-0-2762" id="h55-0-2762" class="i">+func (m *CommitResponse_Version) GetRootEntityKey() *Reference {
</a><a href="#h55-0-2763" id="h55-0-2763" class="i">+	if m != nil {
</a><a href="#h55-0-2764" id="h55-0-2764" class="i">+		return m.RootEntityKey
</a><a href="#h55-0-2765" id="h55-0-2765" class="i">+	}
</a><a href="#h55-0-2766" id="h55-0-2766" class="i">+	return nil
</a><a href="#h55-0-2767" id="h55-0-2767" class="i">+}
</a><a href="#h55-0-2768" id="h55-0-2768" class="i">+
</a><a href="#h55-0-2769" id="h55-0-2769" class="i">+func (m *CommitResponse_Version) GetVersion() int64 {
</a><a href="#h55-0-2770" id="h55-0-2770" class="i">+	if m != nil &amp;&amp; m.Version != nil {
</a><a href="#h55-0-2771" id="h55-0-2771" class="i">+		return *m.Version
</a><a href="#h55-0-2772" id="h55-0-2772" class="i">+	}
</a><a href="#h55-0-2773" id="h55-0-2773" class="i">+	return 0
</a><a href="#h55-0-2774" id="h55-0-2774" class="i">+}
</a><a href="#h55-0-2775" id="h55-0-2775" class="i">+
</a><a href="#h55-0-2776" id="h55-0-2776" class="i">+func init() {
</a><a href="#h55-0-2777" id="h55-0-2777" class="i">+}
</a><b>diff --git a/<a id="h56" href="../file/vendor/google.golang.org/appengine/internal/datastore/datastore_v3.proto">vendor/google.golang.org/appengine/internal/datastore/datastore_v3.proto</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/datastore/datastore_v3.proto">vendor/google.golang.org/appengine/internal/datastore/datastore_v3.proto</a></b>
<a href="#h56-0" id="h56-0" class="h">@@ -0,0 +1,541 @@
</a><a href="#h56-0-0" id="h56-0-0" class="i">+syntax = &quot;proto2&quot;;
</a><a href="#h56-0-1" id="h56-0-1" class="i">+option go_package = &quot;datastore&quot;;
</a><a href="#h56-0-2" id="h56-0-2" class="i">+
</a><a href="#h56-0-3" id="h56-0-3" class="i">+package appengine;
</a><a href="#h56-0-4" id="h56-0-4" class="i">+
</a><a href="#h56-0-5" id="h56-0-5" class="i">+message Action{}
</a><a href="#h56-0-6" id="h56-0-6" class="i">+
</a><a href="#h56-0-7" id="h56-0-7" class="i">+message PropertyValue {
</a><a href="#h56-0-8" id="h56-0-8" class="i">+  optional int64 int64Value = 1;
</a><a href="#h56-0-9" id="h56-0-9" class="i">+  optional bool booleanValue = 2;
</a><a href="#h56-0-10" id="h56-0-10" class="i">+  optional string stringValue = 3;
</a><a href="#h56-0-11" id="h56-0-11" class="i">+  optional double doubleValue = 4;
</a><a href="#h56-0-12" id="h56-0-12" class="i">+
</a><a href="#h56-0-13" id="h56-0-13" class="i">+  optional group PointValue = 5 {
</a><a href="#h56-0-14" id="h56-0-14" class="i">+    required double x = 6;
</a><a href="#h56-0-15" id="h56-0-15" class="i">+    required double y = 7;
</a><a href="#h56-0-16" id="h56-0-16" class="i">+  }
</a><a href="#h56-0-17" id="h56-0-17" class="i">+
</a><a href="#h56-0-18" id="h56-0-18" class="i">+  optional group UserValue = 8 {
</a><a href="#h56-0-19" id="h56-0-19" class="i">+    required string email = 9;
</a><a href="#h56-0-20" id="h56-0-20" class="i">+    required string auth_domain = 10;
</a><a href="#h56-0-21" id="h56-0-21" class="i">+    optional string nickname = 11;
</a><a href="#h56-0-22" id="h56-0-22" class="i">+    optional string federated_identity = 21;
</a><a href="#h56-0-23" id="h56-0-23" class="i">+    optional string federated_provider = 22;
</a><a href="#h56-0-24" id="h56-0-24" class="i">+  }
</a><a href="#h56-0-25" id="h56-0-25" class="i">+
</a><a href="#h56-0-26" id="h56-0-26" class="i">+  optional group ReferenceValue = 12 {
</a><a href="#h56-0-27" id="h56-0-27" class="i">+    required string app = 13;
</a><a href="#h56-0-28" id="h56-0-28" class="i">+    optional string name_space = 20;
</a><a href="#h56-0-29" id="h56-0-29" class="i">+    repeated group PathElement = 14 {
</a><a href="#h56-0-30" id="h56-0-30" class="i">+      required string type = 15;
</a><a href="#h56-0-31" id="h56-0-31" class="i">+      optional int64 id = 16;
</a><a href="#h56-0-32" id="h56-0-32" class="i">+      optional string name = 17;
</a><a href="#h56-0-33" id="h56-0-33" class="i">+    }
</a><a href="#h56-0-34" id="h56-0-34" class="i">+  }
</a><a href="#h56-0-35" id="h56-0-35" class="i">+}
</a><a href="#h56-0-36" id="h56-0-36" class="i">+
</a><a href="#h56-0-37" id="h56-0-37" class="i">+message Property {
</a><a href="#h56-0-38" id="h56-0-38" class="i">+  enum Meaning {
</a><a href="#h56-0-39" id="h56-0-39" class="i">+    NO_MEANING = 0;
</a><a href="#h56-0-40" id="h56-0-40" class="i">+    BLOB = 14;
</a><a href="#h56-0-41" id="h56-0-41" class="i">+    TEXT = 15;
</a><a href="#h56-0-42" id="h56-0-42" class="i">+    BYTESTRING = 16;
</a><a href="#h56-0-43" id="h56-0-43" class="i">+
</a><a href="#h56-0-44" id="h56-0-44" class="i">+    ATOM_CATEGORY = 1;
</a><a href="#h56-0-45" id="h56-0-45" class="i">+    ATOM_LINK = 2;
</a><a href="#h56-0-46" id="h56-0-46" class="i">+    ATOM_TITLE = 3;
</a><a href="#h56-0-47" id="h56-0-47" class="i">+    ATOM_CONTENT = 4;
</a><a href="#h56-0-48" id="h56-0-48" class="i">+    ATOM_SUMMARY = 5;
</a><a href="#h56-0-49" id="h56-0-49" class="i">+    ATOM_AUTHOR = 6;
</a><a href="#h56-0-50" id="h56-0-50" class="i">+
</a><a href="#h56-0-51" id="h56-0-51" class="i">+    GD_WHEN = 7;
</a><a href="#h56-0-52" id="h56-0-52" class="i">+    GD_EMAIL = 8;
</a><a href="#h56-0-53" id="h56-0-53" class="i">+    GEORSS_POINT = 9;
</a><a href="#h56-0-54" id="h56-0-54" class="i">+    GD_IM = 10;
</a><a href="#h56-0-55" id="h56-0-55" class="i">+
</a><a href="#h56-0-56" id="h56-0-56" class="i">+    GD_PHONENUMBER = 11;
</a><a href="#h56-0-57" id="h56-0-57" class="i">+    GD_POSTALADDRESS = 12;
</a><a href="#h56-0-58" id="h56-0-58" class="i">+
</a><a href="#h56-0-59" id="h56-0-59" class="i">+    GD_RATING = 13;
</a><a href="#h56-0-60" id="h56-0-60" class="i">+
</a><a href="#h56-0-61" id="h56-0-61" class="i">+    BLOBKEY = 17;
</a><a href="#h56-0-62" id="h56-0-62" class="i">+    ENTITY_PROTO = 19;
</a><a href="#h56-0-63" id="h56-0-63" class="i">+
</a><a href="#h56-0-64" id="h56-0-64" class="i">+    INDEX_VALUE = 18;
</a><a href="#h56-0-65" id="h56-0-65" class="i">+  };
</a><a href="#h56-0-66" id="h56-0-66" class="i">+
</a><a href="#h56-0-67" id="h56-0-67" class="i">+  optional Meaning meaning = 1 [default = NO_MEANING];
</a><a href="#h56-0-68" id="h56-0-68" class="i">+  optional string meaning_uri = 2;
</a><a href="#h56-0-69" id="h56-0-69" class="i">+
</a><a href="#h56-0-70" id="h56-0-70" class="i">+  required string name = 3;
</a><a href="#h56-0-71" id="h56-0-71" class="i">+
</a><a href="#h56-0-72" id="h56-0-72" class="i">+  required PropertyValue value = 5;
</a><a href="#h56-0-73" id="h56-0-73" class="i">+
</a><a href="#h56-0-74" id="h56-0-74" class="i">+  required bool multiple = 4;
</a><a href="#h56-0-75" id="h56-0-75" class="i">+
</a><a href="#h56-0-76" id="h56-0-76" class="i">+  optional bool searchable = 6 [default=false];
</a><a href="#h56-0-77" id="h56-0-77" class="i">+
</a><a href="#h56-0-78" id="h56-0-78" class="i">+  enum FtsTokenizationOption {
</a><a href="#h56-0-79" id="h56-0-79" class="i">+    HTML = 1;
</a><a href="#h56-0-80" id="h56-0-80" class="i">+    ATOM = 2;
</a><a href="#h56-0-81" id="h56-0-81" class="i">+  }
</a><a href="#h56-0-82" id="h56-0-82" class="i">+
</a><a href="#h56-0-83" id="h56-0-83" class="i">+  optional FtsTokenizationOption fts_tokenization_option = 8;
</a><a href="#h56-0-84" id="h56-0-84" class="i">+
</a><a href="#h56-0-85" id="h56-0-85" class="i">+  optional string locale = 9 [default = &quot;en&quot;];
</a><a href="#h56-0-86" id="h56-0-86" class="i">+}
</a><a href="#h56-0-87" id="h56-0-87" class="i">+
</a><a href="#h56-0-88" id="h56-0-88" class="i">+message Path {
</a><a href="#h56-0-89" id="h56-0-89" class="i">+  repeated group Element = 1 {
</a><a href="#h56-0-90" id="h56-0-90" class="i">+    required string type = 2;
</a><a href="#h56-0-91" id="h56-0-91" class="i">+    optional int64 id = 3;
</a><a href="#h56-0-92" id="h56-0-92" class="i">+    optional string name = 4;
</a><a href="#h56-0-93" id="h56-0-93" class="i">+  }
</a><a href="#h56-0-94" id="h56-0-94" class="i">+}
</a><a href="#h56-0-95" id="h56-0-95" class="i">+
</a><a href="#h56-0-96" id="h56-0-96" class="i">+message Reference {
</a><a href="#h56-0-97" id="h56-0-97" class="i">+  required string app = 13;
</a><a href="#h56-0-98" id="h56-0-98" class="i">+  optional string name_space = 20;
</a><a href="#h56-0-99" id="h56-0-99" class="i">+  required Path path = 14;
</a><a href="#h56-0-100" id="h56-0-100" class="i">+}
</a><a href="#h56-0-101" id="h56-0-101" class="i">+
</a><a href="#h56-0-102" id="h56-0-102" class="i">+message User {
</a><a href="#h56-0-103" id="h56-0-103" class="i">+  required string email = 1;
</a><a href="#h56-0-104" id="h56-0-104" class="i">+  required string auth_domain = 2;
</a><a href="#h56-0-105" id="h56-0-105" class="i">+  optional string nickname = 3;
</a><a href="#h56-0-106" id="h56-0-106" class="i">+  optional string federated_identity = 6;
</a><a href="#h56-0-107" id="h56-0-107" class="i">+  optional string federated_provider = 7;
</a><a href="#h56-0-108" id="h56-0-108" class="i">+}
</a><a href="#h56-0-109" id="h56-0-109" class="i">+
</a><a href="#h56-0-110" id="h56-0-110" class="i">+message EntityProto {
</a><a href="#h56-0-111" id="h56-0-111" class="i">+  required Reference key = 13;
</a><a href="#h56-0-112" id="h56-0-112" class="i">+  required Path entity_group = 16;
</a><a href="#h56-0-113" id="h56-0-113" class="i">+  optional User owner = 17;
</a><a href="#h56-0-114" id="h56-0-114" class="i">+
</a><a href="#h56-0-115" id="h56-0-115" class="i">+  enum Kind {
</a><a href="#h56-0-116" id="h56-0-116" class="i">+    GD_CONTACT = 1;
</a><a href="#h56-0-117" id="h56-0-117" class="i">+    GD_EVENT = 2;
</a><a href="#h56-0-118" id="h56-0-118" class="i">+    GD_MESSAGE = 3;
</a><a href="#h56-0-119" id="h56-0-119" class="i">+  }
</a><a href="#h56-0-120" id="h56-0-120" class="i">+  optional Kind kind = 4;
</a><a href="#h56-0-121" id="h56-0-121" class="i">+  optional string kind_uri = 5;
</a><a href="#h56-0-122" id="h56-0-122" class="i">+
</a><a href="#h56-0-123" id="h56-0-123" class="i">+  repeated Property property = 14;
</a><a href="#h56-0-124" id="h56-0-124" class="i">+  repeated Property raw_property = 15;
</a><a href="#h56-0-125" id="h56-0-125" class="i">+
</a><a href="#h56-0-126" id="h56-0-126" class="i">+  optional int32 rank = 18;
</a><a href="#h56-0-127" id="h56-0-127" class="i">+}
</a><a href="#h56-0-128" id="h56-0-128" class="i">+
</a><a href="#h56-0-129" id="h56-0-129" class="i">+message CompositeProperty {
</a><a href="#h56-0-130" id="h56-0-130" class="i">+  required int64 index_id = 1;
</a><a href="#h56-0-131" id="h56-0-131" class="i">+  repeated string value = 2;
</a><a href="#h56-0-132" id="h56-0-132" class="i">+}
</a><a href="#h56-0-133" id="h56-0-133" class="i">+
</a><a href="#h56-0-134" id="h56-0-134" class="i">+message Index {
</a><a href="#h56-0-135" id="h56-0-135" class="i">+  required string entity_type = 1;
</a><a href="#h56-0-136" id="h56-0-136" class="i">+  required bool ancestor = 5;
</a><a href="#h56-0-137" id="h56-0-137" class="i">+  repeated group Property = 2 {
</a><a href="#h56-0-138" id="h56-0-138" class="i">+    required string name = 3;
</a><a href="#h56-0-139" id="h56-0-139" class="i">+    enum Direction {
</a><a href="#h56-0-140" id="h56-0-140" class="i">+      ASCENDING = 1;
</a><a href="#h56-0-141" id="h56-0-141" class="i">+      DESCENDING = 2;
</a><a href="#h56-0-142" id="h56-0-142" class="i">+    }
</a><a href="#h56-0-143" id="h56-0-143" class="i">+    optional Direction direction = 4 [default = ASCENDING];
</a><a href="#h56-0-144" id="h56-0-144" class="i">+  }
</a><a href="#h56-0-145" id="h56-0-145" class="i">+}
</a><a href="#h56-0-146" id="h56-0-146" class="i">+
</a><a href="#h56-0-147" id="h56-0-147" class="i">+message CompositeIndex {
</a><a href="#h56-0-148" id="h56-0-148" class="i">+  required string app_id = 1;
</a><a href="#h56-0-149" id="h56-0-149" class="i">+  required int64 id = 2;
</a><a href="#h56-0-150" id="h56-0-150" class="i">+  required Index definition = 3;
</a><a href="#h56-0-151" id="h56-0-151" class="i">+
</a><a href="#h56-0-152" id="h56-0-152" class="i">+  enum State {
</a><a href="#h56-0-153" id="h56-0-153" class="i">+    WRITE_ONLY = 1;
</a><a href="#h56-0-154" id="h56-0-154" class="i">+    READ_WRITE = 2;
</a><a href="#h56-0-155" id="h56-0-155" class="i">+    DELETED = 3;
</a><a href="#h56-0-156" id="h56-0-156" class="i">+    ERROR = 4;
</a><a href="#h56-0-157" id="h56-0-157" class="i">+  }
</a><a href="#h56-0-158" id="h56-0-158" class="i">+  required State state = 4;
</a><a href="#h56-0-159" id="h56-0-159" class="i">+
</a><a href="#h56-0-160" id="h56-0-160" class="i">+  optional bool only_use_if_required = 6 [default = false];
</a><a href="#h56-0-161" id="h56-0-161" class="i">+}
</a><a href="#h56-0-162" id="h56-0-162" class="i">+
</a><a href="#h56-0-163" id="h56-0-163" class="i">+message IndexPostfix {
</a><a href="#h56-0-164" id="h56-0-164" class="i">+  message IndexValue {
</a><a href="#h56-0-165" id="h56-0-165" class="i">+    required string property_name = 1;
</a><a href="#h56-0-166" id="h56-0-166" class="i">+    required PropertyValue value = 2;
</a><a href="#h56-0-167" id="h56-0-167" class="i">+  }
</a><a href="#h56-0-168" id="h56-0-168" class="i">+
</a><a href="#h56-0-169" id="h56-0-169" class="i">+  repeated IndexValue index_value = 1;
</a><a href="#h56-0-170" id="h56-0-170" class="i">+
</a><a href="#h56-0-171" id="h56-0-171" class="i">+  optional Reference key = 2;
</a><a href="#h56-0-172" id="h56-0-172" class="i">+
</a><a href="#h56-0-173" id="h56-0-173" class="i">+  optional bool before = 3 [default=true];
</a><a href="#h56-0-174" id="h56-0-174" class="i">+}
</a><a href="#h56-0-175" id="h56-0-175" class="i">+
</a><a href="#h56-0-176" id="h56-0-176" class="i">+message IndexPosition {
</a><a href="#h56-0-177" id="h56-0-177" class="i">+  optional string key = 1;
</a><a href="#h56-0-178" id="h56-0-178" class="i">+
</a><a href="#h56-0-179" id="h56-0-179" class="i">+  optional bool before = 2 [default=true];
</a><a href="#h56-0-180" id="h56-0-180" class="i">+}
</a><a href="#h56-0-181" id="h56-0-181" class="i">+
</a><a href="#h56-0-182" id="h56-0-182" class="i">+message Snapshot {
</a><a href="#h56-0-183" id="h56-0-183" class="i">+  enum Status {
</a><a href="#h56-0-184" id="h56-0-184" class="i">+    INACTIVE = 0;
</a><a href="#h56-0-185" id="h56-0-185" class="i">+    ACTIVE = 1;
</a><a href="#h56-0-186" id="h56-0-186" class="i">+  }
</a><a href="#h56-0-187" id="h56-0-187" class="i">+
</a><a href="#h56-0-188" id="h56-0-188" class="i">+  required int64 ts = 1;
</a><a href="#h56-0-189" id="h56-0-189" class="i">+}
</a><a href="#h56-0-190" id="h56-0-190" class="i">+
</a><a href="#h56-0-191" id="h56-0-191" class="i">+message InternalHeader {
</a><a href="#h56-0-192" id="h56-0-192" class="i">+  optional string qos = 1;
</a><a href="#h56-0-193" id="h56-0-193" class="i">+}
</a><a href="#h56-0-194" id="h56-0-194" class="i">+
</a><a href="#h56-0-195" id="h56-0-195" class="i">+message Transaction {
</a><a href="#h56-0-196" id="h56-0-196" class="i">+  optional InternalHeader header = 4;
</a><a href="#h56-0-197" id="h56-0-197" class="i">+  required fixed64 handle = 1;
</a><a href="#h56-0-198" id="h56-0-198" class="i">+  required string app = 2;
</a><a href="#h56-0-199" id="h56-0-199" class="i">+  optional bool mark_changes = 3 [default = false];
</a><a href="#h56-0-200" id="h56-0-200" class="i">+}
</a><a href="#h56-0-201" id="h56-0-201" class="i">+
</a><a href="#h56-0-202" id="h56-0-202" class="i">+message Query {
</a><a href="#h56-0-203" id="h56-0-203" class="i">+  optional InternalHeader header = 39;
</a><a href="#h56-0-204" id="h56-0-204" class="i">+
</a><a href="#h56-0-205" id="h56-0-205" class="i">+  required string app = 1;
</a><a href="#h56-0-206" id="h56-0-206" class="i">+  optional string name_space = 29;
</a><a href="#h56-0-207" id="h56-0-207" class="i">+
</a><a href="#h56-0-208" id="h56-0-208" class="i">+  optional string kind = 3;
</a><a href="#h56-0-209" id="h56-0-209" class="i">+  optional Reference ancestor = 17;
</a><a href="#h56-0-210" id="h56-0-210" class="i">+
</a><a href="#h56-0-211" id="h56-0-211" class="i">+  repeated group Filter = 4 {
</a><a href="#h56-0-212" id="h56-0-212" class="i">+    enum Operator {
</a><a href="#h56-0-213" id="h56-0-213" class="i">+      LESS_THAN = 1;
</a><a href="#h56-0-214" id="h56-0-214" class="i">+      LESS_THAN_OR_EQUAL = 2;
</a><a href="#h56-0-215" id="h56-0-215" class="i">+      GREATER_THAN = 3;
</a><a href="#h56-0-216" id="h56-0-216" class="i">+      GREATER_THAN_OR_EQUAL = 4;
</a><a href="#h56-0-217" id="h56-0-217" class="i">+      EQUAL = 5;
</a><a href="#h56-0-218" id="h56-0-218" class="i">+      IN = 6;
</a><a href="#h56-0-219" id="h56-0-219" class="i">+      EXISTS = 7;
</a><a href="#h56-0-220" id="h56-0-220" class="i">+    }
</a><a href="#h56-0-221" id="h56-0-221" class="i">+
</a><a href="#h56-0-222" id="h56-0-222" class="i">+    required Operator op = 6;
</a><a href="#h56-0-223" id="h56-0-223" class="i">+    repeated Property property = 14;
</a><a href="#h56-0-224" id="h56-0-224" class="i">+  }
</a><a href="#h56-0-225" id="h56-0-225" class="i">+
</a><a href="#h56-0-226" id="h56-0-226" class="i">+  optional string search_query = 8;
</a><a href="#h56-0-227" id="h56-0-227" class="i">+
</a><a href="#h56-0-228" id="h56-0-228" class="i">+  repeated group Order = 9 {
</a><a href="#h56-0-229" id="h56-0-229" class="i">+    enum Direction {
</a><a href="#h56-0-230" id="h56-0-230" class="i">+      ASCENDING = 1;
</a><a href="#h56-0-231" id="h56-0-231" class="i">+      DESCENDING = 2;
</a><a href="#h56-0-232" id="h56-0-232" class="i">+    }
</a><a href="#h56-0-233" id="h56-0-233" class="i">+
</a><a href="#h56-0-234" id="h56-0-234" class="i">+    required string property = 10;
</a><a href="#h56-0-235" id="h56-0-235" class="i">+    optional Direction direction = 11 [default = ASCENDING];
</a><a href="#h56-0-236" id="h56-0-236" class="i">+  }
</a><a href="#h56-0-237" id="h56-0-237" class="i">+
</a><a href="#h56-0-238" id="h56-0-238" class="i">+  enum Hint {
</a><a href="#h56-0-239" id="h56-0-239" class="i">+    ORDER_FIRST = 1;
</a><a href="#h56-0-240" id="h56-0-240" class="i">+    ANCESTOR_FIRST = 2;
</a><a href="#h56-0-241" id="h56-0-241" class="i">+    FILTER_FIRST = 3;
</a><a href="#h56-0-242" id="h56-0-242" class="i">+  }
</a><a href="#h56-0-243" id="h56-0-243" class="i">+  optional Hint hint = 18;
</a><a href="#h56-0-244" id="h56-0-244" class="i">+
</a><a href="#h56-0-245" id="h56-0-245" class="i">+  optional int32 count = 23;
</a><a href="#h56-0-246" id="h56-0-246" class="i">+
</a><a href="#h56-0-247" id="h56-0-247" class="i">+  optional int32 offset = 12 [default = 0];
</a><a href="#h56-0-248" id="h56-0-248" class="i">+
</a><a href="#h56-0-249" id="h56-0-249" class="i">+  optional int32 limit = 16;
</a><a href="#h56-0-250" id="h56-0-250" class="i">+
</a><a href="#h56-0-251" id="h56-0-251" class="i">+  optional CompiledCursor compiled_cursor = 30;
</a><a href="#h56-0-252" id="h56-0-252" class="i">+  optional CompiledCursor end_compiled_cursor = 31;
</a><a href="#h56-0-253" id="h56-0-253" class="i">+
</a><a href="#h56-0-254" id="h56-0-254" class="i">+  repeated CompositeIndex composite_index = 19;
</a><a href="#h56-0-255" id="h56-0-255" class="i">+
</a><a href="#h56-0-256" id="h56-0-256" class="i">+  optional bool require_perfect_plan = 20 [default = false];
</a><a href="#h56-0-257" id="h56-0-257" class="i">+
</a><a href="#h56-0-258" id="h56-0-258" class="i">+  optional bool keys_only = 21 [default = false];
</a><a href="#h56-0-259" id="h56-0-259" class="i">+
</a><a href="#h56-0-260" id="h56-0-260" class="i">+  optional Transaction transaction = 22;
</a><a href="#h56-0-261" id="h56-0-261" class="i">+
</a><a href="#h56-0-262" id="h56-0-262" class="i">+  optional bool compile = 25 [default = false];
</a><a href="#h56-0-263" id="h56-0-263" class="i">+
</a><a href="#h56-0-264" id="h56-0-264" class="i">+  optional int64 failover_ms = 26;
</a><a href="#h56-0-265" id="h56-0-265" class="i">+
</a><a href="#h56-0-266" id="h56-0-266" class="i">+  optional bool strong = 32;
</a><a href="#h56-0-267" id="h56-0-267" class="i">+
</a><a href="#h56-0-268" id="h56-0-268" class="i">+  repeated string property_name = 33;
</a><a href="#h56-0-269" id="h56-0-269" class="i">+
</a><a href="#h56-0-270" id="h56-0-270" class="i">+  repeated string group_by_property_name = 34;
</a><a href="#h56-0-271" id="h56-0-271" class="i">+
</a><a href="#h56-0-272" id="h56-0-272" class="i">+  optional bool distinct = 24;
</a><a href="#h56-0-273" id="h56-0-273" class="i">+
</a><a href="#h56-0-274" id="h56-0-274" class="i">+  optional int64 min_safe_time_seconds = 35;
</a><a href="#h56-0-275" id="h56-0-275" class="i">+
</a><a href="#h56-0-276" id="h56-0-276" class="i">+  repeated string safe_replica_name = 36;
</a><a href="#h56-0-277" id="h56-0-277" class="i">+
</a><a href="#h56-0-278" id="h56-0-278" class="i">+  optional bool persist_offset = 37 [default=false];
</a><a href="#h56-0-279" id="h56-0-279" class="i">+}
</a><a href="#h56-0-280" id="h56-0-280" class="i">+
</a><a href="#h56-0-281" id="h56-0-281" class="i">+message CompiledQuery {
</a><a href="#h56-0-282" id="h56-0-282" class="i">+  required group PrimaryScan = 1 {
</a><a href="#h56-0-283" id="h56-0-283" class="i">+    optional string index_name = 2;
</a><a href="#h56-0-284" id="h56-0-284" class="i">+
</a><a href="#h56-0-285" id="h56-0-285" class="i">+    optional string start_key = 3;
</a><a href="#h56-0-286" id="h56-0-286" class="i">+    optional bool start_inclusive = 4;
</a><a href="#h56-0-287" id="h56-0-287" class="i">+    optional string end_key = 5;
</a><a href="#h56-0-288" id="h56-0-288" class="i">+    optional bool end_inclusive = 6;
</a><a href="#h56-0-289" id="h56-0-289" class="i">+
</a><a href="#h56-0-290" id="h56-0-290" class="i">+    repeated string start_postfix_value = 22;
</a><a href="#h56-0-291" id="h56-0-291" class="i">+    repeated string end_postfix_value = 23;
</a><a href="#h56-0-292" id="h56-0-292" class="i">+
</a><a href="#h56-0-293" id="h56-0-293" class="i">+    optional int64 end_unapplied_log_timestamp_us = 19;
</a><a href="#h56-0-294" id="h56-0-294" class="i">+  }
</a><a href="#h56-0-295" id="h56-0-295" class="i">+
</a><a href="#h56-0-296" id="h56-0-296" class="i">+  repeated group MergeJoinScan = 7 {
</a><a href="#h56-0-297" id="h56-0-297" class="i">+    required string index_name = 8;
</a><a href="#h56-0-298" id="h56-0-298" class="i">+
</a><a href="#h56-0-299" id="h56-0-299" class="i">+    repeated string prefix_value = 9;
</a><a href="#h56-0-300" id="h56-0-300" class="i">+
</a><a href="#h56-0-301" id="h56-0-301" class="i">+    optional bool value_prefix = 20 [default=false];
</a><a href="#h56-0-302" id="h56-0-302" class="i">+  }
</a><a href="#h56-0-303" id="h56-0-303" class="i">+
</a><a href="#h56-0-304" id="h56-0-304" class="i">+  optional Index index_def = 21;
</a><a href="#h56-0-305" id="h56-0-305" class="i">+
</a><a href="#h56-0-306" id="h56-0-306" class="i">+  optional int32 offset = 10 [default = 0];
</a><a href="#h56-0-307" id="h56-0-307" class="i">+
</a><a href="#h56-0-308" id="h56-0-308" class="i">+  optional int32 limit = 11;
</a><a href="#h56-0-309" id="h56-0-309" class="i">+
</a><a href="#h56-0-310" id="h56-0-310" class="i">+  required bool keys_only = 12;
</a><a href="#h56-0-311" id="h56-0-311" class="i">+
</a><a href="#h56-0-312" id="h56-0-312" class="i">+  repeated string property_name = 24;
</a><a href="#h56-0-313" id="h56-0-313" class="i">+
</a><a href="#h56-0-314" id="h56-0-314" class="i">+  optional int32 distinct_infix_size = 25;
</a><a href="#h56-0-315" id="h56-0-315" class="i">+
</a><a href="#h56-0-316" id="h56-0-316" class="i">+  optional group EntityFilter = 13 {
</a><a href="#h56-0-317" id="h56-0-317" class="i">+    optional bool distinct = 14 [default=false];
</a><a href="#h56-0-318" id="h56-0-318" class="i">+
</a><a href="#h56-0-319" id="h56-0-319" class="i">+    optional string kind = 17;
</a><a href="#h56-0-320" id="h56-0-320" class="i">+    optional Reference ancestor = 18;
</a><a href="#h56-0-321" id="h56-0-321" class="i">+  }
</a><a href="#h56-0-322" id="h56-0-322" class="i">+}
</a><a href="#h56-0-323" id="h56-0-323" class="i">+
</a><a href="#h56-0-324" id="h56-0-324" class="i">+message CompiledCursor {
</a><a href="#h56-0-325" id="h56-0-325" class="i">+  optional group Position = 2 {
</a><a href="#h56-0-326" id="h56-0-326" class="i">+    optional string start_key = 27;
</a><a href="#h56-0-327" id="h56-0-327" class="i">+
</a><a href="#h56-0-328" id="h56-0-328" class="i">+    repeated group IndexValue = 29 {
</a><a href="#h56-0-329" id="h56-0-329" class="i">+      optional string property = 30;
</a><a href="#h56-0-330" id="h56-0-330" class="i">+      required PropertyValue value = 31;
</a><a href="#h56-0-331" id="h56-0-331" class="i">+    }
</a><a href="#h56-0-332" id="h56-0-332" class="i">+
</a><a href="#h56-0-333" id="h56-0-333" class="i">+    optional Reference key = 32;
</a><a href="#h56-0-334" id="h56-0-334" class="i">+
</a><a href="#h56-0-335" id="h56-0-335" class="i">+    optional bool start_inclusive = 28 [default=true];
</a><a href="#h56-0-336" id="h56-0-336" class="i">+  }
</a><a href="#h56-0-337" id="h56-0-337" class="i">+}
</a><a href="#h56-0-338" id="h56-0-338" class="i">+
</a><a href="#h56-0-339" id="h56-0-339" class="i">+message Cursor {
</a><a href="#h56-0-340" id="h56-0-340" class="i">+  required fixed64 cursor = 1;
</a><a href="#h56-0-341" id="h56-0-341" class="i">+
</a><a href="#h56-0-342" id="h56-0-342" class="i">+  optional string app = 2;
</a><a href="#h56-0-343" id="h56-0-343" class="i">+}
</a><a href="#h56-0-344" id="h56-0-344" class="i">+
</a><a href="#h56-0-345" id="h56-0-345" class="i">+message Error {
</a><a href="#h56-0-346" id="h56-0-346" class="i">+  enum ErrorCode {
</a><a href="#h56-0-347" id="h56-0-347" class="i">+    BAD_REQUEST = 1;
</a><a href="#h56-0-348" id="h56-0-348" class="i">+    CONCURRENT_TRANSACTION = 2;
</a><a href="#h56-0-349" id="h56-0-349" class="i">+    INTERNAL_ERROR = 3;
</a><a href="#h56-0-350" id="h56-0-350" class="i">+    NEED_INDEX = 4;
</a><a href="#h56-0-351" id="h56-0-351" class="i">+    TIMEOUT = 5;
</a><a href="#h56-0-352" id="h56-0-352" class="i">+    PERMISSION_DENIED = 6;
</a><a href="#h56-0-353" id="h56-0-353" class="i">+    BIGTABLE_ERROR = 7;
</a><a href="#h56-0-354" id="h56-0-354" class="i">+    COMMITTED_BUT_STILL_APPLYING = 8;
</a><a href="#h56-0-355" id="h56-0-355" class="i">+    CAPABILITY_DISABLED = 9;
</a><a href="#h56-0-356" id="h56-0-356" class="i">+    TRY_ALTERNATE_BACKEND = 10;
</a><a href="#h56-0-357" id="h56-0-357" class="i">+    SAFE_TIME_TOO_OLD = 11;
</a><a href="#h56-0-358" id="h56-0-358" class="i">+  }
</a><a href="#h56-0-359" id="h56-0-359" class="i">+}
</a><a href="#h56-0-360" id="h56-0-360" class="i">+
</a><a href="#h56-0-361" id="h56-0-361" class="i">+message Cost {
</a><a href="#h56-0-362" id="h56-0-362" class="i">+  optional int32 index_writes = 1;
</a><a href="#h56-0-363" id="h56-0-363" class="i">+  optional int32 index_write_bytes = 2;
</a><a href="#h56-0-364" id="h56-0-364" class="i">+  optional int32 entity_writes = 3;
</a><a href="#h56-0-365" id="h56-0-365" class="i">+  optional int32 entity_write_bytes = 4;
</a><a href="#h56-0-366" id="h56-0-366" class="i">+  optional group CommitCost = 5 {
</a><a href="#h56-0-367" id="h56-0-367" class="i">+    optional int32 requested_entity_puts = 6;
</a><a href="#h56-0-368" id="h56-0-368" class="i">+    optional int32 requested_entity_deletes = 7;
</a><a href="#h56-0-369" id="h56-0-369" class="i">+  };
</a><a href="#h56-0-370" id="h56-0-370" class="i">+  optional int32 approximate_storage_delta = 8;
</a><a href="#h56-0-371" id="h56-0-371" class="i">+  optional int32 id_sequence_updates = 9;
</a><a href="#h56-0-372" id="h56-0-372" class="i">+}
</a><a href="#h56-0-373" id="h56-0-373" class="i">+
</a><a href="#h56-0-374" id="h56-0-374" class="i">+message GetRequest {
</a><a href="#h56-0-375" id="h56-0-375" class="i">+  optional InternalHeader header = 6;
</a><a href="#h56-0-376" id="h56-0-376" class="i">+
</a><a href="#h56-0-377" id="h56-0-377" class="i">+  repeated Reference key = 1;
</a><a href="#h56-0-378" id="h56-0-378" class="i">+  optional Transaction transaction = 2;
</a><a href="#h56-0-379" id="h56-0-379" class="i">+
</a><a href="#h56-0-380" id="h56-0-380" class="i">+  optional int64 failover_ms = 3;
</a><a href="#h56-0-381" id="h56-0-381" class="i">+
</a><a href="#h56-0-382" id="h56-0-382" class="i">+  optional bool strong = 4;
</a><a href="#h56-0-383" id="h56-0-383" class="i">+
</a><a href="#h56-0-384" id="h56-0-384" class="i">+  optional bool allow_deferred = 5 [default=false];
</a><a href="#h56-0-385" id="h56-0-385" class="i">+}
</a><a href="#h56-0-386" id="h56-0-386" class="i">+
</a><a href="#h56-0-387" id="h56-0-387" class="i">+message GetResponse {
</a><a href="#h56-0-388" id="h56-0-388" class="i">+  repeated group Entity = 1 {
</a><a href="#h56-0-389" id="h56-0-389" class="i">+    optional EntityProto entity = 2;
</a><a href="#h56-0-390" id="h56-0-390" class="i">+    optional Reference key = 4;
</a><a href="#h56-0-391" id="h56-0-391" class="i">+
</a><a href="#h56-0-392" id="h56-0-392" class="i">+    optional int64 version = 3;
</a><a href="#h56-0-393" id="h56-0-393" class="i">+  }
</a><a href="#h56-0-394" id="h56-0-394" class="i">+
</a><a href="#h56-0-395" id="h56-0-395" class="i">+  repeated Reference deferred = 5;
</a><a href="#h56-0-396" id="h56-0-396" class="i">+
</a><a href="#h56-0-397" id="h56-0-397" class="i">+  optional bool in_order = 6 [default=true];
</a><a href="#h56-0-398" id="h56-0-398" class="i">+}
</a><a href="#h56-0-399" id="h56-0-399" class="i">+
</a><a href="#h56-0-400" id="h56-0-400" class="i">+message PutRequest {
</a><a href="#h56-0-401" id="h56-0-401" class="i">+  optional InternalHeader header = 11;
</a><a href="#h56-0-402" id="h56-0-402" class="i">+
</a><a href="#h56-0-403" id="h56-0-403" class="i">+  repeated EntityProto entity = 1;
</a><a href="#h56-0-404" id="h56-0-404" class="i">+  optional Transaction transaction = 2;
</a><a href="#h56-0-405" id="h56-0-405" class="i">+  repeated CompositeIndex composite_index = 3;
</a><a href="#h56-0-406" id="h56-0-406" class="i">+
</a><a href="#h56-0-407" id="h56-0-407" class="i">+  optional bool trusted = 4 [default = false];
</a><a href="#h56-0-408" id="h56-0-408" class="i">+
</a><a href="#h56-0-409" id="h56-0-409" class="i">+  optional bool force = 7 [default = false];
</a><a href="#h56-0-410" id="h56-0-410" class="i">+
</a><a href="#h56-0-411" id="h56-0-411" class="i">+  optional bool mark_changes = 8 [default = false];
</a><a href="#h56-0-412" id="h56-0-412" class="i">+  repeated Snapshot snapshot = 9;
</a><a href="#h56-0-413" id="h56-0-413" class="i">+
</a><a href="#h56-0-414" id="h56-0-414" class="i">+  enum AutoIdPolicy {
</a><a href="#h56-0-415" id="h56-0-415" class="i">+    CURRENT = 0;
</a><a href="#h56-0-416" id="h56-0-416" class="i">+    SEQUENTIAL = 1;
</a><a href="#h56-0-417" id="h56-0-417" class="i">+  }
</a><a href="#h56-0-418" id="h56-0-418" class="i">+  optional AutoIdPolicy auto_id_policy = 10 [default = CURRENT];
</a><a href="#h56-0-419" id="h56-0-419" class="i">+}
</a><a href="#h56-0-420" id="h56-0-420" class="i">+
</a><a href="#h56-0-421" id="h56-0-421" class="i">+message PutResponse {
</a><a href="#h56-0-422" id="h56-0-422" class="i">+  repeated Reference key = 1;
</a><a href="#h56-0-423" id="h56-0-423" class="i">+  optional Cost cost = 2;
</a><a href="#h56-0-424" id="h56-0-424" class="i">+  repeated int64 version = 3;
</a><a href="#h56-0-425" id="h56-0-425" class="i">+}
</a><a href="#h56-0-426" id="h56-0-426" class="i">+
</a><a href="#h56-0-427" id="h56-0-427" class="i">+message TouchRequest {
</a><a href="#h56-0-428" id="h56-0-428" class="i">+  optional InternalHeader header = 10;
</a><a href="#h56-0-429" id="h56-0-429" class="i">+
</a><a href="#h56-0-430" id="h56-0-430" class="i">+  repeated Reference key = 1;
</a><a href="#h56-0-431" id="h56-0-431" class="i">+  repeated CompositeIndex composite_index = 2;
</a><a href="#h56-0-432" id="h56-0-432" class="i">+  optional bool force = 3 [default = false];
</a><a href="#h56-0-433" id="h56-0-433" class="i">+  repeated Snapshot snapshot = 9;
</a><a href="#h56-0-434" id="h56-0-434" class="i">+}
</a><a href="#h56-0-435" id="h56-0-435" class="i">+
</a><a href="#h56-0-436" id="h56-0-436" class="i">+message TouchResponse {
</a><a href="#h56-0-437" id="h56-0-437" class="i">+  optional Cost cost = 1;
</a><a href="#h56-0-438" id="h56-0-438" class="i">+}
</a><a href="#h56-0-439" id="h56-0-439" class="i">+
</a><a href="#h56-0-440" id="h56-0-440" class="i">+message DeleteRequest {
</a><a href="#h56-0-441" id="h56-0-441" class="i">+  optional InternalHeader header = 10;
</a><a href="#h56-0-442" id="h56-0-442" class="i">+
</a><a href="#h56-0-443" id="h56-0-443" class="i">+  repeated Reference key = 6;
</a><a href="#h56-0-444" id="h56-0-444" class="i">+  optional Transaction transaction = 5;
</a><a href="#h56-0-445" id="h56-0-445" class="i">+
</a><a href="#h56-0-446" id="h56-0-446" class="i">+  optional bool trusted = 4 [default = false];
</a><a href="#h56-0-447" id="h56-0-447" class="i">+
</a><a href="#h56-0-448" id="h56-0-448" class="i">+  optional bool force = 7 [default = false];
</a><a href="#h56-0-449" id="h56-0-449" class="i">+
</a><a href="#h56-0-450" id="h56-0-450" class="i">+  optional bool mark_changes = 8 [default = false];
</a><a href="#h56-0-451" id="h56-0-451" class="i">+  repeated Snapshot snapshot = 9;
</a><a href="#h56-0-452" id="h56-0-452" class="i">+}
</a><a href="#h56-0-453" id="h56-0-453" class="i">+
</a><a href="#h56-0-454" id="h56-0-454" class="i">+message DeleteResponse {
</a><a href="#h56-0-455" id="h56-0-455" class="i">+  optional Cost cost = 1;
</a><a href="#h56-0-456" id="h56-0-456" class="i">+  repeated int64 version = 3;
</a><a href="#h56-0-457" id="h56-0-457" class="i">+}
</a><a href="#h56-0-458" id="h56-0-458" class="i">+
</a><a href="#h56-0-459" id="h56-0-459" class="i">+message NextRequest {
</a><a href="#h56-0-460" id="h56-0-460" class="i">+  optional InternalHeader header = 5;
</a><a href="#h56-0-461" id="h56-0-461" class="i">+
</a><a href="#h56-0-462" id="h56-0-462" class="i">+  required Cursor cursor = 1;
</a><a href="#h56-0-463" id="h56-0-463" class="i">+  optional int32 count = 2;
</a><a href="#h56-0-464" id="h56-0-464" class="i">+
</a><a href="#h56-0-465" id="h56-0-465" class="i">+  optional int32 offset = 4 [default = 0];
</a><a href="#h56-0-466" id="h56-0-466" class="i">+
</a><a href="#h56-0-467" id="h56-0-467" class="i">+  optional bool compile = 3 [default = false];
</a><a href="#h56-0-468" id="h56-0-468" class="i">+}
</a><a href="#h56-0-469" id="h56-0-469" class="i">+
</a><a href="#h56-0-470" id="h56-0-470" class="i">+message QueryResult {
</a><a href="#h56-0-471" id="h56-0-471" class="i">+  optional Cursor cursor = 1;
</a><a href="#h56-0-472" id="h56-0-472" class="i">+
</a><a href="#h56-0-473" id="h56-0-473" class="i">+  repeated EntityProto result = 2;
</a><a href="#h56-0-474" id="h56-0-474" class="i">+
</a><a href="#h56-0-475" id="h56-0-475" class="i">+  optional int32 skipped_results = 7;
</a><a href="#h56-0-476" id="h56-0-476" class="i">+
</a><a href="#h56-0-477" id="h56-0-477" class="i">+  required bool more_results = 3;
</a><a href="#h56-0-478" id="h56-0-478" class="i">+
</a><a href="#h56-0-479" id="h56-0-479" class="i">+  optional bool keys_only = 4;
</a><a href="#h56-0-480" id="h56-0-480" class="i">+
</a><a href="#h56-0-481" id="h56-0-481" class="i">+  optional bool index_only = 9;
</a><a href="#h56-0-482" id="h56-0-482" class="i">+
</a><a href="#h56-0-483" id="h56-0-483" class="i">+  optional bool small_ops = 10;
</a><a href="#h56-0-484" id="h56-0-484" class="i">+
</a><a href="#h56-0-485" id="h56-0-485" class="i">+  optional CompiledQuery compiled_query = 5;
</a><a href="#h56-0-486" id="h56-0-486" class="i">+
</a><a href="#h56-0-487" id="h56-0-487" class="i">+  optional CompiledCursor compiled_cursor = 6;
</a><a href="#h56-0-488" id="h56-0-488" class="i">+
</a><a href="#h56-0-489" id="h56-0-489" class="i">+  repeated CompositeIndex index = 8;
</a><a href="#h56-0-490" id="h56-0-490" class="i">+
</a><a href="#h56-0-491" id="h56-0-491" class="i">+  repeated int64 version = 11;
</a><a href="#h56-0-492" id="h56-0-492" class="i">+}
</a><a href="#h56-0-493" id="h56-0-493" class="i">+
</a><a href="#h56-0-494" id="h56-0-494" class="i">+message AllocateIdsRequest {
</a><a href="#h56-0-495" id="h56-0-495" class="i">+  optional InternalHeader header = 4;
</a><a href="#h56-0-496" id="h56-0-496" class="i">+
</a><a href="#h56-0-497" id="h56-0-497" class="i">+  optional Reference model_key = 1;
</a><a href="#h56-0-498" id="h56-0-498" class="i">+
</a><a href="#h56-0-499" id="h56-0-499" class="i">+  optional int64 size = 2;
</a><a href="#h56-0-500" id="h56-0-500" class="i">+
</a><a href="#h56-0-501" id="h56-0-501" class="i">+  optional int64 max = 3;
</a><a href="#h56-0-502" id="h56-0-502" class="i">+
</a><a href="#h56-0-503" id="h56-0-503" class="i">+  repeated Reference reserve = 5;
</a><a href="#h56-0-504" id="h56-0-504" class="i">+}
</a><a href="#h56-0-505" id="h56-0-505" class="i">+
</a><a href="#h56-0-506" id="h56-0-506" class="i">+message AllocateIdsResponse {
</a><a href="#h56-0-507" id="h56-0-507" class="i">+  required int64 start = 1;
</a><a href="#h56-0-508" id="h56-0-508" class="i">+  required int64 end = 2;
</a><a href="#h56-0-509" id="h56-0-509" class="i">+  optional Cost cost = 3;
</a><a href="#h56-0-510" id="h56-0-510" class="i">+}
</a><a href="#h56-0-511" id="h56-0-511" class="i">+
</a><a href="#h56-0-512" id="h56-0-512" class="i">+message CompositeIndices {
</a><a href="#h56-0-513" id="h56-0-513" class="i">+  repeated CompositeIndex index = 1;
</a><a href="#h56-0-514" id="h56-0-514" class="i">+}
</a><a href="#h56-0-515" id="h56-0-515" class="i">+
</a><a href="#h56-0-516" id="h56-0-516" class="i">+message AddActionsRequest {
</a><a href="#h56-0-517" id="h56-0-517" class="i">+  optional InternalHeader header = 3;
</a><a href="#h56-0-518" id="h56-0-518" class="i">+
</a><a href="#h56-0-519" id="h56-0-519" class="i">+  required Transaction transaction = 1;
</a><a href="#h56-0-520" id="h56-0-520" class="i">+  repeated Action action = 2;
</a><a href="#h56-0-521" id="h56-0-521" class="i">+}
</a><a href="#h56-0-522" id="h56-0-522" class="i">+
</a><a href="#h56-0-523" id="h56-0-523" class="i">+message AddActionsResponse {
</a><a href="#h56-0-524" id="h56-0-524" class="i">+}
</a><a href="#h56-0-525" id="h56-0-525" class="i">+
</a><a href="#h56-0-526" id="h56-0-526" class="i">+message BeginTransactionRequest {
</a><a href="#h56-0-527" id="h56-0-527" class="i">+  optional InternalHeader header = 3;
</a><a href="#h56-0-528" id="h56-0-528" class="i">+
</a><a href="#h56-0-529" id="h56-0-529" class="i">+  required string app = 1;
</a><a href="#h56-0-530" id="h56-0-530" class="i">+  optional bool allow_multiple_eg = 2 [default = false];
</a><a href="#h56-0-531" id="h56-0-531" class="i">+}
</a><a href="#h56-0-532" id="h56-0-532" class="i">+
</a><a href="#h56-0-533" id="h56-0-533" class="i">+message CommitResponse {
</a><a href="#h56-0-534" id="h56-0-534" class="i">+  optional Cost cost = 1;
</a><a href="#h56-0-535" id="h56-0-535" class="i">+
</a><a href="#h56-0-536" id="h56-0-536" class="i">+  repeated group Version = 3 {
</a><a href="#h56-0-537" id="h56-0-537" class="i">+    required Reference root_entity_key = 4;
</a><a href="#h56-0-538" id="h56-0-538" class="i">+    required int64 version = 5;
</a><a href="#h56-0-539" id="h56-0-539" class="i">+  }
</a><a href="#h56-0-540" id="h56-0-540" class="i">+}
</a><b>diff --git a/<a id="h57" href="../file/vendor/google.golang.org/appengine/internal/identity.go">vendor/google.golang.org/appengine/internal/identity.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/identity.go">vendor/google.golang.org/appengine/internal/identity.go</a></b>
<a href="#h57-0" id="h57-0" class="h">@@ -0,0 +1,14 @@
</a><a href="#h57-0-0" id="h57-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h57-0-1" id="h57-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h57-0-2" id="h57-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h57-0-3" id="h57-0-3" class="i">+
</a><a href="#h57-0-4" id="h57-0-4" class="i">+package internal
</a><a href="#h57-0-5" id="h57-0-5" class="i">+
</a><a href="#h57-0-6" id="h57-0-6" class="i">+import netcontext &quot;golang.org/x/net/context&quot;
</a><a href="#h57-0-7" id="h57-0-7" class="i">+
</a><a href="#h57-0-8" id="h57-0-8" class="i">+// These functions are implementations of the wrapper functions
</a><a href="#h57-0-9" id="h57-0-9" class="i">+// in ../appengine/identity.go. See that file for commentary.
</a><a href="#h57-0-10" id="h57-0-10" class="i">+
</a><a href="#h57-0-11" id="h57-0-11" class="i">+func AppID(c netcontext.Context) string {
</a><a href="#h57-0-12" id="h57-0-12" class="i">+	return appID(FullyQualifiedAppID(c))
</a><a href="#h57-0-13" id="h57-0-13" class="i">+}
</a><b>diff --git a/<a id="h58" href="../file/vendor/google.golang.org/appengine/internal/identity_classic.go">vendor/google.golang.org/appengine/internal/identity_classic.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/identity_classic.go">vendor/google.golang.org/appengine/internal/identity_classic.go</a></b>
<a href="#h58-0" id="h58-0" class="h">@@ -0,0 +1,27 @@
</a><a href="#h58-0-0" id="h58-0-0" class="i">+// Copyright 2015 Google Inc. All rights reserved.
</a><a href="#h58-0-1" id="h58-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h58-0-2" id="h58-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h58-0-3" id="h58-0-3" class="i">+
</a><a href="#h58-0-4" id="h58-0-4" class="i">+// +build appengine
</a><a href="#h58-0-5" id="h58-0-5" class="i">+
</a><a href="#h58-0-6" id="h58-0-6" class="i">+package internal
</a><a href="#h58-0-7" id="h58-0-7" class="i">+
</a><a href="#h58-0-8" id="h58-0-8" class="i">+import (
</a><a href="#h58-0-9" id="h58-0-9" class="i">+	&quot;appengine&quot;
</a><a href="#h58-0-10" id="h58-0-10" class="i">+
</a><a href="#h58-0-11" id="h58-0-11" class="i">+	netcontext &quot;golang.org/x/net/context&quot;
</a><a href="#h58-0-12" id="h58-0-12" class="i">+)
</a><a href="#h58-0-13" id="h58-0-13" class="i">+
</a><a href="#h58-0-14" id="h58-0-14" class="i">+func DefaultVersionHostname(ctx netcontext.Context) string {
</a><a href="#h58-0-15" id="h58-0-15" class="i">+	return appengine.DefaultVersionHostname(fromContext(ctx))
</a><a href="#h58-0-16" id="h58-0-16" class="i">+}
</a><a href="#h58-0-17" id="h58-0-17" class="i">+
</a><a href="#h58-0-18" id="h58-0-18" class="i">+func RequestID(ctx netcontext.Context) string  { return appengine.RequestID(fromContext(ctx)) }
</a><a href="#h58-0-19" id="h58-0-19" class="i">+func Datacenter(_ netcontext.Context) string   { return appengine.Datacenter() }
</a><a href="#h58-0-20" id="h58-0-20" class="i">+func ServerSoftware() string                   { return appengine.ServerSoftware() }
</a><a href="#h58-0-21" id="h58-0-21" class="i">+func ModuleName(ctx netcontext.Context) string { return appengine.ModuleName(fromContext(ctx)) }
</a><a href="#h58-0-22" id="h58-0-22" class="i">+func VersionID(ctx netcontext.Context) string  { return appengine.VersionID(fromContext(ctx)) }
</a><a href="#h58-0-23" id="h58-0-23" class="i">+func InstanceID() string                       { return appengine.InstanceID() }
</a><a href="#h58-0-24" id="h58-0-24" class="i">+func IsDevAppServer() bool                     { return appengine.IsDevAppServer() }
</a><a href="#h58-0-25" id="h58-0-25" class="i">+
</a><a href="#h58-0-26" id="h58-0-26" class="i">+func fullyQualifiedAppID(ctx netcontext.Context) string { return fromContext(ctx).FullyQualifiedAppID() }
</a><b>diff --git a/<a id="h59" href="../file/vendor/google.golang.org/appengine/internal/identity_vm.go">vendor/google.golang.org/appengine/internal/identity_vm.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/identity_vm.go">vendor/google.golang.org/appengine/internal/identity_vm.go</a></b>
<a href="#h59-0" id="h59-0" class="h">@@ -0,0 +1,97 @@
</a><a href="#h59-0-0" id="h59-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h59-0-1" id="h59-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h59-0-2" id="h59-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h59-0-3" id="h59-0-3" class="i">+
</a><a href="#h59-0-4" id="h59-0-4" class="i">+// +build !appengine
</a><a href="#h59-0-5" id="h59-0-5" class="i">+
</a><a href="#h59-0-6" id="h59-0-6" class="i">+package internal
</a><a href="#h59-0-7" id="h59-0-7" class="i">+
</a><a href="#h59-0-8" id="h59-0-8" class="i">+import (
</a><a href="#h59-0-9" id="h59-0-9" class="i">+	&quot;net/http&quot;
</a><a href="#h59-0-10" id="h59-0-10" class="i">+	&quot;os&quot;
</a><a href="#h59-0-11" id="h59-0-11" class="i">+
</a><a href="#h59-0-12" id="h59-0-12" class="i">+	netcontext &quot;golang.org/x/net/context&quot;
</a><a href="#h59-0-13" id="h59-0-13" class="i">+)
</a><a href="#h59-0-14" id="h59-0-14" class="i">+
</a><a href="#h59-0-15" id="h59-0-15" class="i">+// These functions are implementations of the wrapper functions
</a><a href="#h59-0-16" id="h59-0-16" class="i">+// in ../appengine/identity.go. See that file for commentary.
</a><a href="#h59-0-17" id="h59-0-17" class="i">+
</a><a href="#h59-0-18" id="h59-0-18" class="i">+const (
</a><a href="#h59-0-19" id="h59-0-19" class="i">+	hDefaultVersionHostname = &quot;X-AppEngine-Default-Version-Hostname&quot;
</a><a href="#h59-0-20" id="h59-0-20" class="i">+	hRequestLogId           = &quot;X-AppEngine-Request-Log-Id&quot;
</a><a href="#h59-0-21" id="h59-0-21" class="i">+	hDatacenter             = &quot;X-AppEngine-Datacenter&quot;
</a><a href="#h59-0-22" id="h59-0-22" class="i">+)
</a><a href="#h59-0-23" id="h59-0-23" class="i">+
</a><a href="#h59-0-24" id="h59-0-24" class="i">+func ctxHeaders(ctx netcontext.Context) http.Header {
</a><a href="#h59-0-25" id="h59-0-25" class="i">+	return fromContext(ctx).Request().Header
</a><a href="#h59-0-26" id="h59-0-26" class="i">+}
</a><a href="#h59-0-27" id="h59-0-27" class="i">+
</a><a href="#h59-0-28" id="h59-0-28" class="i">+func DefaultVersionHostname(ctx netcontext.Context) string {
</a><a href="#h59-0-29" id="h59-0-29" class="i">+	return ctxHeaders(ctx).Get(hDefaultVersionHostname)
</a><a href="#h59-0-30" id="h59-0-30" class="i">+}
</a><a href="#h59-0-31" id="h59-0-31" class="i">+
</a><a href="#h59-0-32" id="h59-0-32" class="i">+func RequestID(ctx netcontext.Context) string {
</a><a href="#h59-0-33" id="h59-0-33" class="i">+	return ctxHeaders(ctx).Get(hRequestLogId)
</a><a href="#h59-0-34" id="h59-0-34" class="i">+}
</a><a href="#h59-0-35" id="h59-0-35" class="i">+
</a><a href="#h59-0-36" id="h59-0-36" class="i">+func Datacenter(ctx netcontext.Context) string {
</a><a href="#h59-0-37" id="h59-0-37" class="i">+	return ctxHeaders(ctx).Get(hDatacenter)
</a><a href="#h59-0-38" id="h59-0-38" class="i">+}
</a><a href="#h59-0-39" id="h59-0-39" class="i">+
</a><a href="#h59-0-40" id="h59-0-40" class="i">+func ServerSoftware() string {
</a><a href="#h59-0-41" id="h59-0-41" class="i">+	// TODO(dsymonds): Remove fallback when we&#39;ve verified this.
</a><a href="#h59-0-42" id="h59-0-42" class="i">+	if s := os.Getenv(&quot;SERVER_SOFTWARE&quot;); s != &quot;&quot; {
</a><a href="#h59-0-43" id="h59-0-43" class="i">+		return s
</a><a href="#h59-0-44" id="h59-0-44" class="i">+	}
</a><a href="#h59-0-45" id="h59-0-45" class="i">+	return &quot;Google App Engine/1.x.x&quot;
</a><a href="#h59-0-46" id="h59-0-46" class="i">+}
</a><a href="#h59-0-47" id="h59-0-47" class="i">+
</a><a href="#h59-0-48" id="h59-0-48" class="i">+// TODO(dsymonds): Remove the metadata fetches.
</a><a href="#h59-0-49" id="h59-0-49" class="i">+
</a><a href="#h59-0-50" id="h59-0-50" class="i">+func ModuleName(_ netcontext.Context) string {
</a><a href="#h59-0-51" id="h59-0-51" class="i">+	if s := os.Getenv(&quot;GAE_MODULE_NAME&quot;); s != &quot;&quot; {
</a><a href="#h59-0-52" id="h59-0-52" class="i">+		return s
</a><a href="#h59-0-53" id="h59-0-53" class="i">+	}
</a><a href="#h59-0-54" id="h59-0-54" class="i">+	return string(mustGetMetadata(&quot;instance/attributes/gae_backend_name&quot;))
</a><a href="#h59-0-55" id="h59-0-55" class="i">+}
</a><a href="#h59-0-56" id="h59-0-56" class="i">+
</a><a href="#h59-0-57" id="h59-0-57" class="i">+func VersionID(_ netcontext.Context) string {
</a><a href="#h59-0-58" id="h59-0-58" class="i">+	if s1, s2 := os.Getenv(&quot;GAE_MODULE_VERSION&quot;), os.Getenv(&quot;GAE_MINOR_VERSION&quot;); s1 != &quot;&quot; &amp;&amp; s2 != &quot;&quot; {
</a><a href="#h59-0-59" id="h59-0-59" class="i">+		return s1 + &quot;.&quot; + s2
</a><a href="#h59-0-60" id="h59-0-60" class="i">+	}
</a><a href="#h59-0-61" id="h59-0-61" class="i">+	return string(mustGetMetadata(&quot;instance/attributes/gae_backend_version&quot;)) + &quot;.&quot; + string(mustGetMetadata(&quot;instance/attributes/gae_backend_minor_version&quot;))
</a><a href="#h59-0-62" id="h59-0-62" class="i">+}
</a><a href="#h59-0-63" id="h59-0-63" class="i">+
</a><a href="#h59-0-64" id="h59-0-64" class="i">+func InstanceID() string {
</a><a href="#h59-0-65" id="h59-0-65" class="i">+	if s := os.Getenv(&quot;GAE_MODULE_INSTANCE&quot;); s != &quot;&quot; {
</a><a href="#h59-0-66" id="h59-0-66" class="i">+		return s
</a><a href="#h59-0-67" id="h59-0-67" class="i">+	}
</a><a href="#h59-0-68" id="h59-0-68" class="i">+	return string(mustGetMetadata(&quot;instance/attributes/gae_backend_instance&quot;))
</a><a href="#h59-0-69" id="h59-0-69" class="i">+}
</a><a href="#h59-0-70" id="h59-0-70" class="i">+
</a><a href="#h59-0-71" id="h59-0-71" class="i">+func partitionlessAppID() string {
</a><a href="#h59-0-72" id="h59-0-72" class="i">+	// gae_project has everything except the partition prefix.
</a><a href="#h59-0-73" id="h59-0-73" class="i">+	appID := os.Getenv(&quot;GAE_LONG_APP_ID&quot;)
</a><a href="#h59-0-74" id="h59-0-74" class="i">+	if appID == &quot;&quot; {
</a><a href="#h59-0-75" id="h59-0-75" class="i">+		appID = string(mustGetMetadata(&quot;instance/attributes/gae_project&quot;))
</a><a href="#h59-0-76" id="h59-0-76" class="i">+	}
</a><a href="#h59-0-77" id="h59-0-77" class="i">+	return appID
</a><a href="#h59-0-78" id="h59-0-78" class="i">+}
</a><a href="#h59-0-79" id="h59-0-79" class="i">+
</a><a href="#h59-0-80" id="h59-0-80" class="i">+func fullyQualifiedAppID(_ netcontext.Context) string {
</a><a href="#h59-0-81" id="h59-0-81" class="i">+	appID := partitionlessAppID()
</a><a href="#h59-0-82" id="h59-0-82" class="i">+
</a><a href="#h59-0-83" id="h59-0-83" class="i">+	part := os.Getenv(&quot;GAE_PARTITION&quot;)
</a><a href="#h59-0-84" id="h59-0-84" class="i">+	if part == &quot;&quot; {
</a><a href="#h59-0-85" id="h59-0-85" class="i">+		part = string(mustGetMetadata(&quot;instance/attributes/gae_partition&quot;))
</a><a href="#h59-0-86" id="h59-0-86" class="i">+	}
</a><a href="#h59-0-87" id="h59-0-87" class="i">+
</a><a href="#h59-0-88" id="h59-0-88" class="i">+	if part != &quot;&quot; {
</a><a href="#h59-0-89" id="h59-0-89" class="i">+		appID = part + &quot;~&quot; + appID
</a><a href="#h59-0-90" id="h59-0-90" class="i">+	}
</a><a href="#h59-0-91" id="h59-0-91" class="i">+	return appID
</a><a href="#h59-0-92" id="h59-0-92" class="i">+}
</a><a href="#h59-0-93" id="h59-0-93" class="i">+
</a><a href="#h59-0-94" id="h59-0-94" class="i">+func IsDevAppServer() bool {
</a><a href="#h59-0-95" id="h59-0-95" class="i">+	return os.Getenv(&quot;RUN_WITH_DEVAPPSERVER&quot;) != &quot;&quot;
</a><a href="#h59-0-96" id="h59-0-96" class="i">+}
</a><b>diff --git a/<a id="h60" href="../file/vendor/google.golang.org/appengine/internal/internal.go">vendor/google.golang.org/appengine/internal/internal.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/internal.go">vendor/google.golang.org/appengine/internal/internal.go</a></b>
<a href="#h60-0" id="h60-0" class="h">@@ -0,0 +1,110 @@
</a><a href="#h60-0-0" id="h60-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h60-0-1" id="h60-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h60-0-2" id="h60-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h60-0-3" id="h60-0-3" class="i">+
</a><a href="#h60-0-4" id="h60-0-4" class="i">+// Package internal provides support for package appengine.
</a><a href="#h60-0-5" id="h60-0-5" class="i">+//
</a><a href="#h60-0-6" id="h60-0-6" class="i">+// Programs should not use this package directly. Its API is not stable.
</a><a href="#h60-0-7" id="h60-0-7" class="i">+// Use packages appengine and appengine/* instead.
</a><a href="#h60-0-8" id="h60-0-8" class="i">+package internal
</a><a href="#h60-0-9" id="h60-0-9" class="i">+
</a><a href="#h60-0-10" id="h60-0-10" class="i">+import (
</a><a href="#h60-0-11" id="h60-0-11" class="i">+	&quot;fmt&quot;
</a><a href="#h60-0-12" id="h60-0-12" class="i">+
</a><a href="#h60-0-13" id="h60-0-13" class="i">+	&quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h60-0-14" id="h60-0-14" class="i">+
</a><a href="#h60-0-15" id="h60-0-15" class="i">+	remotepb &quot;google.golang.org/appengine/internal/remote_api&quot;
</a><a href="#h60-0-16" id="h60-0-16" class="i">+)
</a><a href="#h60-0-17" id="h60-0-17" class="i">+
</a><a href="#h60-0-18" id="h60-0-18" class="i">+// errorCodeMaps is a map of service name to the error code map for the service.
</a><a href="#h60-0-19" id="h60-0-19" class="i">+var errorCodeMaps = make(map[string]map[int32]string)
</a><a href="#h60-0-20" id="h60-0-20" class="i">+
</a><a href="#h60-0-21" id="h60-0-21" class="i">+// RegisterErrorCodeMap is called from API implementations to register their
</a><a href="#h60-0-22" id="h60-0-22" class="i">+// error code map. This should only be called from init functions.
</a><a href="#h60-0-23" id="h60-0-23" class="i">+func RegisterErrorCodeMap(service string, m map[int32]string) {
</a><a href="#h60-0-24" id="h60-0-24" class="i">+	errorCodeMaps[service] = m
</a><a href="#h60-0-25" id="h60-0-25" class="i">+}
</a><a href="#h60-0-26" id="h60-0-26" class="i">+
</a><a href="#h60-0-27" id="h60-0-27" class="i">+type timeoutCodeKey struct {
</a><a href="#h60-0-28" id="h60-0-28" class="i">+	service string
</a><a href="#h60-0-29" id="h60-0-29" class="i">+	code    int32
</a><a href="#h60-0-30" id="h60-0-30" class="i">+}
</a><a href="#h60-0-31" id="h60-0-31" class="i">+
</a><a href="#h60-0-32" id="h60-0-32" class="i">+// timeoutCodes is the set of service+code pairs that represent timeouts.
</a><a href="#h60-0-33" id="h60-0-33" class="i">+var timeoutCodes = make(map[timeoutCodeKey]bool)
</a><a href="#h60-0-34" id="h60-0-34" class="i">+
</a><a href="#h60-0-35" id="h60-0-35" class="i">+func RegisterTimeoutErrorCode(service string, code int32) {
</a><a href="#h60-0-36" id="h60-0-36" class="i">+	timeoutCodes[timeoutCodeKey{service, code}] = true
</a><a href="#h60-0-37" id="h60-0-37" class="i">+}
</a><a href="#h60-0-38" id="h60-0-38" class="i">+
</a><a href="#h60-0-39" id="h60-0-39" class="i">+// APIError is the type returned by appengine.Context&#39;s Call method
</a><a href="#h60-0-40" id="h60-0-40" class="i">+// when an API call fails in an API-specific way. This may be, for instance,
</a><a href="#h60-0-41" id="h60-0-41" class="i">+// a taskqueue API call failing with TaskQueueServiceError::UNKNOWN_QUEUE.
</a><a href="#h60-0-42" id="h60-0-42" class="i">+type APIError struct {
</a><a href="#h60-0-43" id="h60-0-43" class="i">+	Service string
</a><a href="#h60-0-44" id="h60-0-44" class="i">+	Detail  string
</a><a href="#h60-0-45" id="h60-0-45" class="i">+	Code    int32 // API-specific error code
</a><a href="#h60-0-46" id="h60-0-46" class="i">+}
</a><a href="#h60-0-47" id="h60-0-47" class="i">+
</a><a href="#h60-0-48" id="h60-0-48" class="i">+func (e *APIError) Error() string {
</a><a href="#h60-0-49" id="h60-0-49" class="i">+	if e.Code == 0 {
</a><a href="#h60-0-50" id="h60-0-50" class="i">+		if e.Detail == &quot;&quot; {
</a><a href="#h60-0-51" id="h60-0-51" class="i">+			return &quot;APIError &lt;empty&gt;&quot;
</a><a href="#h60-0-52" id="h60-0-52" class="i">+		}
</a><a href="#h60-0-53" id="h60-0-53" class="i">+		return e.Detail
</a><a href="#h60-0-54" id="h60-0-54" class="i">+	}
</a><a href="#h60-0-55" id="h60-0-55" class="i">+	s := fmt.Sprintf(&quot;API error %d&quot;, e.Code)
</a><a href="#h60-0-56" id="h60-0-56" class="i">+	if m, ok := errorCodeMaps[e.Service]; ok {
</a><a href="#h60-0-57" id="h60-0-57" class="i">+		s += &quot; (&quot; + e.Service + &quot;: &quot; + m[e.Code] + &quot;)&quot;
</a><a href="#h60-0-58" id="h60-0-58" class="i">+	} else {
</a><a href="#h60-0-59" id="h60-0-59" class="i">+		// Shouldn&#39;t happen, but provide a bit more detail if it does.
</a><a href="#h60-0-60" id="h60-0-60" class="i">+		s = e.Service + &quot; &quot; + s
</a><a href="#h60-0-61" id="h60-0-61" class="i">+	}
</a><a href="#h60-0-62" id="h60-0-62" class="i">+	if e.Detail != &quot;&quot; {
</a><a href="#h60-0-63" id="h60-0-63" class="i">+		s += &quot;: &quot; + e.Detail
</a><a href="#h60-0-64" id="h60-0-64" class="i">+	}
</a><a href="#h60-0-65" id="h60-0-65" class="i">+	return s
</a><a href="#h60-0-66" id="h60-0-66" class="i">+}
</a><a href="#h60-0-67" id="h60-0-67" class="i">+
</a><a href="#h60-0-68" id="h60-0-68" class="i">+func (e *APIError) IsTimeout() bool {
</a><a href="#h60-0-69" id="h60-0-69" class="i">+	return timeoutCodes[timeoutCodeKey{e.Service, e.Code}]
</a><a href="#h60-0-70" id="h60-0-70" class="i">+}
</a><a href="#h60-0-71" id="h60-0-71" class="i">+
</a><a href="#h60-0-72" id="h60-0-72" class="i">+// CallError is the type returned by appengine.Context&#39;s Call method when an
</a><a href="#h60-0-73" id="h60-0-73" class="i">+// API call fails in a generic way, such as RpcError::CAPABILITY_DISABLED.
</a><a href="#h60-0-74" id="h60-0-74" class="i">+type CallError struct {
</a><a href="#h60-0-75" id="h60-0-75" class="i">+	Detail string
</a><a href="#h60-0-76" id="h60-0-76" class="i">+	Code   int32
</a><a href="#h60-0-77" id="h60-0-77" class="i">+	// TODO: Remove this if we get a distinguishable error code.
</a><a href="#h60-0-78" id="h60-0-78" class="i">+	Timeout bool
</a><a href="#h60-0-79" id="h60-0-79" class="i">+}
</a><a href="#h60-0-80" id="h60-0-80" class="i">+
</a><a href="#h60-0-81" id="h60-0-81" class="i">+func (e *CallError) Error() string {
</a><a href="#h60-0-82" id="h60-0-82" class="i">+	var msg string
</a><a href="#h60-0-83" id="h60-0-83" class="i">+	switch remotepb.RpcError_ErrorCode(e.Code) {
</a><a href="#h60-0-84" id="h60-0-84" class="i">+	case remotepb.RpcError_UNKNOWN:
</a><a href="#h60-0-85" id="h60-0-85" class="i">+		return e.Detail
</a><a href="#h60-0-86" id="h60-0-86" class="i">+	case remotepb.RpcError_OVER_QUOTA:
</a><a href="#h60-0-87" id="h60-0-87" class="i">+		msg = &quot;Over quota&quot;
</a><a href="#h60-0-88" id="h60-0-88" class="i">+	case remotepb.RpcError_CAPABILITY_DISABLED:
</a><a href="#h60-0-89" id="h60-0-89" class="i">+		msg = &quot;Capability disabled&quot;
</a><a href="#h60-0-90" id="h60-0-90" class="i">+	case remotepb.RpcError_CANCELLED:
</a><a href="#h60-0-91" id="h60-0-91" class="i">+		msg = &quot;Canceled&quot;
</a><a href="#h60-0-92" id="h60-0-92" class="i">+	default:
</a><a href="#h60-0-93" id="h60-0-93" class="i">+		msg = fmt.Sprintf(&quot;Call error %d&quot;, e.Code)
</a><a href="#h60-0-94" id="h60-0-94" class="i">+	}
</a><a href="#h60-0-95" id="h60-0-95" class="i">+	s := msg + &quot;: &quot; + e.Detail
</a><a href="#h60-0-96" id="h60-0-96" class="i">+	if e.Timeout {
</a><a href="#h60-0-97" id="h60-0-97" class="i">+		s += &quot; (timeout)&quot;
</a><a href="#h60-0-98" id="h60-0-98" class="i">+	}
</a><a href="#h60-0-99" id="h60-0-99" class="i">+	return s
</a><a href="#h60-0-100" id="h60-0-100" class="i">+}
</a><a href="#h60-0-101" id="h60-0-101" class="i">+
</a><a href="#h60-0-102" id="h60-0-102" class="i">+func (e *CallError) IsTimeout() bool {
</a><a href="#h60-0-103" id="h60-0-103" class="i">+	return e.Timeout
</a><a href="#h60-0-104" id="h60-0-104" class="i">+}
</a><a href="#h60-0-105" id="h60-0-105" class="i">+
</a><a href="#h60-0-106" id="h60-0-106" class="i">+// NamespaceMods is a map from API service to a function that will mutate an RPC request to attach a namespace.
</a><a href="#h60-0-107" id="h60-0-107" class="i">+// The function should be prepared to be called on the same message more than once; it should only modify the
</a><a href="#h60-0-108" id="h60-0-108" class="i">+// RPC request the first time.
</a><a href="#h60-0-109" id="h60-0-109" class="i">+var NamespaceMods = make(map[string]func(m proto.Message, namespace string))
</a><b>diff --git a/<a id="h61" href="../file/vendor/google.golang.org/appengine/internal/log/BUILD">vendor/google.golang.org/appengine/internal/log/BUILD</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/log/BUILD">vendor/google.golang.org/appengine/internal/log/BUILD</a></b>
<a href="#h61-0" id="h61-0" class="h">@@ -0,0 +1,19 @@
</a><a href="#h61-0-0" id="h61-0-0" class="i">+
</a><a href="#h61-0-1" id="h61-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h61-0-2" id="h61-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h61-0-3" id="h61-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h61-0-4" id="h61-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h61-0-5" id="h61-0-5" class="i">+)
</a><a href="#h61-0-6" id="h61-0-6" class="i">+
</a><a href="#h61-0-7" id="h61-0-7" class="i">+go_library(
</a><a href="#h61-0-8" id="h61-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h61-0-9" id="h61-0-9" class="i">+  srcs = [
</a><a href="#h61-0-10" id="h61-0-10" class="i">+    &quot;log_service.pb.go&quot;,
</a><a href="#h61-0-11" id="h61-0-11" class="i">+  ],
</a><a href="#h61-0-12" id="h61-0-12" class="i">+  deps = [
</a><a href="#h61-0-13" id="h61-0-13" class="i">+    &quot;//vendor/github.com/golang/protobuf/proto:go_default_library&quot;,
</a><a href="#h61-0-14" id="h61-0-14" class="i">+  ],
</a><a href="#h61-0-15" id="h61-0-15" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h61-0-16" id="h61-0-16" class="i">+)
</a><a href="#h61-0-17" id="h61-0-17" class="i">+
</a><a href="#h61-0-18" id="h61-0-18" class="i">+
</a><b>diff --git a/<a id="h62" href="../file/vendor/google.golang.org/appengine/internal/log/log_service.pb.go">vendor/google.golang.org/appengine/internal/log/log_service.pb.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/log/log_service.pb.go">vendor/google.golang.org/appengine/internal/log/log_service.pb.go</a></b>
<a href="#h62-0" id="h62-0" class="h">@@ -0,0 +1,899 @@
</a><a href="#h62-0-0" id="h62-0-0" class="i">+// Code generated by protoc-gen-go.
</a><a href="#h62-0-1" id="h62-0-1" class="i">+// source: google.golang.org/appengine/internal/log/log_service.proto
</a><a href="#h62-0-2" id="h62-0-2" class="i">+// DO NOT EDIT!
</a><a href="#h62-0-3" id="h62-0-3" class="i">+
</a><a href="#h62-0-4" id="h62-0-4" class="i">+/*
</a><a href="#h62-0-5" id="h62-0-5" class="i">+Package log is a generated protocol buffer package.
</a><a href="#h62-0-6" id="h62-0-6" class="i">+
</a><a href="#h62-0-7" id="h62-0-7" class="i">+It is generated from these files:
</a><a href="#h62-0-8" id="h62-0-8" class="i">+	google.golang.org/appengine/internal/log/log_service.proto
</a><a href="#h62-0-9" id="h62-0-9" class="i">+
</a><a href="#h62-0-10" id="h62-0-10" class="i">+It has these top-level messages:
</a><a href="#h62-0-11" id="h62-0-11" class="i">+	LogServiceError
</a><a href="#h62-0-12" id="h62-0-12" class="i">+	UserAppLogLine
</a><a href="#h62-0-13" id="h62-0-13" class="i">+	UserAppLogGroup
</a><a href="#h62-0-14" id="h62-0-14" class="i">+	FlushRequest
</a><a href="#h62-0-15" id="h62-0-15" class="i">+	SetStatusRequest
</a><a href="#h62-0-16" id="h62-0-16" class="i">+	LogOffset
</a><a href="#h62-0-17" id="h62-0-17" class="i">+	LogLine
</a><a href="#h62-0-18" id="h62-0-18" class="i">+	RequestLog
</a><a href="#h62-0-19" id="h62-0-19" class="i">+	LogModuleVersion
</a><a href="#h62-0-20" id="h62-0-20" class="i">+	LogReadRequest
</a><a href="#h62-0-21" id="h62-0-21" class="i">+	LogReadResponse
</a><a href="#h62-0-22" id="h62-0-22" class="i">+	LogUsageRecord
</a><a href="#h62-0-23" id="h62-0-23" class="i">+	LogUsageRequest
</a><a href="#h62-0-24" id="h62-0-24" class="i">+	LogUsageResponse
</a><a href="#h62-0-25" id="h62-0-25" class="i">+*/
</a><a href="#h62-0-26" id="h62-0-26" class="i">+package log
</a><a href="#h62-0-27" id="h62-0-27" class="i">+
</a><a href="#h62-0-28" id="h62-0-28" class="i">+import proto &quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h62-0-29" id="h62-0-29" class="i">+import fmt &quot;fmt&quot;
</a><a href="#h62-0-30" id="h62-0-30" class="i">+import math &quot;math&quot;
</a><a href="#h62-0-31" id="h62-0-31" class="i">+
</a><a href="#h62-0-32" id="h62-0-32" class="i">+// Reference imports to suppress errors if they are not otherwise used.
</a><a href="#h62-0-33" id="h62-0-33" class="i">+var _ = proto.Marshal
</a><a href="#h62-0-34" id="h62-0-34" class="i">+var _ = fmt.Errorf
</a><a href="#h62-0-35" id="h62-0-35" class="i">+var _ = math.Inf
</a><a href="#h62-0-36" id="h62-0-36" class="i">+
</a><a href="#h62-0-37" id="h62-0-37" class="i">+type LogServiceError_ErrorCode int32
</a><a href="#h62-0-38" id="h62-0-38" class="i">+
</a><a href="#h62-0-39" id="h62-0-39" class="i">+const (
</a><a href="#h62-0-40" id="h62-0-40" class="i">+	LogServiceError_OK              LogServiceError_ErrorCode = 0
</a><a href="#h62-0-41" id="h62-0-41" class="i">+	LogServiceError_INVALID_REQUEST LogServiceError_ErrorCode = 1
</a><a href="#h62-0-42" id="h62-0-42" class="i">+	LogServiceError_STORAGE_ERROR   LogServiceError_ErrorCode = 2
</a><a href="#h62-0-43" id="h62-0-43" class="i">+)
</a><a href="#h62-0-44" id="h62-0-44" class="i">+
</a><a href="#h62-0-45" id="h62-0-45" class="i">+var LogServiceError_ErrorCode_name = map[int32]string{
</a><a href="#h62-0-46" id="h62-0-46" class="i">+	0: &quot;OK&quot;,
</a><a href="#h62-0-47" id="h62-0-47" class="i">+	1: &quot;INVALID_REQUEST&quot;,
</a><a href="#h62-0-48" id="h62-0-48" class="i">+	2: &quot;STORAGE_ERROR&quot;,
</a><a href="#h62-0-49" id="h62-0-49" class="i">+}
</a><a href="#h62-0-50" id="h62-0-50" class="i">+var LogServiceError_ErrorCode_value = map[string]int32{
</a><a href="#h62-0-51" id="h62-0-51" class="i">+	&quot;OK&quot;:              0,
</a><a href="#h62-0-52" id="h62-0-52" class="i">+	&quot;INVALID_REQUEST&quot;: 1,
</a><a href="#h62-0-53" id="h62-0-53" class="i">+	&quot;STORAGE_ERROR&quot;:   2,
</a><a href="#h62-0-54" id="h62-0-54" class="i">+}
</a><a href="#h62-0-55" id="h62-0-55" class="i">+
</a><a href="#h62-0-56" id="h62-0-56" class="i">+func (x LogServiceError_ErrorCode) Enum() *LogServiceError_ErrorCode {
</a><a href="#h62-0-57" id="h62-0-57" class="i">+	p := new(LogServiceError_ErrorCode)
</a><a href="#h62-0-58" id="h62-0-58" class="i">+	*p = x
</a><a href="#h62-0-59" id="h62-0-59" class="i">+	return p
</a><a href="#h62-0-60" id="h62-0-60" class="i">+}
</a><a href="#h62-0-61" id="h62-0-61" class="i">+func (x LogServiceError_ErrorCode) String() string {
</a><a href="#h62-0-62" id="h62-0-62" class="i">+	return proto.EnumName(LogServiceError_ErrorCode_name, int32(x))
</a><a href="#h62-0-63" id="h62-0-63" class="i">+}
</a><a href="#h62-0-64" id="h62-0-64" class="i">+func (x *LogServiceError_ErrorCode) UnmarshalJSON(data []byte) error {
</a><a href="#h62-0-65" id="h62-0-65" class="i">+	value, err := proto.UnmarshalJSONEnum(LogServiceError_ErrorCode_value, data, &quot;LogServiceError_ErrorCode&quot;)
</a><a href="#h62-0-66" id="h62-0-66" class="i">+	if err != nil {
</a><a href="#h62-0-67" id="h62-0-67" class="i">+		return err
</a><a href="#h62-0-68" id="h62-0-68" class="i">+	}
</a><a href="#h62-0-69" id="h62-0-69" class="i">+	*x = LogServiceError_ErrorCode(value)
</a><a href="#h62-0-70" id="h62-0-70" class="i">+	return nil
</a><a href="#h62-0-71" id="h62-0-71" class="i">+}
</a><a href="#h62-0-72" id="h62-0-72" class="i">+
</a><a href="#h62-0-73" id="h62-0-73" class="i">+type LogServiceError struct {
</a><a href="#h62-0-74" id="h62-0-74" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h62-0-75" id="h62-0-75" class="i">+}
</a><a href="#h62-0-76" id="h62-0-76" class="i">+
</a><a href="#h62-0-77" id="h62-0-77" class="i">+func (m *LogServiceError) Reset()         { *m = LogServiceError{} }
</a><a href="#h62-0-78" id="h62-0-78" class="i">+func (m *LogServiceError) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-79" id="h62-0-79" class="i">+func (*LogServiceError) ProtoMessage()    {}
</a><a href="#h62-0-80" id="h62-0-80" class="i">+
</a><a href="#h62-0-81" id="h62-0-81" class="i">+type UserAppLogLine struct {
</a><a href="#h62-0-82" id="h62-0-82" class="i">+	TimestampUsec    *int64  `protobuf:&quot;varint,1,req,name=timestamp_usec&quot; json:&quot;timestamp_usec,omitempty&quot;`
</a><a href="#h62-0-83" id="h62-0-83" class="i">+	Level            *int64  `protobuf:&quot;varint,2,req,name=level&quot; json:&quot;level,omitempty&quot;`
</a><a href="#h62-0-84" id="h62-0-84" class="i">+	Message          *string `protobuf:&quot;bytes,3,req,name=message&quot; json:&quot;message,omitempty&quot;`
</a><a href="#h62-0-85" id="h62-0-85" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h62-0-86" id="h62-0-86" class="i">+}
</a><a href="#h62-0-87" id="h62-0-87" class="i">+
</a><a href="#h62-0-88" id="h62-0-88" class="i">+func (m *UserAppLogLine) Reset()         { *m = UserAppLogLine{} }
</a><a href="#h62-0-89" id="h62-0-89" class="i">+func (m *UserAppLogLine) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-90" id="h62-0-90" class="i">+func (*UserAppLogLine) ProtoMessage()    {}
</a><a href="#h62-0-91" id="h62-0-91" class="i">+
</a><a href="#h62-0-92" id="h62-0-92" class="i">+func (m *UserAppLogLine) GetTimestampUsec() int64 {
</a><a href="#h62-0-93" id="h62-0-93" class="i">+	if m != nil &amp;&amp; m.TimestampUsec != nil {
</a><a href="#h62-0-94" id="h62-0-94" class="i">+		return *m.TimestampUsec
</a><a href="#h62-0-95" id="h62-0-95" class="i">+	}
</a><a href="#h62-0-96" id="h62-0-96" class="i">+	return 0
</a><a href="#h62-0-97" id="h62-0-97" class="i">+}
</a><a href="#h62-0-98" id="h62-0-98" class="i">+
</a><a href="#h62-0-99" id="h62-0-99" class="i">+func (m *UserAppLogLine) GetLevel() int64 {
</a><a href="#h62-0-100" id="h62-0-100" class="i">+	if m != nil &amp;&amp; m.Level != nil {
</a><a href="#h62-0-101" id="h62-0-101" class="i">+		return *m.Level
</a><a href="#h62-0-102" id="h62-0-102" class="i">+	}
</a><a href="#h62-0-103" id="h62-0-103" class="i">+	return 0
</a><a href="#h62-0-104" id="h62-0-104" class="i">+}
</a><a href="#h62-0-105" id="h62-0-105" class="i">+
</a><a href="#h62-0-106" id="h62-0-106" class="i">+func (m *UserAppLogLine) GetMessage() string {
</a><a href="#h62-0-107" id="h62-0-107" class="i">+	if m != nil &amp;&amp; m.Message != nil {
</a><a href="#h62-0-108" id="h62-0-108" class="i">+		return *m.Message
</a><a href="#h62-0-109" id="h62-0-109" class="i">+	}
</a><a href="#h62-0-110" id="h62-0-110" class="i">+	return &quot;&quot;
</a><a href="#h62-0-111" id="h62-0-111" class="i">+}
</a><a href="#h62-0-112" id="h62-0-112" class="i">+
</a><a href="#h62-0-113" id="h62-0-113" class="i">+type UserAppLogGroup struct {
</a><a href="#h62-0-114" id="h62-0-114" class="i">+	LogLine          []*UserAppLogLine `protobuf:&quot;bytes,2,rep,name=log_line&quot; json:&quot;log_line,omitempty&quot;`
</a><a href="#h62-0-115" id="h62-0-115" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h62-0-116" id="h62-0-116" class="i">+}
</a><a href="#h62-0-117" id="h62-0-117" class="i">+
</a><a href="#h62-0-118" id="h62-0-118" class="i">+func (m *UserAppLogGroup) Reset()         { *m = UserAppLogGroup{} }
</a><a href="#h62-0-119" id="h62-0-119" class="i">+func (m *UserAppLogGroup) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-120" id="h62-0-120" class="i">+func (*UserAppLogGroup) ProtoMessage()    {}
</a><a href="#h62-0-121" id="h62-0-121" class="i">+
</a><a href="#h62-0-122" id="h62-0-122" class="i">+func (m *UserAppLogGroup) GetLogLine() []*UserAppLogLine {
</a><a href="#h62-0-123" id="h62-0-123" class="i">+	if m != nil {
</a><a href="#h62-0-124" id="h62-0-124" class="i">+		return m.LogLine
</a><a href="#h62-0-125" id="h62-0-125" class="i">+	}
</a><a href="#h62-0-126" id="h62-0-126" class="i">+	return nil
</a><a href="#h62-0-127" id="h62-0-127" class="i">+}
</a><a href="#h62-0-128" id="h62-0-128" class="i">+
</a><a href="#h62-0-129" id="h62-0-129" class="i">+type FlushRequest struct {
</a><a href="#h62-0-130" id="h62-0-130" class="i">+	Logs             []byte `protobuf:&quot;bytes,1,opt,name=logs&quot; json:&quot;logs,omitempty&quot;`
</a><a href="#h62-0-131" id="h62-0-131" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h62-0-132" id="h62-0-132" class="i">+}
</a><a href="#h62-0-133" id="h62-0-133" class="i">+
</a><a href="#h62-0-134" id="h62-0-134" class="i">+func (m *FlushRequest) Reset()         { *m = FlushRequest{} }
</a><a href="#h62-0-135" id="h62-0-135" class="i">+func (m *FlushRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-136" id="h62-0-136" class="i">+func (*FlushRequest) ProtoMessage()    {}
</a><a href="#h62-0-137" id="h62-0-137" class="i">+
</a><a href="#h62-0-138" id="h62-0-138" class="i">+func (m *FlushRequest) GetLogs() []byte {
</a><a href="#h62-0-139" id="h62-0-139" class="i">+	if m != nil {
</a><a href="#h62-0-140" id="h62-0-140" class="i">+		return m.Logs
</a><a href="#h62-0-141" id="h62-0-141" class="i">+	}
</a><a href="#h62-0-142" id="h62-0-142" class="i">+	return nil
</a><a href="#h62-0-143" id="h62-0-143" class="i">+}
</a><a href="#h62-0-144" id="h62-0-144" class="i">+
</a><a href="#h62-0-145" id="h62-0-145" class="i">+type SetStatusRequest struct {
</a><a href="#h62-0-146" id="h62-0-146" class="i">+	Status           *string `protobuf:&quot;bytes,1,req,name=status&quot; json:&quot;status,omitempty&quot;`
</a><a href="#h62-0-147" id="h62-0-147" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h62-0-148" id="h62-0-148" class="i">+}
</a><a href="#h62-0-149" id="h62-0-149" class="i">+
</a><a href="#h62-0-150" id="h62-0-150" class="i">+func (m *SetStatusRequest) Reset()         { *m = SetStatusRequest{} }
</a><a href="#h62-0-151" id="h62-0-151" class="i">+func (m *SetStatusRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-152" id="h62-0-152" class="i">+func (*SetStatusRequest) ProtoMessage()    {}
</a><a href="#h62-0-153" id="h62-0-153" class="i">+
</a><a href="#h62-0-154" id="h62-0-154" class="i">+func (m *SetStatusRequest) GetStatus() string {
</a><a href="#h62-0-155" id="h62-0-155" class="i">+	if m != nil &amp;&amp; m.Status != nil {
</a><a href="#h62-0-156" id="h62-0-156" class="i">+		return *m.Status
</a><a href="#h62-0-157" id="h62-0-157" class="i">+	}
</a><a href="#h62-0-158" id="h62-0-158" class="i">+	return &quot;&quot;
</a><a href="#h62-0-159" id="h62-0-159" class="i">+}
</a><a href="#h62-0-160" id="h62-0-160" class="i">+
</a><a href="#h62-0-161" id="h62-0-161" class="i">+type LogOffset struct {
</a><a href="#h62-0-162" id="h62-0-162" class="i">+	RequestId        []byte `protobuf:&quot;bytes,1,opt,name=request_id&quot; json:&quot;request_id,omitempty&quot;`
</a><a href="#h62-0-163" id="h62-0-163" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h62-0-164" id="h62-0-164" class="i">+}
</a><a href="#h62-0-165" id="h62-0-165" class="i">+
</a><a href="#h62-0-166" id="h62-0-166" class="i">+func (m *LogOffset) Reset()         { *m = LogOffset{} }
</a><a href="#h62-0-167" id="h62-0-167" class="i">+func (m *LogOffset) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-168" id="h62-0-168" class="i">+func (*LogOffset) ProtoMessage()    {}
</a><a href="#h62-0-169" id="h62-0-169" class="i">+
</a><a href="#h62-0-170" id="h62-0-170" class="i">+func (m *LogOffset) GetRequestId() []byte {
</a><a href="#h62-0-171" id="h62-0-171" class="i">+	if m != nil {
</a><a href="#h62-0-172" id="h62-0-172" class="i">+		return m.RequestId
</a><a href="#h62-0-173" id="h62-0-173" class="i">+	}
</a><a href="#h62-0-174" id="h62-0-174" class="i">+	return nil
</a><a href="#h62-0-175" id="h62-0-175" class="i">+}
</a><a href="#h62-0-176" id="h62-0-176" class="i">+
</a><a href="#h62-0-177" id="h62-0-177" class="i">+type LogLine struct {
</a><a href="#h62-0-178" id="h62-0-178" class="i">+	Time             *int64  `protobuf:&quot;varint,1,req,name=time&quot; json:&quot;time,omitempty&quot;`
</a><a href="#h62-0-179" id="h62-0-179" class="i">+	Level            *int32  `protobuf:&quot;varint,2,req,name=level&quot; json:&quot;level,omitempty&quot;`
</a><a href="#h62-0-180" id="h62-0-180" class="i">+	LogMessage       *string `protobuf:&quot;bytes,3,req,name=log_message&quot; json:&quot;log_message,omitempty&quot;`
</a><a href="#h62-0-181" id="h62-0-181" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h62-0-182" id="h62-0-182" class="i">+}
</a><a href="#h62-0-183" id="h62-0-183" class="i">+
</a><a href="#h62-0-184" id="h62-0-184" class="i">+func (m *LogLine) Reset()         { *m = LogLine{} }
</a><a href="#h62-0-185" id="h62-0-185" class="i">+func (m *LogLine) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-186" id="h62-0-186" class="i">+func (*LogLine) ProtoMessage()    {}
</a><a href="#h62-0-187" id="h62-0-187" class="i">+
</a><a href="#h62-0-188" id="h62-0-188" class="i">+func (m *LogLine) GetTime() int64 {
</a><a href="#h62-0-189" id="h62-0-189" class="i">+	if m != nil &amp;&amp; m.Time != nil {
</a><a href="#h62-0-190" id="h62-0-190" class="i">+		return *m.Time
</a><a href="#h62-0-191" id="h62-0-191" class="i">+	}
</a><a href="#h62-0-192" id="h62-0-192" class="i">+	return 0
</a><a href="#h62-0-193" id="h62-0-193" class="i">+}
</a><a href="#h62-0-194" id="h62-0-194" class="i">+
</a><a href="#h62-0-195" id="h62-0-195" class="i">+func (m *LogLine) GetLevel() int32 {
</a><a href="#h62-0-196" id="h62-0-196" class="i">+	if m != nil &amp;&amp; m.Level != nil {
</a><a href="#h62-0-197" id="h62-0-197" class="i">+		return *m.Level
</a><a href="#h62-0-198" id="h62-0-198" class="i">+	}
</a><a href="#h62-0-199" id="h62-0-199" class="i">+	return 0
</a><a href="#h62-0-200" id="h62-0-200" class="i">+}
</a><a href="#h62-0-201" id="h62-0-201" class="i">+
</a><a href="#h62-0-202" id="h62-0-202" class="i">+func (m *LogLine) GetLogMessage() string {
</a><a href="#h62-0-203" id="h62-0-203" class="i">+	if m != nil &amp;&amp; m.LogMessage != nil {
</a><a href="#h62-0-204" id="h62-0-204" class="i">+		return *m.LogMessage
</a><a href="#h62-0-205" id="h62-0-205" class="i">+	}
</a><a href="#h62-0-206" id="h62-0-206" class="i">+	return &quot;&quot;
</a><a href="#h62-0-207" id="h62-0-207" class="i">+}
</a><a href="#h62-0-208" id="h62-0-208" class="i">+
</a><a href="#h62-0-209" id="h62-0-209" class="i">+type RequestLog struct {
</a><a href="#h62-0-210" id="h62-0-210" class="i">+	AppId                   *string    `protobuf:&quot;bytes,1,req,name=app_id&quot; json:&quot;app_id,omitempty&quot;`
</a><a href="#h62-0-211" id="h62-0-211" class="i">+	ModuleId                *string    `protobuf:&quot;bytes,37,opt,name=module_id,def=default&quot; json:&quot;module_id,omitempty&quot;`
</a><a href="#h62-0-212" id="h62-0-212" class="i">+	VersionId               *string    `protobuf:&quot;bytes,2,req,name=version_id&quot; json:&quot;version_id,omitempty&quot;`
</a><a href="#h62-0-213" id="h62-0-213" class="i">+	RequestId               []byte     `protobuf:&quot;bytes,3,req,name=request_id&quot; json:&quot;request_id,omitempty&quot;`
</a><a href="#h62-0-214" id="h62-0-214" class="i">+	Offset                  *LogOffset `protobuf:&quot;bytes,35,opt,name=offset&quot; json:&quot;offset,omitempty&quot;`
</a><a href="#h62-0-215" id="h62-0-215" class="i">+	Ip                      *string    `protobuf:&quot;bytes,4,req,name=ip&quot; json:&quot;ip,omitempty&quot;`
</a><a href="#h62-0-216" id="h62-0-216" class="i">+	Nickname                *string    `protobuf:&quot;bytes,5,opt,name=nickname&quot; json:&quot;nickname,omitempty&quot;`
</a><a href="#h62-0-217" id="h62-0-217" class="i">+	StartTime               *int64     `protobuf:&quot;varint,6,req,name=start_time&quot; json:&quot;start_time,omitempty&quot;`
</a><a href="#h62-0-218" id="h62-0-218" class="i">+	EndTime                 *int64     `protobuf:&quot;varint,7,req,name=end_time&quot; json:&quot;end_time,omitempty&quot;`
</a><a href="#h62-0-219" id="h62-0-219" class="i">+	Latency                 *int64     `protobuf:&quot;varint,8,req,name=latency&quot; json:&quot;latency,omitempty&quot;`
</a><a href="#h62-0-220" id="h62-0-220" class="i">+	Mcycles                 *int64     `protobuf:&quot;varint,9,req,name=mcycles&quot; json:&quot;mcycles,omitempty&quot;`
</a><a href="#h62-0-221" id="h62-0-221" class="i">+	Method                  *string    `protobuf:&quot;bytes,10,req,name=method&quot; json:&quot;method,omitempty&quot;`
</a><a href="#h62-0-222" id="h62-0-222" class="i">+	Resource                *string    `protobuf:&quot;bytes,11,req,name=resource&quot; json:&quot;resource,omitempty&quot;`
</a><a href="#h62-0-223" id="h62-0-223" class="i">+	HttpVersion             *string    `protobuf:&quot;bytes,12,req,name=http_version&quot; json:&quot;http_version,omitempty&quot;`
</a><a href="#h62-0-224" id="h62-0-224" class="i">+	Status                  *int32     `protobuf:&quot;varint,13,req,name=status&quot; json:&quot;status,omitempty&quot;`
</a><a href="#h62-0-225" id="h62-0-225" class="i">+	ResponseSize            *int64     `protobuf:&quot;varint,14,req,name=response_size&quot; json:&quot;response_size,omitempty&quot;`
</a><a href="#h62-0-226" id="h62-0-226" class="i">+	Referrer                *string    `protobuf:&quot;bytes,15,opt,name=referrer&quot; json:&quot;referrer,omitempty&quot;`
</a><a href="#h62-0-227" id="h62-0-227" class="i">+	UserAgent               *string    `protobuf:&quot;bytes,16,opt,name=user_agent&quot; json:&quot;user_agent,omitempty&quot;`
</a><a href="#h62-0-228" id="h62-0-228" class="i">+	UrlMapEntry             *string    `protobuf:&quot;bytes,17,req,name=url_map_entry&quot; json:&quot;url_map_entry,omitempty&quot;`
</a><a href="#h62-0-229" id="h62-0-229" class="i">+	Combined                *string    `protobuf:&quot;bytes,18,req,name=combined&quot; json:&quot;combined,omitempty&quot;`
</a><a href="#h62-0-230" id="h62-0-230" class="i">+	ApiMcycles              *int64     `protobuf:&quot;varint,19,opt,name=api_mcycles&quot; json:&quot;api_mcycles,omitempty&quot;`
</a><a href="#h62-0-231" id="h62-0-231" class="i">+	Host                    *string    `protobuf:&quot;bytes,20,opt,name=host&quot; json:&quot;host,omitempty&quot;`
</a><a href="#h62-0-232" id="h62-0-232" class="i">+	Cost                    *float64   `protobuf:&quot;fixed64,21,opt,name=cost&quot; json:&quot;cost,omitempty&quot;`
</a><a href="#h62-0-233" id="h62-0-233" class="i">+	TaskQueueName           *string    `protobuf:&quot;bytes,22,opt,name=task_queue_name&quot; json:&quot;task_queue_name,omitempty&quot;`
</a><a href="#h62-0-234" id="h62-0-234" class="i">+	TaskName                *string    `protobuf:&quot;bytes,23,opt,name=task_name&quot; json:&quot;task_name,omitempty&quot;`
</a><a href="#h62-0-235" id="h62-0-235" class="i">+	WasLoadingRequest       *bool      `protobuf:&quot;varint,24,opt,name=was_loading_request&quot; json:&quot;was_loading_request,omitempty&quot;`
</a><a href="#h62-0-236" id="h62-0-236" class="i">+	PendingTime             *int64     `protobuf:&quot;varint,25,opt,name=pending_time&quot; json:&quot;pending_time,omitempty&quot;`
</a><a href="#h62-0-237" id="h62-0-237" class="i">+	ReplicaIndex            *int32     `protobuf:&quot;varint,26,opt,name=replica_index,def=-1&quot; json:&quot;replica_index,omitempty&quot;`
</a><a href="#h62-0-238" id="h62-0-238" class="i">+	Finished                *bool      `protobuf:&quot;varint,27,opt,name=finished,def=1&quot; json:&quot;finished,omitempty&quot;`
</a><a href="#h62-0-239" id="h62-0-239" class="i">+	CloneKey                []byte     `protobuf:&quot;bytes,28,opt,name=clone_key&quot; json:&quot;clone_key,omitempty&quot;`
</a><a href="#h62-0-240" id="h62-0-240" class="i">+	Line                    []*LogLine `protobuf:&quot;bytes,29,rep,name=line&quot; json:&quot;line,omitempty&quot;`
</a><a href="#h62-0-241" id="h62-0-241" class="i">+	LinesIncomplete         *bool      `protobuf:&quot;varint,36,opt,name=lines_incomplete&quot; json:&quot;lines_incomplete,omitempty&quot;`
</a><a href="#h62-0-242" id="h62-0-242" class="i">+	AppEngineRelease        []byte     `protobuf:&quot;bytes,38,opt,name=app_engine_release&quot; json:&quot;app_engine_release,omitempty&quot;`
</a><a href="#h62-0-243" id="h62-0-243" class="i">+	ExitReason              *int32     `protobuf:&quot;varint,30,opt,name=exit_reason&quot; json:&quot;exit_reason,omitempty&quot;`
</a><a href="#h62-0-244" id="h62-0-244" class="i">+	WasThrottledForTime     *bool      `protobuf:&quot;varint,31,opt,name=was_throttled_for_time&quot; json:&quot;was_throttled_for_time,omitempty&quot;`
</a><a href="#h62-0-245" id="h62-0-245" class="i">+	WasThrottledForRequests *bool      `protobuf:&quot;varint,32,opt,name=was_throttled_for_requests&quot; json:&quot;was_throttled_for_requests,omitempty&quot;`
</a><a href="#h62-0-246" id="h62-0-246" class="i">+	ThrottledTime           *int64     `protobuf:&quot;varint,33,opt,name=throttled_time&quot; json:&quot;throttled_time,omitempty&quot;`
</a><a href="#h62-0-247" id="h62-0-247" class="i">+	ServerName              []byte     `protobuf:&quot;bytes,34,opt,name=server_name&quot; json:&quot;server_name,omitempty&quot;`
</a><a href="#h62-0-248" id="h62-0-248" class="i">+	XXX_unrecognized        []byte     `json:&quot;-&quot;`
</a><a href="#h62-0-249" id="h62-0-249" class="i">+}
</a><a href="#h62-0-250" id="h62-0-250" class="i">+
</a><a href="#h62-0-251" id="h62-0-251" class="i">+func (m *RequestLog) Reset()         { *m = RequestLog{} }
</a><a href="#h62-0-252" id="h62-0-252" class="i">+func (m *RequestLog) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-253" id="h62-0-253" class="i">+func (*RequestLog) ProtoMessage()    {}
</a><a href="#h62-0-254" id="h62-0-254" class="i">+
</a><a href="#h62-0-255" id="h62-0-255" class="i">+const Default_RequestLog_ModuleId string = &quot;default&quot;
</a><a href="#h62-0-256" id="h62-0-256" class="i">+const Default_RequestLog_ReplicaIndex int32 = -1
</a><a href="#h62-0-257" id="h62-0-257" class="i">+const Default_RequestLog_Finished bool = true
</a><a href="#h62-0-258" id="h62-0-258" class="i">+
</a><a href="#h62-0-259" id="h62-0-259" class="i">+func (m *RequestLog) GetAppId() string {
</a><a href="#h62-0-260" id="h62-0-260" class="i">+	if m != nil &amp;&amp; m.AppId != nil {
</a><a href="#h62-0-261" id="h62-0-261" class="i">+		return *m.AppId
</a><a href="#h62-0-262" id="h62-0-262" class="i">+	}
</a><a href="#h62-0-263" id="h62-0-263" class="i">+	return &quot;&quot;
</a><a href="#h62-0-264" id="h62-0-264" class="i">+}
</a><a href="#h62-0-265" id="h62-0-265" class="i">+
</a><a href="#h62-0-266" id="h62-0-266" class="i">+func (m *RequestLog) GetModuleId() string {
</a><a href="#h62-0-267" id="h62-0-267" class="i">+	if m != nil &amp;&amp; m.ModuleId != nil {
</a><a href="#h62-0-268" id="h62-0-268" class="i">+		return *m.ModuleId
</a><a href="#h62-0-269" id="h62-0-269" class="i">+	}
</a><a href="#h62-0-270" id="h62-0-270" class="i">+	return Default_RequestLog_ModuleId
</a><a href="#h62-0-271" id="h62-0-271" class="i">+}
</a><a href="#h62-0-272" id="h62-0-272" class="i">+
</a><a href="#h62-0-273" id="h62-0-273" class="i">+func (m *RequestLog) GetVersionId() string {
</a><a href="#h62-0-274" id="h62-0-274" class="i">+	if m != nil &amp;&amp; m.VersionId != nil {
</a><a href="#h62-0-275" id="h62-0-275" class="i">+		return *m.VersionId
</a><a href="#h62-0-276" id="h62-0-276" class="i">+	}
</a><a href="#h62-0-277" id="h62-0-277" class="i">+	return &quot;&quot;
</a><a href="#h62-0-278" id="h62-0-278" class="i">+}
</a><a href="#h62-0-279" id="h62-0-279" class="i">+
</a><a href="#h62-0-280" id="h62-0-280" class="i">+func (m *RequestLog) GetRequestId() []byte {
</a><a href="#h62-0-281" id="h62-0-281" class="i">+	if m != nil {
</a><a href="#h62-0-282" id="h62-0-282" class="i">+		return m.RequestId
</a><a href="#h62-0-283" id="h62-0-283" class="i">+	}
</a><a href="#h62-0-284" id="h62-0-284" class="i">+	return nil
</a><a href="#h62-0-285" id="h62-0-285" class="i">+}
</a><a href="#h62-0-286" id="h62-0-286" class="i">+
</a><a href="#h62-0-287" id="h62-0-287" class="i">+func (m *RequestLog) GetOffset() *LogOffset {
</a><a href="#h62-0-288" id="h62-0-288" class="i">+	if m != nil {
</a><a href="#h62-0-289" id="h62-0-289" class="i">+		return m.Offset
</a><a href="#h62-0-290" id="h62-0-290" class="i">+	}
</a><a href="#h62-0-291" id="h62-0-291" class="i">+	return nil
</a><a href="#h62-0-292" id="h62-0-292" class="i">+}
</a><a href="#h62-0-293" id="h62-0-293" class="i">+
</a><a href="#h62-0-294" id="h62-0-294" class="i">+func (m *RequestLog) GetIp() string {
</a><a href="#h62-0-295" id="h62-0-295" class="i">+	if m != nil &amp;&amp; m.Ip != nil {
</a><a href="#h62-0-296" id="h62-0-296" class="i">+		return *m.Ip
</a><a href="#h62-0-297" id="h62-0-297" class="i">+	}
</a><a href="#h62-0-298" id="h62-0-298" class="i">+	return &quot;&quot;
</a><a href="#h62-0-299" id="h62-0-299" class="i">+}
</a><a href="#h62-0-300" id="h62-0-300" class="i">+
</a><a href="#h62-0-301" id="h62-0-301" class="i">+func (m *RequestLog) GetNickname() string {
</a><a href="#h62-0-302" id="h62-0-302" class="i">+	if m != nil &amp;&amp; m.Nickname != nil {
</a><a href="#h62-0-303" id="h62-0-303" class="i">+		return *m.Nickname
</a><a href="#h62-0-304" id="h62-0-304" class="i">+	}
</a><a href="#h62-0-305" id="h62-0-305" class="i">+	return &quot;&quot;
</a><a href="#h62-0-306" id="h62-0-306" class="i">+}
</a><a href="#h62-0-307" id="h62-0-307" class="i">+
</a><a href="#h62-0-308" id="h62-0-308" class="i">+func (m *RequestLog) GetStartTime() int64 {
</a><a href="#h62-0-309" id="h62-0-309" class="i">+	if m != nil &amp;&amp; m.StartTime != nil {
</a><a href="#h62-0-310" id="h62-0-310" class="i">+		return *m.StartTime
</a><a href="#h62-0-311" id="h62-0-311" class="i">+	}
</a><a href="#h62-0-312" id="h62-0-312" class="i">+	return 0
</a><a href="#h62-0-313" id="h62-0-313" class="i">+}
</a><a href="#h62-0-314" id="h62-0-314" class="i">+
</a><a href="#h62-0-315" id="h62-0-315" class="i">+func (m *RequestLog) GetEndTime() int64 {
</a><a href="#h62-0-316" id="h62-0-316" class="i">+	if m != nil &amp;&amp; m.EndTime != nil {
</a><a href="#h62-0-317" id="h62-0-317" class="i">+		return *m.EndTime
</a><a href="#h62-0-318" id="h62-0-318" class="i">+	}
</a><a href="#h62-0-319" id="h62-0-319" class="i">+	return 0
</a><a href="#h62-0-320" id="h62-0-320" class="i">+}
</a><a href="#h62-0-321" id="h62-0-321" class="i">+
</a><a href="#h62-0-322" id="h62-0-322" class="i">+func (m *RequestLog) GetLatency() int64 {
</a><a href="#h62-0-323" id="h62-0-323" class="i">+	if m != nil &amp;&amp; m.Latency != nil {
</a><a href="#h62-0-324" id="h62-0-324" class="i">+		return *m.Latency
</a><a href="#h62-0-325" id="h62-0-325" class="i">+	}
</a><a href="#h62-0-326" id="h62-0-326" class="i">+	return 0
</a><a href="#h62-0-327" id="h62-0-327" class="i">+}
</a><a href="#h62-0-328" id="h62-0-328" class="i">+
</a><a href="#h62-0-329" id="h62-0-329" class="i">+func (m *RequestLog) GetMcycles() int64 {
</a><a href="#h62-0-330" id="h62-0-330" class="i">+	if m != nil &amp;&amp; m.Mcycles != nil {
</a><a href="#h62-0-331" id="h62-0-331" class="i">+		return *m.Mcycles
</a><a href="#h62-0-332" id="h62-0-332" class="i">+	}
</a><a href="#h62-0-333" id="h62-0-333" class="i">+	return 0
</a><a href="#h62-0-334" id="h62-0-334" class="i">+}
</a><a href="#h62-0-335" id="h62-0-335" class="i">+
</a><a href="#h62-0-336" id="h62-0-336" class="i">+func (m *RequestLog) GetMethod() string {
</a><a href="#h62-0-337" id="h62-0-337" class="i">+	if m != nil &amp;&amp; m.Method != nil {
</a><a href="#h62-0-338" id="h62-0-338" class="i">+		return *m.Method
</a><a href="#h62-0-339" id="h62-0-339" class="i">+	}
</a><a href="#h62-0-340" id="h62-0-340" class="i">+	return &quot;&quot;
</a><a href="#h62-0-341" id="h62-0-341" class="i">+}
</a><a href="#h62-0-342" id="h62-0-342" class="i">+
</a><a href="#h62-0-343" id="h62-0-343" class="i">+func (m *RequestLog) GetResource() string {
</a><a href="#h62-0-344" id="h62-0-344" class="i">+	if m != nil &amp;&amp; m.Resource != nil {
</a><a href="#h62-0-345" id="h62-0-345" class="i">+		return *m.Resource
</a><a href="#h62-0-346" id="h62-0-346" class="i">+	}
</a><a href="#h62-0-347" id="h62-0-347" class="i">+	return &quot;&quot;
</a><a href="#h62-0-348" id="h62-0-348" class="i">+}
</a><a href="#h62-0-349" id="h62-0-349" class="i">+
</a><a href="#h62-0-350" id="h62-0-350" class="i">+func (m *RequestLog) GetHttpVersion() string {
</a><a href="#h62-0-351" id="h62-0-351" class="i">+	if m != nil &amp;&amp; m.HttpVersion != nil {
</a><a href="#h62-0-352" id="h62-0-352" class="i">+		return *m.HttpVersion
</a><a href="#h62-0-353" id="h62-0-353" class="i">+	}
</a><a href="#h62-0-354" id="h62-0-354" class="i">+	return &quot;&quot;
</a><a href="#h62-0-355" id="h62-0-355" class="i">+}
</a><a href="#h62-0-356" id="h62-0-356" class="i">+
</a><a href="#h62-0-357" id="h62-0-357" class="i">+func (m *RequestLog) GetStatus() int32 {
</a><a href="#h62-0-358" id="h62-0-358" class="i">+	if m != nil &amp;&amp; m.Status != nil {
</a><a href="#h62-0-359" id="h62-0-359" class="i">+		return *m.Status
</a><a href="#h62-0-360" id="h62-0-360" class="i">+	}
</a><a href="#h62-0-361" id="h62-0-361" class="i">+	return 0
</a><a href="#h62-0-362" id="h62-0-362" class="i">+}
</a><a href="#h62-0-363" id="h62-0-363" class="i">+
</a><a href="#h62-0-364" id="h62-0-364" class="i">+func (m *RequestLog) GetResponseSize() int64 {
</a><a href="#h62-0-365" id="h62-0-365" class="i">+	if m != nil &amp;&amp; m.ResponseSize != nil {
</a><a href="#h62-0-366" id="h62-0-366" class="i">+		return *m.ResponseSize
</a><a href="#h62-0-367" id="h62-0-367" class="i">+	}
</a><a href="#h62-0-368" id="h62-0-368" class="i">+	return 0
</a><a href="#h62-0-369" id="h62-0-369" class="i">+}
</a><a href="#h62-0-370" id="h62-0-370" class="i">+
</a><a href="#h62-0-371" id="h62-0-371" class="i">+func (m *RequestLog) GetReferrer() string {
</a><a href="#h62-0-372" id="h62-0-372" class="i">+	if m != nil &amp;&amp; m.Referrer != nil {
</a><a href="#h62-0-373" id="h62-0-373" class="i">+		return *m.Referrer
</a><a href="#h62-0-374" id="h62-0-374" class="i">+	}
</a><a href="#h62-0-375" id="h62-0-375" class="i">+	return &quot;&quot;
</a><a href="#h62-0-376" id="h62-0-376" class="i">+}
</a><a href="#h62-0-377" id="h62-0-377" class="i">+
</a><a href="#h62-0-378" id="h62-0-378" class="i">+func (m *RequestLog) GetUserAgent() string {
</a><a href="#h62-0-379" id="h62-0-379" class="i">+	if m != nil &amp;&amp; m.UserAgent != nil {
</a><a href="#h62-0-380" id="h62-0-380" class="i">+		return *m.UserAgent
</a><a href="#h62-0-381" id="h62-0-381" class="i">+	}
</a><a href="#h62-0-382" id="h62-0-382" class="i">+	return &quot;&quot;
</a><a href="#h62-0-383" id="h62-0-383" class="i">+}
</a><a href="#h62-0-384" id="h62-0-384" class="i">+
</a><a href="#h62-0-385" id="h62-0-385" class="i">+func (m *RequestLog) GetUrlMapEntry() string {
</a><a href="#h62-0-386" id="h62-0-386" class="i">+	if m != nil &amp;&amp; m.UrlMapEntry != nil {
</a><a href="#h62-0-387" id="h62-0-387" class="i">+		return *m.UrlMapEntry
</a><a href="#h62-0-388" id="h62-0-388" class="i">+	}
</a><a href="#h62-0-389" id="h62-0-389" class="i">+	return &quot;&quot;
</a><a href="#h62-0-390" id="h62-0-390" class="i">+}
</a><a href="#h62-0-391" id="h62-0-391" class="i">+
</a><a href="#h62-0-392" id="h62-0-392" class="i">+func (m *RequestLog) GetCombined() string {
</a><a href="#h62-0-393" id="h62-0-393" class="i">+	if m != nil &amp;&amp; m.Combined != nil {
</a><a href="#h62-0-394" id="h62-0-394" class="i">+		return *m.Combined
</a><a href="#h62-0-395" id="h62-0-395" class="i">+	}
</a><a href="#h62-0-396" id="h62-0-396" class="i">+	return &quot;&quot;
</a><a href="#h62-0-397" id="h62-0-397" class="i">+}
</a><a href="#h62-0-398" id="h62-0-398" class="i">+
</a><a href="#h62-0-399" id="h62-0-399" class="i">+func (m *RequestLog) GetApiMcycles() int64 {
</a><a href="#h62-0-400" id="h62-0-400" class="i">+	if m != nil &amp;&amp; m.ApiMcycles != nil {
</a><a href="#h62-0-401" id="h62-0-401" class="i">+		return *m.ApiMcycles
</a><a href="#h62-0-402" id="h62-0-402" class="i">+	}
</a><a href="#h62-0-403" id="h62-0-403" class="i">+	return 0
</a><a href="#h62-0-404" id="h62-0-404" class="i">+}
</a><a href="#h62-0-405" id="h62-0-405" class="i">+
</a><a href="#h62-0-406" id="h62-0-406" class="i">+func (m *RequestLog) GetHost() string {
</a><a href="#h62-0-407" id="h62-0-407" class="i">+	if m != nil &amp;&amp; m.Host != nil {
</a><a href="#h62-0-408" id="h62-0-408" class="i">+		return *m.Host
</a><a href="#h62-0-409" id="h62-0-409" class="i">+	}
</a><a href="#h62-0-410" id="h62-0-410" class="i">+	return &quot;&quot;
</a><a href="#h62-0-411" id="h62-0-411" class="i">+}
</a><a href="#h62-0-412" id="h62-0-412" class="i">+
</a><a href="#h62-0-413" id="h62-0-413" class="i">+func (m *RequestLog) GetCost() float64 {
</a><a href="#h62-0-414" id="h62-0-414" class="i">+	if m != nil &amp;&amp; m.Cost != nil {
</a><a href="#h62-0-415" id="h62-0-415" class="i">+		return *m.Cost
</a><a href="#h62-0-416" id="h62-0-416" class="i">+	}
</a><a href="#h62-0-417" id="h62-0-417" class="i">+	return 0
</a><a href="#h62-0-418" id="h62-0-418" class="i">+}
</a><a href="#h62-0-419" id="h62-0-419" class="i">+
</a><a href="#h62-0-420" id="h62-0-420" class="i">+func (m *RequestLog) GetTaskQueueName() string {
</a><a href="#h62-0-421" id="h62-0-421" class="i">+	if m != nil &amp;&amp; m.TaskQueueName != nil {
</a><a href="#h62-0-422" id="h62-0-422" class="i">+		return *m.TaskQueueName
</a><a href="#h62-0-423" id="h62-0-423" class="i">+	}
</a><a href="#h62-0-424" id="h62-0-424" class="i">+	return &quot;&quot;
</a><a href="#h62-0-425" id="h62-0-425" class="i">+}
</a><a href="#h62-0-426" id="h62-0-426" class="i">+
</a><a href="#h62-0-427" id="h62-0-427" class="i">+func (m *RequestLog) GetTaskName() string {
</a><a href="#h62-0-428" id="h62-0-428" class="i">+	if m != nil &amp;&amp; m.TaskName != nil {
</a><a href="#h62-0-429" id="h62-0-429" class="i">+		return *m.TaskName
</a><a href="#h62-0-430" id="h62-0-430" class="i">+	}
</a><a href="#h62-0-431" id="h62-0-431" class="i">+	return &quot;&quot;
</a><a href="#h62-0-432" id="h62-0-432" class="i">+}
</a><a href="#h62-0-433" id="h62-0-433" class="i">+
</a><a href="#h62-0-434" id="h62-0-434" class="i">+func (m *RequestLog) GetWasLoadingRequest() bool {
</a><a href="#h62-0-435" id="h62-0-435" class="i">+	if m != nil &amp;&amp; m.WasLoadingRequest != nil {
</a><a href="#h62-0-436" id="h62-0-436" class="i">+		return *m.WasLoadingRequest
</a><a href="#h62-0-437" id="h62-0-437" class="i">+	}
</a><a href="#h62-0-438" id="h62-0-438" class="i">+	return false
</a><a href="#h62-0-439" id="h62-0-439" class="i">+}
</a><a href="#h62-0-440" id="h62-0-440" class="i">+
</a><a href="#h62-0-441" id="h62-0-441" class="i">+func (m *RequestLog) GetPendingTime() int64 {
</a><a href="#h62-0-442" id="h62-0-442" class="i">+	if m != nil &amp;&amp; m.PendingTime != nil {
</a><a href="#h62-0-443" id="h62-0-443" class="i">+		return *m.PendingTime
</a><a href="#h62-0-444" id="h62-0-444" class="i">+	}
</a><a href="#h62-0-445" id="h62-0-445" class="i">+	return 0
</a><a href="#h62-0-446" id="h62-0-446" class="i">+}
</a><a href="#h62-0-447" id="h62-0-447" class="i">+
</a><a href="#h62-0-448" id="h62-0-448" class="i">+func (m *RequestLog) GetReplicaIndex() int32 {
</a><a href="#h62-0-449" id="h62-0-449" class="i">+	if m != nil &amp;&amp; m.ReplicaIndex != nil {
</a><a href="#h62-0-450" id="h62-0-450" class="i">+		return *m.ReplicaIndex
</a><a href="#h62-0-451" id="h62-0-451" class="i">+	}
</a><a href="#h62-0-452" id="h62-0-452" class="i">+	return Default_RequestLog_ReplicaIndex
</a><a href="#h62-0-453" id="h62-0-453" class="i">+}
</a><a href="#h62-0-454" id="h62-0-454" class="i">+
</a><a href="#h62-0-455" id="h62-0-455" class="i">+func (m *RequestLog) GetFinished() bool {
</a><a href="#h62-0-456" id="h62-0-456" class="i">+	if m != nil &amp;&amp; m.Finished != nil {
</a><a href="#h62-0-457" id="h62-0-457" class="i">+		return *m.Finished
</a><a href="#h62-0-458" id="h62-0-458" class="i">+	}
</a><a href="#h62-0-459" id="h62-0-459" class="i">+	return Default_RequestLog_Finished
</a><a href="#h62-0-460" id="h62-0-460" class="i">+}
</a><a href="#h62-0-461" id="h62-0-461" class="i">+
</a><a href="#h62-0-462" id="h62-0-462" class="i">+func (m *RequestLog) GetCloneKey() []byte {
</a><a href="#h62-0-463" id="h62-0-463" class="i">+	if m != nil {
</a><a href="#h62-0-464" id="h62-0-464" class="i">+		return m.CloneKey
</a><a href="#h62-0-465" id="h62-0-465" class="i">+	}
</a><a href="#h62-0-466" id="h62-0-466" class="i">+	return nil
</a><a href="#h62-0-467" id="h62-0-467" class="i">+}
</a><a href="#h62-0-468" id="h62-0-468" class="i">+
</a><a href="#h62-0-469" id="h62-0-469" class="i">+func (m *RequestLog) GetLine() []*LogLine {
</a><a href="#h62-0-470" id="h62-0-470" class="i">+	if m != nil {
</a><a href="#h62-0-471" id="h62-0-471" class="i">+		return m.Line
</a><a href="#h62-0-472" id="h62-0-472" class="i">+	}
</a><a href="#h62-0-473" id="h62-0-473" class="i">+	return nil
</a><a href="#h62-0-474" id="h62-0-474" class="i">+}
</a><a href="#h62-0-475" id="h62-0-475" class="i">+
</a><a href="#h62-0-476" id="h62-0-476" class="i">+func (m *RequestLog) GetLinesIncomplete() bool {
</a><a href="#h62-0-477" id="h62-0-477" class="i">+	if m != nil &amp;&amp; m.LinesIncomplete != nil {
</a><a href="#h62-0-478" id="h62-0-478" class="i">+		return *m.LinesIncomplete
</a><a href="#h62-0-479" id="h62-0-479" class="i">+	}
</a><a href="#h62-0-480" id="h62-0-480" class="i">+	return false
</a><a href="#h62-0-481" id="h62-0-481" class="i">+}
</a><a href="#h62-0-482" id="h62-0-482" class="i">+
</a><a href="#h62-0-483" id="h62-0-483" class="i">+func (m *RequestLog) GetAppEngineRelease() []byte {
</a><a href="#h62-0-484" id="h62-0-484" class="i">+	if m != nil {
</a><a href="#h62-0-485" id="h62-0-485" class="i">+		return m.AppEngineRelease
</a><a href="#h62-0-486" id="h62-0-486" class="i">+	}
</a><a href="#h62-0-487" id="h62-0-487" class="i">+	return nil
</a><a href="#h62-0-488" id="h62-0-488" class="i">+}
</a><a href="#h62-0-489" id="h62-0-489" class="i">+
</a><a href="#h62-0-490" id="h62-0-490" class="i">+func (m *RequestLog) GetExitReason() int32 {
</a><a href="#h62-0-491" id="h62-0-491" class="i">+	if m != nil &amp;&amp; m.ExitReason != nil {
</a><a href="#h62-0-492" id="h62-0-492" class="i">+		return *m.ExitReason
</a><a href="#h62-0-493" id="h62-0-493" class="i">+	}
</a><a href="#h62-0-494" id="h62-0-494" class="i">+	return 0
</a><a href="#h62-0-495" id="h62-0-495" class="i">+}
</a><a href="#h62-0-496" id="h62-0-496" class="i">+
</a><a href="#h62-0-497" id="h62-0-497" class="i">+func (m *RequestLog) GetWasThrottledForTime() bool {
</a><a href="#h62-0-498" id="h62-0-498" class="i">+	if m != nil &amp;&amp; m.WasThrottledForTime != nil {
</a><a href="#h62-0-499" id="h62-0-499" class="i">+		return *m.WasThrottledForTime
</a><a href="#h62-0-500" id="h62-0-500" class="i">+	}
</a><a href="#h62-0-501" id="h62-0-501" class="i">+	return false
</a><a href="#h62-0-502" id="h62-0-502" class="i">+}
</a><a href="#h62-0-503" id="h62-0-503" class="i">+
</a><a href="#h62-0-504" id="h62-0-504" class="i">+func (m *RequestLog) GetWasThrottledForRequests() bool {
</a><a href="#h62-0-505" id="h62-0-505" class="i">+	if m != nil &amp;&amp; m.WasThrottledForRequests != nil {
</a><a href="#h62-0-506" id="h62-0-506" class="i">+		return *m.WasThrottledForRequests
</a><a href="#h62-0-507" id="h62-0-507" class="i">+	}
</a><a href="#h62-0-508" id="h62-0-508" class="i">+	return false
</a><a href="#h62-0-509" id="h62-0-509" class="i">+}
</a><a href="#h62-0-510" id="h62-0-510" class="i">+
</a><a href="#h62-0-511" id="h62-0-511" class="i">+func (m *RequestLog) GetThrottledTime() int64 {
</a><a href="#h62-0-512" id="h62-0-512" class="i">+	if m != nil &amp;&amp; m.ThrottledTime != nil {
</a><a href="#h62-0-513" id="h62-0-513" class="i">+		return *m.ThrottledTime
</a><a href="#h62-0-514" id="h62-0-514" class="i">+	}
</a><a href="#h62-0-515" id="h62-0-515" class="i">+	return 0
</a><a href="#h62-0-516" id="h62-0-516" class="i">+}
</a><a href="#h62-0-517" id="h62-0-517" class="i">+
</a><a href="#h62-0-518" id="h62-0-518" class="i">+func (m *RequestLog) GetServerName() []byte {
</a><a href="#h62-0-519" id="h62-0-519" class="i">+	if m != nil {
</a><a href="#h62-0-520" id="h62-0-520" class="i">+		return m.ServerName
</a><a href="#h62-0-521" id="h62-0-521" class="i">+	}
</a><a href="#h62-0-522" id="h62-0-522" class="i">+	return nil
</a><a href="#h62-0-523" id="h62-0-523" class="i">+}
</a><a href="#h62-0-524" id="h62-0-524" class="i">+
</a><a href="#h62-0-525" id="h62-0-525" class="i">+type LogModuleVersion struct {
</a><a href="#h62-0-526" id="h62-0-526" class="i">+	ModuleId         *string `protobuf:&quot;bytes,1,opt,name=module_id,def=default&quot; json:&quot;module_id,omitempty&quot;`
</a><a href="#h62-0-527" id="h62-0-527" class="i">+	VersionId        *string `protobuf:&quot;bytes,2,opt,name=version_id&quot; json:&quot;version_id,omitempty&quot;`
</a><a href="#h62-0-528" id="h62-0-528" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h62-0-529" id="h62-0-529" class="i">+}
</a><a href="#h62-0-530" id="h62-0-530" class="i">+
</a><a href="#h62-0-531" id="h62-0-531" class="i">+func (m *LogModuleVersion) Reset()         { *m = LogModuleVersion{} }
</a><a href="#h62-0-532" id="h62-0-532" class="i">+func (m *LogModuleVersion) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-533" id="h62-0-533" class="i">+func (*LogModuleVersion) ProtoMessage()    {}
</a><a href="#h62-0-534" id="h62-0-534" class="i">+
</a><a href="#h62-0-535" id="h62-0-535" class="i">+const Default_LogModuleVersion_ModuleId string = &quot;default&quot;
</a><a href="#h62-0-536" id="h62-0-536" class="i">+
</a><a href="#h62-0-537" id="h62-0-537" class="i">+func (m *LogModuleVersion) GetModuleId() string {
</a><a href="#h62-0-538" id="h62-0-538" class="i">+	if m != nil &amp;&amp; m.ModuleId != nil {
</a><a href="#h62-0-539" id="h62-0-539" class="i">+		return *m.ModuleId
</a><a href="#h62-0-540" id="h62-0-540" class="i">+	}
</a><a href="#h62-0-541" id="h62-0-541" class="i">+	return Default_LogModuleVersion_ModuleId
</a><a href="#h62-0-542" id="h62-0-542" class="i">+}
</a><a href="#h62-0-543" id="h62-0-543" class="i">+
</a><a href="#h62-0-544" id="h62-0-544" class="i">+func (m *LogModuleVersion) GetVersionId() string {
</a><a href="#h62-0-545" id="h62-0-545" class="i">+	if m != nil &amp;&amp; m.VersionId != nil {
</a><a href="#h62-0-546" id="h62-0-546" class="i">+		return *m.VersionId
</a><a href="#h62-0-547" id="h62-0-547" class="i">+	}
</a><a href="#h62-0-548" id="h62-0-548" class="i">+	return &quot;&quot;
</a><a href="#h62-0-549" id="h62-0-549" class="i">+}
</a><a href="#h62-0-550" id="h62-0-550" class="i">+
</a><a href="#h62-0-551" id="h62-0-551" class="i">+type LogReadRequest struct {
</a><a href="#h62-0-552" id="h62-0-552" class="i">+	AppId             *string             `protobuf:&quot;bytes,1,req,name=app_id&quot; json:&quot;app_id,omitempty&quot;`
</a><a href="#h62-0-553" id="h62-0-553" class="i">+	VersionId         []string            `protobuf:&quot;bytes,2,rep,name=version_id&quot; json:&quot;version_id,omitempty&quot;`
</a><a href="#h62-0-554" id="h62-0-554" class="i">+	ModuleVersion     []*LogModuleVersion `protobuf:&quot;bytes,19,rep,name=module_version&quot; json:&quot;module_version,omitempty&quot;`
</a><a href="#h62-0-555" id="h62-0-555" class="i">+	StartTime         *int64              `protobuf:&quot;varint,3,opt,name=start_time&quot; json:&quot;start_time,omitempty&quot;`
</a><a href="#h62-0-556" id="h62-0-556" class="i">+	EndTime           *int64              `protobuf:&quot;varint,4,opt,name=end_time&quot; json:&quot;end_time,omitempty&quot;`
</a><a href="#h62-0-557" id="h62-0-557" class="i">+	Offset            *LogOffset          `protobuf:&quot;bytes,5,opt,name=offset&quot; json:&quot;offset,omitempty&quot;`
</a><a href="#h62-0-558" id="h62-0-558" class="i">+	RequestId         [][]byte            `protobuf:&quot;bytes,6,rep,name=request_id&quot; json:&quot;request_id,omitempty&quot;`
</a><a href="#h62-0-559" id="h62-0-559" class="i">+	MinimumLogLevel   *int32              `protobuf:&quot;varint,7,opt,name=minimum_log_level&quot; json:&quot;minimum_log_level,omitempty&quot;`
</a><a href="#h62-0-560" id="h62-0-560" class="i">+	IncludeIncomplete *bool               `protobuf:&quot;varint,8,opt,name=include_incomplete&quot; json:&quot;include_incomplete,omitempty&quot;`
</a><a href="#h62-0-561" id="h62-0-561" class="i">+	Count             *int64              `protobuf:&quot;varint,9,opt,name=count&quot; json:&quot;count,omitempty&quot;`
</a><a href="#h62-0-562" id="h62-0-562" class="i">+	CombinedLogRegex  *string             `protobuf:&quot;bytes,14,opt,name=combined_log_regex&quot; json:&quot;combined_log_regex,omitempty&quot;`
</a><a href="#h62-0-563" id="h62-0-563" class="i">+	HostRegex         *string             `protobuf:&quot;bytes,15,opt,name=host_regex&quot; json:&quot;host_regex,omitempty&quot;`
</a><a href="#h62-0-564" id="h62-0-564" class="i">+	ReplicaIndex      *int32              `protobuf:&quot;varint,16,opt,name=replica_index&quot; json:&quot;replica_index,omitempty&quot;`
</a><a href="#h62-0-565" id="h62-0-565" class="i">+	IncludeAppLogs    *bool               `protobuf:&quot;varint,10,opt,name=include_app_logs&quot; json:&quot;include_app_logs,omitempty&quot;`
</a><a href="#h62-0-566" id="h62-0-566" class="i">+	AppLogsPerRequest *int32              `protobuf:&quot;varint,17,opt,name=app_logs_per_request&quot; json:&quot;app_logs_per_request,omitempty&quot;`
</a><a href="#h62-0-567" id="h62-0-567" class="i">+	IncludeHost       *bool               `protobuf:&quot;varint,11,opt,name=include_host&quot; json:&quot;include_host,omitempty&quot;`
</a><a href="#h62-0-568" id="h62-0-568" class="i">+	IncludeAll        *bool               `protobuf:&quot;varint,12,opt,name=include_all&quot; json:&quot;include_all,omitempty&quot;`
</a><a href="#h62-0-569" id="h62-0-569" class="i">+	CacheIterator     *bool               `protobuf:&quot;varint,13,opt,name=cache_iterator&quot; json:&quot;cache_iterator,omitempty&quot;`
</a><a href="#h62-0-570" id="h62-0-570" class="i">+	NumShards         *int32              `protobuf:&quot;varint,18,opt,name=num_shards&quot; json:&quot;num_shards,omitempty&quot;`
</a><a href="#h62-0-571" id="h62-0-571" class="i">+	XXX_unrecognized  []byte              `json:&quot;-&quot;`
</a><a href="#h62-0-572" id="h62-0-572" class="i">+}
</a><a href="#h62-0-573" id="h62-0-573" class="i">+
</a><a href="#h62-0-574" id="h62-0-574" class="i">+func (m *LogReadRequest) Reset()         { *m = LogReadRequest{} }
</a><a href="#h62-0-575" id="h62-0-575" class="i">+func (m *LogReadRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-576" id="h62-0-576" class="i">+func (*LogReadRequest) ProtoMessage()    {}
</a><a href="#h62-0-577" id="h62-0-577" class="i">+
</a><a href="#h62-0-578" id="h62-0-578" class="i">+func (m *LogReadRequest) GetAppId() string {
</a><a href="#h62-0-579" id="h62-0-579" class="i">+	if m != nil &amp;&amp; m.AppId != nil {
</a><a href="#h62-0-580" id="h62-0-580" class="i">+		return *m.AppId
</a><a href="#h62-0-581" id="h62-0-581" class="i">+	}
</a><a href="#h62-0-582" id="h62-0-582" class="i">+	return &quot;&quot;
</a><a href="#h62-0-583" id="h62-0-583" class="i">+}
</a><a href="#h62-0-584" id="h62-0-584" class="i">+
</a><a href="#h62-0-585" id="h62-0-585" class="i">+func (m *LogReadRequest) GetVersionId() []string {
</a><a href="#h62-0-586" id="h62-0-586" class="i">+	if m != nil {
</a><a href="#h62-0-587" id="h62-0-587" class="i">+		return m.VersionId
</a><a href="#h62-0-588" id="h62-0-588" class="i">+	}
</a><a href="#h62-0-589" id="h62-0-589" class="i">+	return nil
</a><a href="#h62-0-590" id="h62-0-590" class="i">+}
</a><a href="#h62-0-591" id="h62-0-591" class="i">+
</a><a href="#h62-0-592" id="h62-0-592" class="i">+func (m *LogReadRequest) GetModuleVersion() []*LogModuleVersion {
</a><a href="#h62-0-593" id="h62-0-593" class="i">+	if m != nil {
</a><a href="#h62-0-594" id="h62-0-594" class="i">+		return m.ModuleVersion
</a><a href="#h62-0-595" id="h62-0-595" class="i">+	}
</a><a href="#h62-0-596" id="h62-0-596" class="i">+	return nil
</a><a href="#h62-0-597" id="h62-0-597" class="i">+}
</a><a href="#h62-0-598" id="h62-0-598" class="i">+
</a><a href="#h62-0-599" id="h62-0-599" class="i">+func (m *LogReadRequest) GetStartTime() int64 {
</a><a href="#h62-0-600" id="h62-0-600" class="i">+	if m != nil &amp;&amp; m.StartTime != nil {
</a><a href="#h62-0-601" id="h62-0-601" class="i">+		return *m.StartTime
</a><a href="#h62-0-602" id="h62-0-602" class="i">+	}
</a><a href="#h62-0-603" id="h62-0-603" class="i">+	return 0
</a><a href="#h62-0-604" id="h62-0-604" class="i">+}
</a><a href="#h62-0-605" id="h62-0-605" class="i">+
</a><a href="#h62-0-606" id="h62-0-606" class="i">+func (m *LogReadRequest) GetEndTime() int64 {
</a><a href="#h62-0-607" id="h62-0-607" class="i">+	if m != nil &amp;&amp; m.EndTime != nil {
</a><a href="#h62-0-608" id="h62-0-608" class="i">+		return *m.EndTime
</a><a href="#h62-0-609" id="h62-0-609" class="i">+	}
</a><a href="#h62-0-610" id="h62-0-610" class="i">+	return 0
</a><a href="#h62-0-611" id="h62-0-611" class="i">+}
</a><a href="#h62-0-612" id="h62-0-612" class="i">+
</a><a href="#h62-0-613" id="h62-0-613" class="i">+func (m *LogReadRequest) GetOffset() *LogOffset {
</a><a href="#h62-0-614" id="h62-0-614" class="i">+	if m != nil {
</a><a href="#h62-0-615" id="h62-0-615" class="i">+		return m.Offset
</a><a href="#h62-0-616" id="h62-0-616" class="i">+	}
</a><a href="#h62-0-617" id="h62-0-617" class="i">+	return nil
</a><a href="#h62-0-618" id="h62-0-618" class="i">+}
</a><a href="#h62-0-619" id="h62-0-619" class="i">+
</a><a href="#h62-0-620" id="h62-0-620" class="i">+func (m *LogReadRequest) GetRequestId() [][]byte {
</a><a href="#h62-0-621" id="h62-0-621" class="i">+	if m != nil {
</a><a href="#h62-0-622" id="h62-0-622" class="i">+		return m.RequestId
</a><a href="#h62-0-623" id="h62-0-623" class="i">+	}
</a><a href="#h62-0-624" id="h62-0-624" class="i">+	return nil
</a><a href="#h62-0-625" id="h62-0-625" class="i">+}
</a><a href="#h62-0-626" id="h62-0-626" class="i">+
</a><a href="#h62-0-627" id="h62-0-627" class="i">+func (m *LogReadRequest) GetMinimumLogLevel() int32 {
</a><a href="#h62-0-628" id="h62-0-628" class="i">+	if m != nil &amp;&amp; m.MinimumLogLevel != nil {
</a><a href="#h62-0-629" id="h62-0-629" class="i">+		return *m.MinimumLogLevel
</a><a href="#h62-0-630" id="h62-0-630" class="i">+	}
</a><a href="#h62-0-631" id="h62-0-631" class="i">+	return 0
</a><a href="#h62-0-632" id="h62-0-632" class="i">+}
</a><a href="#h62-0-633" id="h62-0-633" class="i">+
</a><a href="#h62-0-634" id="h62-0-634" class="i">+func (m *LogReadRequest) GetIncludeIncomplete() bool {
</a><a href="#h62-0-635" id="h62-0-635" class="i">+	if m != nil &amp;&amp; m.IncludeIncomplete != nil {
</a><a href="#h62-0-636" id="h62-0-636" class="i">+		return *m.IncludeIncomplete
</a><a href="#h62-0-637" id="h62-0-637" class="i">+	}
</a><a href="#h62-0-638" id="h62-0-638" class="i">+	return false
</a><a href="#h62-0-639" id="h62-0-639" class="i">+}
</a><a href="#h62-0-640" id="h62-0-640" class="i">+
</a><a href="#h62-0-641" id="h62-0-641" class="i">+func (m *LogReadRequest) GetCount() int64 {
</a><a href="#h62-0-642" id="h62-0-642" class="i">+	if m != nil &amp;&amp; m.Count != nil {
</a><a href="#h62-0-643" id="h62-0-643" class="i">+		return *m.Count
</a><a href="#h62-0-644" id="h62-0-644" class="i">+	}
</a><a href="#h62-0-645" id="h62-0-645" class="i">+	return 0
</a><a href="#h62-0-646" id="h62-0-646" class="i">+}
</a><a href="#h62-0-647" id="h62-0-647" class="i">+
</a><a href="#h62-0-648" id="h62-0-648" class="i">+func (m *LogReadRequest) GetCombinedLogRegex() string {
</a><a href="#h62-0-649" id="h62-0-649" class="i">+	if m != nil &amp;&amp; m.CombinedLogRegex != nil {
</a><a href="#h62-0-650" id="h62-0-650" class="i">+		return *m.CombinedLogRegex
</a><a href="#h62-0-651" id="h62-0-651" class="i">+	}
</a><a href="#h62-0-652" id="h62-0-652" class="i">+	return &quot;&quot;
</a><a href="#h62-0-653" id="h62-0-653" class="i">+}
</a><a href="#h62-0-654" id="h62-0-654" class="i">+
</a><a href="#h62-0-655" id="h62-0-655" class="i">+func (m *LogReadRequest) GetHostRegex() string {
</a><a href="#h62-0-656" id="h62-0-656" class="i">+	if m != nil &amp;&amp; m.HostRegex != nil {
</a><a href="#h62-0-657" id="h62-0-657" class="i">+		return *m.HostRegex
</a><a href="#h62-0-658" id="h62-0-658" class="i">+	}
</a><a href="#h62-0-659" id="h62-0-659" class="i">+	return &quot;&quot;
</a><a href="#h62-0-660" id="h62-0-660" class="i">+}
</a><a href="#h62-0-661" id="h62-0-661" class="i">+
</a><a href="#h62-0-662" id="h62-0-662" class="i">+func (m *LogReadRequest) GetReplicaIndex() int32 {
</a><a href="#h62-0-663" id="h62-0-663" class="i">+	if m != nil &amp;&amp; m.ReplicaIndex != nil {
</a><a href="#h62-0-664" id="h62-0-664" class="i">+		return *m.ReplicaIndex
</a><a href="#h62-0-665" id="h62-0-665" class="i">+	}
</a><a href="#h62-0-666" id="h62-0-666" class="i">+	return 0
</a><a href="#h62-0-667" id="h62-0-667" class="i">+}
</a><a href="#h62-0-668" id="h62-0-668" class="i">+
</a><a href="#h62-0-669" id="h62-0-669" class="i">+func (m *LogReadRequest) GetIncludeAppLogs() bool {
</a><a href="#h62-0-670" id="h62-0-670" class="i">+	if m != nil &amp;&amp; m.IncludeAppLogs != nil {
</a><a href="#h62-0-671" id="h62-0-671" class="i">+		return *m.IncludeAppLogs
</a><a href="#h62-0-672" id="h62-0-672" class="i">+	}
</a><a href="#h62-0-673" id="h62-0-673" class="i">+	return false
</a><a href="#h62-0-674" id="h62-0-674" class="i">+}
</a><a href="#h62-0-675" id="h62-0-675" class="i">+
</a><a href="#h62-0-676" id="h62-0-676" class="i">+func (m *LogReadRequest) GetAppLogsPerRequest() int32 {
</a><a href="#h62-0-677" id="h62-0-677" class="i">+	if m != nil &amp;&amp; m.AppLogsPerRequest != nil {
</a><a href="#h62-0-678" id="h62-0-678" class="i">+		return *m.AppLogsPerRequest
</a><a href="#h62-0-679" id="h62-0-679" class="i">+	}
</a><a href="#h62-0-680" id="h62-0-680" class="i">+	return 0
</a><a href="#h62-0-681" id="h62-0-681" class="i">+}
</a><a href="#h62-0-682" id="h62-0-682" class="i">+
</a><a href="#h62-0-683" id="h62-0-683" class="i">+func (m *LogReadRequest) GetIncludeHost() bool {
</a><a href="#h62-0-684" id="h62-0-684" class="i">+	if m != nil &amp;&amp; m.IncludeHost != nil {
</a><a href="#h62-0-685" id="h62-0-685" class="i">+		return *m.IncludeHost
</a><a href="#h62-0-686" id="h62-0-686" class="i">+	}
</a><a href="#h62-0-687" id="h62-0-687" class="i">+	return false
</a><a href="#h62-0-688" id="h62-0-688" class="i">+}
</a><a href="#h62-0-689" id="h62-0-689" class="i">+
</a><a href="#h62-0-690" id="h62-0-690" class="i">+func (m *LogReadRequest) GetIncludeAll() bool {
</a><a href="#h62-0-691" id="h62-0-691" class="i">+	if m != nil &amp;&amp; m.IncludeAll != nil {
</a><a href="#h62-0-692" id="h62-0-692" class="i">+		return *m.IncludeAll
</a><a href="#h62-0-693" id="h62-0-693" class="i">+	}
</a><a href="#h62-0-694" id="h62-0-694" class="i">+	return false
</a><a href="#h62-0-695" id="h62-0-695" class="i">+}
</a><a href="#h62-0-696" id="h62-0-696" class="i">+
</a><a href="#h62-0-697" id="h62-0-697" class="i">+func (m *LogReadRequest) GetCacheIterator() bool {
</a><a href="#h62-0-698" id="h62-0-698" class="i">+	if m != nil &amp;&amp; m.CacheIterator != nil {
</a><a href="#h62-0-699" id="h62-0-699" class="i">+		return *m.CacheIterator
</a><a href="#h62-0-700" id="h62-0-700" class="i">+	}
</a><a href="#h62-0-701" id="h62-0-701" class="i">+	return false
</a><a href="#h62-0-702" id="h62-0-702" class="i">+}
</a><a href="#h62-0-703" id="h62-0-703" class="i">+
</a><a href="#h62-0-704" id="h62-0-704" class="i">+func (m *LogReadRequest) GetNumShards() int32 {
</a><a href="#h62-0-705" id="h62-0-705" class="i">+	if m != nil &amp;&amp; m.NumShards != nil {
</a><a href="#h62-0-706" id="h62-0-706" class="i">+		return *m.NumShards
</a><a href="#h62-0-707" id="h62-0-707" class="i">+	}
</a><a href="#h62-0-708" id="h62-0-708" class="i">+	return 0
</a><a href="#h62-0-709" id="h62-0-709" class="i">+}
</a><a href="#h62-0-710" id="h62-0-710" class="i">+
</a><a href="#h62-0-711" id="h62-0-711" class="i">+type LogReadResponse struct {
</a><a href="#h62-0-712" id="h62-0-712" class="i">+	Log              []*RequestLog `protobuf:&quot;bytes,1,rep,name=log&quot; json:&quot;log,omitempty&quot;`
</a><a href="#h62-0-713" id="h62-0-713" class="i">+	Offset           *LogOffset    `protobuf:&quot;bytes,2,opt,name=offset&quot; json:&quot;offset,omitempty&quot;`
</a><a href="#h62-0-714" id="h62-0-714" class="i">+	LastEndTime      *int64        `protobuf:&quot;varint,3,opt,name=last_end_time&quot; json:&quot;last_end_time,omitempty&quot;`
</a><a href="#h62-0-715" id="h62-0-715" class="i">+	XXX_unrecognized []byte        `json:&quot;-&quot;`
</a><a href="#h62-0-716" id="h62-0-716" class="i">+}
</a><a href="#h62-0-717" id="h62-0-717" class="i">+
</a><a href="#h62-0-718" id="h62-0-718" class="i">+func (m *LogReadResponse) Reset()         { *m = LogReadResponse{} }
</a><a href="#h62-0-719" id="h62-0-719" class="i">+func (m *LogReadResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-720" id="h62-0-720" class="i">+func (*LogReadResponse) ProtoMessage()    {}
</a><a href="#h62-0-721" id="h62-0-721" class="i">+
</a><a href="#h62-0-722" id="h62-0-722" class="i">+func (m *LogReadResponse) GetLog() []*RequestLog {
</a><a href="#h62-0-723" id="h62-0-723" class="i">+	if m != nil {
</a><a href="#h62-0-724" id="h62-0-724" class="i">+		return m.Log
</a><a href="#h62-0-725" id="h62-0-725" class="i">+	}
</a><a href="#h62-0-726" id="h62-0-726" class="i">+	return nil
</a><a href="#h62-0-727" id="h62-0-727" class="i">+}
</a><a href="#h62-0-728" id="h62-0-728" class="i">+
</a><a href="#h62-0-729" id="h62-0-729" class="i">+func (m *LogReadResponse) GetOffset() *LogOffset {
</a><a href="#h62-0-730" id="h62-0-730" class="i">+	if m != nil {
</a><a href="#h62-0-731" id="h62-0-731" class="i">+		return m.Offset
</a><a href="#h62-0-732" id="h62-0-732" class="i">+	}
</a><a href="#h62-0-733" id="h62-0-733" class="i">+	return nil
</a><a href="#h62-0-734" id="h62-0-734" class="i">+}
</a><a href="#h62-0-735" id="h62-0-735" class="i">+
</a><a href="#h62-0-736" id="h62-0-736" class="i">+func (m *LogReadResponse) GetLastEndTime() int64 {
</a><a href="#h62-0-737" id="h62-0-737" class="i">+	if m != nil &amp;&amp; m.LastEndTime != nil {
</a><a href="#h62-0-738" id="h62-0-738" class="i">+		return *m.LastEndTime
</a><a href="#h62-0-739" id="h62-0-739" class="i">+	}
</a><a href="#h62-0-740" id="h62-0-740" class="i">+	return 0
</a><a href="#h62-0-741" id="h62-0-741" class="i">+}
</a><a href="#h62-0-742" id="h62-0-742" class="i">+
</a><a href="#h62-0-743" id="h62-0-743" class="i">+type LogUsageRecord struct {
</a><a href="#h62-0-744" id="h62-0-744" class="i">+	VersionId        *string `protobuf:&quot;bytes,1,opt,name=version_id&quot; json:&quot;version_id,omitempty&quot;`
</a><a href="#h62-0-745" id="h62-0-745" class="i">+	StartTime        *int32  `protobuf:&quot;varint,2,opt,name=start_time&quot; json:&quot;start_time,omitempty&quot;`
</a><a href="#h62-0-746" id="h62-0-746" class="i">+	EndTime          *int32  `protobuf:&quot;varint,3,opt,name=end_time&quot; json:&quot;end_time,omitempty&quot;`
</a><a href="#h62-0-747" id="h62-0-747" class="i">+	Count            *int64  `protobuf:&quot;varint,4,opt,name=count&quot; json:&quot;count,omitempty&quot;`
</a><a href="#h62-0-748" id="h62-0-748" class="i">+	TotalSize        *int64  `protobuf:&quot;varint,5,opt,name=total_size&quot; json:&quot;total_size,omitempty&quot;`
</a><a href="#h62-0-749" id="h62-0-749" class="i">+	Records          *int32  `protobuf:&quot;varint,6,opt,name=records&quot; json:&quot;records,omitempty&quot;`
</a><a href="#h62-0-750" id="h62-0-750" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h62-0-751" id="h62-0-751" class="i">+}
</a><a href="#h62-0-752" id="h62-0-752" class="i">+
</a><a href="#h62-0-753" id="h62-0-753" class="i">+func (m *LogUsageRecord) Reset()         { *m = LogUsageRecord{} }
</a><a href="#h62-0-754" id="h62-0-754" class="i">+func (m *LogUsageRecord) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-755" id="h62-0-755" class="i">+func (*LogUsageRecord) ProtoMessage()    {}
</a><a href="#h62-0-756" id="h62-0-756" class="i">+
</a><a href="#h62-0-757" id="h62-0-757" class="i">+func (m *LogUsageRecord) GetVersionId() string {
</a><a href="#h62-0-758" id="h62-0-758" class="i">+	if m != nil &amp;&amp; m.VersionId != nil {
</a><a href="#h62-0-759" id="h62-0-759" class="i">+		return *m.VersionId
</a><a href="#h62-0-760" id="h62-0-760" class="i">+	}
</a><a href="#h62-0-761" id="h62-0-761" class="i">+	return &quot;&quot;
</a><a href="#h62-0-762" id="h62-0-762" class="i">+}
</a><a href="#h62-0-763" id="h62-0-763" class="i">+
</a><a href="#h62-0-764" id="h62-0-764" class="i">+func (m *LogUsageRecord) GetStartTime() int32 {
</a><a href="#h62-0-765" id="h62-0-765" class="i">+	if m != nil &amp;&amp; m.StartTime != nil {
</a><a href="#h62-0-766" id="h62-0-766" class="i">+		return *m.StartTime
</a><a href="#h62-0-767" id="h62-0-767" class="i">+	}
</a><a href="#h62-0-768" id="h62-0-768" class="i">+	return 0
</a><a href="#h62-0-769" id="h62-0-769" class="i">+}
</a><a href="#h62-0-770" id="h62-0-770" class="i">+
</a><a href="#h62-0-771" id="h62-0-771" class="i">+func (m *LogUsageRecord) GetEndTime() int32 {
</a><a href="#h62-0-772" id="h62-0-772" class="i">+	if m != nil &amp;&amp; m.EndTime != nil {
</a><a href="#h62-0-773" id="h62-0-773" class="i">+		return *m.EndTime
</a><a href="#h62-0-774" id="h62-0-774" class="i">+	}
</a><a href="#h62-0-775" id="h62-0-775" class="i">+	return 0
</a><a href="#h62-0-776" id="h62-0-776" class="i">+}
</a><a href="#h62-0-777" id="h62-0-777" class="i">+
</a><a href="#h62-0-778" id="h62-0-778" class="i">+func (m *LogUsageRecord) GetCount() int64 {
</a><a href="#h62-0-779" id="h62-0-779" class="i">+	if m != nil &amp;&amp; m.Count != nil {
</a><a href="#h62-0-780" id="h62-0-780" class="i">+		return *m.Count
</a><a href="#h62-0-781" id="h62-0-781" class="i">+	}
</a><a href="#h62-0-782" id="h62-0-782" class="i">+	return 0
</a><a href="#h62-0-783" id="h62-0-783" class="i">+}
</a><a href="#h62-0-784" id="h62-0-784" class="i">+
</a><a href="#h62-0-785" id="h62-0-785" class="i">+func (m *LogUsageRecord) GetTotalSize() int64 {
</a><a href="#h62-0-786" id="h62-0-786" class="i">+	if m != nil &amp;&amp; m.TotalSize != nil {
</a><a href="#h62-0-787" id="h62-0-787" class="i">+		return *m.TotalSize
</a><a href="#h62-0-788" id="h62-0-788" class="i">+	}
</a><a href="#h62-0-789" id="h62-0-789" class="i">+	return 0
</a><a href="#h62-0-790" id="h62-0-790" class="i">+}
</a><a href="#h62-0-791" id="h62-0-791" class="i">+
</a><a href="#h62-0-792" id="h62-0-792" class="i">+func (m *LogUsageRecord) GetRecords() int32 {
</a><a href="#h62-0-793" id="h62-0-793" class="i">+	if m != nil &amp;&amp; m.Records != nil {
</a><a href="#h62-0-794" id="h62-0-794" class="i">+		return *m.Records
</a><a href="#h62-0-795" id="h62-0-795" class="i">+	}
</a><a href="#h62-0-796" id="h62-0-796" class="i">+	return 0
</a><a href="#h62-0-797" id="h62-0-797" class="i">+}
</a><a href="#h62-0-798" id="h62-0-798" class="i">+
</a><a href="#h62-0-799" id="h62-0-799" class="i">+type LogUsageRequest struct {
</a><a href="#h62-0-800" id="h62-0-800" class="i">+	AppId            *string  `protobuf:&quot;bytes,1,req,name=app_id&quot; json:&quot;app_id,omitempty&quot;`
</a><a href="#h62-0-801" id="h62-0-801" class="i">+	VersionId        []string `protobuf:&quot;bytes,2,rep,name=version_id&quot; json:&quot;version_id,omitempty&quot;`
</a><a href="#h62-0-802" id="h62-0-802" class="i">+	StartTime        *int32   `protobuf:&quot;varint,3,opt,name=start_time&quot; json:&quot;start_time,omitempty&quot;`
</a><a href="#h62-0-803" id="h62-0-803" class="i">+	EndTime          *int32   `protobuf:&quot;varint,4,opt,name=end_time&quot; json:&quot;end_time,omitempty&quot;`
</a><a href="#h62-0-804" id="h62-0-804" class="i">+	ResolutionHours  *uint32  `protobuf:&quot;varint,5,opt,name=resolution_hours,def=1&quot; json:&quot;resolution_hours,omitempty&quot;`
</a><a href="#h62-0-805" id="h62-0-805" class="i">+	CombineVersions  *bool    `protobuf:&quot;varint,6,opt,name=combine_versions&quot; json:&quot;combine_versions,omitempty&quot;`
</a><a href="#h62-0-806" id="h62-0-806" class="i">+	UsageVersion     *int32   `protobuf:&quot;varint,7,opt,name=usage_version&quot; json:&quot;usage_version,omitempty&quot;`
</a><a href="#h62-0-807" id="h62-0-807" class="i">+	VersionsOnly     *bool    `protobuf:&quot;varint,8,opt,name=versions_only&quot; json:&quot;versions_only,omitempty&quot;`
</a><a href="#h62-0-808" id="h62-0-808" class="i">+	XXX_unrecognized []byte   `json:&quot;-&quot;`
</a><a href="#h62-0-809" id="h62-0-809" class="i">+}
</a><a href="#h62-0-810" id="h62-0-810" class="i">+
</a><a href="#h62-0-811" id="h62-0-811" class="i">+func (m *LogUsageRequest) Reset()         { *m = LogUsageRequest{} }
</a><a href="#h62-0-812" id="h62-0-812" class="i">+func (m *LogUsageRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-813" id="h62-0-813" class="i">+func (*LogUsageRequest) ProtoMessage()    {}
</a><a href="#h62-0-814" id="h62-0-814" class="i">+
</a><a href="#h62-0-815" id="h62-0-815" class="i">+const Default_LogUsageRequest_ResolutionHours uint32 = 1
</a><a href="#h62-0-816" id="h62-0-816" class="i">+
</a><a href="#h62-0-817" id="h62-0-817" class="i">+func (m *LogUsageRequest) GetAppId() string {
</a><a href="#h62-0-818" id="h62-0-818" class="i">+	if m != nil &amp;&amp; m.AppId != nil {
</a><a href="#h62-0-819" id="h62-0-819" class="i">+		return *m.AppId
</a><a href="#h62-0-820" id="h62-0-820" class="i">+	}
</a><a href="#h62-0-821" id="h62-0-821" class="i">+	return &quot;&quot;
</a><a href="#h62-0-822" id="h62-0-822" class="i">+}
</a><a href="#h62-0-823" id="h62-0-823" class="i">+
</a><a href="#h62-0-824" id="h62-0-824" class="i">+func (m *LogUsageRequest) GetVersionId() []string {
</a><a href="#h62-0-825" id="h62-0-825" class="i">+	if m != nil {
</a><a href="#h62-0-826" id="h62-0-826" class="i">+		return m.VersionId
</a><a href="#h62-0-827" id="h62-0-827" class="i">+	}
</a><a href="#h62-0-828" id="h62-0-828" class="i">+	return nil
</a><a href="#h62-0-829" id="h62-0-829" class="i">+}
</a><a href="#h62-0-830" id="h62-0-830" class="i">+
</a><a href="#h62-0-831" id="h62-0-831" class="i">+func (m *LogUsageRequest) GetStartTime() int32 {
</a><a href="#h62-0-832" id="h62-0-832" class="i">+	if m != nil &amp;&amp; m.StartTime != nil {
</a><a href="#h62-0-833" id="h62-0-833" class="i">+		return *m.StartTime
</a><a href="#h62-0-834" id="h62-0-834" class="i">+	}
</a><a href="#h62-0-835" id="h62-0-835" class="i">+	return 0
</a><a href="#h62-0-836" id="h62-0-836" class="i">+}
</a><a href="#h62-0-837" id="h62-0-837" class="i">+
</a><a href="#h62-0-838" id="h62-0-838" class="i">+func (m *LogUsageRequest) GetEndTime() int32 {
</a><a href="#h62-0-839" id="h62-0-839" class="i">+	if m != nil &amp;&amp; m.EndTime != nil {
</a><a href="#h62-0-840" id="h62-0-840" class="i">+		return *m.EndTime
</a><a href="#h62-0-841" id="h62-0-841" class="i">+	}
</a><a href="#h62-0-842" id="h62-0-842" class="i">+	return 0
</a><a href="#h62-0-843" id="h62-0-843" class="i">+}
</a><a href="#h62-0-844" id="h62-0-844" class="i">+
</a><a href="#h62-0-845" id="h62-0-845" class="i">+func (m *LogUsageRequest) GetResolutionHours() uint32 {
</a><a href="#h62-0-846" id="h62-0-846" class="i">+	if m != nil &amp;&amp; m.ResolutionHours != nil {
</a><a href="#h62-0-847" id="h62-0-847" class="i">+		return *m.ResolutionHours
</a><a href="#h62-0-848" id="h62-0-848" class="i">+	}
</a><a href="#h62-0-849" id="h62-0-849" class="i">+	return Default_LogUsageRequest_ResolutionHours
</a><a href="#h62-0-850" id="h62-0-850" class="i">+}
</a><a href="#h62-0-851" id="h62-0-851" class="i">+
</a><a href="#h62-0-852" id="h62-0-852" class="i">+func (m *LogUsageRequest) GetCombineVersions() bool {
</a><a href="#h62-0-853" id="h62-0-853" class="i">+	if m != nil &amp;&amp; m.CombineVersions != nil {
</a><a href="#h62-0-854" id="h62-0-854" class="i">+		return *m.CombineVersions
</a><a href="#h62-0-855" id="h62-0-855" class="i">+	}
</a><a href="#h62-0-856" id="h62-0-856" class="i">+	return false
</a><a href="#h62-0-857" id="h62-0-857" class="i">+}
</a><a href="#h62-0-858" id="h62-0-858" class="i">+
</a><a href="#h62-0-859" id="h62-0-859" class="i">+func (m *LogUsageRequest) GetUsageVersion() int32 {
</a><a href="#h62-0-860" id="h62-0-860" class="i">+	if m != nil &amp;&amp; m.UsageVersion != nil {
</a><a href="#h62-0-861" id="h62-0-861" class="i">+		return *m.UsageVersion
</a><a href="#h62-0-862" id="h62-0-862" class="i">+	}
</a><a href="#h62-0-863" id="h62-0-863" class="i">+	return 0
</a><a href="#h62-0-864" id="h62-0-864" class="i">+}
</a><a href="#h62-0-865" id="h62-0-865" class="i">+
</a><a href="#h62-0-866" id="h62-0-866" class="i">+func (m *LogUsageRequest) GetVersionsOnly() bool {
</a><a href="#h62-0-867" id="h62-0-867" class="i">+	if m != nil &amp;&amp; m.VersionsOnly != nil {
</a><a href="#h62-0-868" id="h62-0-868" class="i">+		return *m.VersionsOnly
</a><a href="#h62-0-869" id="h62-0-869" class="i">+	}
</a><a href="#h62-0-870" id="h62-0-870" class="i">+	return false
</a><a href="#h62-0-871" id="h62-0-871" class="i">+}
</a><a href="#h62-0-872" id="h62-0-872" class="i">+
</a><a href="#h62-0-873" id="h62-0-873" class="i">+type LogUsageResponse struct {
</a><a href="#h62-0-874" id="h62-0-874" class="i">+	Usage            []*LogUsageRecord `protobuf:&quot;bytes,1,rep,name=usage&quot; json:&quot;usage,omitempty&quot;`
</a><a href="#h62-0-875" id="h62-0-875" class="i">+	Summary          *LogUsageRecord   `protobuf:&quot;bytes,2,opt,name=summary&quot; json:&quot;summary,omitempty&quot;`
</a><a href="#h62-0-876" id="h62-0-876" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h62-0-877" id="h62-0-877" class="i">+}
</a><a href="#h62-0-878" id="h62-0-878" class="i">+
</a><a href="#h62-0-879" id="h62-0-879" class="i">+func (m *LogUsageResponse) Reset()         { *m = LogUsageResponse{} }
</a><a href="#h62-0-880" id="h62-0-880" class="i">+func (m *LogUsageResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h62-0-881" id="h62-0-881" class="i">+func (*LogUsageResponse) ProtoMessage()    {}
</a><a href="#h62-0-882" id="h62-0-882" class="i">+
</a><a href="#h62-0-883" id="h62-0-883" class="i">+func (m *LogUsageResponse) GetUsage() []*LogUsageRecord {
</a><a href="#h62-0-884" id="h62-0-884" class="i">+	if m != nil {
</a><a href="#h62-0-885" id="h62-0-885" class="i">+		return m.Usage
</a><a href="#h62-0-886" id="h62-0-886" class="i">+	}
</a><a href="#h62-0-887" id="h62-0-887" class="i">+	return nil
</a><a href="#h62-0-888" id="h62-0-888" class="i">+}
</a><a href="#h62-0-889" id="h62-0-889" class="i">+
</a><a href="#h62-0-890" id="h62-0-890" class="i">+func (m *LogUsageResponse) GetSummary() *LogUsageRecord {
</a><a href="#h62-0-891" id="h62-0-891" class="i">+	if m != nil {
</a><a href="#h62-0-892" id="h62-0-892" class="i">+		return m.Summary
</a><a href="#h62-0-893" id="h62-0-893" class="i">+	}
</a><a href="#h62-0-894" id="h62-0-894" class="i">+	return nil
</a><a href="#h62-0-895" id="h62-0-895" class="i">+}
</a><a href="#h62-0-896" id="h62-0-896" class="i">+
</a><a href="#h62-0-897" id="h62-0-897" class="i">+func init() {
</a><a href="#h62-0-898" id="h62-0-898" class="i">+}
</a><b>diff --git a/<a id="h63" href="../file/vendor/google.golang.org/appengine/internal/log/log_service.proto">vendor/google.golang.org/appengine/internal/log/log_service.proto</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/log/log_service.proto">vendor/google.golang.org/appengine/internal/log/log_service.proto</a></b>
<a href="#h63-0" id="h63-0" class="h">@@ -0,0 +1,150 @@
</a><a href="#h63-0-0" id="h63-0-0" class="i">+syntax = &quot;proto2&quot;;
</a><a href="#h63-0-1" id="h63-0-1" class="i">+option go_package = &quot;log&quot;;
</a><a href="#h63-0-2" id="h63-0-2" class="i">+
</a><a href="#h63-0-3" id="h63-0-3" class="i">+package appengine;
</a><a href="#h63-0-4" id="h63-0-4" class="i">+
</a><a href="#h63-0-5" id="h63-0-5" class="i">+message LogServiceError {
</a><a href="#h63-0-6" id="h63-0-6" class="i">+  enum ErrorCode {
</a><a href="#h63-0-7" id="h63-0-7" class="i">+    OK  = 0;
</a><a href="#h63-0-8" id="h63-0-8" class="i">+    INVALID_REQUEST = 1;
</a><a href="#h63-0-9" id="h63-0-9" class="i">+    STORAGE_ERROR = 2;
</a><a href="#h63-0-10" id="h63-0-10" class="i">+  }
</a><a href="#h63-0-11" id="h63-0-11" class="i">+}
</a><a href="#h63-0-12" id="h63-0-12" class="i">+
</a><a href="#h63-0-13" id="h63-0-13" class="i">+message UserAppLogLine {
</a><a href="#h63-0-14" id="h63-0-14" class="i">+  required int64 timestamp_usec = 1;
</a><a href="#h63-0-15" id="h63-0-15" class="i">+  required int64 level = 2;
</a><a href="#h63-0-16" id="h63-0-16" class="i">+  required string message = 3;
</a><a href="#h63-0-17" id="h63-0-17" class="i">+}
</a><a href="#h63-0-18" id="h63-0-18" class="i">+
</a><a href="#h63-0-19" id="h63-0-19" class="i">+message UserAppLogGroup {
</a><a href="#h63-0-20" id="h63-0-20" class="i">+  repeated UserAppLogLine log_line = 2;
</a><a href="#h63-0-21" id="h63-0-21" class="i">+}
</a><a href="#h63-0-22" id="h63-0-22" class="i">+
</a><a href="#h63-0-23" id="h63-0-23" class="i">+message FlushRequest {
</a><a href="#h63-0-24" id="h63-0-24" class="i">+  optional bytes logs = 1;
</a><a href="#h63-0-25" id="h63-0-25" class="i">+}
</a><a href="#h63-0-26" id="h63-0-26" class="i">+
</a><a href="#h63-0-27" id="h63-0-27" class="i">+message SetStatusRequest {
</a><a href="#h63-0-28" id="h63-0-28" class="i">+  required string status = 1;
</a><a href="#h63-0-29" id="h63-0-29" class="i">+}
</a><a href="#h63-0-30" id="h63-0-30" class="i">+
</a><a href="#h63-0-31" id="h63-0-31" class="i">+
</a><a href="#h63-0-32" id="h63-0-32" class="i">+message LogOffset {
</a><a href="#h63-0-33" id="h63-0-33" class="i">+  optional bytes request_id = 1;
</a><a href="#h63-0-34" id="h63-0-34" class="i">+}
</a><a href="#h63-0-35" id="h63-0-35" class="i">+
</a><a href="#h63-0-36" id="h63-0-36" class="i">+message LogLine {
</a><a href="#h63-0-37" id="h63-0-37" class="i">+  required int64 time = 1;
</a><a href="#h63-0-38" id="h63-0-38" class="i">+  required int32 level = 2;
</a><a href="#h63-0-39" id="h63-0-39" class="i">+  required string log_message = 3;
</a><a href="#h63-0-40" id="h63-0-40" class="i">+}
</a><a href="#h63-0-41" id="h63-0-41" class="i">+
</a><a href="#h63-0-42" id="h63-0-42" class="i">+message RequestLog {
</a><a href="#h63-0-43" id="h63-0-43" class="i">+  required string app_id = 1;
</a><a href="#h63-0-44" id="h63-0-44" class="i">+  optional string module_id = 37 [default=&quot;default&quot;];
</a><a href="#h63-0-45" id="h63-0-45" class="i">+  required string version_id = 2;
</a><a href="#h63-0-46" id="h63-0-46" class="i">+  required bytes request_id = 3;
</a><a href="#h63-0-47" id="h63-0-47" class="i">+  optional LogOffset offset = 35;
</a><a href="#h63-0-48" id="h63-0-48" class="i">+  required string ip = 4;
</a><a href="#h63-0-49" id="h63-0-49" class="i">+  optional string nickname = 5;
</a><a href="#h63-0-50" id="h63-0-50" class="i">+  required int64 start_time = 6;
</a><a href="#h63-0-51" id="h63-0-51" class="i">+  required int64 end_time = 7;
</a><a href="#h63-0-52" id="h63-0-52" class="i">+  required int64 latency = 8;
</a><a href="#h63-0-53" id="h63-0-53" class="i">+  required int64 mcycles = 9;
</a><a href="#h63-0-54" id="h63-0-54" class="i">+  required string method = 10;
</a><a href="#h63-0-55" id="h63-0-55" class="i">+  required string resource = 11;
</a><a href="#h63-0-56" id="h63-0-56" class="i">+  required string http_version = 12;
</a><a href="#h63-0-57" id="h63-0-57" class="i">+  required int32 status = 13;
</a><a href="#h63-0-58" id="h63-0-58" class="i">+  required int64 response_size = 14;
</a><a href="#h63-0-59" id="h63-0-59" class="i">+  optional string referrer = 15;
</a><a href="#h63-0-60" id="h63-0-60" class="i">+  optional string user_agent = 16;
</a><a href="#h63-0-61" id="h63-0-61" class="i">+  required string url_map_entry = 17;
</a><a href="#h63-0-62" id="h63-0-62" class="i">+  required string combined = 18;
</a><a href="#h63-0-63" id="h63-0-63" class="i">+  optional int64 api_mcycles = 19;
</a><a href="#h63-0-64" id="h63-0-64" class="i">+  optional string host = 20;
</a><a href="#h63-0-65" id="h63-0-65" class="i">+  optional double cost = 21;
</a><a href="#h63-0-66" id="h63-0-66" class="i">+
</a><a href="#h63-0-67" id="h63-0-67" class="i">+  optional string task_queue_name = 22;
</a><a href="#h63-0-68" id="h63-0-68" class="i">+  optional string task_name = 23;
</a><a href="#h63-0-69" id="h63-0-69" class="i">+
</a><a href="#h63-0-70" id="h63-0-70" class="i">+  optional bool was_loading_request = 24;
</a><a href="#h63-0-71" id="h63-0-71" class="i">+  optional int64 pending_time = 25;
</a><a href="#h63-0-72" id="h63-0-72" class="i">+  optional int32 replica_index = 26 [default = -1];
</a><a href="#h63-0-73" id="h63-0-73" class="i">+  optional bool finished = 27 [default = true];
</a><a href="#h63-0-74" id="h63-0-74" class="i">+  optional bytes clone_key = 28;
</a><a href="#h63-0-75" id="h63-0-75" class="i">+
</a><a href="#h63-0-76" id="h63-0-76" class="i">+  repeated LogLine line = 29;
</a><a href="#h63-0-77" id="h63-0-77" class="i">+
</a><a href="#h63-0-78" id="h63-0-78" class="i">+  optional bool lines_incomplete = 36;
</a><a href="#h63-0-79" id="h63-0-79" class="i">+  optional bytes app_engine_release = 38;
</a><a href="#h63-0-80" id="h63-0-80" class="i">+
</a><a href="#h63-0-81" id="h63-0-81" class="i">+  optional int32 exit_reason = 30;
</a><a href="#h63-0-82" id="h63-0-82" class="i">+  optional bool was_throttled_for_time = 31;
</a><a href="#h63-0-83" id="h63-0-83" class="i">+  optional bool was_throttled_for_requests = 32;
</a><a href="#h63-0-84" id="h63-0-84" class="i">+  optional int64 throttled_time = 33;
</a><a href="#h63-0-85" id="h63-0-85" class="i">+
</a><a href="#h63-0-86" id="h63-0-86" class="i">+  optional bytes server_name = 34;
</a><a href="#h63-0-87" id="h63-0-87" class="i">+}
</a><a href="#h63-0-88" id="h63-0-88" class="i">+
</a><a href="#h63-0-89" id="h63-0-89" class="i">+message LogModuleVersion {
</a><a href="#h63-0-90" id="h63-0-90" class="i">+  optional string module_id = 1 [default=&quot;default&quot;];
</a><a href="#h63-0-91" id="h63-0-91" class="i">+  optional string version_id = 2;
</a><a href="#h63-0-92" id="h63-0-92" class="i">+}
</a><a href="#h63-0-93" id="h63-0-93" class="i">+
</a><a href="#h63-0-94" id="h63-0-94" class="i">+message LogReadRequest {
</a><a href="#h63-0-95" id="h63-0-95" class="i">+  required string app_id = 1;
</a><a href="#h63-0-96" id="h63-0-96" class="i">+  repeated string version_id = 2;
</a><a href="#h63-0-97" id="h63-0-97" class="i">+  repeated LogModuleVersion module_version = 19;
</a><a href="#h63-0-98" id="h63-0-98" class="i">+
</a><a href="#h63-0-99" id="h63-0-99" class="i">+  optional int64 start_time = 3;
</a><a href="#h63-0-100" id="h63-0-100" class="i">+  optional int64 end_time = 4;
</a><a href="#h63-0-101" id="h63-0-101" class="i">+  optional LogOffset offset = 5;
</a><a href="#h63-0-102" id="h63-0-102" class="i">+  repeated bytes request_id = 6;
</a><a href="#h63-0-103" id="h63-0-103" class="i">+
</a><a href="#h63-0-104" id="h63-0-104" class="i">+  optional int32 minimum_log_level = 7;
</a><a href="#h63-0-105" id="h63-0-105" class="i">+  optional bool include_incomplete = 8;
</a><a href="#h63-0-106" id="h63-0-106" class="i">+  optional int64 count = 9;
</a><a href="#h63-0-107" id="h63-0-107" class="i">+
</a><a href="#h63-0-108" id="h63-0-108" class="i">+  optional string combined_log_regex = 14;
</a><a href="#h63-0-109" id="h63-0-109" class="i">+  optional string host_regex = 15;
</a><a href="#h63-0-110" id="h63-0-110" class="i">+  optional int32 replica_index = 16;
</a><a href="#h63-0-111" id="h63-0-111" class="i">+
</a><a href="#h63-0-112" id="h63-0-112" class="i">+  optional bool include_app_logs = 10;
</a><a href="#h63-0-113" id="h63-0-113" class="i">+  optional int32 app_logs_per_request = 17;
</a><a href="#h63-0-114" id="h63-0-114" class="i">+  optional bool include_host = 11;
</a><a href="#h63-0-115" id="h63-0-115" class="i">+  optional bool include_all = 12;
</a><a href="#h63-0-116" id="h63-0-116" class="i">+  optional bool cache_iterator = 13;
</a><a href="#h63-0-117" id="h63-0-117" class="i">+  optional int32 num_shards = 18;
</a><a href="#h63-0-118" id="h63-0-118" class="i">+}
</a><a href="#h63-0-119" id="h63-0-119" class="i">+
</a><a href="#h63-0-120" id="h63-0-120" class="i">+message LogReadResponse {
</a><a href="#h63-0-121" id="h63-0-121" class="i">+  repeated RequestLog log = 1;
</a><a href="#h63-0-122" id="h63-0-122" class="i">+  optional LogOffset offset = 2;
</a><a href="#h63-0-123" id="h63-0-123" class="i">+  optional int64 last_end_time = 3;
</a><a href="#h63-0-124" id="h63-0-124" class="i">+}
</a><a href="#h63-0-125" id="h63-0-125" class="i">+
</a><a href="#h63-0-126" id="h63-0-126" class="i">+message LogUsageRecord {
</a><a href="#h63-0-127" id="h63-0-127" class="i">+  optional string version_id = 1;
</a><a href="#h63-0-128" id="h63-0-128" class="i">+  optional int32 start_time = 2;
</a><a href="#h63-0-129" id="h63-0-129" class="i">+  optional int32 end_time = 3;
</a><a href="#h63-0-130" id="h63-0-130" class="i">+  optional int64 count = 4;
</a><a href="#h63-0-131" id="h63-0-131" class="i">+  optional int64 total_size = 5;
</a><a href="#h63-0-132" id="h63-0-132" class="i">+  optional int32 records = 6;
</a><a href="#h63-0-133" id="h63-0-133" class="i">+}
</a><a href="#h63-0-134" id="h63-0-134" class="i">+
</a><a href="#h63-0-135" id="h63-0-135" class="i">+message LogUsageRequest {
</a><a href="#h63-0-136" id="h63-0-136" class="i">+  required string app_id = 1;
</a><a href="#h63-0-137" id="h63-0-137" class="i">+  repeated string version_id = 2;
</a><a href="#h63-0-138" id="h63-0-138" class="i">+  optional int32 start_time = 3;
</a><a href="#h63-0-139" id="h63-0-139" class="i">+  optional int32 end_time = 4;
</a><a href="#h63-0-140" id="h63-0-140" class="i">+  optional uint32 resolution_hours = 5 [default = 1];
</a><a href="#h63-0-141" id="h63-0-141" class="i">+  optional bool combine_versions = 6;
</a><a href="#h63-0-142" id="h63-0-142" class="i">+  optional int32 usage_version = 7;
</a><a href="#h63-0-143" id="h63-0-143" class="i">+  optional bool versions_only = 8;
</a><a href="#h63-0-144" id="h63-0-144" class="i">+}
</a><a href="#h63-0-145" id="h63-0-145" class="i">+
</a><a href="#h63-0-146" id="h63-0-146" class="i">+message LogUsageResponse {
</a><a href="#h63-0-147" id="h63-0-147" class="i">+  repeated LogUsageRecord usage = 1;
</a><a href="#h63-0-148" id="h63-0-148" class="i">+  optional LogUsageRecord summary = 2;
</a><a href="#h63-0-149" id="h63-0-149" class="i">+}
</a><b>diff --git a/<a id="h64" href="../file/vendor/google.golang.org/appengine/internal/main.go">vendor/google.golang.org/appengine/internal/main.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/main.go">vendor/google.golang.org/appengine/internal/main.go</a></b>
<a href="#h64-0" id="h64-0" class="h">@@ -0,0 +1,15 @@
</a><a href="#h64-0-0" id="h64-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h64-0-1" id="h64-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h64-0-2" id="h64-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h64-0-3" id="h64-0-3" class="i">+
</a><a href="#h64-0-4" id="h64-0-4" class="i">+// +build appengine
</a><a href="#h64-0-5" id="h64-0-5" class="i">+
</a><a href="#h64-0-6" id="h64-0-6" class="i">+package internal
</a><a href="#h64-0-7" id="h64-0-7" class="i">+
</a><a href="#h64-0-8" id="h64-0-8" class="i">+import (
</a><a href="#h64-0-9" id="h64-0-9" class="i">+	&quot;appengine_internal&quot;
</a><a href="#h64-0-10" id="h64-0-10" class="i">+)
</a><a href="#h64-0-11" id="h64-0-11" class="i">+
</a><a href="#h64-0-12" id="h64-0-12" class="i">+func Main() {
</a><a href="#h64-0-13" id="h64-0-13" class="i">+	appengine_internal.Main()
</a><a href="#h64-0-14" id="h64-0-14" class="i">+}
</a><b>diff --git a/<a id="h65" href="../file/vendor/google.golang.org/appengine/internal/main_vm.go">vendor/google.golang.org/appengine/internal/main_vm.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/main_vm.go">vendor/google.golang.org/appengine/internal/main_vm.go</a></b>
<a href="#h65-0" id="h65-0" class="h">@@ -0,0 +1,44 @@
</a><a href="#h65-0-0" id="h65-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h65-0-1" id="h65-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h65-0-2" id="h65-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h65-0-3" id="h65-0-3" class="i">+
</a><a href="#h65-0-4" id="h65-0-4" class="i">+// +build !appengine
</a><a href="#h65-0-5" id="h65-0-5" class="i">+
</a><a href="#h65-0-6" id="h65-0-6" class="i">+package internal
</a><a href="#h65-0-7" id="h65-0-7" class="i">+
</a><a href="#h65-0-8" id="h65-0-8" class="i">+import (
</a><a href="#h65-0-9" id="h65-0-9" class="i">+	&quot;io&quot;
</a><a href="#h65-0-10" id="h65-0-10" class="i">+	&quot;log&quot;
</a><a href="#h65-0-11" id="h65-0-11" class="i">+	&quot;net/http&quot;
</a><a href="#h65-0-12" id="h65-0-12" class="i">+	&quot;net/url&quot;
</a><a href="#h65-0-13" id="h65-0-13" class="i">+	&quot;os&quot;
</a><a href="#h65-0-14" id="h65-0-14" class="i">+)
</a><a href="#h65-0-15" id="h65-0-15" class="i">+
</a><a href="#h65-0-16" id="h65-0-16" class="i">+func Main() {
</a><a href="#h65-0-17" id="h65-0-17" class="i">+	installHealthChecker(http.DefaultServeMux)
</a><a href="#h65-0-18" id="h65-0-18" class="i">+
</a><a href="#h65-0-19" id="h65-0-19" class="i">+	port := &quot;8080&quot;
</a><a href="#h65-0-20" id="h65-0-20" class="i">+	if s := os.Getenv(&quot;PORT&quot;); s != &quot;&quot; {
</a><a href="#h65-0-21" id="h65-0-21" class="i">+		port = s
</a><a href="#h65-0-22" id="h65-0-22" class="i">+	}
</a><a href="#h65-0-23" id="h65-0-23" class="i">+
</a><a href="#h65-0-24" id="h65-0-24" class="i">+	if err := http.ListenAndServe(&quot;:&quot;+port, http.HandlerFunc(handleHTTP)); err != nil {
</a><a href="#h65-0-25" id="h65-0-25" class="i">+		log.Fatalf(&quot;http.ListenAndServe: %v&quot;, err)
</a><a href="#h65-0-26" id="h65-0-26" class="i">+	}
</a><a href="#h65-0-27" id="h65-0-27" class="i">+}
</a><a href="#h65-0-28" id="h65-0-28" class="i">+
</a><a href="#h65-0-29" id="h65-0-29" class="i">+func installHealthChecker(mux *http.ServeMux) {
</a><a href="#h65-0-30" id="h65-0-30" class="i">+	// If no health check handler has been installed by this point, add a trivial one.
</a><a href="#h65-0-31" id="h65-0-31" class="i">+	const healthPath = &quot;/_ah/health&quot;
</a><a href="#h65-0-32" id="h65-0-32" class="i">+	hreq := &amp;http.Request{
</a><a href="#h65-0-33" id="h65-0-33" class="i">+		Method: &quot;GET&quot;,
</a><a href="#h65-0-34" id="h65-0-34" class="i">+		URL: &amp;url.URL{
</a><a href="#h65-0-35" id="h65-0-35" class="i">+			Path: healthPath,
</a><a href="#h65-0-36" id="h65-0-36" class="i">+		},
</a><a href="#h65-0-37" id="h65-0-37" class="i">+	}
</a><a href="#h65-0-38" id="h65-0-38" class="i">+	if _, pat := mux.Handler(hreq); pat != healthPath {
</a><a href="#h65-0-39" id="h65-0-39" class="i">+		mux.HandleFunc(healthPath, func(w http.ResponseWriter, r *http.Request) {
</a><a href="#h65-0-40" id="h65-0-40" class="i">+			io.WriteString(w, &quot;ok&quot;)
</a><a href="#h65-0-41" id="h65-0-41" class="i">+		})
</a><a href="#h65-0-42" id="h65-0-42" class="i">+	}
</a><a href="#h65-0-43" id="h65-0-43" class="i">+}
</a><b>diff --git a/<a id="h66" href="../file/vendor/google.golang.org/appengine/internal/metadata.go">vendor/google.golang.org/appengine/internal/metadata.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/metadata.go">vendor/google.golang.org/appengine/internal/metadata.go</a></b>
<a href="#h66-0" id="h66-0" class="h">@@ -0,0 +1,61 @@
</a><a href="#h66-0-0" id="h66-0-0" class="i">+// Copyright 2014 Google Inc. All rights reserved.
</a><a href="#h66-0-1" id="h66-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h66-0-2" id="h66-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h66-0-3" id="h66-0-3" class="i">+
</a><a href="#h66-0-4" id="h66-0-4" class="i">+package internal
</a><a href="#h66-0-5" id="h66-0-5" class="i">+
</a><a href="#h66-0-6" id="h66-0-6" class="i">+// This file has code for accessing metadata.
</a><a href="#h66-0-7" id="h66-0-7" class="i">+//
</a><a href="#h66-0-8" id="h66-0-8" class="i">+// References:
</a><a href="#h66-0-9" id="h66-0-9" class="i">+//	https://cloud.google.com/compute/docs/metadata
</a><a href="#h66-0-10" id="h66-0-10" class="i">+
</a><a href="#h66-0-11" id="h66-0-11" class="i">+import (
</a><a href="#h66-0-12" id="h66-0-12" class="i">+	&quot;fmt&quot;
</a><a href="#h66-0-13" id="h66-0-13" class="i">+	&quot;io/ioutil&quot;
</a><a href="#h66-0-14" id="h66-0-14" class="i">+	&quot;log&quot;
</a><a href="#h66-0-15" id="h66-0-15" class="i">+	&quot;net/http&quot;
</a><a href="#h66-0-16" id="h66-0-16" class="i">+	&quot;net/url&quot;
</a><a href="#h66-0-17" id="h66-0-17" class="i">+)
</a><a href="#h66-0-18" id="h66-0-18" class="i">+
</a><a href="#h66-0-19" id="h66-0-19" class="i">+const (
</a><a href="#h66-0-20" id="h66-0-20" class="i">+	metadataHost = &quot;metadata&quot;
</a><a href="#h66-0-21" id="h66-0-21" class="i">+	metadataPath = &quot;/computeMetadata/v1/&quot;
</a><a href="#h66-0-22" id="h66-0-22" class="i">+)
</a><a href="#h66-0-23" id="h66-0-23" class="i">+
</a><a href="#h66-0-24" id="h66-0-24" class="i">+var (
</a><a href="#h66-0-25" id="h66-0-25" class="i">+	metadataRequestHeaders = http.Header{
</a><a href="#h66-0-26" id="h66-0-26" class="i">+		&quot;Metadata-Flavor&quot;: []string{&quot;Google&quot;},
</a><a href="#h66-0-27" id="h66-0-27" class="i">+	}
</a><a href="#h66-0-28" id="h66-0-28" class="i">+)
</a><a href="#h66-0-29" id="h66-0-29" class="i">+
</a><a href="#h66-0-30" id="h66-0-30" class="i">+// TODO(dsymonds): Do we need to support default values, like Python?
</a><a href="#h66-0-31" id="h66-0-31" class="i">+func mustGetMetadata(key string) []byte {
</a><a href="#h66-0-32" id="h66-0-32" class="i">+	b, err := getMetadata(key)
</a><a href="#h66-0-33" id="h66-0-33" class="i">+	if err != nil {
</a><a href="#h66-0-34" id="h66-0-34" class="i">+		log.Fatalf(&quot;Metadata fetch failed: %v&quot;, err)
</a><a href="#h66-0-35" id="h66-0-35" class="i">+	}
</a><a href="#h66-0-36" id="h66-0-36" class="i">+	return b
</a><a href="#h66-0-37" id="h66-0-37" class="i">+}
</a><a href="#h66-0-38" id="h66-0-38" class="i">+
</a><a href="#h66-0-39" id="h66-0-39" class="i">+func getMetadata(key string) ([]byte, error) {
</a><a href="#h66-0-40" id="h66-0-40" class="i">+	// TODO(dsymonds): May need to use url.Parse to support keys with query args.
</a><a href="#h66-0-41" id="h66-0-41" class="i">+	req := &amp;http.Request{
</a><a href="#h66-0-42" id="h66-0-42" class="i">+		Method: &quot;GET&quot;,
</a><a href="#h66-0-43" id="h66-0-43" class="i">+		URL: &amp;url.URL{
</a><a href="#h66-0-44" id="h66-0-44" class="i">+			Scheme: &quot;http&quot;,
</a><a href="#h66-0-45" id="h66-0-45" class="i">+			Host:   metadataHost,
</a><a href="#h66-0-46" id="h66-0-46" class="i">+			Path:   metadataPath + key,
</a><a href="#h66-0-47" id="h66-0-47" class="i">+		},
</a><a href="#h66-0-48" id="h66-0-48" class="i">+		Header: metadataRequestHeaders,
</a><a href="#h66-0-49" id="h66-0-49" class="i">+		Host:   metadataHost,
</a><a href="#h66-0-50" id="h66-0-50" class="i">+	}
</a><a href="#h66-0-51" id="h66-0-51" class="i">+	resp, err := http.DefaultClient.Do(req)
</a><a href="#h66-0-52" id="h66-0-52" class="i">+	if err != nil {
</a><a href="#h66-0-53" id="h66-0-53" class="i">+		return nil, err
</a><a href="#h66-0-54" id="h66-0-54" class="i">+	}
</a><a href="#h66-0-55" id="h66-0-55" class="i">+	defer resp.Body.Close()
</a><a href="#h66-0-56" id="h66-0-56" class="i">+	if resp.StatusCode != 200 {
</a><a href="#h66-0-57" id="h66-0-57" class="i">+		return nil, fmt.Errorf(&quot;metadata server returned HTTP %d&quot;, resp.StatusCode)
</a><a href="#h66-0-58" id="h66-0-58" class="i">+	}
</a><a href="#h66-0-59" id="h66-0-59" class="i">+	return ioutil.ReadAll(resp.Body)
</a><a href="#h66-0-60" id="h66-0-60" class="i">+}
</a><b>diff --git a/<a id="h67" href="../file/vendor/google.golang.org/appengine/internal/net.go">vendor/google.golang.org/appengine/internal/net.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/net.go">vendor/google.golang.org/appengine/internal/net.go</a></b>
<a href="#h67-0" id="h67-0" class="h">@@ -0,0 +1,56 @@
</a><a href="#h67-0-0" id="h67-0-0" class="i">+// Copyright 2014 Google Inc. All rights reserved.
</a><a href="#h67-0-1" id="h67-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h67-0-2" id="h67-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h67-0-3" id="h67-0-3" class="i">+
</a><a href="#h67-0-4" id="h67-0-4" class="i">+package internal
</a><a href="#h67-0-5" id="h67-0-5" class="i">+
</a><a href="#h67-0-6" id="h67-0-6" class="i">+// This file implements a network dialer that limits the number of concurrent connections.
</a><a href="#h67-0-7" id="h67-0-7" class="i">+// It is only used for API calls.
</a><a href="#h67-0-8" id="h67-0-8" class="i">+
</a><a href="#h67-0-9" id="h67-0-9" class="i">+import (
</a><a href="#h67-0-10" id="h67-0-10" class="i">+	&quot;log&quot;
</a><a href="#h67-0-11" id="h67-0-11" class="i">+	&quot;net&quot;
</a><a href="#h67-0-12" id="h67-0-12" class="i">+	&quot;runtime&quot;
</a><a href="#h67-0-13" id="h67-0-13" class="i">+	&quot;sync&quot;
</a><a href="#h67-0-14" id="h67-0-14" class="i">+	&quot;time&quot;
</a><a href="#h67-0-15" id="h67-0-15" class="i">+)
</a><a href="#h67-0-16" id="h67-0-16" class="i">+
</a><a href="#h67-0-17" id="h67-0-17" class="i">+var limitSem = make(chan int, 100) // TODO(dsymonds): Use environment variable.
</a><a href="#h67-0-18" id="h67-0-18" class="i">+
</a><a href="#h67-0-19" id="h67-0-19" class="i">+func limitRelease() {
</a><a href="#h67-0-20" id="h67-0-20" class="i">+	// non-blocking
</a><a href="#h67-0-21" id="h67-0-21" class="i">+	select {
</a><a href="#h67-0-22" id="h67-0-22" class="i">+	case &lt;-limitSem:
</a><a href="#h67-0-23" id="h67-0-23" class="i">+	default:
</a><a href="#h67-0-24" id="h67-0-24" class="i">+		// This should not normally happen.
</a><a href="#h67-0-25" id="h67-0-25" class="i">+		log.Print(&quot;appengine: unbalanced limitSem release!&quot;)
</a><a href="#h67-0-26" id="h67-0-26" class="i">+	}
</a><a href="#h67-0-27" id="h67-0-27" class="i">+}
</a><a href="#h67-0-28" id="h67-0-28" class="i">+
</a><a href="#h67-0-29" id="h67-0-29" class="i">+func limitDial(network, addr string) (net.Conn, error) {
</a><a href="#h67-0-30" id="h67-0-30" class="i">+	limitSem &lt;- 1
</a><a href="#h67-0-31" id="h67-0-31" class="i">+
</a><a href="#h67-0-32" id="h67-0-32" class="i">+	// Dial with a timeout in case the API host is MIA.
</a><a href="#h67-0-33" id="h67-0-33" class="i">+	// The connection should normally be very fast.
</a><a href="#h67-0-34" id="h67-0-34" class="i">+	conn, err := net.DialTimeout(network, addr, 500*time.Millisecond)
</a><a href="#h67-0-35" id="h67-0-35" class="i">+	if err != nil {
</a><a href="#h67-0-36" id="h67-0-36" class="i">+		limitRelease()
</a><a href="#h67-0-37" id="h67-0-37" class="i">+		return nil, err
</a><a href="#h67-0-38" id="h67-0-38" class="i">+	}
</a><a href="#h67-0-39" id="h67-0-39" class="i">+	lc := &amp;limitConn{Conn: conn}
</a><a href="#h67-0-40" id="h67-0-40" class="i">+	runtime.SetFinalizer(lc, (*limitConn).Close) // shouldn&#39;t usually be required
</a><a href="#h67-0-41" id="h67-0-41" class="i">+	return lc, nil
</a><a href="#h67-0-42" id="h67-0-42" class="i">+}
</a><a href="#h67-0-43" id="h67-0-43" class="i">+
</a><a href="#h67-0-44" id="h67-0-44" class="i">+type limitConn struct {
</a><a href="#h67-0-45" id="h67-0-45" class="i">+	close sync.Once
</a><a href="#h67-0-46" id="h67-0-46" class="i">+	net.Conn
</a><a href="#h67-0-47" id="h67-0-47" class="i">+}
</a><a href="#h67-0-48" id="h67-0-48" class="i">+
</a><a href="#h67-0-49" id="h67-0-49" class="i">+func (lc *limitConn) Close() error {
</a><a href="#h67-0-50" id="h67-0-50" class="i">+	defer lc.close.Do(func() {
</a><a href="#h67-0-51" id="h67-0-51" class="i">+		limitRelease()
</a><a href="#h67-0-52" id="h67-0-52" class="i">+		runtime.SetFinalizer(lc, nil)
</a><a href="#h67-0-53" id="h67-0-53" class="i">+	})
</a><a href="#h67-0-54" id="h67-0-54" class="i">+	return lc.Conn.Close()
</a><a href="#h67-0-55" id="h67-0-55" class="i">+}
</a><b>diff --git a/<a id="h68" href="../file/vendor/google.golang.org/appengine/internal/regen.sh">vendor/google.golang.org/appengine/internal/regen.sh</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/regen.sh">vendor/google.golang.org/appengine/internal/regen.sh</a></b>
<a href="#h68-0" id="h68-0" class="h">@@ -0,0 +1,40 @@
</a><a href="#h68-0-0" id="h68-0-0" class="i">+#!/bin/bash -e
</a><a href="#h68-0-1" id="h68-0-1" class="i">+#
</a><a href="#h68-0-2" id="h68-0-2" class="i">+# This script rebuilds the generated code for the protocol buffers.
</a><a href="#h68-0-3" id="h68-0-3" class="i">+# To run this you will need protoc and goprotobuf installed;
</a><a href="#h68-0-4" id="h68-0-4" class="i">+# see https://github.com/golang/protobuf for instructions.
</a><a href="#h68-0-5" id="h68-0-5" class="i">+
</a><a href="#h68-0-6" id="h68-0-6" class="i">+PKG=google.golang.org/appengine
</a><a href="#h68-0-7" id="h68-0-7" class="i">+
</a><a href="#h68-0-8" id="h68-0-8" class="i">+function die() {
</a><a href="#h68-0-9" id="h68-0-9" class="i">+	echo 1&gt;&amp;2 $*
</a><a href="#h68-0-10" id="h68-0-10" class="i">+	exit 1
</a><a href="#h68-0-11" id="h68-0-11" class="i">+}
</a><a href="#h68-0-12" id="h68-0-12" class="i">+
</a><a href="#h68-0-13" id="h68-0-13" class="i">+# Sanity check that the right tools are accessible.
</a><a href="#h68-0-14" id="h68-0-14" class="i">+for tool in go protoc protoc-gen-go; do
</a><a href="#h68-0-15" id="h68-0-15" class="i">+	q=$(which $tool) || die &quot;didn&#39;t find $tool&quot;
</a><a href="#h68-0-16" id="h68-0-16" class="i">+	echo 1&gt;&amp;2 &quot;$tool: $q&quot;
</a><a href="#h68-0-17" id="h68-0-17" class="i">+done
</a><a href="#h68-0-18" id="h68-0-18" class="i">+
</a><a href="#h68-0-19" id="h68-0-19" class="i">+echo -n 1&gt;&amp;2 &quot;finding package dir... &quot;
</a><a href="#h68-0-20" id="h68-0-20" class="i">+pkgdir=$(go list -f &#39;{{.Dir}}&#39; $PKG)
</a><a href="#h68-0-21" id="h68-0-21" class="i">+echo 1&gt;&amp;2 $pkgdir
</a><a href="#h68-0-22" id="h68-0-22" class="i">+base=$(echo $pkgdir | sed &quot;s,/$PKG\$,,&quot;)
</a><a href="#h68-0-23" id="h68-0-23" class="i">+echo 1&gt;&amp;2 &quot;base: $base&quot;
</a><a href="#h68-0-24" id="h68-0-24" class="i">+cd $base
</a><a href="#h68-0-25" id="h68-0-25" class="i">+
</a><a href="#h68-0-26" id="h68-0-26" class="i">+# Run protoc once per package.
</a><a href="#h68-0-27" id="h68-0-27" class="i">+for dir in $(find $PKG/internal -name &#39;*.proto&#39; | xargs dirname | sort | uniq); do
</a><a href="#h68-0-28" id="h68-0-28" class="i">+	echo 1&gt;&amp;2 &quot;* $dir&quot;
</a><a href="#h68-0-29" id="h68-0-29" class="i">+	protoc --go_out=. $dir/*.proto
</a><a href="#h68-0-30" id="h68-0-30" class="i">+done
</a><a href="#h68-0-31" id="h68-0-31" class="i">+
</a><a href="#h68-0-32" id="h68-0-32" class="i">+for f in $(find $PKG/internal -name &#39;*.pb.go&#39;); do
</a><a href="#h68-0-33" id="h68-0-33" class="i">+  # Remove proto.RegisterEnum calls.
</a><a href="#h68-0-34" id="h68-0-34" class="i">+  # These cause duplicate registration panics when these packages
</a><a href="#h68-0-35" id="h68-0-35" class="i">+  # are used on classic App Engine. proto.RegisterEnum only affects
</a><a href="#h68-0-36" id="h68-0-36" class="i">+  # parsing the text format; we don&#39;t care about that.
</a><a href="#h68-0-37" id="h68-0-37" class="i">+  # https://code.google.com/p/googleappengine/issues/detail?id=11670#c17
</a><a href="#h68-0-38" id="h68-0-38" class="i">+  sed -i &#39;/proto.RegisterEnum/d&#39; $f
</a><a href="#h68-0-39" id="h68-0-39" class="i">+done
</a><b>diff --git a/<a id="h69" href="../file/vendor/google.golang.org/appengine/internal/remote_api/BUILD">vendor/google.golang.org/appengine/internal/remote_api/BUILD</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/remote_api/BUILD">vendor/google.golang.org/appengine/internal/remote_api/BUILD</a></b>
<a href="#h69-0" id="h69-0" class="h">@@ -0,0 +1,19 @@
</a><a href="#h69-0-0" id="h69-0-0" class="i">+
</a><a href="#h69-0-1" id="h69-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h69-0-2" id="h69-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h69-0-3" id="h69-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h69-0-4" id="h69-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h69-0-5" id="h69-0-5" class="i">+)
</a><a href="#h69-0-6" id="h69-0-6" class="i">+
</a><a href="#h69-0-7" id="h69-0-7" class="i">+go_library(
</a><a href="#h69-0-8" id="h69-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h69-0-9" id="h69-0-9" class="i">+  srcs = [
</a><a href="#h69-0-10" id="h69-0-10" class="i">+    &quot;remote_api.pb.go&quot;,
</a><a href="#h69-0-11" id="h69-0-11" class="i">+  ],
</a><a href="#h69-0-12" id="h69-0-12" class="i">+  deps = [
</a><a href="#h69-0-13" id="h69-0-13" class="i">+    &quot;//vendor/github.com/golang/protobuf/proto:go_default_library&quot;,
</a><a href="#h69-0-14" id="h69-0-14" class="i">+  ],
</a><a href="#h69-0-15" id="h69-0-15" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h69-0-16" id="h69-0-16" class="i">+)
</a><a href="#h69-0-17" id="h69-0-17" class="i">+
</a><a href="#h69-0-18" id="h69-0-18" class="i">+
</a><b>diff --git a/<a id="h70" href="../file/vendor/google.golang.org/appengine/internal/remote_api/remote_api.pb.go">vendor/google.golang.org/appengine/internal/remote_api/remote_api.pb.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/remote_api/remote_api.pb.go">vendor/google.golang.org/appengine/internal/remote_api/remote_api.pb.go</a></b>
<a href="#h70-0" id="h70-0" class="h">@@ -0,0 +1,231 @@
</a><a href="#h70-0-0" id="h70-0-0" class="i">+// Code generated by protoc-gen-go.
</a><a href="#h70-0-1" id="h70-0-1" class="i">+// source: google.golang.org/appengine/internal/remote_api/remote_api.proto
</a><a href="#h70-0-2" id="h70-0-2" class="i">+// DO NOT EDIT!
</a><a href="#h70-0-3" id="h70-0-3" class="i">+
</a><a href="#h70-0-4" id="h70-0-4" class="i">+/*
</a><a href="#h70-0-5" id="h70-0-5" class="i">+Package remote_api is a generated protocol buffer package.
</a><a href="#h70-0-6" id="h70-0-6" class="i">+
</a><a href="#h70-0-7" id="h70-0-7" class="i">+It is generated from these files:
</a><a href="#h70-0-8" id="h70-0-8" class="i">+	google.golang.org/appengine/internal/remote_api/remote_api.proto
</a><a href="#h70-0-9" id="h70-0-9" class="i">+
</a><a href="#h70-0-10" id="h70-0-10" class="i">+It has these top-level messages:
</a><a href="#h70-0-11" id="h70-0-11" class="i">+	Request
</a><a href="#h70-0-12" id="h70-0-12" class="i">+	ApplicationError
</a><a href="#h70-0-13" id="h70-0-13" class="i">+	RpcError
</a><a href="#h70-0-14" id="h70-0-14" class="i">+	Response
</a><a href="#h70-0-15" id="h70-0-15" class="i">+*/
</a><a href="#h70-0-16" id="h70-0-16" class="i">+package remote_api
</a><a href="#h70-0-17" id="h70-0-17" class="i">+
</a><a href="#h70-0-18" id="h70-0-18" class="i">+import proto &quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h70-0-19" id="h70-0-19" class="i">+import fmt &quot;fmt&quot;
</a><a href="#h70-0-20" id="h70-0-20" class="i">+import math &quot;math&quot;
</a><a href="#h70-0-21" id="h70-0-21" class="i">+
</a><a href="#h70-0-22" id="h70-0-22" class="i">+// Reference imports to suppress errors if they are not otherwise used.
</a><a href="#h70-0-23" id="h70-0-23" class="i">+var _ = proto.Marshal
</a><a href="#h70-0-24" id="h70-0-24" class="i">+var _ = fmt.Errorf
</a><a href="#h70-0-25" id="h70-0-25" class="i">+var _ = math.Inf
</a><a href="#h70-0-26" id="h70-0-26" class="i">+
</a><a href="#h70-0-27" id="h70-0-27" class="i">+type RpcError_ErrorCode int32
</a><a href="#h70-0-28" id="h70-0-28" class="i">+
</a><a href="#h70-0-29" id="h70-0-29" class="i">+const (
</a><a href="#h70-0-30" id="h70-0-30" class="i">+	RpcError_UNKNOWN             RpcError_ErrorCode = 0
</a><a href="#h70-0-31" id="h70-0-31" class="i">+	RpcError_CALL_NOT_FOUND      RpcError_ErrorCode = 1
</a><a href="#h70-0-32" id="h70-0-32" class="i">+	RpcError_PARSE_ERROR         RpcError_ErrorCode = 2
</a><a href="#h70-0-33" id="h70-0-33" class="i">+	RpcError_SECURITY_VIOLATION  RpcError_ErrorCode = 3
</a><a href="#h70-0-34" id="h70-0-34" class="i">+	RpcError_OVER_QUOTA          RpcError_ErrorCode = 4
</a><a href="#h70-0-35" id="h70-0-35" class="i">+	RpcError_REQUEST_TOO_LARGE   RpcError_ErrorCode = 5
</a><a href="#h70-0-36" id="h70-0-36" class="i">+	RpcError_CAPABILITY_DISABLED RpcError_ErrorCode = 6
</a><a href="#h70-0-37" id="h70-0-37" class="i">+	RpcError_FEATURE_DISABLED    RpcError_ErrorCode = 7
</a><a href="#h70-0-38" id="h70-0-38" class="i">+	RpcError_BAD_REQUEST         RpcError_ErrorCode = 8
</a><a href="#h70-0-39" id="h70-0-39" class="i">+	RpcError_RESPONSE_TOO_LARGE  RpcError_ErrorCode = 9
</a><a href="#h70-0-40" id="h70-0-40" class="i">+	RpcError_CANCELLED           RpcError_ErrorCode = 10
</a><a href="#h70-0-41" id="h70-0-41" class="i">+	RpcError_REPLAY_ERROR        RpcError_ErrorCode = 11
</a><a href="#h70-0-42" id="h70-0-42" class="i">+	RpcError_DEADLINE_EXCEEDED   RpcError_ErrorCode = 12
</a><a href="#h70-0-43" id="h70-0-43" class="i">+)
</a><a href="#h70-0-44" id="h70-0-44" class="i">+
</a><a href="#h70-0-45" id="h70-0-45" class="i">+var RpcError_ErrorCode_name = map[int32]string{
</a><a href="#h70-0-46" id="h70-0-46" class="i">+	0:  &quot;UNKNOWN&quot;,
</a><a href="#h70-0-47" id="h70-0-47" class="i">+	1:  &quot;CALL_NOT_FOUND&quot;,
</a><a href="#h70-0-48" id="h70-0-48" class="i">+	2:  &quot;PARSE_ERROR&quot;,
</a><a href="#h70-0-49" id="h70-0-49" class="i">+	3:  &quot;SECURITY_VIOLATION&quot;,
</a><a href="#h70-0-50" id="h70-0-50" class="i">+	4:  &quot;OVER_QUOTA&quot;,
</a><a href="#h70-0-51" id="h70-0-51" class="i">+	5:  &quot;REQUEST_TOO_LARGE&quot;,
</a><a href="#h70-0-52" id="h70-0-52" class="i">+	6:  &quot;CAPABILITY_DISABLED&quot;,
</a><a href="#h70-0-53" id="h70-0-53" class="i">+	7:  &quot;FEATURE_DISABLED&quot;,
</a><a href="#h70-0-54" id="h70-0-54" class="i">+	8:  &quot;BAD_REQUEST&quot;,
</a><a href="#h70-0-55" id="h70-0-55" class="i">+	9:  &quot;RESPONSE_TOO_LARGE&quot;,
</a><a href="#h70-0-56" id="h70-0-56" class="i">+	10: &quot;CANCELLED&quot;,
</a><a href="#h70-0-57" id="h70-0-57" class="i">+	11: &quot;REPLAY_ERROR&quot;,
</a><a href="#h70-0-58" id="h70-0-58" class="i">+	12: &quot;DEADLINE_EXCEEDED&quot;,
</a><a href="#h70-0-59" id="h70-0-59" class="i">+}
</a><a href="#h70-0-60" id="h70-0-60" class="i">+var RpcError_ErrorCode_value = map[string]int32{
</a><a href="#h70-0-61" id="h70-0-61" class="i">+	&quot;UNKNOWN&quot;:             0,
</a><a href="#h70-0-62" id="h70-0-62" class="i">+	&quot;CALL_NOT_FOUND&quot;:      1,
</a><a href="#h70-0-63" id="h70-0-63" class="i">+	&quot;PARSE_ERROR&quot;:         2,
</a><a href="#h70-0-64" id="h70-0-64" class="i">+	&quot;SECURITY_VIOLATION&quot;:  3,
</a><a href="#h70-0-65" id="h70-0-65" class="i">+	&quot;OVER_QUOTA&quot;:          4,
</a><a href="#h70-0-66" id="h70-0-66" class="i">+	&quot;REQUEST_TOO_LARGE&quot;:   5,
</a><a href="#h70-0-67" id="h70-0-67" class="i">+	&quot;CAPABILITY_DISABLED&quot;: 6,
</a><a href="#h70-0-68" id="h70-0-68" class="i">+	&quot;FEATURE_DISABLED&quot;:    7,
</a><a href="#h70-0-69" id="h70-0-69" class="i">+	&quot;BAD_REQUEST&quot;:         8,
</a><a href="#h70-0-70" id="h70-0-70" class="i">+	&quot;RESPONSE_TOO_LARGE&quot;:  9,
</a><a href="#h70-0-71" id="h70-0-71" class="i">+	&quot;CANCELLED&quot;:           10,
</a><a href="#h70-0-72" id="h70-0-72" class="i">+	&quot;REPLAY_ERROR&quot;:        11,
</a><a href="#h70-0-73" id="h70-0-73" class="i">+	&quot;DEADLINE_EXCEEDED&quot;:   12,
</a><a href="#h70-0-74" id="h70-0-74" class="i">+}
</a><a href="#h70-0-75" id="h70-0-75" class="i">+
</a><a href="#h70-0-76" id="h70-0-76" class="i">+func (x RpcError_ErrorCode) Enum() *RpcError_ErrorCode {
</a><a href="#h70-0-77" id="h70-0-77" class="i">+	p := new(RpcError_ErrorCode)
</a><a href="#h70-0-78" id="h70-0-78" class="i">+	*p = x
</a><a href="#h70-0-79" id="h70-0-79" class="i">+	return p
</a><a href="#h70-0-80" id="h70-0-80" class="i">+}
</a><a href="#h70-0-81" id="h70-0-81" class="i">+func (x RpcError_ErrorCode) String() string {
</a><a href="#h70-0-82" id="h70-0-82" class="i">+	return proto.EnumName(RpcError_ErrorCode_name, int32(x))
</a><a href="#h70-0-83" id="h70-0-83" class="i">+}
</a><a href="#h70-0-84" id="h70-0-84" class="i">+func (x *RpcError_ErrorCode) UnmarshalJSON(data []byte) error {
</a><a href="#h70-0-85" id="h70-0-85" class="i">+	value, err := proto.UnmarshalJSONEnum(RpcError_ErrorCode_value, data, &quot;RpcError_ErrorCode&quot;)
</a><a href="#h70-0-86" id="h70-0-86" class="i">+	if err != nil {
</a><a href="#h70-0-87" id="h70-0-87" class="i">+		return err
</a><a href="#h70-0-88" id="h70-0-88" class="i">+	}
</a><a href="#h70-0-89" id="h70-0-89" class="i">+	*x = RpcError_ErrorCode(value)
</a><a href="#h70-0-90" id="h70-0-90" class="i">+	return nil
</a><a href="#h70-0-91" id="h70-0-91" class="i">+}
</a><a href="#h70-0-92" id="h70-0-92" class="i">+
</a><a href="#h70-0-93" id="h70-0-93" class="i">+type Request struct {
</a><a href="#h70-0-94" id="h70-0-94" class="i">+	ServiceName      *string `protobuf:&quot;bytes,2,req,name=service_name&quot; json:&quot;service_name,omitempty&quot;`
</a><a href="#h70-0-95" id="h70-0-95" class="i">+	Method           *string `protobuf:&quot;bytes,3,req,name=method&quot; json:&quot;method,omitempty&quot;`
</a><a href="#h70-0-96" id="h70-0-96" class="i">+	Request          []byte  `protobuf:&quot;bytes,4,req,name=request&quot; json:&quot;request,omitempty&quot;`
</a><a href="#h70-0-97" id="h70-0-97" class="i">+	RequestId        *string `protobuf:&quot;bytes,5,opt,name=request_id&quot; json:&quot;request_id,omitempty&quot;`
</a><a href="#h70-0-98" id="h70-0-98" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h70-0-99" id="h70-0-99" class="i">+}
</a><a href="#h70-0-100" id="h70-0-100" class="i">+
</a><a href="#h70-0-101" id="h70-0-101" class="i">+func (m *Request) Reset()         { *m = Request{} }
</a><a href="#h70-0-102" id="h70-0-102" class="i">+func (m *Request) String() string { return proto.CompactTextString(m) }
</a><a href="#h70-0-103" id="h70-0-103" class="i">+func (*Request) ProtoMessage()    {}
</a><a href="#h70-0-104" id="h70-0-104" class="i">+
</a><a href="#h70-0-105" id="h70-0-105" class="i">+func (m *Request) GetServiceName() string {
</a><a href="#h70-0-106" id="h70-0-106" class="i">+	if m != nil &amp;&amp; m.ServiceName != nil {
</a><a href="#h70-0-107" id="h70-0-107" class="i">+		return *m.ServiceName
</a><a href="#h70-0-108" id="h70-0-108" class="i">+	}
</a><a href="#h70-0-109" id="h70-0-109" class="i">+	return &quot;&quot;
</a><a href="#h70-0-110" id="h70-0-110" class="i">+}
</a><a href="#h70-0-111" id="h70-0-111" class="i">+
</a><a href="#h70-0-112" id="h70-0-112" class="i">+func (m *Request) GetMethod() string {
</a><a href="#h70-0-113" id="h70-0-113" class="i">+	if m != nil &amp;&amp; m.Method != nil {
</a><a href="#h70-0-114" id="h70-0-114" class="i">+		return *m.Method
</a><a href="#h70-0-115" id="h70-0-115" class="i">+	}
</a><a href="#h70-0-116" id="h70-0-116" class="i">+	return &quot;&quot;
</a><a href="#h70-0-117" id="h70-0-117" class="i">+}
</a><a href="#h70-0-118" id="h70-0-118" class="i">+
</a><a href="#h70-0-119" id="h70-0-119" class="i">+func (m *Request) GetRequest() []byte {
</a><a href="#h70-0-120" id="h70-0-120" class="i">+	if m != nil {
</a><a href="#h70-0-121" id="h70-0-121" class="i">+		return m.Request
</a><a href="#h70-0-122" id="h70-0-122" class="i">+	}
</a><a href="#h70-0-123" id="h70-0-123" class="i">+	return nil
</a><a href="#h70-0-124" id="h70-0-124" class="i">+}
</a><a href="#h70-0-125" id="h70-0-125" class="i">+
</a><a href="#h70-0-126" id="h70-0-126" class="i">+func (m *Request) GetRequestId() string {
</a><a href="#h70-0-127" id="h70-0-127" class="i">+	if m != nil &amp;&amp; m.RequestId != nil {
</a><a href="#h70-0-128" id="h70-0-128" class="i">+		return *m.RequestId
</a><a href="#h70-0-129" id="h70-0-129" class="i">+	}
</a><a href="#h70-0-130" id="h70-0-130" class="i">+	return &quot;&quot;
</a><a href="#h70-0-131" id="h70-0-131" class="i">+}
</a><a href="#h70-0-132" id="h70-0-132" class="i">+
</a><a href="#h70-0-133" id="h70-0-133" class="i">+type ApplicationError struct {
</a><a href="#h70-0-134" id="h70-0-134" class="i">+	Code             *int32  `protobuf:&quot;varint,1,req,name=code&quot; json:&quot;code,omitempty&quot;`
</a><a href="#h70-0-135" id="h70-0-135" class="i">+	Detail           *string `protobuf:&quot;bytes,2,req,name=detail&quot; json:&quot;detail,omitempty&quot;`
</a><a href="#h70-0-136" id="h70-0-136" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h70-0-137" id="h70-0-137" class="i">+}
</a><a href="#h70-0-138" id="h70-0-138" class="i">+
</a><a href="#h70-0-139" id="h70-0-139" class="i">+func (m *ApplicationError) Reset()         { *m = ApplicationError{} }
</a><a href="#h70-0-140" id="h70-0-140" class="i">+func (m *ApplicationError) String() string { return proto.CompactTextString(m) }
</a><a href="#h70-0-141" id="h70-0-141" class="i">+func (*ApplicationError) ProtoMessage()    {}
</a><a href="#h70-0-142" id="h70-0-142" class="i">+
</a><a href="#h70-0-143" id="h70-0-143" class="i">+func (m *ApplicationError) GetCode() int32 {
</a><a href="#h70-0-144" id="h70-0-144" class="i">+	if m != nil &amp;&amp; m.Code != nil {
</a><a href="#h70-0-145" id="h70-0-145" class="i">+		return *m.Code
</a><a href="#h70-0-146" id="h70-0-146" class="i">+	}
</a><a href="#h70-0-147" id="h70-0-147" class="i">+	return 0
</a><a href="#h70-0-148" id="h70-0-148" class="i">+}
</a><a href="#h70-0-149" id="h70-0-149" class="i">+
</a><a href="#h70-0-150" id="h70-0-150" class="i">+func (m *ApplicationError) GetDetail() string {
</a><a href="#h70-0-151" id="h70-0-151" class="i">+	if m != nil &amp;&amp; m.Detail != nil {
</a><a href="#h70-0-152" id="h70-0-152" class="i">+		return *m.Detail
</a><a href="#h70-0-153" id="h70-0-153" class="i">+	}
</a><a href="#h70-0-154" id="h70-0-154" class="i">+	return &quot;&quot;
</a><a href="#h70-0-155" id="h70-0-155" class="i">+}
</a><a href="#h70-0-156" id="h70-0-156" class="i">+
</a><a href="#h70-0-157" id="h70-0-157" class="i">+type RpcError struct {
</a><a href="#h70-0-158" id="h70-0-158" class="i">+	Code             *int32  `protobuf:&quot;varint,1,req,name=code&quot; json:&quot;code,omitempty&quot;`
</a><a href="#h70-0-159" id="h70-0-159" class="i">+	Detail           *string `protobuf:&quot;bytes,2,opt,name=detail&quot; json:&quot;detail,omitempty&quot;`
</a><a href="#h70-0-160" id="h70-0-160" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h70-0-161" id="h70-0-161" class="i">+}
</a><a href="#h70-0-162" id="h70-0-162" class="i">+
</a><a href="#h70-0-163" id="h70-0-163" class="i">+func (m *RpcError) Reset()         { *m = RpcError{} }
</a><a href="#h70-0-164" id="h70-0-164" class="i">+func (m *RpcError) String() string { return proto.CompactTextString(m) }
</a><a href="#h70-0-165" id="h70-0-165" class="i">+func (*RpcError) ProtoMessage()    {}
</a><a href="#h70-0-166" id="h70-0-166" class="i">+
</a><a href="#h70-0-167" id="h70-0-167" class="i">+func (m *RpcError) GetCode() int32 {
</a><a href="#h70-0-168" id="h70-0-168" class="i">+	if m != nil &amp;&amp; m.Code != nil {
</a><a href="#h70-0-169" id="h70-0-169" class="i">+		return *m.Code
</a><a href="#h70-0-170" id="h70-0-170" class="i">+	}
</a><a href="#h70-0-171" id="h70-0-171" class="i">+	return 0
</a><a href="#h70-0-172" id="h70-0-172" class="i">+}
</a><a href="#h70-0-173" id="h70-0-173" class="i">+
</a><a href="#h70-0-174" id="h70-0-174" class="i">+func (m *RpcError) GetDetail() string {
</a><a href="#h70-0-175" id="h70-0-175" class="i">+	if m != nil &amp;&amp; m.Detail != nil {
</a><a href="#h70-0-176" id="h70-0-176" class="i">+		return *m.Detail
</a><a href="#h70-0-177" id="h70-0-177" class="i">+	}
</a><a href="#h70-0-178" id="h70-0-178" class="i">+	return &quot;&quot;
</a><a href="#h70-0-179" id="h70-0-179" class="i">+}
</a><a href="#h70-0-180" id="h70-0-180" class="i">+
</a><a href="#h70-0-181" id="h70-0-181" class="i">+type Response struct {
</a><a href="#h70-0-182" id="h70-0-182" class="i">+	Response         []byte            `protobuf:&quot;bytes,1,opt,name=response&quot; json:&quot;response,omitempty&quot;`
</a><a href="#h70-0-183" id="h70-0-183" class="i">+	Exception        []byte            `protobuf:&quot;bytes,2,opt,name=exception&quot; json:&quot;exception,omitempty&quot;`
</a><a href="#h70-0-184" id="h70-0-184" class="i">+	ApplicationError *ApplicationError `protobuf:&quot;bytes,3,opt,name=application_error&quot; json:&quot;application_error,omitempty&quot;`
</a><a href="#h70-0-185" id="h70-0-185" class="i">+	JavaException    []byte            `protobuf:&quot;bytes,4,opt,name=java_exception&quot; json:&quot;java_exception,omitempty&quot;`
</a><a href="#h70-0-186" id="h70-0-186" class="i">+	RpcError         *RpcError         `protobuf:&quot;bytes,5,opt,name=rpc_error&quot; json:&quot;rpc_error,omitempty&quot;`
</a><a href="#h70-0-187" id="h70-0-187" class="i">+	XXX_unrecognized []byte            `json:&quot;-&quot;`
</a><a href="#h70-0-188" id="h70-0-188" class="i">+}
</a><a href="#h70-0-189" id="h70-0-189" class="i">+
</a><a href="#h70-0-190" id="h70-0-190" class="i">+func (m *Response) Reset()         { *m = Response{} }
</a><a href="#h70-0-191" id="h70-0-191" class="i">+func (m *Response) String() string { return proto.CompactTextString(m) }
</a><a href="#h70-0-192" id="h70-0-192" class="i">+func (*Response) ProtoMessage()    {}
</a><a href="#h70-0-193" id="h70-0-193" class="i">+
</a><a href="#h70-0-194" id="h70-0-194" class="i">+func (m *Response) GetResponse() []byte {
</a><a href="#h70-0-195" id="h70-0-195" class="i">+	if m != nil {
</a><a href="#h70-0-196" id="h70-0-196" class="i">+		return m.Response
</a><a href="#h70-0-197" id="h70-0-197" class="i">+	}
</a><a href="#h70-0-198" id="h70-0-198" class="i">+	return nil
</a><a href="#h70-0-199" id="h70-0-199" class="i">+}
</a><a href="#h70-0-200" id="h70-0-200" class="i">+
</a><a href="#h70-0-201" id="h70-0-201" class="i">+func (m *Response) GetException() []byte {
</a><a href="#h70-0-202" id="h70-0-202" class="i">+	if m != nil {
</a><a href="#h70-0-203" id="h70-0-203" class="i">+		return m.Exception
</a><a href="#h70-0-204" id="h70-0-204" class="i">+	}
</a><a href="#h70-0-205" id="h70-0-205" class="i">+	return nil
</a><a href="#h70-0-206" id="h70-0-206" class="i">+}
</a><a href="#h70-0-207" id="h70-0-207" class="i">+
</a><a href="#h70-0-208" id="h70-0-208" class="i">+func (m *Response) GetApplicationError() *ApplicationError {
</a><a href="#h70-0-209" id="h70-0-209" class="i">+	if m != nil {
</a><a href="#h70-0-210" id="h70-0-210" class="i">+		return m.ApplicationError
</a><a href="#h70-0-211" id="h70-0-211" class="i">+	}
</a><a href="#h70-0-212" id="h70-0-212" class="i">+	return nil
</a><a href="#h70-0-213" id="h70-0-213" class="i">+}
</a><a href="#h70-0-214" id="h70-0-214" class="i">+
</a><a href="#h70-0-215" id="h70-0-215" class="i">+func (m *Response) GetJavaException() []byte {
</a><a href="#h70-0-216" id="h70-0-216" class="i">+	if m != nil {
</a><a href="#h70-0-217" id="h70-0-217" class="i">+		return m.JavaException
</a><a href="#h70-0-218" id="h70-0-218" class="i">+	}
</a><a href="#h70-0-219" id="h70-0-219" class="i">+	return nil
</a><a href="#h70-0-220" id="h70-0-220" class="i">+}
</a><a href="#h70-0-221" id="h70-0-221" class="i">+
</a><a href="#h70-0-222" id="h70-0-222" class="i">+func (m *Response) GetRpcError() *RpcError {
</a><a href="#h70-0-223" id="h70-0-223" class="i">+	if m != nil {
</a><a href="#h70-0-224" id="h70-0-224" class="i">+		return m.RpcError
</a><a href="#h70-0-225" id="h70-0-225" class="i">+	}
</a><a href="#h70-0-226" id="h70-0-226" class="i">+	return nil
</a><a href="#h70-0-227" id="h70-0-227" class="i">+}
</a><a href="#h70-0-228" id="h70-0-228" class="i">+
</a><a href="#h70-0-229" id="h70-0-229" class="i">+func init() {
</a><a href="#h70-0-230" id="h70-0-230" class="i">+}
</a><b>diff --git a/<a id="h71" href="../file/vendor/google.golang.org/appengine/internal/remote_api/remote_api.proto">vendor/google.golang.org/appengine/internal/remote_api/remote_api.proto</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/remote_api/remote_api.proto">vendor/google.golang.org/appengine/internal/remote_api/remote_api.proto</a></b>
<a href="#h71-0" id="h71-0" class="h">@@ -0,0 +1,44 @@
</a><a href="#h71-0-0" id="h71-0-0" class="i">+syntax = &quot;proto2&quot;;
</a><a href="#h71-0-1" id="h71-0-1" class="i">+option go_package = &quot;remote_api&quot;;
</a><a href="#h71-0-2" id="h71-0-2" class="i">+
</a><a href="#h71-0-3" id="h71-0-3" class="i">+package remote_api;
</a><a href="#h71-0-4" id="h71-0-4" class="i">+
</a><a href="#h71-0-5" id="h71-0-5" class="i">+message Request {
</a><a href="#h71-0-6" id="h71-0-6" class="i">+  required string service_name = 2;
</a><a href="#h71-0-7" id="h71-0-7" class="i">+  required string method = 3;
</a><a href="#h71-0-8" id="h71-0-8" class="i">+  required bytes request = 4;
</a><a href="#h71-0-9" id="h71-0-9" class="i">+  optional string request_id = 5;
</a><a href="#h71-0-10" id="h71-0-10" class="i">+}
</a><a href="#h71-0-11" id="h71-0-11" class="i">+
</a><a href="#h71-0-12" id="h71-0-12" class="i">+message ApplicationError {
</a><a href="#h71-0-13" id="h71-0-13" class="i">+  required int32 code = 1;
</a><a href="#h71-0-14" id="h71-0-14" class="i">+  required string detail = 2;
</a><a href="#h71-0-15" id="h71-0-15" class="i">+}
</a><a href="#h71-0-16" id="h71-0-16" class="i">+
</a><a href="#h71-0-17" id="h71-0-17" class="i">+message RpcError {
</a><a href="#h71-0-18" id="h71-0-18" class="i">+  enum ErrorCode {
</a><a href="#h71-0-19" id="h71-0-19" class="i">+    UNKNOWN = 0;
</a><a href="#h71-0-20" id="h71-0-20" class="i">+    CALL_NOT_FOUND = 1;
</a><a href="#h71-0-21" id="h71-0-21" class="i">+    PARSE_ERROR = 2;
</a><a href="#h71-0-22" id="h71-0-22" class="i">+    SECURITY_VIOLATION = 3;
</a><a href="#h71-0-23" id="h71-0-23" class="i">+    OVER_QUOTA = 4;
</a><a href="#h71-0-24" id="h71-0-24" class="i">+    REQUEST_TOO_LARGE = 5;
</a><a href="#h71-0-25" id="h71-0-25" class="i">+    CAPABILITY_DISABLED = 6;
</a><a href="#h71-0-26" id="h71-0-26" class="i">+    FEATURE_DISABLED = 7;
</a><a href="#h71-0-27" id="h71-0-27" class="i">+    BAD_REQUEST = 8;
</a><a href="#h71-0-28" id="h71-0-28" class="i">+    RESPONSE_TOO_LARGE = 9;
</a><a href="#h71-0-29" id="h71-0-29" class="i">+    CANCELLED = 10;
</a><a href="#h71-0-30" id="h71-0-30" class="i">+    REPLAY_ERROR = 11;
</a><a href="#h71-0-31" id="h71-0-31" class="i">+    DEADLINE_EXCEEDED = 12;
</a><a href="#h71-0-32" id="h71-0-32" class="i">+  }
</a><a href="#h71-0-33" id="h71-0-33" class="i">+  required int32 code = 1;
</a><a href="#h71-0-34" id="h71-0-34" class="i">+  optional string detail = 2;
</a><a href="#h71-0-35" id="h71-0-35" class="i">+}
</a><a href="#h71-0-36" id="h71-0-36" class="i">+
</a><a href="#h71-0-37" id="h71-0-37" class="i">+message Response {
</a><a href="#h71-0-38" id="h71-0-38" class="i">+  optional bytes response = 1;
</a><a href="#h71-0-39" id="h71-0-39" class="i">+  optional bytes exception = 2;
</a><a href="#h71-0-40" id="h71-0-40" class="i">+  optional ApplicationError application_error = 3;
</a><a href="#h71-0-41" id="h71-0-41" class="i">+  optional bytes java_exception = 4;
</a><a href="#h71-0-42" id="h71-0-42" class="i">+  optional RpcError rpc_error = 5;
</a><a href="#h71-0-43" id="h71-0-43" class="i">+}
</a><b>diff --git a/<a id="h72" href="../file/vendor/google.golang.org/appengine/internal/transaction.go">vendor/google.golang.org/appengine/internal/transaction.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/transaction.go">vendor/google.golang.org/appengine/internal/transaction.go</a></b>
<a href="#h72-0" id="h72-0" class="h">@@ -0,0 +1,107 @@
</a><a href="#h72-0-0" id="h72-0-0" class="i">+// Copyright 2014 Google Inc. All rights reserved.
</a><a href="#h72-0-1" id="h72-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h72-0-2" id="h72-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h72-0-3" id="h72-0-3" class="i">+
</a><a href="#h72-0-4" id="h72-0-4" class="i">+package internal
</a><a href="#h72-0-5" id="h72-0-5" class="i">+
</a><a href="#h72-0-6" id="h72-0-6" class="i">+// This file implements hooks for applying datastore transactions.
</a><a href="#h72-0-7" id="h72-0-7" class="i">+
</a><a href="#h72-0-8" id="h72-0-8" class="i">+import (
</a><a href="#h72-0-9" id="h72-0-9" class="i">+	&quot;errors&quot;
</a><a href="#h72-0-10" id="h72-0-10" class="i">+	&quot;reflect&quot;
</a><a href="#h72-0-11" id="h72-0-11" class="i">+
</a><a href="#h72-0-12" id="h72-0-12" class="i">+	&quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h72-0-13" id="h72-0-13" class="i">+	netcontext &quot;golang.org/x/net/context&quot;
</a><a href="#h72-0-14" id="h72-0-14" class="i">+
</a><a href="#h72-0-15" id="h72-0-15" class="i">+	basepb &quot;google.golang.org/appengine/internal/base&quot;
</a><a href="#h72-0-16" id="h72-0-16" class="i">+	pb &quot;google.golang.org/appengine/internal/datastore&quot;
</a><a href="#h72-0-17" id="h72-0-17" class="i">+)
</a><a href="#h72-0-18" id="h72-0-18" class="i">+
</a><a href="#h72-0-19" id="h72-0-19" class="i">+var transactionSetters = make(map[reflect.Type]reflect.Value)
</a><a href="#h72-0-20" id="h72-0-20" class="i">+
</a><a href="#h72-0-21" id="h72-0-21" class="i">+// RegisterTransactionSetter registers a function that sets transaction information
</a><a href="#h72-0-22" id="h72-0-22" class="i">+// in a protocol buffer message. f should be a function with two arguments,
</a><a href="#h72-0-23" id="h72-0-23" class="i">+// the first being a protocol buffer type, and the second being *datastore.Transaction.
</a><a href="#h72-0-24" id="h72-0-24" class="i">+func RegisterTransactionSetter(f interface{}) {
</a><a href="#h72-0-25" id="h72-0-25" class="i">+	v := reflect.ValueOf(f)
</a><a href="#h72-0-26" id="h72-0-26" class="i">+	transactionSetters[v.Type().In(0)] = v
</a><a href="#h72-0-27" id="h72-0-27" class="i">+}
</a><a href="#h72-0-28" id="h72-0-28" class="i">+
</a><a href="#h72-0-29" id="h72-0-29" class="i">+// applyTransaction applies the transaction t to message pb
</a><a href="#h72-0-30" id="h72-0-30" class="i">+// by using the relevant setter passed to RegisterTransactionSetter.
</a><a href="#h72-0-31" id="h72-0-31" class="i">+func applyTransaction(pb proto.Message, t *pb.Transaction) {
</a><a href="#h72-0-32" id="h72-0-32" class="i">+	v := reflect.ValueOf(pb)
</a><a href="#h72-0-33" id="h72-0-33" class="i">+	if f, ok := transactionSetters[v.Type()]; ok {
</a><a href="#h72-0-34" id="h72-0-34" class="i">+		f.Call([]reflect.Value{v, reflect.ValueOf(t)})
</a><a href="#h72-0-35" id="h72-0-35" class="i">+	}
</a><a href="#h72-0-36" id="h72-0-36" class="i">+}
</a><a href="#h72-0-37" id="h72-0-37" class="i">+
</a><a href="#h72-0-38" id="h72-0-38" class="i">+var transactionKey = &quot;used for *Transaction&quot;
</a><a href="#h72-0-39" id="h72-0-39" class="i">+
</a><a href="#h72-0-40" id="h72-0-40" class="i">+func transactionFromContext(ctx netcontext.Context) *transaction {
</a><a href="#h72-0-41" id="h72-0-41" class="i">+	t, _ := ctx.Value(&amp;transactionKey).(*transaction)
</a><a href="#h72-0-42" id="h72-0-42" class="i">+	return t
</a><a href="#h72-0-43" id="h72-0-43" class="i">+}
</a><a href="#h72-0-44" id="h72-0-44" class="i">+
</a><a href="#h72-0-45" id="h72-0-45" class="i">+func withTransaction(ctx netcontext.Context, t *transaction) netcontext.Context {
</a><a href="#h72-0-46" id="h72-0-46" class="i">+	return netcontext.WithValue(ctx, &amp;transactionKey, t)
</a><a href="#h72-0-47" id="h72-0-47" class="i">+}
</a><a href="#h72-0-48" id="h72-0-48" class="i">+
</a><a href="#h72-0-49" id="h72-0-49" class="i">+type transaction struct {
</a><a href="#h72-0-50" id="h72-0-50" class="i">+	transaction pb.Transaction
</a><a href="#h72-0-51" id="h72-0-51" class="i">+	finished    bool
</a><a href="#h72-0-52" id="h72-0-52" class="i">+}
</a><a href="#h72-0-53" id="h72-0-53" class="i">+
</a><a href="#h72-0-54" id="h72-0-54" class="i">+var ErrConcurrentTransaction = errors.New(&quot;internal: concurrent transaction&quot;)
</a><a href="#h72-0-55" id="h72-0-55" class="i">+
</a><a href="#h72-0-56" id="h72-0-56" class="i">+func RunTransactionOnce(c netcontext.Context, f func(netcontext.Context) error, xg bool) error {
</a><a href="#h72-0-57" id="h72-0-57" class="i">+	if transactionFromContext(c) != nil {
</a><a href="#h72-0-58" id="h72-0-58" class="i">+		return errors.New(&quot;nested transactions are not supported&quot;)
</a><a href="#h72-0-59" id="h72-0-59" class="i">+	}
</a><a href="#h72-0-60" id="h72-0-60" class="i">+
</a><a href="#h72-0-61" id="h72-0-61" class="i">+	// Begin the transaction.
</a><a href="#h72-0-62" id="h72-0-62" class="i">+	t := &amp;transaction{}
</a><a href="#h72-0-63" id="h72-0-63" class="i">+	req := &amp;pb.BeginTransactionRequest{
</a><a href="#h72-0-64" id="h72-0-64" class="i">+		App: proto.String(FullyQualifiedAppID(c)),
</a><a href="#h72-0-65" id="h72-0-65" class="i">+	}
</a><a href="#h72-0-66" id="h72-0-66" class="i">+	if xg {
</a><a href="#h72-0-67" id="h72-0-67" class="i">+		req.AllowMultipleEg = proto.Bool(true)
</a><a href="#h72-0-68" id="h72-0-68" class="i">+	}
</a><a href="#h72-0-69" id="h72-0-69" class="i">+	if err := Call(c, &quot;datastore_v3&quot;, &quot;BeginTransaction&quot;, req, &amp;t.transaction); err != nil {
</a><a href="#h72-0-70" id="h72-0-70" class="i">+		return err
</a><a href="#h72-0-71" id="h72-0-71" class="i">+	}
</a><a href="#h72-0-72" id="h72-0-72" class="i">+
</a><a href="#h72-0-73" id="h72-0-73" class="i">+	// Call f, rolling back the transaction if f returns a non-nil error, or panics.
</a><a href="#h72-0-74" id="h72-0-74" class="i">+	// The panic is not recovered.
</a><a href="#h72-0-75" id="h72-0-75" class="i">+	defer func() {
</a><a href="#h72-0-76" id="h72-0-76" class="i">+		if t.finished {
</a><a href="#h72-0-77" id="h72-0-77" class="i">+			return
</a><a href="#h72-0-78" id="h72-0-78" class="i">+		}
</a><a href="#h72-0-79" id="h72-0-79" class="i">+		t.finished = true
</a><a href="#h72-0-80" id="h72-0-80" class="i">+		// Ignore the error return value, since we are already returning a non-nil
</a><a href="#h72-0-81" id="h72-0-81" class="i">+		// error (or we&#39;re panicking).
</a><a href="#h72-0-82" id="h72-0-82" class="i">+		Call(c, &quot;datastore_v3&quot;, &quot;Rollback&quot;, &amp;t.transaction, &amp;basepb.VoidProto{})
</a><a href="#h72-0-83" id="h72-0-83" class="i">+	}()
</a><a href="#h72-0-84" id="h72-0-84" class="i">+	if err := f(withTransaction(c, t)); err != nil {
</a><a href="#h72-0-85" id="h72-0-85" class="i">+		return err
</a><a href="#h72-0-86" id="h72-0-86" class="i">+	}
</a><a href="#h72-0-87" id="h72-0-87" class="i">+	t.finished = true
</a><a href="#h72-0-88" id="h72-0-88" class="i">+
</a><a href="#h72-0-89" id="h72-0-89" class="i">+	// Commit the transaction.
</a><a href="#h72-0-90" id="h72-0-90" class="i">+	res := &amp;pb.CommitResponse{}
</a><a href="#h72-0-91" id="h72-0-91" class="i">+	err := Call(c, &quot;datastore_v3&quot;, &quot;Commit&quot;, &amp;t.transaction, res)
</a><a href="#h72-0-92" id="h72-0-92" class="i">+	if ae, ok := err.(*APIError); ok {
</a><a href="#h72-0-93" id="h72-0-93" class="i">+		/* TODO: restore this conditional
</a><a href="#h72-0-94" id="h72-0-94" class="i">+		if appengine.IsDevAppServer() {
</a><a href="#h72-0-95" id="h72-0-95" class="i">+		*/
</a><a href="#h72-0-96" id="h72-0-96" class="i">+		// The Python Dev AppServer raises an ApplicationError with error code 2 (which is
</a><a href="#h72-0-97" id="h72-0-97" class="i">+		// Error.CONCURRENT_TRANSACTION) and message &quot;Concurrency exception.&quot;.
</a><a href="#h72-0-98" id="h72-0-98" class="i">+		if ae.Code == int32(pb.Error_BAD_REQUEST) &amp;&amp; ae.Detail == &quot;ApplicationError: 2 Concurrency exception.&quot; {
</a><a href="#h72-0-99" id="h72-0-99" class="i">+			return ErrConcurrentTransaction
</a><a href="#h72-0-100" id="h72-0-100" class="i">+		}
</a><a href="#h72-0-101" id="h72-0-101" class="i">+		if ae.Code == int32(pb.Error_CONCURRENT_TRANSACTION) {
</a><a href="#h72-0-102" id="h72-0-102" class="i">+			return ErrConcurrentTransaction
</a><a href="#h72-0-103" id="h72-0-103" class="i">+		}
</a><a href="#h72-0-104" id="h72-0-104" class="i">+	}
</a><a href="#h72-0-105" id="h72-0-105" class="i">+	return err
</a><a href="#h72-0-106" id="h72-0-106" class="i">+}
</a><b>diff --git a/<a id="h73" href="../file/vendor/google.golang.org/appengine/internal/urlfetch/BUILD">vendor/google.golang.org/appengine/internal/urlfetch/BUILD</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/urlfetch/BUILD">vendor/google.golang.org/appengine/internal/urlfetch/BUILD</a></b>
<a href="#h73-0" id="h73-0" class="h">@@ -0,0 +1,19 @@
</a><a href="#h73-0-0" id="h73-0-0" class="i">+
</a><a href="#h73-0-1" id="h73-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h73-0-2" id="h73-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h73-0-3" id="h73-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h73-0-4" id="h73-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h73-0-5" id="h73-0-5" class="i">+)
</a><a href="#h73-0-6" id="h73-0-6" class="i">+
</a><a href="#h73-0-7" id="h73-0-7" class="i">+go_library(
</a><a href="#h73-0-8" id="h73-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h73-0-9" id="h73-0-9" class="i">+  srcs = [
</a><a href="#h73-0-10" id="h73-0-10" class="i">+    &quot;urlfetch_service.pb.go&quot;,
</a><a href="#h73-0-11" id="h73-0-11" class="i">+  ],
</a><a href="#h73-0-12" id="h73-0-12" class="i">+  deps = [
</a><a href="#h73-0-13" id="h73-0-13" class="i">+    &quot;//vendor/github.com/golang/protobuf/proto:go_default_library&quot;,
</a><a href="#h73-0-14" id="h73-0-14" class="i">+  ],
</a><a href="#h73-0-15" id="h73-0-15" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h73-0-16" id="h73-0-16" class="i">+)
</a><a href="#h73-0-17" id="h73-0-17" class="i">+
</a><a href="#h73-0-18" id="h73-0-18" class="i">+
</a><b>diff --git a/<a id="h74" href="../file/vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.pb.go">vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.pb.go</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.pb.go">vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.pb.go</a></b>
<a href="#h74-0" id="h74-0" class="h">@@ -0,0 +1,355 @@
</a><a href="#h74-0-0" id="h74-0-0" class="i">+// Code generated by protoc-gen-go.
</a><a href="#h74-0-1" id="h74-0-1" class="i">+// source: google.golang.org/appengine/internal/urlfetch/urlfetch_service.proto
</a><a href="#h74-0-2" id="h74-0-2" class="i">+// DO NOT EDIT!
</a><a href="#h74-0-3" id="h74-0-3" class="i">+
</a><a href="#h74-0-4" id="h74-0-4" class="i">+/*
</a><a href="#h74-0-5" id="h74-0-5" class="i">+Package urlfetch is a generated protocol buffer package.
</a><a href="#h74-0-6" id="h74-0-6" class="i">+
</a><a href="#h74-0-7" id="h74-0-7" class="i">+It is generated from these files:
</a><a href="#h74-0-8" id="h74-0-8" class="i">+	google.golang.org/appengine/internal/urlfetch/urlfetch_service.proto
</a><a href="#h74-0-9" id="h74-0-9" class="i">+
</a><a href="#h74-0-10" id="h74-0-10" class="i">+It has these top-level messages:
</a><a href="#h74-0-11" id="h74-0-11" class="i">+	URLFetchServiceError
</a><a href="#h74-0-12" id="h74-0-12" class="i">+	URLFetchRequest
</a><a href="#h74-0-13" id="h74-0-13" class="i">+	URLFetchResponse
</a><a href="#h74-0-14" id="h74-0-14" class="i">+*/
</a><a href="#h74-0-15" id="h74-0-15" class="i">+package urlfetch
</a><a href="#h74-0-16" id="h74-0-16" class="i">+
</a><a href="#h74-0-17" id="h74-0-17" class="i">+import proto &quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h74-0-18" id="h74-0-18" class="i">+import fmt &quot;fmt&quot;
</a><a href="#h74-0-19" id="h74-0-19" class="i">+import math &quot;math&quot;
</a><a href="#h74-0-20" id="h74-0-20" class="i">+
</a><a href="#h74-0-21" id="h74-0-21" class="i">+// Reference imports to suppress errors if they are not otherwise used.
</a><a href="#h74-0-22" id="h74-0-22" class="i">+var _ = proto.Marshal
</a><a href="#h74-0-23" id="h74-0-23" class="i">+var _ = fmt.Errorf
</a><a href="#h74-0-24" id="h74-0-24" class="i">+var _ = math.Inf
</a><a href="#h74-0-25" id="h74-0-25" class="i">+
</a><a href="#h74-0-26" id="h74-0-26" class="i">+type URLFetchServiceError_ErrorCode int32
</a><a href="#h74-0-27" id="h74-0-27" class="i">+
</a><a href="#h74-0-28" id="h74-0-28" class="i">+const (
</a><a href="#h74-0-29" id="h74-0-29" class="i">+	URLFetchServiceError_OK                       URLFetchServiceError_ErrorCode = 0
</a><a href="#h74-0-30" id="h74-0-30" class="i">+	URLFetchServiceError_INVALID_URL              URLFetchServiceError_ErrorCode = 1
</a><a href="#h74-0-31" id="h74-0-31" class="i">+	URLFetchServiceError_FETCH_ERROR              URLFetchServiceError_ErrorCode = 2
</a><a href="#h74-0-32" id="h74-0-32" class="i">+	URLFetchServiceError_UNSPECIFIED_ERROR        URLFetchServiceError_ErrorCode = 3
</a><a href="#h74-0-33" id="h74-0-33" class="i">+	URLFetchServiceError_RESPONSE_TOO_LARGE       URLFetchServiceError_ErrorCode = 4
</a><a href="#h74-0-34" id="h74-0-34" class="i">+	URLFetchServiceError_DEADLINE_EXCEEDED        URLFetchServiceError_ErrorCode = 5
</a><a href="#h74-0-35" id="h74-0-35" class="i">+	URLFetchServiceError_SSL_CERTIFICATE_ERROR    URLFetchServiceError_ErrorCode = 6
</a><a href="#h74-0-36" id="h74-0-36" class="i">+	URLFetchServiceError_DNS_ERROR                URLFetchServiceError_ErrorCode = 7
</a><a href="#h74-0-37" id="h74-0-37" class="i">+	URLFetchServiceError_CLOSED                   URLFetchServiceError_ErrorCode = 8
</a><a href="#h74-0-38" id="h74-0-38" class="i">+	URLFetchServiceError_INTERNAL_TRANSIENT_ERROR URLFetchServiceError_ErrorCode = 9
</a><a href="#h74-0-39" id="h74-0-39" class="i">+	URLFetchServiceError_TOO_MANY_REDIRECTS       URLFetchServiceError_ErrorCode = 10
</a><a href="#h74-0-40" id="h74-0-40" class="i">+	URLFetchServiceError_MALFORMED_REPLY          URLFetchServiceError_ErrorCode = 11
</a><a href="#h74-0-41" id="h74-0-41" class="i">+	URLFetchServiceError_CONNECTION_ERROR         URLFetchServiceError_ErrorCode = 12
</a><a href="#h74-0-42" id="h74-0-42" class="i">+)
</a><a href="#h74-0-43" id="h74-0-43" class="i">+
</a><a href="#h74-0-44" id="h74-0-44" class="i">+var URLFetchServiceError_ErrorCode_name = map[int32]string{
</a><a href="#h74-0-45" id="h74-0-45" class="i">+	0:  &quot;OK&quot;,
</a><a href="#h74-0-46" id="h74-0-46" class="i">+	1:  &quot;INVALID_URL&quot;,
</a><a href="#h74-0-47" id="h74-0-47" class="i">+	2:  &quot;FETCH_ERROR&quot;,
</a><a href="#h74-0-48" id="h74-0-48" class="i">+	3:  &quot;UNSPECIFIED_ERROR&quot;,
</a><a href="#h74-0-49" id="h74-0-49" class="i">+	4:  &quot;RESPONSE_TOO_LARGE&quot;,
</a><a href="#h74-0-50" id="h74-0-50" class="i">+	5:  &quot;DEADLINE_EXCEEDED&quot;,
</a><a href="#h74-0-51" id="h74-0-51" class="i">+	6:  &quot;SSL_CERTIFICATE_ERROR&quot;,
</a><a href="#h74-0-52" id="h74-0-52" class="i">+	7:  &quot;DNS_ERROR&quot;,
</a><a href="#h74-0-53" id="h74-0-53" class="i">+	8:  &quot;CLOSED&quot;,
</a><a href="#h74-0-54" id="h74-0-54" class="i">+	9:  &quot;INTERNAL_TRANSIENT_ERROR&quot;,
</a><a href="#h74-0-55" id="h74-0-55" class="i">+	10: &quot;TOO_MANY_REDIRECTS&quot;,
</a><a href="#h74-0-56" id="h74-0-56" class="i">+	11: &quot;MALFORMED_REPLY&quot;,
</a><a href="#h74-0-57" id="h74-0-57" class="i">+	12: &quot;CONNECTION_ERROR&quot;,
</a><a href="#h74-0-58" id="h74-0-58" class="i">+}
</a><a href="#h74-0-59" id="h74-0-59" class="i">+var URLFetchServiceError_ErrorCode_value = map[string]int32{
</a><a href="#h74-0-60" id="h74-0-60" class="i">+	&quot;OK&quot;:                       0,
</a><a href="#h74-0-61" id="h74-0-61" class="i">+	&quot;INVALID_URL&quot;:              1,
</a><a href="#h74-0-62" id="h74-0-62" class="i">+	&quot;FETCH_ERROR&quot;:              2,
</a><a href="#h74-0-63" id="h74-0-63" class="i">+	&quot;UNSPECIFIED_ERROR&quot;:        3,
</a><a href="#h74-0-64" id="h74-0-64" class="i">+	&quot;RESPONSE_TOO_LARGE&quot;:       4,
</a><a href="#h74-0-65" id="h74-0-65" class="i">+	&quot;DEADLINE_EXCEEDED&quot;:        5,
</a><a href="#h74-0-66" id="h74-0-66" class="i">+	&quot;SSL_CERTIFICATE_ERROR&quot;:    6,
</a><a href="#h74-0-67" id="h74-0-67" class="i">+	&quot;DNS_ERROR&quot;:                7,
</a><a href="#h74-0-68" id="h74-0-68" class="i">+	&quot;CLOSED&quot;:                   8,
</a><a href="#h74-0-69" id="h74-0-69" class="i">+	&quot;INTERNAL_TRANSIENT_ERROR&quot;: 9,
</a><a href="#h74-0-70" id="h74-0-70" class="i">+	&quot;TOO_MANY_REDIRECTS&quot;:       10,
</a><a href="#h74-0-71" id="h74-0-71" class="i">+	&quot;MALFORMED_REPLY&quot;:          11,
</a><a href="#h74-0-72" id="h74-0-72" class="i">+	&quot;CONNECTION_ERROR&quot;:         12,
</a><a href="#h74-0-73" id="h74-0-73" class="i">+}
</a><a href="#h74-0-74" id="h74-0-74" class="i">+
</a><a href="#h74-0-75" id="h74-0-75" class="i">+func (x URLFetchServiceError_ErrorCode) Enum() *URLFetchServiceError_ErrorCode {
</a><a href="#h74-0-76" id="h74-0-76" class="i">+	p := new(URLFetchServiceError_ErrorCode)
</a><a href="#h74-0-77" id="h74-0-77" class="i">+	*p = x
</a><a href="#h74-0-78" id="h74-0-78" class="i">+	return p
</a><a href="#h74-0-79" id="h74-0-79" class="i">+}
</a><a href="#h74-0-80" id="h74-0-80" class="i">+func (x URLFetchServiceError_ErrorCode) String() string {
</a><a href="#h74-0-81" id="h74-0-81" class="i">+	return proto.EnumName(URLFetchServiceError_ErrorCode_name, int32(x))
</a><a href="#h74-0-82" id="h74-0-82" class="i">+}
</a><a href="#h74-0-83" id="h74-0-83" class="i">+func (x *URLFetchServiceError_ErrorCode) UnmarshalJSON(data []byte) error {
</a><a href="#h74-0-84" id="h74-0-84" class="i">+	value, err := proto.UnmarshalJSONEnum(URLFetchServiceError_ErrorCode_value, data, &quot;URLFetchServiceError_ErrorCode&quot;)
</a><a href="#h74-0-85" id="h74-0-85" class="i">+	if err != nil {
</a><a href="#h74-0-86" id="h74-0-86" class="i">+		return err
</a><a href="#h74-0-87" id="h74-0-87" class="i">+	}
</a><a href="#h74-0-88" id="h74-0-88" class="i">+	*x = URLFetchServiceError_ErrorCode(value)
</a><a href="#h74-0-89" id="h74-0-89" class="i">+	return nil
</a><a href="#h74-0-90" id="h74-0-90" class="i">+}
</a><a href="#h74-0-91" id="h74-0-91" class="i">+
</a><a href="#h74-0-92" id="h74-0-92" class="i">+type URLFetchRequest_RequestMethod int32
</a><a href="#h74-0-93" id="h74-0-93" class="i">+
</a><a href="#h74-0-94" id="h74-0-94" class="i">+const (
</a><a href="#h74-0-95" id="h74-0-95" class="i">+	URLFetchRequest_GET    URLFetchRequest_RequestMethod = 1
</a><a href="#h74-0-96" id="h74-0-96" class="i">+	URLFetchRequest_POST   URLFetchRequest_RequestMethod = 2
</a><a href="#h74-0-97" id="h74-0-97" class="i">+	URLFetchRequest_HEAD   URLFetchRequest_RequestMethod = 3
</a><a href="#h74-0-98" id="h74-0-98" class="i">+	URLFetchRequest_PUT    URLFetchRequest_RequestMethod = 4
</a><a href="#h74-0-99" id="h74-0-99" class="i">+	URLFetchRequest_DELETE URLFetchRequest_RequestMethod = 5
</a><a href="#h74-0-100" id="h74-0-100" class="i">+	URLFetchRequest_PATCH  URLFetchRequest_RequestMethod = 6
</a><a href="#h74-0-101" id="h74-0-101" class="i">+)
</a><a href="#h74-0-102" id="h74-0-102" class="i">+
</a><a href="#h74-0-103" id="h74-0-103" class="i">+var URLFetchRequest_RequestMethod_name = map[int32]string{
</a><a href="#h74-0-104" id="h74-0-104" class="i">+	1: &quot;GET&quot;,
</a><a href="#h74-0-105" id="h74-0-105" class="i">+	2: &quot;POST&quot;,
</a><a href="#h74-0-106" id="h74-0-106" class="i">+	3: &quot;HEAD&quot;,
</a><a href="#h74-0-107" id="h74-0-107" class="i">+	4: &quot;PUT&quot;,
</a><a href="#h74-0-108" id="h74-0-108" class="i">+	5: &quot;DELETE&quot;,
</a><a href="#h74-0-109" id="h74-0-109" class="i">+	6: &quot;PATCH&quot;,
</a><a href="#h74-0-110" id="h74-0-110" class="i">+}
</a><a href="#h74-0-111" id="h74-0-111" class="i">+var URLFetchRequest_RequestMethod_value = map[string]int32{
</a><a href="#h74-0-112" id="h74-0-112" class="i">+	&quot;GET&quot;:    1,
</a><a href="#h74-0-113" id="h74-0-113" class="i">+	&quot;POST&quot;:   2,
</a><a href="#h74-0-114" id="h74-0-114" class="i">+	&quot;HEAD&quot;:   3,
</a><a href="#h74-0-115" id="h74-0-115" class="i">+	&quot;PUT&quot;:    4,
</a><a href="#h74-0-116" id="h74-0-116" class="i">+	&quot;DELETE&quot;: 5,
</a><a href="#h74-0-117" id="h74-0-117" class="i">+	&quot;PATCH&quot;:  6,
</a><a href="#h74-0-118" id="h74-0-118" class="i">+}
</a><a href="#h74-0-119" id="h74-0-119" class="i">+
</a><a href="#h74-0-120" id="h74-0-120" class="i">+func (x URLFetchRequest_RequestMethod) Enum() *URLFetchRequest_RequestMethod {
</a><a href="#h74-0-121" id="h74-0-121" class="i">+	p := new(URLFetchRequest_RequestMethod)
</a><a href="#h74-0-122" id="h74-0-122" class="i">+	*p = x
</a><a href="#h74-0-123" id="h74-0-123" class="i">+	return p
</a><a href="#h74-0-124" id="h74-0-124" class="i">+}
</a><a href="#h74-0-125" id="h74-0-125" class="i">+func (x URLFetchRequest_RequestMethod) String() string {
</a><a href="#h74-0-126" id="h74-0-126" class="i">+	return proto.EnumName(URLFetchRequest_RequestMethod_name, int32(x))
</a><a href="#h74-0-127" id="h74-0-127" class="i">+}
</a><a href="#h74-0-128" id="h74-0-128" class="i">+func (x *URLFetchRequest_RequestMethod) UnmarshalJSON(data []byte) error {
</a><a href="#h74-0-129" id="h74-0-129" class="i">+	value, err := proto.UnmarshalJSONEnum(URLFetchRequest_RequestMethod_value, data, &quot;URLFetchRequest_RequestMethod&quot;)
</a><a href="#h74-0-130" id="h74-0-130" class="i">+	if err != nil {
</a><a href="#h74-0-131" id="h74-0-131" class="i">+		return err
</a><a href="#h74-0-132" id="h74-0-132" class="i">+	}
</a><a href="#h74-0-133" id="h74-0-133" class="i">+	*x = URLFetchRequest_RequestMethod(value)
</a><a href="#h74-0-134" id="h74-0-134" class="i">+	return nil
</a><a href="#h74-0-135" id="h74-0-135" class="i">+}
</a><a href="#h74-0-136" id="h74-0-136" class="i">+
</a><a href="#h74-0-137" id="h74-0-137" class="i">+type URLFetchServiceError struct {
</a><a href="#h74-0-138" id="h74-0-138" class="i">+	XXX_unrecognized []byte `json:&quot;-&quot;`
</a><a href="#h74-0-139" id="h74-0-139" class="i">+}
</a><a href="#h74-0-140" id="h74-0-140" class="i">+
</a><a href="#h74-0-141" id="h74-0-141" class="i">+func (m *URLFetchServiceError) Reset()         { *m = URLFetchServiceError{} }
</a><a href="#h74-0-142" id="h74-0-142" class="i">+func (m *URLFetchServiceError) String() string { return proto.CompactTextString(m) }
</a><a href="#h74-0-143" id="h74-0-143" class="i">+func (*URLFetchServiceError) ProtoMessage()    {}
</a><a href="#h74-0-144" id="h74-0-144" class="i">+
</a><a href="#h74-0-145" id="h74-0-145" class="i">+type URLFetchRequest struct {
</a><a href="#h74-0-146" id="h74-0-146" class="i">+	Method                        *URLFetchRequest_RequestMethod `protobuf:&quot;varint,1,req,name=Method,enum=appengine.URLFetchRequest_RequestMethod&quot; json:&quot;Method,omitempty&quot;`
</a><a href="#h74-0-147" id="h74-0-147" class="i">+	Url                           *string                        `protobuf:&quot;bytes,2,req,name=Url&quot; json:&quot;Url,omitempty&quot;`
</a><a href="#h74-0-148" id="h74-0-148" class="i">+	Header                        []*URLFetchRequest_Header      `protobuf:&quot;group,3,rep,name=Header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h74-0-149" id="h74-0-149" class="i">+	Payload                       []byte                         `protobuf:&quot;bytes,6,opt,name=Payload&quot; json:&quot;Payload,omitempty&quot;`
</a><a href="#h74-0-150" id="h74-0-150" class="i">+	FollowRedirects               *bool                          `protobuf:&quot;varint,7,opt,name=FollowRedirects,def=1&quot; json:&quot;FollowRedirects,omitempty&quot;`
</a><a href="#h74-0-151" id="h74-0-151" class="i">+	Deadline                      *float64                       `protobuf:&quot;fixed64,8,opt,name=Deadline&quot; json:&quot;Deadline,omitempty&quot;`
</a><a href="#h74-0-152" id="h74-0-152" class="i">+	MustValidateServerCertificate *bool                          `protobuf:&quot;varint,9,opt,name=MustValidateServerCertificate,def=1&quot; json:&quot;MustValidateServerCertificate,omitempty&quot;`
</a><a href="#h74-0-153" id="h74-0-153" class="i">+	XXX_unrecognized              []byte                         `json:&quot;-&quot;`
</a><a href="#h74-0-154" id="h74-0-154" class="i">+}
</a><a href="#h74-0-155" id="h74-0-155" class="i">+
</a><a href="#h74-0-156" id="h74-0-156" class="i">+func (m *URLFetchRequest) Reset()         { *m = URLFetchRequest{} }
</a><a href="#h74-0-157" id="h74-0-157" class="i">+func (m *URLFetchRequest) String() string { return proto.CompactTextString(m) }
</a><a href="#h74-0-158" id="h74-0-158" class="i">+func (*URLFetchRequest) ProtoMessage()    {}
</a><a href="#h74-0-159" id="h74-0-159" class="i">+
</a><a href="#h74-0-160" id="h74-0-160" class="i">+const Default_URLFetchRequest_FollowRedirects bool = true
</a><a href="#h74-0-161" id="h74-0-161" class="i">+const Default_URLFetchRequest_MustValidateServerCertificate bool = true
</a><a href="#h74-0-162" id="h74-0-162" class="i">+
</a><a href="#h74-0-163" id="h74-0-163" class="i">+func (m *URLFetchRequest) GetMethod() URLFetchRequest_RequestMethod {
</a><a href="#h74-0-164" id="h74-0-164" class="i">+	if m != nil &amp;&amp; m.Method != nil {
</a><a href="#h74-0-165" id="h74-0-165" class="i">+		return *m.Method
</a><a href="#h74-0-166" id="h74-0-166" class="i">+	}
</a><a href="#h74-0-167" id="h74-0-167" class="i">+	return URLFetchRequest_GET
</a><a href="#h74-0-168" id="h74-0-168" class="i">+}
</a><a href="#h74-0-169" id="h74-0-169" class="i">+
</a><a href="#h74-0-170" id="h74-0-170" class="i">+func (m *URLFetchRequest) GetUrl() string {
</a><a href="#h74-0-171" id="h74-0-171" class="i">+	if m != nil &amp;&amp; m.Url != nil {
</a><a href="#h74-0-172" id="h74-0-172" class="i">+		return *m.Url
</a><a href="#h74-0-173" id="h74-0-173" class="i">+	}
</a><a href="#h74-0-174" id="h74-0-174" class="i">+	return &quot;&quot;
</a><a href="#h74-0-175" id="h74-0-175" class="i">+}
</a><a href="#h74-0-176" id="h74-0-176" class="i">+
</a><a href="#h74-0-177" id="h74-0-177" class="i">+func (m *URLFetchRequest) GetHeader() []*URLFetchRequest_Header {
</a><a href="#h74-0-178" id="h74-0-178" class="i">+	if m != nil {
</a><a href="#h74-0-179" id="h74-0-179" class="i">+		return m.Header
</a><a href="#h74-0-180" id="h74-0-180" class="i">+	}
</a><a href="#h74-0-181" id="h74-0-181" class="i">+	return nil
</a><a href="#h74-0-182" id="h74-0-182" class="i">+}
</a><a href="#h74-0-183" id="h74-0-183" class="i">+
</a><a href="#h74-0-184" id="h74-0-184" class="i">+func (m *URLFetchRequest) GetPayload() []byte {
</a><a href="#h74-0-185" id="h74-0-185" class="i">+	if m != nil {
</a><a href="#h74-0-186" id="h74-0-186" class="i">+		return m.Payload
</a><a href="#h74-0-187" id="h74-0-187" class="i">+	}
</a><a href="#h74-0-188" id="h74-0-188" class="i">+	return nil
</a><a href="#h74-0-189" id="h74-0-189" class="i">+}
</a><a href="#h74-0-190" id="h74-0-190" class="i">+
</a><a href="#h74-0-191" id="h74-0-191" class="i">+func (m *URLFetchRequest) GetFollowRedirects() bool {
</a><a href="#h74-0-192" id="h74-0-192" class="i">+	if m != nil &amp;&amp; m.FollowRedirects != nil {
</a><a href="#h74-0-193" id="h74-0-193" class="i">+		return *m.FollowRedirects
</a><a href="#h74-0-194" id="h74-0-194" class="i">+	}
</a><a href="#h74-0-195" id="h74-0-195" class="i">+	return Default_URLFetchRequest_FollowRedirects
</a><a href="#h74-0-196" id="h74-0-196" class="i">+}
</a><a href="#h74-0-197" id="h74-0-197" class="i">+
</a><a href="#h74-0-198" id="h74-0-198" class="i">+func (m *URLFetchRequest) GetDeadline() float64 {
</a><a href="#h74-0-199" id="h74-0-199" class="i">+	if m != nil &amp;&amp; m.Deadline != nil {
</a><a href="#h74-0-200" id="h74-0-200" class="i">+		return *m.Deadline
</a><a href="#h74-0-201" id="h74-0-201" class="i">+	}
</a><a href="#h74-0-202" id="h74-0-202" class="i">+	return 0
</a><a href="#h74-0-203" id="h74-0-203" class="i">+}
</a><a href="#h74-0-204" id="h74-0-204" class="i">+
</a><a href="#h74-0-205" id="h74-0-205" class="i">+func (m *URLFetchRequest) GetMustValidateServerCertificate() bool {
</a><a href="#h74-0-206" id="h74-0-206" class="i">+	if m != nil &amp;&amp; m.MustValidateServerCertificate != nil {
</a><a href="#h74-0-207" id="h74-0-207" class="i">+		return *m.MustValidateServerCertificate
</a><a href="#h74-0-208" id="h74-0-208" class="i">+	}
</a><a href="#h74-0-209" id="h74-0-209" class="i">+	return Default_URLFetchRequest_MustValidateServerCertificate
</a><a href="#h74-0-210" id="h74-0-210" class="i">+}
</a><a href="#h74-0-211" id="h74-0-211" class="i">+
</a><a href="#h74-0-212" id="h74-0-212" class="i">+type URLFetchRequest_Header struct {
</a><a href="#h74-0-213" id="h74-0-213" class="i">+	Key              *string `protobuf:&quot;bytes,4,req,name=Key&quot; json:&quot;Key,omitempty&quot;`
</a><a href="#h74-0-214" id="h74-0-214" class="i">+	Value            *string `protobuf:&quot;bytes,5,req,name=Value&quot; json:&quot;Value,omitempty&quot;`
</a><a href="#h74-0-215" id="h74-0-215" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h74-0-216" id="h74-0-216" class="i">+}
</a><a href="#h74-0-217" id="h74-0-217" class="i">+
</a><a href="#h74-0-218" id="h74-0-218" class="i">+func (m *URLFetchRequest_Header) Reset()         { *m = URLFetchRequest_Header{} }
</a><a href="#h74-0-219" id="h74-0-219" class="i">+func (m *URLFetchRequest_Header) String() string { return proto.CompactTextString(m) }
</a><a href="#h74-0-220" id="h74-0-220" class="i">+func (*URLFetchRequest_Header) ProtoMessage()    {}
</a><a href="#h74-0-221" id="h74-0-221" class="i">+
</a><a href="#h74-0-222" id="h74-0-222" class="i">+func (m *URLFetchRequest_Header) GetKey() string {
</a><a href="#h74-0-223" id="h74-0-223" class="i">+	if m != nil &amp;&amp; m.Key != nil {
</a><a href="#h74-0-224" id="h74-0-224" class="i">+		return *m.Key
</a><a href="#h74-0-225" id="h74-0-225" class="i">+	}
</a><a href="#h74-0-226" id="h74-0-226" class="i">+	return &quot;&quot;
</a><a href="#h74-0-227" id="h74-0-227" class="i">+}
</a><a href="#h74-0-228" id="h74-0-228" class="i">+
</a><a href="#h74-0-229" id="h74-0-229" class="i">+func (m *URLFetchRequest_Header) GetValue() string {
</a><a href="#h74-0-230" id="h74-0-230" class="i">+	if m != nil &amp;&amp; m.Value != nil {
</a><a href="#h74-0-231" id="h74-0-231" class="i">+		return *m.Value
</a><a href="#h74-0-232" id="h74-0-232" class="i">+	}
</a><a href="#h74-0-233" id="h74-0-233" class="i">+	return &quot;&quot;
</a><a href="#h74-0-234" id="h74-0-234" class="i">+}
</a><a href="#h74-0-235" id="h74-0-235" class="i">+
</a><a href="#h74-0-236" id="h74-0-236" class="i">+type URLFetchResponse struct {
</a><a href="#h74-0-237" id="h74-0-237" class="i">+	Content               []byte                     `protobuf:&quot;bytes,1,opt,name=Content&quot; json:&quot;Content,omitempty&quot;`
</a><a href="#h74-0-238" id="h74-0-238" class="i">+	StatusCode            *int32                     `protobuf:&quot;varint,2,req,name=StatusCode&quot; json:&quot;StatusCode,omitempty&quot;`
</a><a href="#h74-0-239" id="h74-0-239" class="i">+	Header                []*URLFetchResponse_Header `protobuf:&quot;group,3,rep,name=Header&quot; json:&quot;header,omitempty&quot;`
</a><a href="#h74-0-240" id="h74-0-240" class="i">+	ContentWasTruncated   *bool                      `protobuf:&quot;varint,6,opt,name=ContentWasTruncated,def=0&quot; json:&quot;ContentWasTruncated,omitempty&quot;`
</a><a href="#h74-0-241" id="h74-0-241" class="i">+	ExternalBytesSent     *int64                     `protobuf:&quot;varint,7,opt,name=ExternalBytesSent&quot; json:&quot;ExternalBytesSent,omitempty&quot;`
</a><a href="#h74-0-242" id="h74-0-242" class="i">+	ExternalBytesReceived *int64                     `protobuf:&quot;varint,8,opt,name=ExternalBytesReceived&quot; json:&quot;ExternalBytesReceived,omitempty&quot;`
</a><a href="#h74-0-243" id="h74-0-243" class="i">+	FinalUrl              *string                    `protobuf:&quot;bytes,9,opt,name=FinalUrl&quot; json:&quot;FinalUrl,omitempty&quot;`
</a><a href="#h74-0-244" id="h74-0-244" class="i">+	ApiCpuMilliseconds    *int64                     `protobuf:&quot;varint,10,opt,name=ApiCpuMilliseconds,def=0&quot; json:&quot;ApiCpuMilliseconds,omitempty&quot;`
</a><a href="#h74-0-245" id="h74-0-245" class="i">+	ApiBytesSent          *int64                     `protobuf:&quot;varint,11,opt,name=ApiBytesSent,def=0&quot; json:&quot;ApiBytesSent,omitempty&quot;`
</a><a href="#h74-0-246" id="h74-0-246" class="i">+	ApiBytesReceived      *int64                     `protobuf:&quot;varint,12,opt,name=ApiBytesReceived,def=0&quot; json:&quot;ApiBytesReceived,omitempty&quot;`
</a><a href="#h74-0-247" id="h74-0-247" class="i">+	XXX_unrecognized      []byte                     `json:&quot;-&quot;`
</a><a href="#h74-0-248" id="h74-0-248" class="i">+}
</a><a href="#h74-0-249" id="h74-0-249" class="i">+
</a><a href="#h74-0-250" id="h74-0-250" class="i">+func (m *URLFetchResponse) Reset()         { *m = URLFetchResponse{} }
</a><a href="#h74-0-251" id="h74-0-251" class="i">+func (m *URLFetchResponse) String() string { return proto.CompactTextString(m) }
</a><a href="#h74-0-252" id="h74-0-252" class="i">+func (*URLFetchResponse) ProtoMessage()    {}
</a><a href="#h74-0-253" id="h74-0-253" class="i">+
</a><a href="#h74-0-254" id="h74-0-254" class="i">+const Default_URLFetchResponse_ContentWasTruncated bool = false
</a><a href="#h74-0-255" id="h74-0-255" class="i">+const Default_URLFetchResponse_ApiCpuMilliseconds int64 = 0
</a><a href="#h74-0-256" id="h74-0-256" class="i">+const Default_URLFetchResponse_ApiBytesSent int64 = 0
</a><a href="#h74-0-257" id="h74-0-257" class="i">+const Default_URLFetchResponse_ApiBytesReceived int64 = 0
</a><a href="#h74-0-258" id="h74-0-258" class="i">+
</a><a href="#h74-0-259" id="h74-0-259" class="i">+func (m *URLFetchResponse) GetContent() []byte {
</a><a href="#h74-0-260" id="h74-0-260" class="i">+	if m != nil {
</a><a href="#h74-0-261" id="h74-0-261" class="i">+		return m.Content
</a><a href="#h74-0-262" id="h74-0-262" class="i">+	}
</a><a href="#h74-0-263" id="h74-0-263" class="i">+	return nil
</a><a href="#h74-0-264" id="h74-0-264" class="i">+}
</a><a href="#h74-0-265" id="h74-0-265" class="i">+
</a><a href="#h74-0-266" id="h74-0-266" class="i">+func (m *URLFetchResponse) GetStatusCode() int32 {
</a><a href="#h74-0-267" id="h74-0-267" class="i">+	if m != nil &amp;&amp; m.StatusCode != nil {
</a><a href="#h74-0-268" id="h74-0-268" class="i">+		return *m.StatusCode
</a><a href="#h74-0-269" id="h74-0-269" class="i">+	}
</a><a href="#h74-0-270" id="h74-0-270" class="i">+	return 0
</a><a href="#h74-0-271" id="h74-0-271" class="i">+}
</a><a href="#h74-0-272" id="h74-0-272" class="i">+
</a><a href="#h74-0-273" id="h74-0-273" class="i">+func (m *URLFetchResponse) GetHeader() []*URLFetchResponse_Header {
</a><a href="#h74-0-274" id="h74-0-274" class="i">+	if m != nil {
</a><a href="#h74-0-275" id="h74-0-275" class="i">+		return m.Header
</a><a href="#h74-0-276" id="h74-0-276" class="i">+	}
</a><a href="#h74-0-277" id="h74-0-277" class="i">+	return nil
</a><a href="#h74-0-278" id="h74-0-278" class="i">+}
</a><a href="#h74-0-279" id="h74-0-279" class="i">+
</a><a href="#h74-0-280" id="h74-0-280" class="i">+func (m *URLFetchResponse) GetContentWasTruncated() bool {
</a><a href="#h74-0-281" id="h74-0-281" class="i">+	if m != nil &amp;&amp; m.ContentWasTruncated != nil {
</a><a href="#h74-0-282" id="h74-0-282" class="i">+		return *m.ContentWasTruncated
</a><a href="#h74-0-283" id="h74-0-283" class="i">+	}
</a><a href="#h74-0-284" id="h74-0-284" class="i">+	return Default_URLFetchResponse_ContentWasTruncated
</a><a href="#h74-0-285" id="h74-0-285" class="i">+}
</a><a href="#h74-0-286" id="h74-0-286" class="i">+
</a><a href="#h74-0-287" id="h74-0-287" class="i">+func (m *URLFetchResponse) GetExternalBytesSent() int64 {
</a><a href="#h74-0-288" id="h74-0-288" class="i">+	if m != nil &amp;&amp; m.ExternalBytesSent != nil {
</a><a href="#h74-0-289" id="h74-0-289" class="i">+		return *m.ExternalBytesSent
</a><a href="#h74-0-290" id="h74-0-290" class="i">+	}
</a><a href="#h74-0-291" id="h74-0-291" class="i">+	return 0
</a><a href="#h74-0-292" id="h74-0-292" class="i">+}
</a><a href="#h74-0-293" id="h74-0-293" class="i">+
</a><a href="#h74-0-294" id="h74-0-294" class="i">+func (m *URLFetchResponse) GetExternalBytesReceived() int64 {
</a><a href="#h74-0-295" id="h74-0-295" class="i">+	if m != nil &amp;&amp; m.ExternalBytesReceived != nil {
</a><a href="#h74-0-296" id="h74-0-296" class="i">+		return *m.ExternalBytesReceived
</a><a href="#h74-0-297" id="h74-0-297" class="i">+	}
</a><a href="#h74-0-298" id="h74-0-298" class="i">+	return 0
</a><a href="#h74-0-299" id="h74-0-299" class="i">+}
</a><a href="#h74-0-300" id="h74-0-300" class="i">+
</a><a href="#h74-0-301" id="h74-0-301" class="i">+func (m *URLFetchResponse) GetFinalUrl() string {
</a><a href="#h74-0-302" id="h74-0-302" class="i">+	if m != nil &amp;&amp; m.FinalUrl != nil {
</a><a href="#h74-0-303" id="h74-0-303" class="i">+		return *m.FinalUrl
</a><a href="#h74-0-304" id="h74-0-304" class="i">+	}
</a><a href="#h74-0-305" id="h74-0-305" class="i">+	return &quot;&quot;
</a><a href="#h74-0-306" id="h74-0-306" class="i">+}
</a><a href="#h74-0-307" id="h74-0-307" class="i">+
</a><a href="#h74-0-308" id="h74-0-308" class="i">+func (m *URLFetchResponse) GetApiCpuMilliseconds() int64 {
</a><a href="#h74-0-309" id="h74-0-309" class="i">+	if m != nil &amp;&amp; m.ApiCpuMilliseconds != nil {
</a><a href="#h74-0-310" id="h74-0-310" class="i">+		return *m.ApiCpuMilliseconds
</a><a href="#h74-0-311" id="h74-0-311" class="i">+	}
</a><a href="#h74-0-312" id="h74-0-312" class="i">+	return Default_URLFetchResponse_ApiCpuMilliseconds
</a><a href="#h74-0-313" id="h74-0-313" class="i">+}
</a><a href="#h74-0-314" id="h74-0-314" class="i">+
</a><a href="#h74-0-315" id="h74-0-315" class="i">+func (m *URLFetchResponse) GetApiBytesSent() int64 {
</a><a href="#h74-0-316" id="h74-0-316" class="i">+	if m != nil &amp;&amp; m.ApiBytesSent != nil {
</a><a href="#h74-0-317" id="h74-0-317" class="i">+		return *m.ApiBytesSent
</a><a href="#h74-0-318" id="h74-0-318" class="i">+	}
</a><a href="#h74-0-319" id="h74-0-319" class="i">+	return Default_URLFetchResponse_ApiBytesSent
</a><a href="#h74-0-320" id="h74-0-320" class="i">+}
</a><a href="#h74-0-321" id="h74-0-321" class="i">+
</a><a href="#h74-0-322" id="h74-0-322" class="i">+func (m *URLFetchResponse) GetApiBytesReceived() int64 {
</a><a href="#h74-0-323" id="h74-0-323" class="i">+	if m != nil &amp;&amp; m.ApiBytesReceived != nil {
</a><a href="#h74-0-324" id="h74-0-324" class="i">+		return *m.ApiBytesReceived
</a><a href="#h74-0-325" id="h74-0-325" class="i">+	}
</a><a href="#h74-0-326" id="h74-0-326" class="i">+	return Default_URLFetchResponse_ApiBytesReceived
</a><a href="#h74-0-327" id="h74-0-327" class="i">+}
</a><a href="#h74-0-328" id="h74-0-328" class="i">+
</a><a href="#h74-0-329" id="h74-0-329" class="i">+type URLFetchResponse_Header struct {
</a><a href="#h74-0-330" id="h74-0-330" class="i">+	Key              *string `protobuf:&quot;bytes,4,req,name=Key&quot; json:&quot;Key,omitempty&quot;`
</a><a href="#h74-0-331" id="h74-0-331" class="i">+	Value            *string `protobuf:&quot;bytes,5,req,name=Value&quot; json:&quot;Value,omitempty&quot;`
</a><a href="#h74-0-332" id="h74-0-332" class="i">+	XXX_unrecognized []byte  `json:&quot;-&quot;`
</a><a href="#h74-0-333" id="h74-0-333" class="i">+}
</a><a href="#h74-0-334" id="h74-0-334" class="i">+
</a><a href="#h74-0-335" id="h74-0-335" class="i">+func (m *URLFetchResponse_Header) Reset()         { *m = URLFetchResponse_Header{} }
</a><a href="#h74-0-336" id="h74-0-336" class="i">+func (m *URLFetchResponse_Header) String() string { return proto.CompactTextString(m) }
</a><a href="#h74-0-337" id="h74-0-337" class="i">+func (*URLFetchResponse_Header) ProtoMessage()    {}
</a><a href="#h74-0-338" id="h74-0-338" class="i">+
</a><a href="#h74-0-339" id="h74-0-339" class="i">+func (m *URLFetchResponse_Header) GetKey() string {
</a><a href="#h74-0-340" id="h74-0-340" class="i">+	if m != nil &amp;&amp; m.Key != nil {
</a><a href="#h74-0-341" id="h74-0-341" class="i">+		return *m.Key
</a><a href="#h74-0-342" id="h74-0-342" class="i">+	}
</a><a href="#h74-0-343" id="h74-0-343" class="i">+	return &quot;&quot;
</a><a href="#h74-0-344" id="h74-0-344" class="i">+}
</a><a href="#h74-0-345" id="h74-0-345" class="i">+
</a><a href="#h74-0-346" id="h74-0-346" class="i">+func (m *URLFetchResponse_Header) GetValue() string {
</a><a href="#h74-0-347" id="h74-0-347" class="i">+	if m != nil &amp;&amp; m.Value != nil {
</a><a href="#h74-0-348" id="h74-0-348" class="i">+		return *m.Value
</a><a href="#h74-0-349" id="h74-0-349" class="i">+	}
</a><a href="#h74-0-350" id="h74-0-350" class="i">+	return &quot;&quot;
</a><a href="#h74-0-351" id="h74-0-351" class="i">+}
</a><a href="#h74-0-352" id="h74-0-352" class="i">+
</a><a href="#h74-0-353" id="h74-0-353" class="i">+func init() {
</a><a href="#h74-0-354" id="h74-0-354" class="i">+}
</a><b>diff --git a/<a id="h75" href="../file/vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.proto">vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.proto</a> b/<a href="../file/vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.proto">vendor/google.golang.org/appengine/internal/urlfetch/urlfetch_service.proto</a></b>
<a href="#h75-0" id="h75-0" class="h">@@ -0,0 +1,64 @@
</a><a href="#h75-0-0" id="h75-0-0" class="i">+syntax = &quot;proto2&quot;;
</a><a href="#h75-0-1" id="h75-0-1" class="i">+option go_package = &quot;urlfetch&quot;;
</a><a href="#h75-0-2" id="h75-0-2" class="i">+
</a><a href="#h75-0-3" id="h75-0-3" class="i">+package appengine;
</a><a href="#h75-0-4" id="h75-0-4" class="i">+
</a><a href="#h75-0-5" id="h75-0-5" class="i">+message URLFetchServiceError {
</a><a href="#h75-0-6" id="h75-0-6" class="i">+  enum ErrorCode {
</a><a href="#h75-0-7" id="h75-0-7" class="i">+    OK = 0;
</a><a href="#h75-0-8" id="h75-0-8" class="i">+    INVALID_URL = 1;
</a><a href="#h75-0-9" id="h75-0-9" class="i">+    FETCH_ERROR = 2;
</a><a href="#h75-0-10" id="h75-0-10" class="i">+    UNSPECIFIED_ERROR = 3;
</a><a href="#h75-0-11" id="h75-0-11" class="i">+    RESPONSE_TOO_LARGE = 4;
</a><a href="#h75-0-12" id="h75-0-12" class="i">+    DEADLINE_EXCEEDED = 5;
</a><a href="#h75-0-13" id="h75-0-13" class="i">+    SSL_CERTIFICATE_ERROR = 6;
</a><a href="#h75-0-14" id="h75-0-14" class="i">+    DNS_ERROR = 7;
</a><a href="#h75-0-15" id="h75-0-15" class="i">+    CLOSED = 8;
</a><a href="#h75-0-16" id="h75-0-16" class="i">+    INTERNAL_TRANSIENT_ERROR = 9;
</a><a href="#h75-0-17" id="h75-0-17" class="i">+    TOO_MANY_REDIRECTS = 10;
</a><a href="#h75-0-18" id="h75-0-18" class="i">+    MALFORMED_REPLY = 11;
</a><a href="#h75-0-19" id="h75-0-19" class="i">+    CONNECTION_ERROR = 12;
</a><a href="#h75-0-20" id="h75-0-20" class="i">+  }
</a><a href="#h75-0-21" id="h75-0-21" class="i">+}
</a><a href="#h75-0-22" id="h75-0-22" class="i">+
</a><a href="#h75-0-23" id="h75-0-23" class="i">+message URLFetchRequest {
</a><a href="#h75-0-24" id="h75-0-24" class="i">+  enum RequestMethod {
</a><a href="#h75-0-25" id="h75-0-25" class="i">+    GET = 1;
</a><a href="#h75-0-26" id="h75-0-26" class="i">+    POST = 2;
</a><a href="#h75-0-27" id="h75-0-27" class="i">+    HEAD = 3;
</a><a href="#h75-0-28" id="h75-0-28" class="i">+    PUT = 4;
</a><a href="#h75-0-29" id="h75-0-29" class="i">+    DELETE = 5;
</a><a href="#h75-0-30" id="h75-0-30" class="i">+    PATCH = 6;
</a><a href="#h75-0-31" id="h75-0-31" class="i">+  }
</a><a href="#h75-0-32" id="h75-0-32" class="i">+  required RequestMethod Method = 1;
</a><a href="#h75-0-33" id="h75-0-33" class="i">+  required string Url = 2;
</a><a href="#h75-0-34" id="h75-0-34" class="i">+  repeated group Header = 3 {
</a><a href="#h75-0-35" id="h75-0-35" class="i">+    required string Key = 4;
</a><a href="#h75-0-36" id="h75-0-36" class="i">+    required string Value = 5;
</a><a href="#h75-0-37" id="h75-0-37" class="i">+  }
</a><a href="#h75-0-38" id="h75-0-38" class="i">+  optional bytes Payload = 6 [ctype=CORD];
</a><a href="#h75-0-39" id="h75-0-39" class="i">+
</a><a href="#h75-0-40" id="h75-0-40" class="i">+  optional bool FollowRedirects = 7 [default=true];
</a><a href="#h75-0-41" id="h75-0-41" class="i">+
</a><a href="#h75-0-42" id="h75-0-42" class="i">+  optional double Deadline = 8;
</a><a href="#h75-0-43" id="h75-0-43" class="i">+
</a><a href="#h75-0-44" id="h75-0-44" class="i">+  optional bool MustValidateServerCertificate = 9 [default=true];
</a><a href="#h75-0-45" id="h75-0-45" class="i">+}
</a><a href="#h75-0-46" id="h75-0-46" class="i">+
</a><a href="#h75-0-47" id="h75-0-47" class="i">+message URLFetchResponse {
</a><a href="#h75-0-48" id="h75-0-48" class="i">+  optional bytes Content = 1;
</a><a href="#h75-0-49" id="h75-0-49" class="i">+  required int32 StatusCode = 2;
</a><a href="#h75-0-50" id="h75-0-50" class="i">+  repeated group Header = 3 {
</a><a href="#h75-0-51" id="h75-0-51" class="i">+    required string Key = 4;
</a><a href="#h75-0-52" id="h75-0-52" class="i">+    required string Value = 5;
</a><a href="#h75-0-53" id="h75-0-53" class="i">+  }
</a><a href="#h75-0-54" id="h75-0-54" class="i">+  optional bool ContentWasTruncated = 6 [default=false];
</a><a href="#h75-0-55" id="h75-0-55" class="i">+  optional int64 ExternalBytesSent = 7;
</a><a href="#h75-0-56" id="h75-0-56" class="i">+  optional int64 ExternalBytesReceived = 8;
</a><a href="#h75-0-57" id="h75-0-57" class="i">+
</a><a href="#h75-0-58" id="h75-0-58" class="i">+  optional string FinalUrl = 9;
</a><a href="#h75-0-59" id="h75-0-59" class="i">+
</a><a href="#h75-0-60" id="h75-0-60" class="i">+  optional int64 ApiCpuMilliseconds = 10 [default=0];
</a><a href="#h75-0-61" id="h75-0-61" class="i">+  optional int64 ApiBytesSent = 11 [default=0];
</a><a href="#h75-0-62" id="h75-0-62" class="i">+  optional int64 ApiBytesReceived = 12 [default=0];
</a><a href="#h75-0-63" id="h75-0-63" class="i">+}
</a><b>diff --git a/<a id="h76" href="../file/vendor/google.golang.org/appengine/urlfetch/BUILD">vendor/google.golang.org/appengine/urlfetch/BUILD</a> b/<a href="../file/vendor/google.golang.org/appengine/urlfetch/BUILD">vendor/google.golang.org/appengine/urlfetch/BUILD</a></b>
<a href="#h76-0" id="h76-0" class="h">@@ -0,0 +1,22 @@
</a><a href="#h76-0-0" id="h76-0-0" class="i">+
</a><a href="#h76-0-1" id="h76-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h76-0-2" id="h76-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h76-0-3" id="h76-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h76-0-4" id="h76-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h76-0-5" id="h76-0-5" class="i">+)
</a><a href="#h76-0-6" id="h76-0-6" class="i">+
</a><a href="#h76-0-7" id="h76-0-7" class="i">+go_library(
</a><a href="#h76-0-8" id="h76-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h76-0-9" id="h76-0-9" class="i">+  srcs = [
</a><a href="#h76-0-10" id="h76-0-10" class="i">+    &quot;urlfetch.go&quot;,
</a><a href="#h76-0-11" id="h76-0-11" class="i">+  ],
</a><a href="#h76-0-12" id="h76-0-12" class="i">+  deps = [
</a><a href="#h76-0-13" id="h76-0-13" class="i">+    &quot;//vendor/github.com/golang/protobuf/proto:go_default_library&quot;,
</a><a href="#h76-0-14" id="h76-0-14" class="i">+    &quot;//vendor/golang.org/x/net/context:go_default_library&quot;,
</a><a href="#h76-0-15" id="h76-0-15" class="i">+    &quot;//vendor/google.golang.org/appengine/internal/urlfetch:go_default_library&quot;,
</a><a href="#h76-0-16" id="h76-0-16" class="i">+    &quot;//vendor/google.golang.org/appengine/internal:go_default_library&quot;,
</a><a href="#h76-0-17" id="h76-0-17" class="i">+  ],
</a><a href="#h76-0-18" id="h76-0-18" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h76-0-19" id="h76-0-19" class="i">+)
</a><a href="#h76-0-20" id="h76-0-20" class="i">+
</a><a href="#h76-0-21" id="h76-0-21" class="i">+
</a><b>diff --git a/<a id="h77" href="../file/vendor/google.golang.org/appengine/urlfetch/urlfetch.go">vendor/google.golang.org/appengine/urlfetch/urlfetch.go</a> b/<a href="../file/vendor/google.golang.org/appengine/urlfetch/urlfetch.go">vendor/google.golang.org/appengine/urlfetch/urlfetch.go</a></b>
<a href="#h77-0" id="h77-0" class="h">@@ -0,0 +1,210 @@
</a><a href="#h77-0-0" id="h77-0-0" class="i">+// Copyright 2011 Google Inc. All rights reserved.
</a><a href="#h77-0-1" id="h77-0-1" class="i">+// Use of this source code is governed by the Apache 2.0
</a><a href="#h77-0-2" id="h77-0-2" class="i">+// license that can be found in the LICENSE file.
</a><a href="#h77-0-3" id="h77-0-3" class="i">+
</a><a href="#h77-0-4" id="h77-0-4" class="i">+// Package urlfetch provides an http.RoundTripper implementation
</a><a href="#h77-0-5" id="h77-0-5" class="i">+// for fetching URLs via App Engine&#39;s urlfetch service.
</a><a href="#h77-0-6" id="h77-0-6" class="i">+package urlfetch // import &quot;google.golang.org/appengine/urlfetch&quot;
</a><a href="#h77-0-7" id="h77-0-7" class="i">+
</a><a href="#h77-0-8" id="h77-0-8" class="i">+import (
</a><a href="#h77-0-9" id="h77-0-9" class="i">+	&quot;errors&quot;
</a><a href="#h77-0-10" id="h77-0-10" class="i">+	&quot;fmt&quot;
</a><a href="#h77-0-11" id="h77-0-11" class="i">+	&quot;io&quot;
</a><a href="#h77-0-12" id="h77-0-12" class="i">+	&quot;io/ioutil&quot;
</a><a href="#h77-0-13" id="h77-0-13" class="i">+	&quot;net/http&quot;
</a><a href="#h77-0-14" id="h77-0-14" class="i">+	&quot;net/url&quot;
</a><a href="#h77-0-15" id="h77-0-15" class="i">+	&quot;strconv&quot;
</a><a href="#h77-0-16" id="h77-0-16" class="i">+	&quot;strings&quot;
</a><a href="#h77-0-17" id="h77-0-17" class="i">+	&quot;time&quot;
</a><a href="#h77-0-18" id="h77-0-18" class="i">+
</a><a href="#h77-0-19" id="h77-0-19" class="i">+	&quot;github.com/golang/protobuf/proto&quot;
</a><a href="#h77-0-20" id="h77-0-20" class="i">+	&quot;golang.org/x/net/context&quot;
</a><a href="#h77-0-21" id="h77-0-21" class="i">+
</a><a href="#h77-0-22" id="h77-0-22" class="i">+	&quot;google.golang.org/appengine/internal&quot;
</a><a href="#h77-0-23" id="h77-0-23" class="i">+	pb &quot;google.golang.org/appengine/internal/urlfetch&quot;
</a><a href="#h77-0-24" id="h77-0-24" class="i">+)
</a><a href="#h77-0-25" id="h77-0-25" class="i">+
</a><a href="#h77-0-26" id="h77-0-26" class="i">+// Transport is an implementation of http.RoundTripper for
</a><a href="#h77-0-27" id="h77-0-27" class="i">+// App Engine. Users should generally create an http.Client using
</a><a href="#h77-0-28" id="h77-0-28" class="i">+// this transport and use the Client rather than using this transport
</a><a href="#h77-0-29" id="h77-0-29" class="i">+// directly.
</a><a href="#h77-0-30" id="h77-0-30" class="i">+type Transport struct {
</a><a href="#h77-0-31" id="h77-0-31" class="i">+	Context context.Context
</a><a href="#h77-0-32" id="h77-0-32" class="i">+
</a><a href="#h77-0-33" id="h77-0-33" class="i">+	// Controls whether the application checks the validity of SSL certificates
</a><a href="#h77-0-34" id="h77-0-34" class="i">+	// over HTTPS connections. A value of false (the default) instructs the
</a><a href="#h77-0-35" id="h77-0-35" class="i">+	// application to send a request to the server only if the certificate is
</a><a href="#h77-0-36" id="h77-0-36" class="i">+	// valid and signed by a trusted certificate authority (CA), and also
</a><a href="#h77-0-37" id="h77-0-37" class="i">+	// includes a hostname that matches the certificate. A value of true
</a><a href="#h77-0-38" id="h77-0-38" class="i">+	// instructs the application to perform no certificate validation.
</a><a href="#h77-0-39" id="h77-0-39" class="i">+	AllowInvalidServerCertificate bool
</a><a href="#h77-0-40" id="h77-0-40" class="i">+}
</a><a href="#h77-0-41" id="h77-0-41" class="i">+
</a><a href="#h77-0-42" id="h77-0-42" class="i">+// Verify statically that *Transport implements http.RoundTripper.
</a><a href="#h77-0-43" id="h77-0-43" class="i">+var _ http.RoundTripper = (*Transport)(nil)
</a><a href="#h77-0-44" id="h77-0-44" class="i">+
</a><a href="#h77-0-45" id="h77-0-45" class="i">+// Client returns an *http.Client using a default urlfetch Transport. This
</a><a href="#h77-0-46" id="h77-0-46" class="i">+// client will have the default deadline of 5 seconds, and will check the
</a><a href="#h77-0-47" id="h77-0-47" class="i">+// validity of SSL certificates.
</a><a href="#h77-0-48" id="h77-0-48" class="i">+//
</a><a href="#h77-0-49" id="h77-0-49" class="i">+// Any deadline of the provided context will be used for requests through this client;
</a><a href="#h77-0-50" id="h77-0-50" class="i">+// if the client does not have a deadline then a 5 second default is used.
</a><a href="#h77-0-51" id="h77-0-51" class="i">+func Client(ctx context.Context) *http.Client {
</a><a href="#h77-0-52" id="h77-0-52" class="i">+	return &amp;http.Client{
</a><a href="#h77-0-53" id="h77-0-53" class="i">+		Transport: &amp;Transport{
</a><a href="#h77-0-54" id="h77-0-54" class="i">+			Context: ctx,
</a><a href="#h77-0-55" id="h77-0-55" class="i">+		},
</a><a href="#h77-0-56" id="h77-0-56" class="i">+	}
</a><a href="#h77-0-57" id="h77-0-57" class="i">+}
</a><a href="#h77-0-58" id="h77-0-58" class="i">+
</a><a href="#h77-0-59" id="h77-0-59" class="i">+type bodyReader struct {
</a><a href="#h77-0-60" id="h77-0-60" class="i">+	content   []byte
</a><a href="#h77-0-61" id="h77-0-61" class="i">+	truncated bool
</a><a href="#h77-0-62" id="h77-0-62" class="i">+	closed    bool
</a><a href="#h77-0-63" id="h77-0-63" class="i">+}
</a><a href="#h77-0-64" id="h77-0-64" class="i">+
</a><a href="#h77-0-65" id="h77-0-65" class="i">+// ErrTruncatedBody is the error returned after the final Read() from a
</a><a href="#h77-0-66" id="h77-0-66" class="i">+// response&#39;s Body if the body has been truncated by App Engine&#39;s proxy.
</a><a href="#h77-0-67" id="h77-0-67" class="i">+var ErrTruncatedBody = errors.New(&quot;urlfetch: truncated body&quot;)
</a><a href="#h77-0-68" id="h77-0-68" class="i">+
</a><a href="#h77-0-69" id="h77-0-69" class="i">+func statusCodeToText(code int) string {
</a><a href="#h77-0-70" id="h77-0-70" class="i">+	if t := http.StatusText(code); t != &quot;&quot; {
</a><a href="#h77-0-71" id="h77-0-71" class="i">+		return t
</a><a href="#h77-0-72" id="h77-0-72" class="i">+	}
</a><a href="#h77-0-73" id="h77-0-73" class="i">+	return strconv.Itoa(code)
</a><a href="#h77-0-74" id="h77-0-74" class="i">+}
</a><a href="#h77-0-75" id="h77-0-75" class="i">+
</a><a href="#h77-0-76" id="h77-0-76" class="i">+func (br *bodyReader) Read(p []byte) (n int, err error) {
</a><a href="#h77-0-77" id="h77-0-77" class="i">+	if br.closed {
</a><a href="#h77-0-78" id="h77-0-78" class="i">+		if br.truncated {
</a><a href="#h77-0-79" id="h77-0-79" class="i">+			return 0, ErrTruncatedBody
</a><a href="#h77-0-80" id="h77-0-80" class="i">+		}
</a><a href="#h77-0-81" id="h77-0-81" class="i">+		return 0, io.EOF
</a><a href="#h77-0-82" id="h77-0-82" class="i">+	}
</a><a href="#h77-0-83" id="h77-0-83" class="i">+	n = copy(p, br.content)
</a><a href="#h77-0-84" id="h77-0-84" class="i">+	if n &gt; 0 {
</a><a href="#h77-0-85" id="h77-0-85" class="i">+		br.content = br.content[n:]
</a><a href="#h77-0-86" id="h77-0-86" class="i">+		return
</a><a href="#h77-0-87" id="h77-0-87" class="i">+	}
</a><a href="#h77-0-88" id="h77-0-88" class="i">+	if br.truncated {
</a><a href="#h77-0-89" id="h77-0-89" class="i">+		br.closed = true
</a><a href="#h77-0-90" id="h77-0-90" class="i">+		return 0, ErrTruncatedBody
</a><a href="#h77-0-91" id="h77-0-91" class="i">+	}
</a><a href="#h77-0-92" id="h77-0-92" class="i">+	return 0, io.EOF
</a><a href="#h77-0-93" id="h77-0-93" class="i">+}
</a><a href="#h77-0-94" id="h77-0-94" class="i">+
</a><a href="#h77-0-95" id="h77-0-95" class="i">+func (br *bodyReader) Close() error {
</a><a href="#h77-0-96" id="h77-0-96" class="i">+	br.closed = true
</a><a href="#h77-0-97" id="h77-0-97" class="i">+	br.content = nil
</a><a href="#h77-0-98" id="h77-0-98" class="i">+	return nil
</a><a href="#h77-0-99" id="h77-0-99" class="i">+}
</a><a href="#h77-0-100" id="h77-0-100" class="i">+
</a><a href="#h77-0-101" id="h77-0-101" class="i">+// A map of the URL Fetch-accepted methods that take a request body.
</a><a href="#h77-0-102" id="h77-0-102" class="i">+var methodAcceptsRequestBody = map[string]bool{
</a><a href="#h77-0-103" id="h77-0-103" class="i">+	&quot;POST&quot;:  true,
</a><a href="#h77-0-104" id="h77-0-104" class="i">+	&quot;PUT&quot;:   true,
</a><a href="#h77-0-105" id="h77-0-105" class="i">+	&quot;PATCH&quot;: true,
</a><a href="#h77-0-106" id="h77-0-106" class="i">+}
</a><a href="#h77-0-107" id="h77-0-107" class="i">+
</a><a href="#h77-0-108" id="h77-0-108" class="i">+// urlString returns a valid string given a URL. This function is necessary because
</a><a href="#h77-0-109" id="h77-0-109" class="i">+// the String method of URL doesn&#39;t correctly handle URLs with non-empty Opaque values.
</a><a href="#h77-0-110" id="h77-0-110" class="i">+// See http://code.google.com/p/go/issues/detail?id=4860.
</a><a href="#h77-0-111" id="h77-0-111" class="i">+func urlString(u *url.URL) string {
</a><a href="#h77-0-112" id="h77-0-112" class="i">+	if u.Opaque == &quot;&quot; || strings.HasPrefix(u.Opaque, &quot;//&quot;) {
</a><a href="#h77-0-113" id="h77-0-113" class="i">+		return u.String()
</a><a href="#h77-0-114" id="h77-0-114" class="i">+	}
</a><a href="#h77-0-115" id="h77-0-115" class="i">+	aux := *u
</a><a href="#h77-0-116" id="h77-0-116" class="i">+	aux.Opaque = &quot;//&quot; + aux.Host + aux.Opaque
</a><a href="#h77-0-117" id="h77-0-117" class="i">+	return aux.String()
</a><a href="#h77-0-118" id="h77-0-118" class="i">+}
</a><a href="#h77-0-119" id="h77-0-119" class="i">+
</a><a href="#h77-0-120" id="h77-0-120" class="i">+// RoundTrip issues a single HTTP request and returns its response. Per the
</a><a href="#h77-0-121" id="h77-0-121" class="i">+// http.RoundTripper interface, RoundTrip only returns an error if there
</a><a href="#h77-0-122" id="h77-0-122" class="i">+// was an unsupported request or the URL Fetch proxy fails.
</a><a href="#h77-0-123" id="h77-0-123" class="i">+// Note that HTTP response codes such as 5xx, 403, 404, etc are not
</a><a href="#h77-0-124" id="h77-0-124" class="i">+// errors as far as the transport is concerned and will be returned
</a><a href="#h77-0-125" id="h77-0-125" class="i">+// with err set to nil.
</a><a href="#h77-0-126" id="h77-0-126" class="i">+func (t *Transport) RoundTrip(req *http.Request) (res *http.Response, err error) {
</a><a href="#h77-0-127" id="h77-0-127" class="i">+	methNum, ok := pb.URLFetchRequest_RequestMethod_value[req.Method]
</a><a href="#h77-0-128" id="h77-0-128" class="i">+	if !ok {
</a><a href="#h77-0-129" id="h77-0-129" class="i">+		return nil, fmt.Errorf(&quot;urlfetch: unsupported HTTP method %q&quot;, req.Method)
</a><a href="#h77-0-130" id="h77-0-130" class="i">+	}
</a><a href="#h77-0-131" id="h77-0-131" class="i">+
</a><a href="#h77-0-132" id="h77-0-132" class="i">+	method := pb.URLFetchRequest_RequestMethod(methNum)
</a><a href="#h77-0-133" id="h77-0-133" class="i">+
</a><a href="#h77-0-134" id="h77-0-134" class="i">+	freq := &amp;pb.URLFetchRequest{
</a><a href="#h77-0-135" id="h77-0-135" class="i">+		Method:                        &amp;method,
</a><a href="#h77-0-136" id="h77-0-136" class="i">+		Url:                           proto.String(urlString(req.URL)),
</a><a href="#h77-0-137" id="h77-0-137" class="i">+		FollowRedirects:               proto.Bool(false), // http.Client&#39;s responsibility
</a><a href="#h77-0-138" id="h77-0-138" class="i">+		MustValidateServerCertificate: proto.Bool(!t.AllowInvalidServerCertificate),
</a><a href="#h77-0-139" id="h77-0-139" class="i">+	}
</a><a href="#h77-0-140" id="h77-0-140" class="i">+	if deadline, ok := t.Context.Deadline(); ok {
</a><a href="#h77-0-141" id="h77-0-141" class="i">+		freq.Deadline = proto.Float64(deadline.Sub(time.Now()).Seconds())
</a><a href="#h77-0-142" id="h77-0-142" class="i">+	}
</a><a href="#h77-0-143" id="h77-0-143" class="i">+
</a><a href="#h77-0-144" id="h77-0-144" class="i">+	for k, vals := range req.Header {
</a><a href="#h77-0-145" id="h77-0-145" class="i">+		for _, val := range vals {
</a><a href="#h77-0-146" id="h77-0-146" class="i">+			freq.Header = append(freq.Header, &amp;pb.URLFetchRequest_Header{
</a><a href="#h77-0-147" id="h77-0-147" class="i">+				Key:   proto.String(k),
</a><a href="#h77-0-148" id="h77-0-148" class="i">+				Value: proto.String(val),
</a><a href="#h77-0-149" id="h77-0-149" class="i">+			})
</a><a href="#h77-0-150" id="h77-0-150" class="i">+		}
</a><a href="#h77-0-151" id="h77-0-151" class="i">+	}
</a><a href="#h77-0-152" id="h77-0-152" class="i">+	if methodAcceptsRequestBody[req.Method] &amp;&amp; req.Body != nil {
</a><a href="#h77-0-153" id="h77-0-153" class="i">+		// Avoid a []byte copy if req.Body has a Bytes method.
</a><a href="#h77-0-154" id="h77-0-154" class="i">+		switch b := req.Body.(type) {
</a><a href="#h77-0-155" id="h77-0-155" class="i">+		case interface {
</a><a href="#h77-0-156" id="h77-0-156" class="i">+			Bytes() []byte
</a><a href="#h77-0-157" id="h77-0-157" class="i">+		}:
</a><a href="#h77-0-158" id="h77-0-158" class="i">+			freq.Payload = b.Bytes()
</a><a href="#h77-0-159" id="h77-0-159" class="i">+		default:
</a><a href="#h77-0-160" id="h77-0-160" class="i">+			freq.Payload, err = ioutil.ReadAll(req.Body)
</a><a href="#h77-0-161" id="h77-0-161" class="i">+			if err != nil {
</a><a href="#h77-0-162" id="h77-0-162" class="i">+				return nil, err
</a><a href="#h77-0-163" id="h77-0-163" class="i">+			}
</a><a href="#h77-0-164" id="h77-0-164" class="i">+		}
</a><a href="#h77-0-165" id="h77-0-165" class="i">+	}
</a><a href="#h77-0-166" id="h77-0-166" class="i">+
</a><a href="#h77-0-167" id="h77-0-167" class="i">+	fres := &amp;pb.URLFetchResponse{}
</a><a href="#h77-0-168" id="h77-0-168" class="i">+	if err := internal.Call(t.Context, &quot;urlfetch&quot;, &quot;Fetch&quot;, freq, fres); err != nil {
</a><a href="#h77-0-169" id="h77-0-169" class="i">+		return nil, err
</a><a href="#h77-0-170" id="h77-0-170" class="i">+	}
</a><a href="#h77-0-171" id="h77-0-171" class="i">+
</a><a href="#h77-0-172" id="h77-0-172" class="i">+	res = &amp;http.Response{}
</a><a href="#h77-0-173" id="h77-0-173" class="i">+	res.StatusCode = int(*fres.StatusCode)
</a><a href="#h77-0-174" id="h77-0-174" class="i">+	res.Status = fmt.Sprintf(&quot;%d %s&quot;, res.StatusCode, statusCodeToText(res.StatusCode))
</a><a href="#h77-0-175" id="h77-0-175" class="i">+	res.Header = make(http.Header)
</a><a href="#h77-0-176" id="h77-0-176" class="i">+	res.Request = req
</a><a href="#h77-0-177" id="h77-0-177" class="i">+
</a><a href="#h77-0-178" id="h77-0-178" class="i">+	// Faked:
</a><a href="#h77-0-179" id="h77-0-179" class="i">+	res.ProtoMajor = 1
</a><a href="#h77-0-180" id="h77-0-180" class="i">+	res.ProtoMinor = 1
</a><a href="#h77-0-181" id="h77-0-181" class="i">+	res.Proto = &quot;HTTP/1.1&quot;
</a><a href="#h77-0-182" id="h77-0-182" class="i">+	res.Close = true
</a><a href="#h77-0-183" id="h77-0-183" class="i">+
</a><a href="#h77-0-184" id="h77-0-184" class="i">+	for _, h := range fres.Header {
</a><a href="#h77-0-185" id="h77-0-185" class="i">+		hkey := http.CanonicalHeaderKey(*h.Key)
</a><a href="#h77-0-186" id="h77-0-186" class="i">+		hval := *h.Value
</a><a href="#h77-0-187" id="h77-0-187" class="i">+		if hkey == &quot;Content-Length&quot; {
</a><a href="#h77-0-188" id="h77-0-188" class="i">+			// Will get filled in below for all but HEAD requests.
</a><a href="#h77-0-189" id="h77-0-189" class="i">+			if req.Method == &quot;HEAD&quot; {
</a><a href="#h77-0-190" id="h77-0-190" class="i">+				res.ContentLength, _ = strconv.ParseInt(hval, 10, 64)
</a><a href="#h77-0-191" id="h77-0-191" class="i">+			}
</a><a href="#h77-0-192" id="h77-0-192" class="i">+			continue
</a><a href="#h77-0-193" id="h77-0-193" class="i">+		}
</a><a href="#h77-0-194" id="h77-0-194" class="i">+		res.Header.Add(hkey, hval)
</a><a href="#h77-0-195" id="h77-0-195" class="i">+	}
</a><a href="#h77-0-196" id="h77-0-196" class="i">+
</a><a href="#h77-0-197" id="h77-0-197" class="i">+	if req.Method != &quot;HEAD&quot; {
</a><a href="#h77-0-198" id="h77-0-198" class="i">+		res.ContentLength = int64(len(fres.Content))
</a><a href="#h77-0-199" id="h77-0-199" class="i">+	}
</a><a href="#h77-0-200" id="h77-0-200" class="i">+
</a><a href="#h77-0-201" id="h77-0-201" class="i">+	truncated := fres.GetContentWasTruncated()
</a><a href="#h77-0-202" id="h77-0-202" class="i">+	res.Body = &amp;bodyReader{content: fres.Content, truncated: truncated}
</a><a href="#h77-0-203" id="h77-0-203" class="i">+	return
</a><a href="#h77-0-204" id="h77-0-204" class="i">+}
</a><a href="#h77-0-205" id="h77-0-205" class="i">+
</a><a href="#h77-0-206" id="h77-0-206" class="i">+func init() {
</a><a href="#h77-0-207" id="h77-0-207" class="i">+	internal.RegisterErrorCodeMap(&quot;urlfetch&quot;, pb.URLFetchServiceError_ErrorCode_name)
</a><a href="#h77-0-208" id="h77-0-208" class="i">+	internal.RegisterTimeoutErrorCode(&quot;urlfetch&quot;, int32(pb.URLFetchServiceError_DEADLINE_EXCEEDED))
</a><a href="#h77-0-209" id="h77-0-209" class="i">+}
</a><b>diff --git a/<a id="h78" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/BUILD">vendor/gopkg.in/alexcesaro/statsd.v2/BUILD</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/BUILD">vendor/gopkg.in/alexcesaro/statsd.v2/BUILD</a></b>
<a href="#h78-0" id="h78-0" class="h">@@ -0,0 +1,21 @@
</a><a href="#h78-0-0" id="h78-0-0" class="i">+
</a><a href="#h78-0-1" id="h78-0-1" class="i">+load(&quot;@io_bazel_rules_go//go:def.bzl&quot;,
</a><a href="#h78-0-2" id="h78-0-2" class="i">+  &quot;go_binary&quot;,
</a><a href="#h78-0-3" id="h78-0-3" class="i">+  &quot;go_library&quot;,
</a><a href="#h78-0-4" id="h78-0-4" class="i">+  &quot;go_test&quot;,
</a><a href="#h78-0-5" id="h78-0-5" class="i">+)
</a><a href="#h78-0-6" id="h78-0-6" class="i">+
</a><a href="#h78-0-7" id="h78-0-7" class="i">+go_library(
</a><a href="#h78-0-8" id="h78-0-8" class="i">+name = &quot;go_default_library&quot;,
</a><a href="#h78-0-9" id="h78-0-9" class="i">+  srcs = [
</a><a href="#h78-0-10" id="h78-0-10" class="i">+    &quot;conn.go&quot;,
</a><a href="#h78-0-11" id="h78-0-11" class="i">+    &quot;doc.go&quot;,
</a><a href="#h78-0-12" id="h78-0-12" class="i">+    &quot;options.go&quot;,
</a><a href="#h78-0-13" id="h78-0-13" class="i">+    &quot;statsd.go&quot;,
</a><a href="#h78-0-14" id="h78-0-14" class="i">+  ],
</a><a href="#h78-0-15" id="h78-0-15" class="i">+  deps = [
</a><a href="#h78-0-16" id="h78-0-16" class="i">+  ],
</a><a href="#h78-0-17" id="h78-0-17" class="i">+  visibility = [&quot;//visibility:public&quot;],
</a><a href="#h78-0-18" id="h78-0-18" class="i">+)
</a><a href="#h78-0-19" id="h78-0-19" class="i">+
</a><a href="#h78-0-20" id="h78-0-20" class="i">+
</a><b>diff --git a/<a id="h79" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/CHANGELOG.md">vendor/gopkg.in/alexcesaro/statsd.v2/CHANGELOG.md</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/CHANGELOG.md">vendor/gopkg.in/alexcesaro/statsd.v2/CHANGELOG.md</a></b>
<a href="#h79-0" id="h79-0" class="h">@@ -0,0 +1,64 @@
</a><a href="#h79-0-0" id="h79-0-0" class="i">+# Change Log
</a><a href="#h79-0-1" id="h79-0-1" class="i">+All notable changes to this project will be documented in this file.
</a><a href="#h79-0-2" id="h79-0-2" class="i">+This project adheres to [Semantic Versioning](http://semver.org/).
</a><a href="#h79-0-3" id="h79-0-3" class="i">+
</a><a href="#h79-0-4" id="h79-0-4" class="i">+## [2.0.0] - 2016-03-20
</a><a href="#h79-0-5" id="h79-0-5" class="i">+
</a><a href="#h79-0-6" id="h79-0-6" class="i">+- `New` signature changed. The default address used is now &quot;:8125&quot;. To use
</a><a href="#h79-0-7" id="h79-0-7" class="i">+  another address use the `Address` option:
</a><a href="#h79-0-8" id="h79-0-8" class="i">+
</a><a href="#h79-0-9" id="h79-0-9" class="i">+  Before:
</a><a href="#h79-0-10" id="h79-0-10" class="i">+  ```
</a><a href="#h79-0-11" id="h79-0-11" class="i">+  statsd.New(&quot;:8125&quot;)
</a><a href="#h79-0-12" id="h79-0-12" class="i">+  statsd.New(&quot;:9000&quot;)
</a><a href="#h79-0-13" id="h79-0-13" class="i">+  ```
</a><a href="#h79-0-14" id="h79-0-14" class="i">+
</a><a href="#h79-0-15" id="h79-0-15" class="i">+  After
</a><a href="#h79-0-16" id="h79-0-16" class="i">+  ```
</a><a href="#h79-0-17" id="h79-0-17" class="i">+  statsd.New()
</a><a href="#h79-0-18" id="h79-0-18" class="i">+  statsd.New(statsd.Address(&quot;:9000&quot;))
</a><a href="#h79-0-19" id="h79-0-19" class="i">+  ```
</a><a href="#h79-0-20" id="h79-0-20" class="i">+
</a><a href="#h79-0-21" id="h79-0-21" class="i">+- The `rate` parameter has been removed from the `Count` and `Timing` methods.
</a><a href="#h79-0-22" id="h79-0-22" class="i">+  Use the new `SampleRate` option instead.
</a><a href="#h79-0-23" id="h79-0-23" class="i">+
</a><a href="#h79-0-24" id="h79-0-24" class="i">+- `Count`, `Gauge` and `Timing` now accept a `interface{}` instead of an int as
</a><a href="#h79-0-25" id="h79-0-25" class="i">+  the value parameter. So you can now use any type of integer or float in these
</a><a href="#h79-0-26" id="h79-0-26" class="i">+  functions.
</a><a href="#h79-0-27" id="h79-0-27" class="i">+
</a><a href="#h79-0-28" id="h79-0-28" class="i">+- The `WithInfluxDBTags` and `WithDatadogTags` options were replaced by the
</a><a href="#h79-0-29" id="h79-0-29" class="i">+  `TagsFormat` and `Tags` options:
</a><a href="#h79-0-30" id="h79-0-30" class="i">+
</a><a href="#h79-0-31" id="h79-0-31" class="i">+  Before:
</a><a href="#h79-0-32" id="h79-0-32" class="i">+  ```
</a><a href="#h79-0-33" id="h79-0-33" class="i">+  statsd.New(statsd.WithInfluxDBTags(&quot;tag&quot;, &quot;value&quot;))
</a><a href="#h79-0-34" id="h79-0-34" class="i">+  statsd.New(statsd.WithDatadogTags(&quot;tag&quot;, &quot;value&quot;))
</a><a href="#h79-0-35" id="h79-0-35" class="i">+  ```
</a><a href="#h79-0-36" id="h79-0-36" class="i">+
</a><a href="#h79-0-37" id="h79-0-37" class="i">+  After
</a><a href="#h79-0-38" id="h79-0-38" class="i">+  ```
</a><a href="#h79-0-39" id="h79-0-39" class="i">+  statsd.New(statsd.TagsFormat(statsd.InfluxDB), statsd.Tags(&quot;tag&quot;, &quot;value&quot;))
</a><a href="#h79-0-40" id="h79-0-40" class="i">+  statsd.New(statsd.TagsFormat(statsd.Datadog), statsd.Tags(&quot;tag&quot;, &quot;value&quot;))
</a><a href="#h79-0-41" id="h79-0-41" class="i">+  ```
</a><a href="#h79-0-42" id="h79-0-42" class="i">+
</a><a href="#h79-0-43" id="h79-0-43" class="i">+- All options whose named began by `With` had the `With` stripped:
</a><a href="#h79-0-44" id="h79-0-44" class="i">+
</a><a href="#h79-0-45" id="h79-0-45" class="i">+  Before:
</a><a href="#h79-0-46" id="h79-0-46" class="i">+  ```
</a><a href="#h79-0-47" id="h79-0-47" class="i">+  statsd.New(statsd.WithMaxPacketSize(65000))
</a><a href="#h79-0-48" id="h79-0-48" class="i">+  ```
</a><a href="#h79-0-49" id="h79-0-49" class="i">+
</a><a href="#h79-0-50" id="h79-0-50" class="i">+  After
</a><a href="#h79-0-51" id="h79-0-51" class="i">+  ```
</a><a href="#h79-0-52" id="h79-0-52" class="i">+  statsd.New(statsd.MaxPacketSize(65000))
</a><a href="#h79-0-53" id="h79-0-53" class="i">+  ```
</a><a href="#h79-0-54" id="h79-0-54" class="i">+
</a><a href="#h79-0-55" id="h79-0-55" class="i">+- `ChangeGauge` has been removed as it is a bad practice: UDP packets can be
</a><a href="#h79-0-56" id="h79-0-56" class="i">+  lost so using relative changes can cause unreliable values in the long term.
</a><a href="#h79-0-57" id="h79-0-57" class="i">+  Use `Gauge` instead which sends an absolute value.
</a><a href="#h79-0-58" id="h79-0-58" class="i">+
</a><a href="#h79-0-59" id="h79-0-59" class="i">+- The `Histogram` method has been added.
</a><a href="#h79-0-60" id="h79-0-60" class="i">+
</a><a href="#h79-0-61" id="h79-0-61" class="i">+- The `Clone` method was added to the `Client`, it allows to create a new
</a><a href="#h79-0-62" id="h79-0-62" class="i">+  `Client` with different rate / prefix / tags parameters while still using the
</a><a href="#h79-0-63" id="h79-0-63" class="i">+  same connection.
</a><b>diff --git a/<a id="h80" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/LICENSE">vendor/gopkg.in/alexcesaro/statsd.v2/LICENSE</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/LICENSE">vendor/gopkg.in/alexcesaro/statsd.v2/LICENSE</a></b>
<a href="#h80-0" id="h80-0" class="h">@@ -0,0 +1,20 @@
</a><a href="#h80-0-0" id="h80-0-0" class="i">+The MIT License (MIT)
</a><a href="#h80-0-1" id="h80-0-1" class="i">+
</a><a href="#h80-0-2" id="h80-0-2" class="i">+Copyright (c) 2015 Alexandre Cesaro
</a><a href="#h80-0-3" id="h80-0-3" class="i">+
</a><a href="#h80-0-4" id="h80-0-4" class="i">+Permission is hereby granted, free of charge, to any person obtaining a copy of
</a><a href="#h80-0-5" id="h80-0-5" class="i">+this software and associated documentation files (the &quot;Software&quot;), to deal in
</a><a href="#h80-0-6" id="h80-0-6" class="i">+the Software without restriction, including without limitation the rights to
</a><a href="#h80-0-7" id="h80-0-7" class="i">+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
</a><a href="#h80-0-8" id="h80-0-8" class="i">+the Software, and to permit persons to whom the Software is furnished to do so,
</a><a href="#h80-0-9" id="h80-0-9" class="i">+subject to the following conditions:
</a><a href="#h80-0-10" id="h80-0-10" class="i">+
</a><a href="#h80-0-11" id="h80-0-11" class="i">+The above copyright notice and this permission notice shall be included in all
</a><a href="#h80-0-12" id="h80-0-12" class="i">+copies or substantial portions of the Software.
</a><a href="#h80-0-13" id="h80-0-13" class="i">+
</a><a href="#h80-0-14" id="h80-0-14" class="i">+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
</a><a href="#h80-0-15" id="h80-0-15" class="i">+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
</a><a href="#h80-0-16" id="h80-0-16" class="i">+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
</a><a href="#h80-0-17" id="h80-0-17" class="i">+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
</a><a href="#h80-0-18" id="h80-0-18" class="i">+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
</a><a href="#h80-0-19" id="h80-0-19" class="i">+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</a><b>diff --git a/<a id="h81" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/README.md">vendor/gopkg.in/alexcesaro/statsd.v2/README.md</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/README.md">vendor/gopkg.in/alexcesaro/statsd.v2/README.md</a></b>
<a href="#h81-0" id="h81-0" class="h">@@ -0,0 +1,50 @@
</a><a href="#h81-0-0" id="h81-0-0" class="i">+# statsd
</a><a href="#h81-0-1" id="h81-0-1" class="i">+[![Build Status](https://travis-ci.org/alexcesaro/statsd.svg?branch=v2)](https://travis-ci.org/alexcesaro/statsd) [![Code Coverage](http://gocover.io/_badge/gopkg.in/alexcesaro/statsd.v2)](http://gocover.io/gopkg.in/alexcesaro/statsd.v2) [![Documentation](https://godoc.org/gopkg.in/alexcesaro/statsd.v2?status.svg)](https://godoc.org/gopkg.in/alexcesaro/statsd.v2)
</a><a href="#h81-0-2" id="h81-0-2" class="i">+
</a><a href="#h81-0-3" id="h81-0-3" class="i">+## Introduction
</a><a href="#h81-0-4" id="h81-0-4" class="i">+
</a><a href="#h81-0-5" id="h81-0-5" class="i">+statsd is a simple and efficient [Statsd](https://github.com/etsy/statsd)
</a><a href="#h81-0-6" id="h81-0-6" class="i">+client.
</a><a href="#h81-0-7" id="h81-0-7" class="i">+
</a><a href="#h81-0-8" id="h81-0-8" class="i">+See the [benchmark](https://github.com/alexcesaro/statsdbench) for a comparison
</a><a href="#h81-0-9" id="h81-0-9" class="i">+with other Go StatsD clients.
</a><a href="#h81-0-10" id="h81-0-10" class="i">+
</a><a href="#h81-0-11" id="h81-0-11" class="i">+## Features
</a><a href="#h81-0-12" id="h81-0-12" class="i">+
</a><a href="#h81-0-13" id="h81-0-13" class="i">+- Supports all StatsD metrics: counter, gauge, timing and set
</a><a href="#h81-0-14" id="h81-0-14" class="i">+- Supports InfluxDB and Datadog tags
</a><a href="#h81-0-15" id="h81-0-15" class="i">+- Fast and GC-friendly: all functions for sending metrics do not allocate
</a><a href="#h81-0-16" id="h81-0-16" class="i">+- Efficient: metrics are buffered by default
</a><a href="#h81-0-17" id="h81-0-17" class="i">+- Simple and clean API
</a><a href="#h81-0-18" id="h81-0-18" class="i">+- 100% test coverage
</a><a href="#h81-0-19" id="h81-0-19" class="i">+- Versioned API using gopkg.in
</a><a href="#h81-0-20" id="h81-0-20" class="i">+
</a><a href="#h81-0-21" id="h81-0-21" class="i">+
</a><a href="#h81-0-22" id="h81-0-22" class="i">+## Documentation
</a><a href="#h81-0-23" id="h81-0-23" class="i">+
</a><a href="#h81-0-24" id="h81-0-24" class="i">+https://godoc.org/gopkg.in/alexcesaro/statsd.v2
</a><a href="#h81-0-25" id="h81-0-25" class="i">+
</a><a href="#h81-0-26" id="h81-0-26" class="i">+
</a><a href="#h81-0-27" id="h81-0-27" class="i">+## Download
</a><a href="#h81-0-28" id="h81-0-28" class="i">+
</a><a href="#h81-0-29" id="h81-0-29" class="i">+    go get gopkg.in/alexcesaro/statsd.v2
</a><a href="#h81-0-30" id="h81-0-30" class="i">+
</a><a href="#h81-0-31" id="h81-0-31" class="i">+
</a><a href="#h81-0-32" id="h81-0-32" class="i">+## Example
</a><a href="#h81-0-33" id="h81-0-33" class="i">+
</a><a href="#h81-0-34" id="h81-0-34" class="i">+See the [examples in the documentation](https://godoc.org/gopkg.in/alexcesaro/statsd.v2#example-package).
</a><a href="#h81-0-35" id="h81-0-35" class="i">+
</a><a href="#h81-0-36" id="h81-0-36" class="i">+
</a><a href="#h81-0-37" id="h81-0-37" class="i">+## License
</a><a href="#h81-0-38" id="h81-0-38" class="i">+
</a><a href="#h81-0-39" id="h81-0-39" class="i">+[MIT](LICENSE)
</a><a href="#h81-0-40" id="h81-0-40" class="i">+
</a><a href="#h81-0-41" id="h81-0-41" class="i">+
</a><a href="#h81-0-42" id="h81-0-42" class="i">+## Contribute
</a><a href="#h81-0-43" id="h81-0-43" class="i">+
</a><a href="#h81-0-44" id="h81-0-44" class="i">+Do you have any question the documentation does not answer? Is there a use case
</a><a href="#h81-0-45" id="h81-0-45" class="i">+that you feel is common and is not well-addressed by the current API?
</a><a href="#h81-0-46" id="h81-0-46" class="i">+
</a><a href="#h81-0-47" id="h81-0-47" class="i">+If so you are more than welcome to ask questions in the
</a><a href="#h81-0-48" id="h81-0-48" class="i">+[thread on golang-nuts](https://groups.google.com/d/topic/golang-nuts/Tz6t4_iLgnw/discussion)
</a><a href="#h81-0-49" id="h81-0-49" class="i">+or open an issue or send a pull-request here on Github.
</a><b>diff --git a/<a id="h82" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/conn.go">vendor/gopkg.in/alexcesaro/statsd.v2/conn.go</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/conn.go">vendor/gopkg.in/alexcesaro/statsd.v2/conn.go</a></b>
<a href="#h82-0" id="h82-0" class="h">@@ -0,0 +1,270 @@
</a><a href="#h82-0-0" id="h82-0-0" class="i">+package statsd
</a><a href="#h82-0-1" id="h82-0-1" class="i">+
</a><a href="#h82-0-2" id="h82-0-2" class="i">+import (
</a><a href="#h82-0-3" id="h82-0-3" class="i">+	&quot;io&quot;
</a><a href="#h82-0-4" id="h82-0-4" class="i">+	&quot;math/rand&quot;
</a><a href="#h82-0-5" id="h82-0-5" class="i">+	&quot;net&quot;
</a><a href="#h82-0-6" id="h82-0-6" class="i">+	&quot;strconv&quot;
</a><a href="#h82-0-7" id="h82-0-7" class="i">+	&quot;sync&quot;
</a><a href="#h82-0-8" id="h82-0-8" class="i">+	&quot;time&quot;
</a><a href="#h82-0-9" id="h82-0-9" class="i">+)
</a><a href="#h82-0-10" id="h82-0-10" class="i">+
</a><a href="#h82-0-11" id="h82-0-11" class="i">+type conn struct {
</a><a href="#h82-0-12" id="h82-0-12" class="i">+	// Fields settable with options at Client&#39;s creation.
</a><a href="#h82-0-13" id="h82-0-13" class="i">+	addr          string
</a><a href="#h82-0-14" id="h82-0-14" class="i">+	errorHandler  func(error)
</a><a href="#h82-0-15" id="h82-0-15" class="i">+	flushPeriod   time.Duration
</a><a href="#h82-0-16" id="h82-0-16" class="i">+	maxPacketSize int
</a><a href="#h82-0-17" id="h82-0-17" class="i">+	network       string
</a><a href="#h82-0-18" id="h82-0-18" class="i">+	tagFormat     TagFormat
</a><a href="#h82-0-19" id="h82-0-19" class="i">+
</a><a href="#h82-0-20" id="h82-0-20" class="i">+	mu sync.Mutex
</a><a href="#h82-0-21" id="h82-0-21" class="i">+	// Fields guarded by the mutex.
</a><a href="#h82-0-22" id="h82-0-22" class="i">+	closed    bool
</a><a href="#h82-0-23" id="h82-0-23" class="i">+	w         io.WriteCloser
</a><a href="#h82-0-24" id="h82-0-24" class="i">+	buf       []byte
</a><a href="#h82-0-25" id="h82-0-25" class="i">+	rateCache map[float32]string
</a><a href="#h82-0-26" id="h82-0-26" class="i">+}
</a><a href="#h82-0-27" id="h82-0-27" class="i">+
</a><a href="#h82-0-28" id="h82-0-28" class="i">+func newConn(conf connConfig, muted bool) (*conn, error) {
</a><a href="#h82-0-29" id="h82-0-29" class="i">+	c := &amp;conn{
</a><a href="#h82-0-30" id="h82-0-30" class="i">+		addr:          conf.Addr,
</a><a href="#h82-0-31" id="h82-0-31" class="i">+		errorHandler:  conf.ErrorHandler,
</a><a href="#h82-0-32" id="h82-0-32" class="i">+		flushPeriod:   conf.FlushPeriod,
</a><a href="#h82-0-33" id="h82-0-33" class="i">+		maxPacketSize: conf.MaxPacketSize,
</a><a href="#h82-0-34" id="h82-0-34" class="i">+		network:       conf.Network,
</a><a href="#h82-0-35" id="h82-0-35" class="i">+		tagFormat:     conf.TagFormat,
</a><a href="#h82-0-36" id="h82-0-36" class="i">+	}
</a><a href="#h82-0-37" id="h82-0-37" class="i">+
</a><a href="#h82-0-38" id="h82-0-38" class="i">+	if muted {
</a><a href="#h82-0-39" id="h82-0-39" class="i">+		return c, nil
</a><a href="#h82-0-40" id="h82-0-40" class="i">+	}
</a><a href="#h82-0-41" id="h82-0-41" class="i">+
</a><a href="#h82-0-42" id="h82-0-42" class="i">+	var err error
</a><a href="#h82-0-43" id="h82-0-43" class="i">+	c.w, err = dialTimeout(c.network, c.addr, 5*time.Second)
</a><a href="#h82-0-44" id="h82-0-44" class="i">+	if err != nil {
</a><a href="#h82-0-45" id="h82-0-45" class="i">+		return c, err
</a><a href="#h82-0-46" id="h82-0-46" class="i">+	}
</a><a href="#h82-0-47" id="h82-0-47" class="i">+	// When using UDP do a quick check to see if something is listening on the
</a><a href="#h82-0-48" id="h82-0-48" class="i">+	// given port to return an error as soon as possible.
</a><a href="#h82-0-49" id="h82-0-49" class="i">+	if c.network[:3] == &quot;udp&quot; {
</a><a href="#h82-0-50" id="h82-0-50" class="i">+		for i := 0; i &lt; 2; i++ {
</a><a href="#h82-0-51" id="h82-0-51" class="i">+			_, err = c.w.Write(nil)
</a><a href="#h82-0-52" id="h82-0-52" class="i">+			if err != nil {
</a><a href="#h82-0-53" id="h82-0-53" class="i">+				_ = c.w.Close()
</a><a href="#h82-0-54" id="h82-0-54" class="i">+				c.w = nil
</a><a href="#h82-0-55" id="h82-0-55" class="i">+				return c, err
</a><a href="#h82-0-56" id="h82-0-56" class="i">+			}
</a><a href="#h82-0-57" id="h82-0-57" class="i">+		}
</a><a href="#h82-0-58" id="h82-0-58" class="i">+	}
</a><a href="#h82-0-59" id="h82-0-59" class="i">+
</a><a href="#h82-0-60" id="h82-0-60" class="i">+	// To prevent a buffer overflow add some capacity to the buffer to allow for
</a><a href="#h82-0-61" id="h82-0-61" class="i">+	// an additional metric.
</a><a href="#h82-0-62" id="h82-0-62" class="i">+	c.buf = make([]byte, 0, c.maxPacketSize+200)
</a><a href="#h82-0-63" id="h82-0-63" class="i">+
</a><a href="#h82-0-64" id="h82-0-64" class="i">+	if c.flushPeriod &gt; 0 {
</a><a href="#h82-0-65" id="h82-0-65" class="i">+		go func() {
</a><a href="#h82-0-66" id="h82-0-66" class="i">+			ticker := time.NewTicker(c.flushPeriod)
</a><a href="#h82-0-67" id="h82-0-67" class="i">+			for _ = range ticker.C {
</a><a href="#h82-0-68" id="h82-0-68" class="i">+				c.mu.Lock()
</a><a href="#h82-0-69" id="h82-0-69" class="i">+				if c.closed {
</a><a href="#h82-0-70" id="h82-0-70" class="i">+					ticker.Stop()
</a><a href="#h82-0-71" id="h82-0-71" class="i">+					c.mu.Unlock()
</a><a href="#h82-0-72" id="h82-0-72" class="i">+					return
</a><a href="#h82-0-73" id="h82-0-73" class="i">+				}
</a><a href="#h82-0-74" id="h82-0-74" class="i">+				c.flush(0)
</a><a href="#h82-0-75" id="h82-0-75" class="i">+				c.mu.Unlock()
</a><a href="#h82-0-76" id="h82-0-76" class="i">+			}
</a><a href="#h82-0-77" id="h82-0-77" class="i">+		}()
</a><a href="#h82-0-78" id="h82-0-78" class="i">+	}
</a><a href="#h82-0-79" id="h82-0-79" class="i">+
</a><a href="#h82-0-80" id="h82-0-80" class="i">+	return c, nil
</a><a href="#h82-0-81" id="h82-0-81" class="i">+}
</a><a href="#h82-0-82" id="h82-0-82" class="i">+
</a><a href="#h82-0-83" id="h82-0-83" class="i">+func (c *conn) metric(prefix, bucket string, n interface{}, typ string, rate float32, tags string) {
</a><a href="#h82-0-84" id="h82-0-84" class="i">+	c.mu.Lock()
</a><a href="#h82-0-85" id="h82-0-85" class="i">+	l := len(c.buf)
</a><a href="#h82-0-86" id="h82-0-86" class="i">+	c.appendBucket(prefix, bucket, tags)
</a><a href="#h82-0-87" id="h82-0-87" class="i">+	c.appendNumber(n)
</a><a href="#h82-0-88" id="h82-0-88" class="i">+	c.appendType(typ)
</a><a href="#h82-0-89" id="h82-0-89" class="i">+	c.appendRate(rate)
</a><a href="#h82-0-90" id="h82-0-90" class="i">+	c.closeMetric(tags)
</a><a href="#h82-0-91" id="h82-0-91" class="i">+	c.flushIfBufferFull(l)
</a><a href="#h82-0-92" id="h82-0-92" class="i">+	c.mu.Unlock()
</a><a href="#h82-0-93" id="h82-0-93" class="i">+}
</a><a href="#h82-0-94" id="h82-0-94" class="i">+
</a><a href="#h82-0-95" id="h82-0-95" class="i">+func (c *conn) gauge(prefix, bucket string, value interface{}, tags string) {
</a><a href="#h82-0-96" id="h82-0-96" class="i">+	c.mu.Lock()
</a><a href="#h82-0-97" id="h82-0-97" class="i">+	l := len(c.buf)
</a><a href="#h82-0-98" id="h82-0-98" class="i">+	// To set a gauge to a negative value we must first set it to 0.
</a><a href="#h82-0-99" id="h82-0-99" class="i">+	// https://github.com/etsy/statsd/blob/master/docs/metric_types.md#gauges
</a><a href="#h82-0-100" id="h82-0-100" class="i">+	if isNegative(value) {
</a><a href="#h82-0-101" id="h82-0-101" class="i">+		c.appendBucket(prefix, bucket, tags)
</a><a href="#h82-0-102" id="h82-0-102" class="i">+		c.appendGauge(0, tags)
</a><a href="#h82-0-103" id="h82-0-103" class="i">+	}
</a><a href="#h82-0-104" id="h82-0-104" class="i">+	c.appendBucket(prefix, bucket, tags)
</a><a href="#h82-0-105" id="h82-0-105" class="i">+	c.appendGauge(value, tags)
</a><a href="#h82-0-106" id="h82-0-106" class="i">+	c.flushIfBufferFull(l)
</a><a href="#h82-0-107" id="h82-0-107" class="i">+	c.mu.Unlock()
</a><a href="#h82-0-108" id="h82-0-108" class="i">+}
</a><a href="#h82-0-109" id="h82-0-109" class="i">+
</a><a href="#h82-0-110" id="h82-0-110" class="i">+func (c *conn) appendGauge(value interface{}, tags string) {
</a><a href="#h82-0-111" id="h82-0-111" class="i">+	c.appendNumber(value)
</a><a href="#h82-0-112" id="h82-0-112" class="i">+	c.appendType(&quot;g&quot;)
</a><a href="#h82-0-113" id="h82-0-113" class="i">+	c.closeMetric(tags)
</a><a href="#h82-0-114" id="h82-0-114" class="i">+}
</a><a href="#h82-0-115" id="h82-0-115" class="i">+
</a><a href="#h82-0-116" id="h82-0-116" class="i">+func (c *conn) unique(prefix, bucket string, value string, tags string) {
</a><a href="#h82-0-117" id="h82-0-117" class="i">+	c.mu.Lock()
</a><a href="#h82-0-118" id="h82-0-118" class="i">+	l := len(c.buf)
</a><a href="#h82-0-119" id="h82-0-119" class="i">+	c.appendBucket(prefix, bucket, tags)
</a><a href="#h82-0-120" id="h82-0-120" class="i">+	c.appendString(value)
</a><a href="#h82-0-121" id="h82-0-121" class="i">+	c.appendType(&quot;s&quot;)
</a><a href="#h82-0-122" id="h82-0-122" class="i">+	c.closeMetric(tags)
</a><a href="#h82-0-123" id="h82-0-123" class="i">+	c.flushIfBufferFull(l)
</a><a href="#h82-0-124" id="h82-0-124" class="i">+	c.mu.Unlock()
</a><a href="#h82-0-125" id="h82-0-125" class="i">+}
</a><a href="#h82-0-126" id="h82-0-126" class="i">+
</a><a href="#h82-0-127" id="h82-0-127" class="i">+func (c *conn) appendByte(b byte) {
</a><a href="#h82-0-128" id="h82-0-128" class="i">+	c.buf = append(c.buf, b)
</a><a href="#h82-0-129" id="h82-0-129" class="i">+}
</a><a href="#h82-0-130" id="h82-0-130" class="i">+
</a><a href="#h82-0-131" id="h82-0-131" class="i">+func (c *conn) appendString(s string) {
</a><a href="#h82-0-132" id="h82-0-132" class="i">+	c.buf = append(c.buf, s...)
</a><a href="#h82-0-133" id="h82-0-133" class="i">+}
</a><a href="#h82-0-134" id="h82-0-134" class="i">+
</a><a href="#h82-0-135" id="h82-0-135" class="i">+func (c *conn) appendNumber(v interface{}) {
</a><a href="#h82-0-136" id="h82-0-136" class="i">+	switch n := v.(type) {
</a><a href="#h82-0-137" id="h82-0-137" class="i">+	case int:
</a><a href="#h82-0-138" id="h82-0-138" class="i">+		c.buf = strconv.AppendInt(c.buf, int64(n), 10)
</a><a href="#h82-0-139" id="h82-0-139" class="i">+	case uint:
</a><a href="#h82-0-140" id="h82-0-140" class="i">+		c.buf = strconv.AppendUint(c.buf, uint64(n), 10)
</a><a href="#h82-0-141" id="h82-0-141" class="i">+	case int64:
</a><a href="#h82-0-142" id="h82-0-142" class="i">+		c.buf = strconv.AppendInt(c.buf, n, 10)
</a><a href="#h82-0-143" id="h82-0-143" class="i">+	case uint64:
</a><a href="#h82-0-144" id="h82-0-144" class="i">+		c.buf = strconv.AppendUint(c.buf, n, 10)
</a><a href="#h82-0-145" id="h82-0-145" class="i">+	case int32:
</a><a href="#h82-0-146" id="h82-0-146" class="i">+		c.buf = strconv.AppendInt(c.buf, int64(n), 10)
</a><a href="#h82-0-147" id="h82-0-147" class="i">+	case uint32:
</a><a href="#h82-0-148" id="h82-0-148" class="i">+		c.buf = strconv.AppendUint(c.buf, uint64(n), 10)
</a><a href="#h82-0-149" id="h82-0-149" class="i">+	case int16:
</a><a href="#h82-0-150" id="h82-0-150" class="i">+		c.buf = strconv.AppendInt(c.buf, int64(n), 10)
</a><a href="#h82-0-151" id="h82-0-151" class="i">+	case uint16:
</a><a href="#h82-0-152" id="h82-0-152" class="i">+		c.buf = strconv.AppendUint(c.buf, uint64(n), 10)
</a><a href="#h82-0-153" id="h82-0-153" class="i">+	case int8:
</a><a href="#h82-0-154" id="h82-0-154" class="i">+		c.buf = strconv.AppendInt(c.buf, int64(n), 10)
</a><a href="#h82-0-155" id="h82-0-155" class="i">+	case uint8:
</a><a href="#h82-0-156" id="h82-0-156" class="i">+		c.buf = strconv.AppendUint(c.buf, uint64(n), 10)
</a><a href="#h82-0-157" id="h82-0-157" class="i">+	case float64:
</a><a href="#h82-0-158" id="h82-0-158" class="i">+		c.buf = strconv.AppendFloat(c.buf, n, &#39;f&#39;, -1, 64)
</a><a href="#h82-0-159" id="h82-0-159" class="i">+	case float32:
</a><a href="#h82-0-160" id="h82-0-160" class="i">+		c.buf = strconv.AppendFloat(c.buf, float64(n), &#39;f&#39;, -1, 32)
</a><a href="#h82-0-161" id="h82-0-161" class="i">+	}
</a><a href="#h82-0-162" id="h82-0-162" class="i">+}
</a><a href="#h82-0-163" id="h82-0-163" class="i">+
</a><a href="#h82-0-164" id="h82-0-164" class="i">+func isNegative(v interface{}) bool {
</a><a href="#h82-0-165" id="h82-0-165" class="i">+	switch n := v.(type) {
</a><a href="#h82-0-166" id="h82-0-166" class="i">+	case int:
</a><a href="#h82-0-167" id="h82-0-167" class="i">+		return n &lt; 0
</a><a href="#h82-0-168" id="h82-0-168" class="i">+	case uint:
</a><a href="#h82-0-169" id="h82-0-169" class="i">+		return n &lt; 0
</a><a href="#h82-0-170" id="h82-0-170" class="i">+	case int64:
</a><a href="#h82-0-171" id="h82-0-171" class="i">+		return n &lt; 0
</a><a href="#h82-0-172" id="h82-0-172" class="i">+	case uint64:
</a><a href="#h82-0-173" id="h82-0-173" class="i">+		return n &lt; 0
</a><a href="#h82-0-174" id="h82-0-174" class="i">+	case int32:
</a><a href="#h82-0-175" id="h82-0-175" class="i">+		return n &lt; 0
</a><a href="#h82-0-176" id="h82-0-176" class="i">+	case uint32:
</a><a href="#h82-0-177" id="h82-0-177" class="i">+		return n &lt; 0
</a><a href="#h82-0-178" id="h82-0-178" class="i">+	case int16:
</a><a href="#h82-0-179" id="h82-0-179" class="i">+		return n &lt; 0
</a><a href="#h82-0-180" id="h82-0-180" class="i">+	case uint16:
</a><a href="#h82-0-181" id="h82-0-181" class="i">+		return n &lt; 0
</a><a href="#h82-0-182" id="h82-0-182" class="i">+	case int8:
</a><a href="#h82-0-183" id="h82-0-183" class="i">+		return n &lt; 0
</a><a href="#h82-0-184" id="h82-0-184" class="i">+	case uint8:
</a><a href="#h82-0-185" id="h82-0-185" class="i">+		return n &lt; 0
</a><a href="#h82-0-186" id="h82-0-186" class="i">+	case float64:
</a><a href="#h82-0-187" id="h82-0-187" class="i">+		return n &lt; 0
</a><a href="#h82-0-188" id="h82-0-188" class="i">+	case float32:
</a><a href="#h82-0-189" id="h82-0-189" class="i">+		return n &lt; 0
</a><a href="#h82-0-190" id="h82-0-190" class="i">+	}
</a><a href="#h82-0-191" id="h82-0-191" class="i">+	return false
</a><a href="#h82-0-192" id="h82-0-192" class="i">+}
</a><a href="#h82-0-193" id="h82-0-193" class="i">+
</a><a href="#h82-0-194" id="h82-0-194" class="i">+func (c *conn) appendBucket(prefix, bucket string, tags string) {
</a><a href="#h82-0-195" id="h82-0-195" class="i">+	c.appendString(prefix)
</a><a href="#h82-0-196" id="h82-0-196" class="i">+	c.appendString(bucket)
</a><a href="#h82-0-197" id="h82-0-197" class="i">+	if c.tagFormat == InfluxDB {
</a><a href="#h82-0-198" id="h82-0-198" class="i">+		c.appendString(tags)
</a><a href="#h82-0-199" id="h82-0-199" class="i">+	}
</a><a href="#h82-0-200" id="h82-0-200" class="i">+	c.appendByte(&#39;:&#39;)
</a><a href="#h82-0-201" id="h82-0-201" class="i">+}
</a><a href="#h82-0-202" id="h82-0-202" class="i">+
</a><a href="#h82-0-203" id="h82-0-203" class="i">+func (c *conn) appendType(t string) {
</a><a href="#h82-0-204" id="h82-0-204" class="i">+	c.appendByte(&#39;|&#39;)
</a><a href="#h82-0-205" id="h82-0-205" class="i">+	c.appendString(t)
</a><a href="#h82-0-206" id="h82-0-206" class="i">+}
</a><a href="#h82-0-207" id="h82-0-207" class="i">+
</a><a href="#h82-0-208" id="h82-0-208" class="i">+func (c *conn) appendRate(rate float32) {
</a><a href="#h82-0-209" id="h82-0-209" class="i">+	if rate == 1 {
</a><a href="#h82-0-210" id="h82-0-210" class="i">+		return
</a><a href="#h82-0-211" id="h82-0-211" class="i">+	}
</a><a href="#h82-0-212" id="h82-0-212" class="i">+	if c.rateCache == nil {
</a><a href="#h82-0-213" id="h82-0-213" class="i">+		c.rateCache = make(map[float32]string)
</a><a href="#h82-0-214" id="h82-0-214" class="i">+	}
</a><a href="#h82-0-215" id="h82-0-215" class="i">+
</a><a href="#h82-0-216" id="h82-0-216" class="i">+	c.appendString(&quot;|@&quot;)
</a><a href="#h82-0-217" id="h82-0-217" class="i">+	if s, ok := c.rateCache[rate]; ok {
</a><a href="#h82-0-218" id="h82-0-218" class="i">+		c.appendString(s)
</a><a href="#h82-0-219" id="h82-0-219" class="i">+	} else {
</a><a href="#h82-0-220" id="h82-0-220" class="i">+		s = strconv.FormatFloat(float64(rate), &#39;f&#39;, -1, 32)
</a><a href="#h82-0-221" id="h82-0-221" class="i">+		c.rateCache[rate] = s
</a><a href="#h82-0-222" id="h82-0-222" class="i">+		c.appendString(s)
</a><a href="#h82-0-223" id="h82-0-223" class="i">+	}
</a><a href="#h82-0-224" id="h82-0-224" class="i">+}
</a><a href="#h82-0-225" id="h82-0-225" class="i">+
</a><a href="#h82-0-226" id="h82-0-226" class="i">+func (c *conn) closeMetric(tags string) {
</a><a href="#h82-0-227" id="h82-0-227" class="i">+	if c.tagFormat == Datadog {
</a><a href="#h82-0-228" id="h82-0-228" class="i">+		c.appendString(tags)
</a><a href="#h82-0-229" id="h82-0-229" class="i">+	}
</a><a href="#h82-0-230" id="h82-0-230" class="i">+	c.appendByte(&#39;\n&#39;)
</a><a href="#h82-0-231" id="h82-0-231" class="i">+}
</a><a href="#h82-0-232" id="h82-0-232" class="i">+
</a><a href="#h82-0-233" id="h82-0-233" class="i">+func (c *conn) flushIfBufferFull(lastSafeLen int) {
</a><a href="#h82-0-234" id="h82-0-234" class="i">+	if len(c.buf) &gt; c.maxPacketSize {
</a><a href="#h82-0-235" id="h82-0-235" class="i">+		c.flush(lastSafeLen)
</a><a href="#h82-0-236" id="h82-0-236" class="i">+	}
</a><a href="#h82-0-237" id="h82-0-237" class="i">+}
</a><a href="#h82-0-238" id="h82-0-238" class="i">+
</a><a href="#h82-0-239" id="h82-0-239" class="i">+// flush flushes the first n bytes of the buffer.
</a><a href="#h82-0-240" id="h82-0-240" class="i">+// If n is 0, the whole buffer is flushed.
</a><a href="#h82-0-241" id="h82-0-241" class="i">+func (c *conn) flush(n int) {
</a><a href="#h82-0-242" id="h82-0-242" class="i">+	if len(c.buf) == 0 {
</a><a href="#h82-0-243" id="h82-0-243" class="i">+		return
</a><a href="#h82-0-244" id="h82-0-244" class="i">+	}
</a><a href="#h82-0-245" id="h82-0-245" class="i">+	if n == 0 {
</a><a href="#h82-0-246" id="h82-0-246" class="i">+		n = len(c.buf)
</a><a href="#h82-0-247" id="h82-0-247" class="i">+	}
</a><a href="#h82-0-248" id="h82-0-248" class="i">+
</a><a href="#h82-0-249" id="h82-0-249" class="i">+	// Trim the last \n, StatsD does not like it.
</a><a href="#h82-0-250" id="h82-0-250" class="i">+	_, err := c.w.Write(c.buf[:n-1])
</a><a href="#h82-0-251" id="h82-0-251" class="i">+	c.handleError(err)
</a><a href="#h82-0-252" id="h82-0-252" class="i">+	if n &lt; len(c.buf) {
</a><a href="#h82-0-253" id="h82-0-253" class="i">+		copy(c.buf, c.buf[n:])
</a><a href="#h82-0-254" id="h82-0-254" class="i">+	}
</a><a href="#h82-0-255" id="h82-0-255" class="i">+	c.buf = c.buf[:len(c.buf)-n]
</a><a href="#h82-0-256" id="h82-0-256" class="i">+}
</a><a href="#h82-0-257" id="h82-0-257" class="i">+
</a><a href="#h82-0-258" id="h82-0-258" class="i">+func (c *conn) handleError(err error) {
</a><a href="#h82-0-259" id="h82-0-259" class="i">+	if err != nil &amp;&amp; c.errorHandler != nil {
</a><a href="#h82-0-260" id="h82-0-260" class="i">+		c.errorHandler(err)
</a><a href="#h82-0-261" id="h82-0-261" class="i">+	}
</a><a href="#h82-0-262" id="h82-0-262" class="i">+}
</a><a href="#h82-0-263" id="h82-0-263" class="i">+
</a><a href="#h82-0-264" id="h82-0-264" class="i">+// Stubbed out for testing.
</a><a href="#h82-0-265" id="h82-0-265" class="i">+var (
</a><a href="#h82-0-266" id="h82-0-266" class="i">+	dialTimeout = net.DialTimeout
</a><a href="#h82-0-267" id="h82-0-267" class="i">+	now         = time.Now
</a><a href="#h82-0-268" id="h82-0-268" class="i">+	randFloat   = rand.Float32
</a><a href="#h82-0-269" id="h82-0-269" class="i">+)
</a><b>diff --git a/<a id="h83" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/doc.go">vendor/gopkg.in/alexcesaro/statsd.v2/doc.go</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/doc.go">vendor/gopkg.in/alexcesaro/statsd.v2/doc.go</a></b>
<a href="#h83-0" id="h83-0" class="h">@@ -0,0 +1,29 @@
</a><a href="#h83-0-0" id="h83-0-0" class="i">+/*
</a><a href="#h83-0-1" id="h83-0-1" class="i">+Package statsd is a simple and efficient StatsD client.
</a><a href="#h83-0-2" id="h83-0-2" class="i">+
</a><a href="#h83-0-3" id="h83-0-3" class="i">+
</a><a href="#h83-0-4" id="h83-0-4" class="i">+Options
</a><a href="#h83-0-5" id="h83-0-5" class="i">+
</a><a href="#h83-0-6" id="h83-0-6" class="i">+Use options to configure the Client: target host/port, sampling rate, tags, etc.
</a><a href="#h83-0-7" id="h83-0-7" class="i">+
</a><a href="#h83-0-8" id="h83-0-8" class="i">+Whenever you want to use different options (e.g. other tags, different sampling
</a><a href="#h83-0-9" id="h83-0-9" class="i">+rate), you should use the Clone() method of the Client.
</a><a href="#h83-0-10" id="h83-0-10" class="i">+
</a><a href="#h83-0-11" id="h83-0-11" class="i">+Because when cloning a Client, the same connection is reused so this is way
</a><a href="#h83-0-12" id="h83-0-12" class="i">+cheaper and more efficient than creating another Client using New().
</a><a href="#h83-0-13" id="h83-0-13" class="i">+
</a><a href="#h83-0-14" id="h83-0-14" class="i">+
</a><a href="#h83-0-15" id="h83-0-15" class="i">+Internals
</a><a href="#h83-0-16" id="h83-0-16" class="i">+
</a><a href="#h83-0-17" id="h83-0-17" class="i">+Client&#39;s methods buffer metrics. The buffer is flushed when either:
</a><a href="#h83-0-18" id="h83-0-18" class="i">+ - the background goroutine flushes the buffer (every 100ms by default)
</a><a href="#h83-0-19" id="h83-0-19" class="i">+ - the buffer is full (1440 bytes by default so that IP packets are not
</a><a href="#h83-0-20" id="h83-0-20" class="i">+   fragmented)
</a><a href="#h83-0-21" id="h83-0-21" class="i">+
</a><a href="#h83-0-22" id="h83-0-22" class="i">+The background goroutine can be disabled using the FlushPeriod(0) option.
</a><a href="#h83-0-23" id="h83-0-23" class="i">+
</a><a href="#h83-0-24" id="h83-0-24" class="i">+Buffering can be disabled using the MaxPacketSize(0) option.
</a><a href="#h83-0-25" id="h83-0-25" class="i">+
</a><a href="#h83-0-26" id="h83-0-26" class="i">+StatsD homepage: https://github.com/etsy/statsd
</a><a href="#h83-0-27" id="h83-0-27" class="i">+*/
</a><a href="#h83-0-28" id="h83-0-28" class="i">+package statsd
</a><b>diff --git a/<a id="h84" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/options.go">vendor/gopkg.in/alexcesaro/statsd.v2/options.go</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/options.go">vendor/gopkg.in/alexcesaro/statsd.v2/options.go</a></b>
<a href="#h84-0" id="h84-0" class="h">@@ -0,0 +1,250 @@
</a><a href="#h84-0-0" id="h84-0-0" class="i">+package statsd
</a><a href="#h84-0-1" id="h84-0-1" class="i">+
</a><a href="#h84-0-2" id="h84-0-2" class="i">+import (
</a><a href="#h84-0-3" id="h84-0-3" class="i">+	&quot;bytes&quot;
</a><a href="#h84-0-4" id="h84-0-4" class="i">+	&quot;strings&quot;
</a><a href="#h84-0-5" id="h84-0-5" class="i">+	&quot;time&quot;
</a><a href="#h84-0-6" id="h84-0-6" class="i">+)
</a><a href="#h84-0-7" id="h84-0-7" class="i">+
</a><a href="#h84-0-8" id="h84-0-8" class="i">+type config struct {
</a><a href="#h84-0-9" id="h84-0-9" class="i">+	Conn   connConfig
</a><a href="#h84-0-10" id="h84-0-10" class="i">+	Client clientConfig
</a><a href="#h84-0-11" id="h84-0-11" class="i">+}
</a><a href="#h84-0-12" id="h84-0-12" class="i">+
</a><a href="#h84-0-13" id="h84-0-13" class="i">+type clientConfig struct {
</a><a href="#h84-0-14" id="h84-0-14" class="i">+	Muted  bool
</a><a href="#h84-0-15" id="h84-0-15" class="i">+	Rate   float32
</a><a href="#h84-0-16" id="h84-0-16" class="i">+	Prefix string
</a><a href="#h84-0-17" id="h84-0-17" class="i">+	Tags   []tag
</a><a href="#h84-0-18" id="h84-0-18" class="i">+}
</a><a href="#h84-0-19" id="h84-0-19" class="i">+
</a><a href="#h84-0-20" id="h84-0-20" class="i">+type connConfig struct {
</a><a href="#h84-0-21" id="h84-0-21" class="i">+	Addr          string
</a><a href="#h84-0-22" id="h84-0-22" class="i">+	ErrorHandler  func(error)
</a><a href="#h84-0-23" id="h84-0-23" class="i">+	FlushPeriod   time.Duration
</a><a href="#h84-0-24" id="h84-0-24" class="i">+	MaxPacketSize int
</a><a href="#h84-0-25" id="h84-0-25" class="i">+	Network       string
</a><a href="#h84-0-26" id="h84-0-26" class="i">+	TagFormat     TagFormat
</a><a href="#h84-0-27" id="h84-0-27" class="i">+}
</a><a href="#h84-0-28" id="h84-0-28" class="i">+
</a><a href="#h84-0-29" id="h84-0-29" class="i">+// An Option represents an option for a Client. It must be used as an
</a><a href="#h84-0-30" id="h84-0-30" class="i">+// argument to New() or Client.Clone().
</a><a href="#h84-0-31" id="h84-0-31" class="i">+type Option func(*config)
</a><a href="#h84-0-32" id="h84-0-32" class="i">+
</a><a href="#h84-0-33" id="h84-0-33" class="i">+// Address sets the address of the StatsD daemon.
</a><a href="#h84-0-34" id="h84-0-34" class="i">+//
</a><a href="#h84-0-35" id="h84-0-35" class="i">+// By default, &quot;:8125&quot; is used. This option is ignored in Client.Clone().
</a><a href="#h84-0-36" id="h84-0-36" class="i">+func Address(addr string) Option {
</a><a href="#h84-0-37" id="h84-0-37" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-38" id="h84-0-38" class="i">+		c.Conn.Addr = addr
</a><a href="#h84-0-39" id="h84-0-39" class="i">+	})
</a><a href="#h84-0-40" id="h84-0-40" class="i">+}
</a><a href="#h84-0-41" id="h84-0-41" class="i">+
</a><a href="#h84-0-42" id="h84-0-42" class="i">+// ErrorHandler sets the function called when an error happens when sending
</a><a href="#h84-0-43" id="h84-0-43" class="i">+// metrics (e.g. the StatsD daemon is not listening anymore).
</a><a href="#h84-0-44" id="h84-0-44" class="i">+//
</a><a href="#h84-0-45" id="h84-0-45" class="i">+// By default, these errors are ignored.  This option is ignored in
</a><a href="#h84-0-46" id="h84-0-46" class="i">+// Client.Clone().
</a><a href="#h84-0-47" id="h84-0-47" class="i">+func ErrorHandler(h func(error)) Option {
</a><a href="#h84-0-48" id="h84-0-48" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-49" id="h84-0-49" class="i">+		c.Conn.ErrorHandler = h
</a><a href="#h84-0-50" id="h84-0-50" class="i">+	})
</a><a href="#h84-0-51" id="h84-0-51" class="i">+}
</a><a href="#h84-0-52" id="h84-0-52" class="i">+
</a><a href="#h84-0-53" id="h84-0-53" class="i">+// FlushPeriod sets how often the Client&#39;s buffer is flushed. If p is 0, the
</a><a href="#h84-0-54" id="h84-0-54" class="i">+// goroutine that periodically flush the buffer is not lauched and the buffer
</a><a href="#h84-0-55" id="h84-0-55" class="i">+// is only flushed when it is full.
</a><a href="#h84-0-56" id="h84-0-56" class="i">+//
</a><a href="#h84-0-57" id="h84-0-57" class="i">+// By default, the flush period is 100 ms.  This option is ignored in
</a><a href="#h84-0-58" id="h84-0-58" class="i">+// Client.Clone().
</a><a href="#h84-0-59" id="h84-0-59" class="i">+func FlushPeriod(p time.Duration) Option {
</a><a href="#h84-0-60" id="h84-0-60" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-61" id="h84-0-61" class="i">+		c.Conn.FlushPeriod = p
</a><a href="#h84-0-62" id="h84-0-62" class="i">+	})
</a><a href="#h84-0-63" id="h84-0-63" class="i">+}
</a><a href="#h84-0-64" id="h84-0-64" class="i">+
</a><a href="#h84-0-65" id="h84-0-65" class="i">+// MaxPacketSize sets the maximum packet size in bytes sent by the Client.
</a><a href="#h84-0-66" id="h84-0-66" class="i">+//
</a><a href="#h84-0-67" id="h84-0-67" class="i">+// By default, it is 1440 to avoid IP fragmentation. This option is ignored in
</a><a href="#h84-0-68" id="h84-0-68" class="i">+// Client.Clone().
</a><a href="#h84-0-69" id="h84-0-69" class="i">+func MaxPacketSize(n int) Option {
</a><a href="#h84-0-70" id="h84-0-70" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-71" id="h84-0-71" class="i">+		c.Conn.MaxPacketSize = n
</a><a href="#h84-0-72" id="h84-0-72" class="i">+	})
</a><a href="#h84-0-73" id="h84-0-73" class="i">+}
</a><a href="#h84-0-74" id="h84-0-74" class="i">+
</a><a href="#h84-0-75" id="h84-0-75" class="i">+// Network sets the network (udp, tcp, etc) used by the client. See the
</a><a href="#h84-0-76" id="h84-0-76" class="i">+// net.Dial documentation (https://golang.org/pkg/net/#Dial) for the available
</a><a href="#h84-0-77" id="h84-0-77" class="i">+// network options.
</a><a href="#h84-0-78" id="h84-0-78" class="i">+//
</a><a href="#h84-0-79" id="h84-0-79" class="i">+// By default, network is udp. This option is ignored in Client.Clone().
</a><a href="#h84-0-80" id="h84-0-80" class="i">+func Network(network string) Option {
</a><a href="#h84-0-81" id="h84-0-81" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-82" id="h84-0-82" class="i">+		c.Conn.Network = network
</a><a href="#h84-0-83" id="h84-0-83" class="i">+	})
</a><a href="#h84-0-84" id="h84-0-84" class="i">+}
</a><a href="#h84-0-85" id="h84-0-85" class="i">+
</a><a href="#h84-0-86" id="h84-0-86" class="i">+// Mute sets whether the Client is muted. All methods of a muted Client do
</a><a href="#h84-0-87" id="h84-0-87" class="i">+// nothing and return immedialtly.
</a><a href="#h84-0-88" id="h84-0-88" class="i">+//
</a><a href="#h84-0-89" id="h84-0-89" class="i">+// This option can be used in Client.Clone() only if the parent Client is not
</a><a href="#h84-0-90" id="h84-0-90" class="i">+// muted. The clones of a muted Client are always muted.
</a><a href="#h84-0-91" id="h84-0-91" class="i">+func Mute(b bool) Option {
</a><a href="#h84-0-92" id="h84-0-92" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-93" id="h84-0-93" class="i">+		c.Client.Muted = b
</a><a href="#h84-0-94" id="h84-0-94" class="i">+	})
</a><a href="#h84-0-95" id="h84-0-95" class="i">+}
</a><a href="#h84-0-96" id="h84-0-96" class="i">+
</a><a href="#h84-0-97" id="h84-0-97" class="i">+// SampleRate sets the sample rate of the Client. It allows sending the metrics
</a><a href="#h84-0-98" id="h84-0-98" class="i">+// less often which can be useful for performance intensive code paths.
</a><a href="#h84-0-99" id="h84-0-99" class="i">+func SampleRate(rate float32) Option {
</a><a href="#h84-0-100" id="h84-0-100" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-101" id="h84-0-101" class="i">+		c.Client.Rate = rate
</a><a href="#h84-0-102" id="h84-0-102" class="i">+	})
</a><a href="#h84-0-103" id="h84-0-103" class="i">+}
</a><a href="#h84-0-104" id="h84-0-104" class="i">+
</a><a href="#h84-0-105" id="h84-0-105" class="i">+// Prefix appends the prefix that will be used in every bucket name.
</a><a href="#h84-0-106" id="h84-0-106" class="i">+//
</a><a href="#h84-0-107" id="h84-0-107" class="i">+// Note that when used in cloned, the prefix of the parent Client is not
</a><a href="#h84-0-108" id="h84-0-108" class="i">+// replaced but is prepended to the given prefix.
</a><a href="#h84-0-109" id="h84-0-109" class="i">+func Prefix(p string) Option {
</a><a href="#h84-0-110" id="h84-0-110" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-111" id="h84-0-111" class="i">+		c.Client.Prefix += strings.TrimSuffix(p, &quot;.&quot;) + &quot;.&quot;
</a><a href="#h84-0-112" id="h84-0-112" class="i">+	})
</a><a href="#h84-0-113" id="h84-0-113" class="i">+}
</a><a href="#h84-0-114" id="h84-0-114" class="i">+
</a><a href="#h84-0-115" id="h84-0-115" class="i">+// TagFormat represents the format of tags sent by a Client.
</a><a href="#h84-0-116" id="h84-0-116" class="i">+type TagFormat uint8
</a><a href="#h84-0-117" id="h84-0-117" class="i">+
</a><a href="#h84-0-118" id="h84-0-118" class="i">+// TagsFormat sets the format of tags.
</a><a href="#h84-0-119" id="h84-0-119" class="i">+func TagsFormat(tf TagFormat) Option {
</a><a href="#h84-0-120" id="h84-0-120" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-121" id="h84-0-121" class="i">+		c.Conn.TagFormat = tf
</a><a href="#h84-0-122" id="h84-0-122" class="i">+	})
</a><a href="#h84-0-123" id="h84-0-123" class="i">+}
</a><a href="#h84-0-124" id="h84-0-124" class="i">+
</a><a href="#h84-0-125" id="h84-0-125" class="i">+// Tags appends the given tags to the tags sent with every metrics. If a tag
</a><a href="#h84-0-126" id="h84-0-126" class="i">+// already exists, it is replaced.
</a><a href="#h84-0-127" id="h84-0-127" class="i">+//
</a><a href="#h84-0-128" id="h84-0-128" class="i">+// The tags must be set as key-value pairs. If the number of tags is not even,
</a><a href="#h84-0-129" id="h84-0-129" class="i">+// Tags panics.
</a><a href="#h84-0-130" id="h84-0-130" class="i">+//
</a><a href="#h84-0-131" id="h84-0-131" class="i">+// If the format of tags have not been set using the TagsFormat option, the tags
</a><a href="#h84-0-132" id="h84-0-132" class="i">+// will be ignored.
</a><a href="#h84-0-133" id="h84-0-133" class="i">+func Tags(tags ...string) Option {
</a><a href="#h84-0-134" id="h84-0-134" class="i">+	if len(tags)%2 != 0 {
</a><a href="#h84-0-135" id="h84-0-135" class="i">+		panic(&quot;statsd: Tags only accepts an even number of arguments&quot;)
</a><a href="#h84-0-136" id="h84-0-136" class="i">+	}
</a><a href="#h84-0-137" id="h84-0-137" class="i">+
</a><a href="#h84-0-138" id="h84-0-138" class="i">+	return Option(func(c *config) {
</a><a href="#h84-0-139" id="h84-0-139" class="i">+		if len(tags) == 0 {
</a><a href="#h84-0-140" id="h84-0-140" class="i">+			return
</a><a href="#h84-0-141" id="h84-0-141" class="i">+		}
</a><a href="#h84-0-142" id="h84-0-142" class="i">+
</a><a href="#h84-0-143" id="h84-0-143" class="i">+		newTags := make([]tag, len(tags)/2)
</a><a href="#h84-0-144" id="h84-0-144" class="i">+		for i := 0; i &lt; len(tags)/2; i++ {
</a><a href="#h84-0-145" id="h84-0-145" class="i">+			newTags[i] = tag{K: tags[2*i], V: tags[2*i+1]}
</a><a href="#h84-0-146" id="h84-0-146" class="i">+		}
</a><a href="#h84-0-147" id="h84-0-147" class="i">+
</a><a href="#h84-0-148" id="h84-0-148" class="i">+		for _, newTag := range newTags {
</a><a href="#h84-0-149" id="h84-0-149" class="i">+			exists := false
</a><a href="#h84-0-150" id="h84-0-150" class="i">+			for _, oldTag := range c.Client.Tags {
</a><a href="#h84-0-151" id="h84-0-151" class="i">+				if newTag.K == oldTag.K {
</a><a href="#h84-0-152" id="h84-0-152" class="i">+					exists = true
</a><a href="#h84-0-153" id="h84-0-153" class="i">+					oldTag.V = newTag.V
</a><a href="#h84-0-154" id="h84-0-154" class="i">+				}
</a><a href="#h84-0-155" id="h84-0-155" class="i">+			}
</a><a href="#h84-0-156" id="h84-0-156" class="i">+			if !exists {
</a><a href="#h84-0-157" id="h84-0-157" class="i">+				c.Client.Tags = append(c.Client.Tags, tag{
</a><a href="#h84-0-158" id="h84-0-158" class="i">+					K: newTag.K,
</a><a href="#h84-0-159" id="h84-0-159" class="i">+					V: newTag.V,
</a><a href="#h84-0-160" id="h84-0-160" class="i">+				})
</a><a href="#h84-0-161" id="h84-0-161" class="i">+			}
</a><a href="#h84-0-162" id="h84-0-162" class="i">+		}
</a><a href="#h84-0-163" id="h84-0-163" class="i">+	})
</a><a href="#h84-0-164" id="h84-0-164" class="i">+}
</a><a href="#h84-0-165" id="h84-0-165" class="i">+
</a><a href="#h84-0-166" id="h84-0-166" class="i">+type tag struct {
</a><a href="#h84-0-167" id="h84-0-167" class="i">+	K, V string
</a><a href="#h84-0-168" id="h84-0-168" class="i">+}
</a><a href="#h84-0-169" id="h84-0-169" class="i">+
</a><a href="#h84-0-170" id="h84-0-170" class="i">+func joinTags(tf TagFormat, tags []tag) string {
</a><a href="#h84-0-171" id="h84-0-171" class="i">+	if len(tags) == 0 || tf == 0 {
</a><a href="#h84-0-172" id="h84-0-172" class="i">+		return &quot;&quot;
</a><a href="#h84-0-173" id="h84-0-173" class="i">+	}
</a><a href="#h84-0-174" id="h84-0-174" class="i">+	join := joinFuncs[tf]
</a><a href="#h84-0-175" id="h84-0-175" class="i">+	return join(tags)
</a><a href="#h84-0-176" id="h84-0-176" class="i">+}
</a><a href="#h84-0-177" id="h84-0-177" class="i">+
</a><a href="#h84-0-178" id="h84-0-178" class="i">+func splitTags(tf TagFormat, tags string) []tag {
</a><a href="#h84-0-179" id="h84-0-179" class="i">+	if len(tags) == 0 || tf == 0 {
</a><a href="#h84-0-180" id="h84-0-180" class="i">+		return nil
</a><a href="#h84-0-181" id="h84-0-181" class="i">+	}
</a><a href="#h84-0-182" id="h84-0-182" class="i">+	split := splitFuncs[tf]
</a><a href="#h84-0-183" id="h84-0-183" class="i">+	return split(tags)
</a><a href="#h84-0-184" id="h84-0-184" class="i">+}
</a><a href="#h84-0-185" id="h84-0-185" class="i">+
</a><a href="#h84-0-186" id="h84-0-186" class="i">+const (
</a><a href="#h84-0-187" id="h84-0-187" class="i">+	// InfluxDB tag format.
</a><a href="#h84-0-188" id="h84-0-188" class="i">+	// See https://influxdb.com/blog/2015/11/03/getting_started_with_influx_statsd.html
</a><a href="#h84-0-189" id="h84-0-189" class="i">+	InfluxDB TagFormat = iota + 1
</a><a href="#h84-0-190" id="h84-0-190" class="i">+	// Datadog tag format.
</a><a href="#h84-0-191" id="h84-0-191" class="i">+	// See http://docs.datadoghq.com/guides/metrics/#tags
</a><a href="#h84-0-192" id="h84-0-192" class="i">+	Datadog
</a><a href="#h84-0-193" id="h84-0-193" class="i">+)
</a><a href="#h84-0-194" id="h84-0-194" class="i">+
</a><a href="#h84-0-195" id="h84-0-195" class="i">+var (
</a><a href="#h84-0-196" id="h84-0-196" class="i">+	joinFuncs = map[TagFormat]func([]tag) string{
</a><a href="#h84-0-197" id="h84-0-197" class="i">+		// InfluxDB tag format: ,tag1=payroll,region=us-west
</a><a href="#h84-0-198" id="h84-0-198" class="i">+		// https://influxdb.com/blog/2015/11/03/getting_started_with_influx_statsd.html
</a><a href="#h84-0-199" id="h84-0-199" class="i">+		InfluxDB: func(tags []tag) string {
</a><a href="#h84-0-200" id="h84-0-200" class="i">+			var buf bytes.Buffer
</a><a href="#h84-0-201" id="h84-0-201" class="i">+			for _, tag := range tags {
</a><a href="#h84-0-202" id="h84-0-202" class="i">+				_ = buf.WriteByte(&#39;,&#39;)
</a><a href="#h84-0-203" id="h84-0-203" class="i">+				_, _ = buf.WriteString(tag.K)
</a><a href="#h84-0-204" id="h84-0-204" class="i">+				_ = buf.WriteByte(&#39;=&#39;)
</a><a href="#h84-0-205" id="h84-0-205" class="i">+				_, _ = buf.WriteString(tag.V)
</a><a href="#h84-0-206" id="h84-0-206" class="i">+			}
</a><a href="#h84-0-207" id="h84-0-207" class="i">+			return buf.String()
</a><a href="#h84-0-208" id="h84-0-208" class="i">+		},
</a><a href="#h84-0-209" id="h84-0-209" class="i">+		// Datadog tag format: |#tag1:value1,tag2:value2
</a><a href="#h84-0-210" id="h84-0-210" class="i">+		// http://docs.datadoghq.com/guides/dogstatsd/#datagram-format
</a><a href="#h84-0-211" id="h84-0-211" class="i">+		Datadog: func(tags []tag) string {
</a><a href="#h84-0-212" id="h84-0-212" class="i">+			buf := bytes.NewBufferString(&quot;|#&quot;)
</a><a href="#h84-0-213" id="h84-0-213" class="i">+			first := true
</a><a href="#h84-0-214" id="h84-0-214" class="i">+			for _, tag := range tags {
</a><a href="#h84-0-215" id="h84-0-215" class="i">+				if first {
</a><a href="#h84-0-216" id="h84-0-216" class="i">+					first = false
</a><a href="#h84-0-217" id="h84-0-217" class="i">+				} else {
</a><a href="#h84-0-218" id="h84-0-218" class="i">+					_ = buf.WriteByte(&#39;,&#39;)
</a><a href="#h84-0-219" id="h84-0-219" class="i">+				}
</a><a href="#h84-0-220" id="h84-0-220" class="i">+				_, _ = buf.WriteString(tag.K)
</a><a href="#h84-0-221" id="h84-0-221" class="i">+				_ = buf.WriteByte(&#39;:&#39;)
</a><a href="#h84-0-222" id="h84-0-222" class="i">+				_, _ = buf.WriteString(tag.V)
</a><a href="#h84-0-223" id="h84-0-223" class="i">+			}
</a><a href="#h84-0-224" id="h84-0-224" class="i">+			return buf.String()
</a><a href="#h84-0-225" id="h84-0-225" class="i">+		},
</a><a href="#h84-0-226" id="h84-0-226" class="i">+	}
</a><a href="#h84-0-227" id="h84-0-227" class="i">+	splitFuncs = map[TagFormat]func(string) []tag{
</a><a href="#h84-0-228" id="h84-0-228" class="i">+		InfluxDB: func(s string) []tag {
</a><a href="#h84-0-229" id="h84-0-229" class="i">+			s = s[1:]
</a><a href="#h84-0-230" id="h84-0-230" class="i">+			pairs := strings.Split(s, &quot;,&quot;)
</a><a href="#h84-0-231" id="h84-0-231" class="i">+			tags := make([]tag, len(pairs))
</a><a href="#h84-0-232" id="h84-0-232" class="i">+			for i, pair := range pairs {
</a><a href="#h84-0-233" id="h84-0-233" class="i">+				kv := strings.Split(pair, &quot;=&quot;)
</a><a href="#h84-0-234" id="h84-0-234" class="i">+				tags[i] = tag{K: kv[0], V: kv[1]}
</a><a href="#h84-0-235" id="h84-0-235" class="i">+			}
</a><a href="#h84-0-236" id="h84-0-236" class="i">+			return tags
</a><a href="#h84-0-237" id="h84-0-237" class="i">+		},
</a><a href="#h84-0-238" id="h84-0-238" class="i">+		Datadog: func(s string) []tag {
</a><a href="#h84-0-239" id="h84-0-239" class="i">+			s = s[2:]
</a><a href="#h84-0-240" id="h84-0-240" class="i">+			pairs := strings.Split(s, &quot;,&quot;)
</a><a href="#h84-0-241" id="h84-0-241" class="i">+			tags := make([]tag, len(pairs))
</a><a href="#h84-0-242" id="h84-0-242" class="i">+			for i, pair := range pairs {
</a><a href="#h84-0-243" id="h84-0-243" class="i">+				kv := strings.Split(pair, &quot;:&quot;)
</a><a href="#h84-0-244" id="h84-0-244" class="i">+				tags[i] = tag{K: kv[0], V: kv[1]}
</a><a href="#h84-0-245" id="h84-0-245" class="i">+			}
</a><a href="#h84-0-246" id="h84-0-246" class="i">+			return tags
</a><a href="#h84-0-247" id="h84-0-247" class="i">+		},
</a><a href="#h84-0-248" id="h84-0-248" class="i">+	}
</a><a href="#h84-0-249" id="h84-0-249" class="i">+)
</a><b>diff --git a/<a id="h85" href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/statsd.go">vendor/gopkg.in/alexcesaro/statsd.v2/statsd.go</a> b/<a href="../file/vendor/gopkg.in/alexcesaro/statsd.v2/statsd.go">vendor/gopkg.in/alexcesaro/statsd.v2/statsd.go</a></b>
<a href="#h85-0" id="h85-0" class="h">@@ -0,0 +1,169 @@
</a><a href="#h85-0-0" id="h85-0-0" class="i">+package statsd
</a><a href="#h85-0-1" id="h85-0-1" class="i">+
</a><a href="#h85-0-2" id="h85-0-2" class="i">+import &quot;time&quot;
</a><a href="#h85-0-3" id="h85-0-3" class="i">+
</a><a href="#h85-0-4" id="h85-0-4" class="i">+// A Client represents a StatsD client.
</a><a href="#h85-0-5" id="h85-0-5" class="i">+type Client struct {
</a><a href="#h85-0-6" id="h85-0-6" class="i">+	conn   *conn
</a><a href="#h85-0-7" id="h85-0-7" class="i">+	muted  bool
</a><a href="#h85-0-8" id="h85-0-8" class="i">+	rate   float32
</a><a href="#h85-0-9" id="h85-0-9" class="i">+	prefix string
</a><a href="#h85-0-10" id="h85-0-10" class="i">+	tags   string
</a><a href="#h85-0-11" id="h85-0-11" class="i">+}
</a><a href="#h85-0-12" id="h85-0-12" class="i">+
</a><a href="#h85-0-13" id="h85-0-13" class="i">+// New returns a new Client.
</a><a href="#h85-0-14" id="h85-0-14" class="i">+func New(opts ...Option) (*Client, error) {
</a><a href="#h85-0-15" id="h85-0-15" class="i">+	// The default configuration.
</a><a href="#h85-0-16" id="h85-0-16" class="i">+	conf := &amp;config{
</a><a href="#h85-0-17" id="h85-0-17" class="i">+		Client: clientConfig{
</a><a href="#h85-0-18" id="h85-0-18" class="i">+			Rate: 1,
</a><a href="#h85-0-19" id="h85-0-19" class="i">+		},
</a><a href="#h85-0-20" id="h85-0-20" class="i">+		Conn: connConfig{
</a><a href="#h85-0-21" id="h85-0-21" class="i">+			Addr:        &quot;:8125&quot;,
</a><a href="#h85-0-22" id="h85-0-22" class="i">+			FlushPeriod: 100 * time.Millisecond,
</a><a href="#h85-0-23" id="h85-0-23" class="i">+			// Worst-case scenario:
</a><a href="#h85-0-24" id="h85-0-24" class="i">+			// Ethernet MTU - IPv6 Header - TCP Header = 1500 - 40 - 20 = 1440
</a><a href="#h85-0-25" id="h85-0-25" class="i">+			MaxPacketSize: 1440,
</a><a href="#h85-0-26" id="h85-0-26" class="i">+			Network:       &quot;udp&quot;,
</a><a href="#h85-0-27" id="h85-0-27" class="i">+		},
</a><a href="#h85-0-28" id="h85-0-28" class="i">+	}
</a><a href="#h85-0-29" id="h85-0-29" class="i">+	for _, o := range opts {
</a><a href="#h85-0-30" id="h85-0-30" class="i">+		o(conf)
</a><a href="#h85-0-31" id="h85-0-31" class="i">+	}
</a><a href="#h85-0-32" id="h85-0-32" class="i">+
</a><a href="#h85-0-33" id="h85-0-33" class="i">+	conn, err := newConn(conf.Conn, conf.Client.Muted)
</a><a href="#h85-0-34" id="h85-0-34" class="i">+	c := &amp;Client{
</a><a href="#h85-0-35" id="h85-0-35" class="i">+		conn:  conn,
</a><a href="#h85-0-36" id="h85-0-36" class="i">+		muted: conf.Client.Muted,
</a><a href="#h85-0-37" id="h85-0-37" class="i">+	}
</a><a href="#h85-0-38" id="h85-0-38" class="i">+	if err != nil {
</a><a href="#h85-0-39" id="h85-0-39" class="i">+		c.muted = true
</a><a href="#h85-0-40" id="h85-0-40" class="i">+		return c, err
</a><a href="#h85-0-41" id="h85-0-41" class="i">+	}
</a><a href="#h85-0-42" id="h85-0-42" class="i">+	c.rate = conf.Client.Rate
</a><a href="#h85-0-43" id="h85-0-43" class="i">+	c.prefix = conf.Client.Prefix
</a><a href="#h85-0-44" id="h85-0-44" class="i">+	c.tags = joinTags(conf.Conn.TagFormat, conf.Client.Tags)
</a><a href="#h85-0-45" id="h85-0-45" class="i">+	return c, nil
</a><a href="#h85-0-46" id="h85-0-46" class="i">+}
</a><a href="#h85-0-47" id="h85-0-47" class="i">+
</a><a href="#h85-0-48" id="h85-0-48" class="i">+// Clone returns a clone of the Client. The cloned Client inherits its
</a><a href="#h85-0-49" id="h85-0-49" class="i">+// configuration from its parent.
</a><a href="#h85-0-50" id="h85-0-50" class="i">+//
</a><a href="#h85-0-51" id="h85-0-51" class="i">+// All cloned Clients share the same connection, so cloning a Client is a cheap
</a><a href="#h85-0-52" id="h85-0-52" class="i">+// operation.
</a><a href="#h85-0-53" id="h85-0-53" class="i">+func (c *Client) Clone(opts ...Option) *Client {
</a><a href="#h85-0-54" id="h85-0-54" class="i">+	tf := c.conn.tagFormat
</a><a href="#h85-0-55" id="h85-0-55" class="i">+	conf := &amp;config{
</a><a href="#h85-0-56" id="h85-0-56" class="i">+		Client: clientConfig{
</a><a href="#h85-0-57" id="h85-0-57" class="i">+			Rate:   c.rate,
</a><a href="#h85-0-58" id="h85-0-58" class="i">+			Prefix: c.prefix,
</a><a href="#h85-0-59" id="h85-0-59" class="i">+			Tags:   splitTags(tf, c.tags),
</a><a href="#h85-0-60" id="h85-0-60" class="i">+		},
</a><a href="#h85-0-61" id="h85-0-61" class="i">+	}
</a><a href="#h85-0-62" id="h85-0-62" class="i">+	for _, o := range opts {
</a><a href="#h85-0-63" id="h85-0-63" class="i">+		o(conf)
</a><a href="#h85-0-64" id="h85-0-64" class="i">+	}
</a><a href="#h85-0-65" id="h85-0-65" class="i">+
</a><a href="#h85-0-66" id="h85-0-66" class="i">+	clone := &amp;Client{
</a><a href="#h85-0-67" id="h85-0-67" class="i">+		conn:   c.conn,
</a><a href="#h85-0-68" id="h85-0-68" class="i">+		muted:  c.muted || conf.Client.Muted,
</a><a href="#h85-0-69" id="h85-0-69" class="i">+		rate:   conf.Client.Rate,
</a><a href="#h85-0-70" id="h85-0-70" class="i">+		prefix: conf.Client.Prefix,
</a><a href="#h85-0-71" id="h85-0-71" class="i">+		tags:   joinTags(tf, conf.Client.Tags),
</a><a href="#h85-0-72" id="h85-0-72" class="i">+	}
</a><a href="#h85-0-73" id="h85-0-73" class="i">+	clone.conn = c.conn
</a><a href="#h85-0-74" id="h85-0-74" class="i">+	return clone
</a><a href="#h85-0-75" id="h85-0-75" class="i">+}
</a><a href="#h85-0-76" id="h85-0-76" class="i">+
</a><a href="#h85-0-77" id="h85-0-77" class="i">+// Count adds n to bucket.
</a><a href="#h85-0-78" id="h85-0-78" class="i">+func (c *Client) Count(bucket string, n interface{}) {
</a><a href="#h85-0-79" id="h85-0-79" class="i">+	if c.skip() {
</a><a href="#h85-0-80" id="h85-0-80" class="i">+		return
</a><a href="#h85-0-81" id="h85-0-81" class="i">+	}
</a><a href="#h85-0-82" id="h85-0-82" class="i">+	c.conn.metric(c.prefix, bucket, n, &quot;c&quot;, c.rate, c.tags)
</a><a href="#h85-0-83" id="h85-0-83" class="i">+}
</a><a href="#h85-0-84" id="h85-0-84" class="i">+
</a><a href="#h85-0-85" id="h85-0-85" class="i">+func (c *Client) skip() bool {
</a><a href="#h85-0-86" id="h85-0-86" class="i">+	return c.muted || (c.rate != 1 &amp;&amp; randFloat() &gt; c.rate)
</a><a href="#h85-0-87" id="h85-0-87" class="i">+}
</a><a href="#h85-0-88" id="h85-0-88" class="i">+
</a><a href="#h85-0-89" id="h85-0-89" class="i">+// Increment increment the given bucket. It is equivalent to Count(bucket, 1).
</a><a href="#h85-0-90" id="h85-0-90" class="i">+func (c *Client) Increment(bucket string) {
</a><a href="#h85-0-91" id="h85-0-91" class="i">+	c.Count(bucket, 1)
</a><a href="#h85-0-92" id="h85-0-92" class="i">+}
</a><a href="#h85-0-93" id="h85-0-93" class="i">+
</a><a href="#h85-0-94" id="h85-0-94" class="i">+// Gauge records an absolute value for the given bucket.
</a><a href="#h85-0-95" id="h85-0-95" class="i">+func (c *Client) Gauge(bucket string, value interface{}) {
</a><a href="#h85-0-96" id="h85-0-96" class="i">+	if c.skip() {
</a><a href="#h85-0-97" id="h85-0-97" class="i">+		return
</a><a href="#h85-0-98" id="h85-0-98" class="i">+	}
</a><a href="#h85-0-99" id="h85-0-99" class="i">+	c.conn.gauge(c.prefix, bucket, value, c.tags)
</a><a href="#h85-0-100" id="h85-0-100" class="i">+}
</a><a href="#h85-0-101" id="h85-0-101" class="i">+
</a><a href="#h85-0-102" id="h85-0-102" class="i">+// Timing sends a timing value to a bucket.
</a><a href="#h85-0-103" id="h85-0-103" class="i">+func (c *Client) Timing(bucket string, value interface{}) {
</a><a href="#h85-0-104" id="h85-0-104" class="i">+	if c.skip() {
</a><a href="#h85-0-105" id="h85-0-105" class="i">+		return
</a><a href="#h85-0-106" id="h85-0-106" class="i">+	}
</a><a href="#h85-0-107" id="h85-0-107" class="i">+	c.conn.metric(c.prefix, bucket, value, &quot;ms&quot;, c.rate, c.tags)
</a><a href="#h85-0-108" id="h85-0-108" class="i">+}
</a><a href="#h85-0-109" id="h85-0-109" class="i">+
</a><a href="#h85-0-110" id="h85-0-110" class="i">+// Histogram sends an histogram value to a bucket.
</a><a href="#h85-0-111" id="h85-0-111" class="i">+func (c *Client) Histogram(bucket string, value interface{}) {
</a><a href="#h85-0-112" id="h85-0-112" class="i">+	if c.skip() {
</a><a href="#h85-0-113" id="h85-0-113" class="i">+		return
</a><a href="#h85-0-114" id="h85-0-114" class="i">+	}
</a><a href="#h85-0-115" id="h85-0-115" class="i">+	c.conn.metric(c.prefix, bucket, value, &quot;h&quot;, c.rate, c.tags)
</a><a href="#h85-0-116" id="h85-0-116" class="i">+}
</a><a href="#h85-0-117" id="h85-0-117" class="i">+
</a><a href="#h85-0-118" id="h85-0-118" class="i">+// A Timing is an helper object that eases sending timing values.
</a><a href="#h85-0-119" id="h85-0-119" class="i">+type Timing struct {
</a><a href="#h85-0-120" id="h85-0-120" class="i">+	start time.Time
</a><a href="#h85-0-121" id="h85-0-121" class="i">+	c     *Client
</a><a href="#h85-0-122" id="h85-0-122" class="i">+}
</a><a href="#h85-0-123" id="h85-0-123" class="i">+
</a><a href="#h85-0-124" id="h85-0-124" class="i">+// NewTiming creates a new Timing.
</a><a href="#h85-0-125" id="h85-0-125" class="i">+func (c *Client) NewTiming() Timing {
</a><a href="#h85-0-126" id="h85-0-126" class="i">+	return Timing{start: now(), c: c}
</a><a href="#h85-0-127" id="h85-0-127" class="i">+}
</a><a href="#h85-0-128" id="h85-0-128" class="i">+
</a><a href="#h85-0-129" id="h85-0-129" class="i">+// Send sends the time elapsed since the creation of the Timing.
</a><a href="#h85-0-130" id="h85-0-130" class="i">+func (t Timing) Send(bucket string) {
</a><a href="#h85-0-131" id="h85-0-131" class="i">+	t.c.Timing(bucket, int(t.Duration()/time.Millisecond))
</a><a href="#h85-0-132" id="h85-0-132" class="i">+}
</a><a href="#h85-0-133" id="h85-0-133" class="i">+
</a><a href="#h85-0-134" id="h85-0-134" class="i">+// Duration returns the time elapsed since the creation of the Timing.
</a><a href="#h85-0-135" id="h85-0-135" class="i">+func (t Timing) Duration() time.Duration {
</a><a href="#h85-0-136" id="h85-0-136" class="i">+	return now().Sub(t.start)
</a><a href="#h85-0-137" id="h85-0-137" class="i">+}
</a><a href="#h85-0-138" id="h85-0-138" class="i">+
</a><a href="#h85-0-139" id="h85-0-139" class="i">+// Unique sends the given value to a set bucket.
</a><a href="#h85-0-140" id="h85-0-140" class="i">+func (c *Client) Unique(bucket string, value string) {
</a><a href="#h85-0-141" id="h85-0-141" class="i">+	if c.skip() {
</a><a href="#h85-0-142" id="h85-0-142" class="i">+		return
</a><a href="#h85-0-143" id="h85-0-143" class="i">+	}
</a><a href="#h85-0-144" id="h85-0-144" class="i">+	c.conn.unique(c.prefix, bucket, value, c.tags)
</a><a href="#h85-0-145" id="h85-0-145" class="i">+}
</a><a href="#h85-0-146" id="h85-0-146" class="i">+
</a><a href="#h85-0-147" id="h85-0-147" class="i">+// Flush flushes the Client&#39;s buffer.
</a><a href="#h85-0-148" id="h85-0-148" class="i">+func (c *Client) Flush() {
</a><a href="#h85-0-149" id="h85-0-149" class="i">+	if c.muted {
</a><a href="#h85-0-150" id="h85-0-150" class="i">+		return
</a><a href="#h85-0-151" id="h85-0-151" class="i">+	}
</a><a href="#h85-0-152" id="h85-0-152" class="i">+	c.conn.mu.Lock()
</a><a href="#h85-0-153" id="h85-0-153" class="i">+	c.conn.flush(0)
</a><a href="#h85-0-154" id="h85-0-154" class="i">+	c.conn.mu.Unlock()
</a><a href="#h85-0-155" id="h85-0-155" class="i">+}
</a><a href="#h85-0-156" id="h85-0-156" class="i">+
</a><a href="#h85-0-157" id="h85-0-157" class="i">+// Close flushes the Client&#39;s buffer and releases the associated ressources. The
</a><a href="#h85-0-158" id="h85-0-158" class="i">+// Client and all the cloned Clients must not be used afterward.
</a><a href="#h85-0-159" id="h85-0-159" class="i">+func (c *Client) Close() {
</a><a href="#h85-0-160" id="h85-0-160" class="i">+	if c.muted {
</a><a href="#h85-0-161" id="h85-0-161" class="i">+		return
</a><a href="#h85-0-162" id="h85-0-162" class="i">+	}
</a><a href="#h85-0-163" id="h85-0-163" class="i">+	c.conn.mu.Lock()
</a><a href="#h85-0-164" id="h85-0-164" class="i">+	c.conn.flush(0)
</a><a href="#h85-0-165" id="h85-0-165" class="i">+	c.conn.handleError(c.conn.w.Close())
</a><a href="#h85-0-166" id="h85-0-166" class="i">+	c.conn.closed = true
</a><a href="#h85-0-167" id="h85-0-167" class="i">+	c.conn.mu.Unlock()
</a><a href="#h85-0-168" id="h85-0-168" class="i">+}
</a><b>diff --git a/<a id="h86" href="../file/vendor/vendor.json">vendor/vendor.json</a> b/<a href="../file/vendor/vendor.json">vendor/vendor.json</a></b>
<a href="#h86-0" id="h86-0" class="h">@@ -3,12 +3,52 @@
</a> 	&quot;ignore&quot;: &quot;test&quot;,
 	&quot;package&quot;: [
 		{
<a href="#h86-0-3" id="h86-0-3" class="i">+			&quot;path&quot;: &quot;_m&quot;,
</a><a href="#h86-0-4" id="h86-0-4" class="i">+			&quot;revision&quot;: &quot;&quot;
</a><a href="#h86-0-5" id="h86-0-5" class="i">+		},
</a><a href="#h86-0-6" id="h86-0-6" class="i">+		{
</a><a href="#h86-0-7" id="h86-0-7" class="i">+			&quot;path&quot;: &quot;appengine&quot;,
</a><a href="#h86-0-8" id="h86-0-8" class="i">+			&quot;revision&quot;: &quot;&quot;
</a><a href="#h86-0-9" id="h86-0-9" class="i">+		},
</a><a href="#h86-0-10" id="h86-0-10" class="i">+		{
</a><a href="#h86-0-11" id="h86-0-11" class="i">+			&quot;path&quot;: &quot;appengine_internal&quot;,
</a><a href="#h86-0-12" id="h86-0-12" class="i">+			&quot;revision&quot;: &quot;&quot;
</a><a href="#h86-0-13" id="h86-0-13" class="i">+		},
</a><a href="#h86-0-14" id="h86-0-14" class="i">+		{
</a><a href="#h86-0-15" id="h86-0-15" class="i">+			&quot;path&quot;: &quot;appengine_internal/base&quot;,
</a><a href="#h86-0-16" id="h86-0-16" class="i">+			&quot;revision&quot;: &quot;&quot;
</a><a href="#h86-0-17" id="h86-0-17" class="i">+		},
</a><a href="#h86-0-18" id="h86-0-18" class="i">+		{
</a> 			&quot;checksumSHA1&quot;: &quot;AKjqgiWov1IJWbnpCkjVEs6NunQ=&quot;,
 			&quot;path&quot;: &quot;github.com/bmizerany/pat&quot;,
 			&quot;revision&quot;: &quot;c068ca2f0aacee5ac3681d68e4d0a003b7d1fd2c&quot;,
 			&quot;revisionTime&quot;: &quot;2016-02-17T10:30:50Z&quot;
 		},
 		{
<a href="#h86-0-25" id="h86-0-25" class="i">+			&quot;checksumSHA1&quot;: &quot;imR2wF388/0fBU6RRWx8RvTi8Q8=&quot;,
</a><a href="#h86-0-26" id="h86-0-26" class="i">+			&quot;path&quot;: &quot;github.com/facebookgo/clock&quot;,
</a><a href="#h86-0-27" id="h86-0-27" class="i">+			&quot;revision&quot;: &quot;600d898af40aa09a7a93ecb9265d87b0504b6f03&quot;,
</a><a href="#h86-0-28" id="h86-0-28" class="i">+			&quot;revisionTime&quot;: &quot;2015-04-10T01:09:13Z&quot;
</a><a href="#h86-0-29" id="h86-0-29" class="i">+		},
</a><a href="#h86-0-30" id="h86-0-30" class="i">+		{
</a><a href="#h86-0-31" id="h86-0-31" class="i">+			&quot;checksumSHA1&quot;: &quot;/jfkiemtHBkQcesTAtOso945hTY=&quot;,
</a><a href="#h86-0-32" id="h86-0-32" class="i">+			&quot;path&quot;: &quot;github.com/facebookgo/limitgroup&quot;,
</a><a href="#h86-0-33" id="h86-0-33" class="i">+			&quot;revision&quot;: &quot;6abd8d71ec01451d7f1929eacaa263bbe2935d05&quot;,
</a><a href="#h86-0-34" id="h86-0-34" class="i">+			&quot;revisionTime&quot;: &quot;2015-06-12T19:09:41Z&quot;
</a><a href="#h86-0-35" id="h86-0-35" class="i">+		},
</a><a href="#h86-0-36" id="h86-0-36" class="i">+		{
</a><a href="#h86-0-37" id="h86-0-37" class="i">+			&quot;checksumSHA1&quot;: &quot;6viCX3VLBaomwZukWCTmipmQWO8=&quot;,
</a><a href="#h86-0-38" id="h86-0-38" class="i">+			&quot;path&quot;: &quot;github.com/facebookgo/muster&quot;,
</a><a href="#h86-0-39" id="h86-0-39" class="i">+			&quot;revision&quot;: &quot;fd3d7953fd52354a74b9f6b3d70d0c9650c4ec2a&quot;,
</a><a href="#h86-0-40" id="h86-0-40" class="i">+			&quot;revisionTime&quot;: &quot;2015-07-08T23:28:44Z&quot;
</a><a href="#h86-0-41" id="h86-0-41" class="i">+		},
</a><a href="#h86-0-42" id="h86-0-42" class="i">+		{
</a><a href="#h86-0-43" id="h86-0-43" class="i">+			&quot;checksumSHA1&quot;: &quot;XnbEHQRzINRKXKmu9GcaqGkK4Lg=&quot;,
</a><a href="#h86-0-44" id="h86-0-44" class="i">+			&quot;path&quot;: &quot;github.com/golang/protobuf/proto&quot;,
</a><a href="#h86-0-45" id="h86-0-45" class="i">+			&quot;revision&quot;: &quot;f592bd283e9ef86337a432eb50e592278c3d534d&quot;,
</a><a href="#h86-0-46" id="h86-0-46" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-17T17:41:13Z&quot;
</a><a href="#h86-0-47" id="h86-0-47" class="i">+		},
</a><a href="#h86-0-48" id="h86-0-48" class="i">+		{
</a> 			&quot;checksumSHA1&quot;: &quot;lRiXw/k3wMbVticu4UnHSmqdhSI=&quot;,
 			&quot;path&quot;: &quot;github.com/google/go-github/github&quot;,
 			&quot;revision&quot;: &quot;63f6986f05c3e857d0bd9d7245b24c12a6c11147&quot;,
<a href="#h86-1" id="h86-1" class="h">@@ -21,6 +61,12 @@
</a> 			&quot;revisionTime&quot;: &quot;2016-02-18T00:51:18Z&quot;
 		},
 		{
<a href="#h86-1-3" id="h86-1-3" class="i">+			&quot;checksumSHA1&quot;: &quot;i+NIFvz7X9lNFpdHYgp4TCWvht8=&quot;,
</a><a href="#h86-1-4" id="h86-1-4" class="i">+			&quot;path&quot;: &quot;github.com/honeycombio/libhoney-go&quot;,
</a><a href="#h86-1-5" id="h86-1-5" class="i">+			&quot;revision&quot;: &quot;7ad65cc77a0c4c90145f97f7ce5b837a85b59dab&quot;,
</a><a href="#h86-1-6" id="h86-1-6" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T00:57:24Z&quot;
</a><a href="#h86-1-7" id="h86-1-7" class="i">+		},
</a><a href="#h86-1-8" id="h86-1-8" class="i">+		{
</a> 			&quot;checksumSHA1&quot;: &quot;Dsggox33NpBqmkEYgaYD6vEf1KQ=&quot;,
 			&quot;path&quot;: &quot;github.com/nelhage/go.cli/config&quot;,
 			&quot;revision&quot;: &quot;2aeb96ef8025f3646befae8353b90f95e9e79bdc&quot;,
<a href="#h86-2" id="h86-2" class="h">@@ -45,6 +91,54 @@
</a> 			&quot;revisionTime&quot;: &quot;2016-03-25T17:08:19Z&quot;
 		},
 		{
<a href="#h86-2-3" id="h86-2-3" class="i">+			&quot;checksumSHA1&quot;: &quot;4lEP/dEWOMb4r2Aehu0D9iBDgIU=&quot;,
</a><a href="#h86-2-4" id="h86-2-4" class="i">+			&quot;path&quot;: &quot;google.golang.org/appengine/internal&quot;,
</a><a href="#h86-2-5" id="h86-2-5" class="i">+			&quot;revision&quot;: &quot;e951d3868b377b14f4e60efa3a301532ee3c1ebf&quot;,
</a><a href="#h86-2-6" id="h86-2-6" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T20:11:16Z&quot;
</a><a href="#h86-2-7" id="h86-2-7" class="i">+		},
</a><a href="#h86-2-8" id="h86-2-8" class="i">+		{
</a><a href="#h86-2-9" id="h86-2-9" class="i">+			&quot;checksumSHA1&quot;: &quot;TsNO8P0xUlLNyh3Ic/tzSp/fDWM=&quot;,
</a><a href="#h86-2-10" id="h86-2-10" class="i">+			&quot;path&quot;: &quot;google.golang.org/appengine/internal/base&quot;,
</a><a href="#h86-2-11" id="h86-2-11" class="i">+			&quot;revision&quot;: &quot;e951d3868b377b14f4e60efa3a301532ee3c1ebf&quot;,
</a><a href="#h86-2-12" id="h86-2-12" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T20:11:16Z&quot;
</a><a href="#h86-2-13" id="h86-2-13" class="i">+		},
</a><a href="#h86-2-14" id="h86-2-14" class="i">+		{
</a><a href="#h86-2-15" id="h86-2-15" class="i">+			&quot;checksumSHA1&quot;: &quot;5QsV5oLGSfKZqTCVXP6NRz5T4Tw=&quot;,
</a><a href="#h86-2-16" id="h86-2-16" class="i">+			&quot;path&quot;: &quot;google.golang.org/appengine/internal/datastore&quot;,
</a><a href="#h86-2-17" id="h86-2-17" class="i">+			&quot;revision&quot;: &quot;e951d3868b377b14f4e60efa3a301532ee3c1ebf&quot;,
</a><a href="#h86-2-18" id="h86-2-18" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T20:11:16Z&quot;
</a><a href="#h86-2-19" id="h86-2-19" class="i">+		},
</a><a href="#h86-2-20" id="h86-2-20" class="i">+		{
</a><a href="#h86-2-21" id="h86-2-21" class="i">+			&quot;checksumSHA1&quot;: &quot;Gep2T9zmVYV8qZfK2gu3zrmG6QE=&quot;,
</a><a href="#h86-2-22" id="h86-2-22" class="i">+			&quot;path&quot;: &quot;google.golang.org/appengine/internal/log&quot;,
</a><a href="#h86-2-23" id="h86-2-23" class="i">+			&quot;revision&quot;: &quot;e951d3868b377b14f4e60efa3a301532ee3c1ebf&quot;,
</a><a href="#h86-2-24" id="h86-2-24" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T20:11:16Z&quot;
</a><a href="#h86-2-25" id="h86-2-25" class="i">+		},
</a><a href="#h86-2-26" id="h86-2-26" class="i">+		{
</a><a href="#h86-2-27" id="h86-2-27" class="i">+			&quot;checksumSHA1&quot;: &quot;a1XY7rz3BieOVqVI2Et6rKiwQCk=&quot;,
</a><a href="#h86-2-28" id="h86-2-28" class="i">+			&quot;path&quot;: &quot;google.golang.org/appengine/internal/remote_api&quot;,
</a><a href="#h86-2-29" id="h86-2-29" class="i">+			&quot;revision&quot;: &quot;e951d3868b377b14f4e60efa3a301532ee3c1ebf&quot;,
</a><a href="#h86-2-30" id="h86-2-30" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T20:11:16Z&quot;
</a><a href="#h86-2-31" id="h86-2-31" class="i">+		},
</a><a href="#h86-2-32" id="h86-2-32" class="i">+		{
</a><a href="#h86-2-33" id="h86-2-33" class="i">+			&quot;checksumSHA1&quot;: &quot;QtAbHtHmDzcf6vOV9eqlCpKgjiw=&quot;,
</a><a href="#h86-2-34" id="h86-2-34" class="i">+			&quot;path&quot;: &quot;google.golang.org/appengine/internal/urlfetch&quot;,
</a><a href="#h86-2-35" id="h86-2-35" class="i">+			&quot;revision&quot;: &quot;e951d3868b377b14f4e60efa3a301532ee3c1ebf&quot;,
</a><a href="#h86-2-36" id="h86-2-36" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T20:11:16Z&quot;
</a><a href="#h86-2-37" id="h86-2-37" class="i">+		},
</a><a href="#h86-2-38" id="h86-2-38" class="i">+		{
</a><a href="#h86-2-39" id="h86-2-39" class="i">+			&quot;checksumSHA1&quot;: &quot;akOV9pYnCbcPA8wJUutSQVibdyg=&quot;,
</a><a href="#h86-2-40" id="h86-2-40" class="i">+			&quot;path&quot;: &quot;google.golang.org/appengine/urlfetch&quot;,
</a><a href="#h86-2-41" id="h86-2-41" class="i">+			&quot;revision&quot;: &quot;e951d3868b377b14f4e60efa3a301532ee3c1ebf&quot;,
</a><a href="#h86-2-42" id="h86-2-42" class="i">+			&quot;revisionTime&quot;: &quot;2016-08-10T20:11:16Z&quot;
</a><a href="#h86-2-43" id="h86-2-43" class="i">+		},
</a><a href="#h86-2-44" id="h86-2-44" class="i">+		{
</a><a href="#h86-2-45" id="h86-2-45" class="i">+			&quot;checksumSHA1&quot;: &quot;o5Skl9YjZqmvEEqWie3f3oY0Kow=&quot;,
</a><a href="#h86-2-46" id="h86-2-46" class="i">+			&quot;path&quot;: &quot;gopkg.in/alexcesaro/statsd.v2&quot;,
</a><a href="#h86-2-47" id="h86-2-47" class="i">+			&quot;revision&quot;: &quot;7fea3f0d2fab1ad973e641e51dba45443a311a90&quot;,
</a><a href="#h86-2-48" id="h86-2-48" class="i">+			&quot;revisionTime&quot;: &quot;2016-03-20T18:21:10Z&quot;
</a><a href="#h86-2-49" id="h86-2-49" class="i">+		},
</a><a href="#h86-2-50" id="h86-2-50" class="i">+		{
</a> 			&quot;checksumSHA1&quot;: &quot;I2d7Kn572Fz02mnnlcI4MHXCu0c=&quot;,
 			&quot;path&quot;: &quot;gopkg.in/check.v1&quot;,
 			&quot;revision&quot;: &quot;4f90aeace3a26ad7021961c297b22c42160c7b25&quot;,
</pre>
</div>
</body>
</html>
